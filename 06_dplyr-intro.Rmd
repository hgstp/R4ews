# Einführung in dplyr  {#dplyr-intro}

```{r include = FALSE}
source("common.R")
```


## Einstieg

[dplyr] ist ein Paket zur Datenmanipulation, entwickelt von Hadley Wickham und Romain Francois. Das Paket ist Teil des  [tidyverse] und gehört als Kernpaket zu den Paketen, die über `library(tidyverse)` geladen werden.

Der Ursprung von `dplyr` liegt in einem früheren Paket mit dem Namen [plyr], das zum Ziel hat die ["split-apply-combine"-Strategie der Datenanalyse](https://www.jstatsoft.org/article/view/v040i01) [@wickham2011a] umzusetzen. Wo `plyr` noch einen vielfältigen Satz von Ein- und Ausgabetypen abdeckt (z.B. Arrays, data frames, Listen), hat `dplyr` einen klaren Fokus auf data frames oder __tibbles__, wenn man sich im tidyverse befindet. 

`dplyr` bietet schnelle Alternativen zu den R Standardfunktionen:

+ `subset()`

+ `apply()`, `sapply()`, `lapply()`, `tapply()`

+ `aggregate()` 
+ `split()`

+ `do.call()`

+ `with()`, `within()`

und mehr. Ferner bietet `dplyr` die Möglichkeit schnell über Zeilen oder Gruppen von Zeilen zu iterieren, was eine schnelle Alternative zur Nutzung von `for` Schleifen darstellt.



:::: {.content-box-grey}
__Wie immer, laden wir zu Beginn__ 
```{r, fig.align='right', echo=FALSE, out.width="30%"}
knitr::include_graphics("img/tidyverse.png")
```
::::

Der Fokus liegt in diesem Abschnitt auf `dplyr`. Aber da wir immer wieder auch Funktionen aus anderen "tidyverse-Paketen" nutzen, laden wir stets `tidyverse`.

```{r start_dplyr}
library(tidyverse)
```

Zusätzlich wollen wir auch noch das Paket [gapminder] laden, da wir erneut mit dem `gapminder` Datensatz arbeiten wollen.

```{r message = FALSE, warning = FALSE}
library(gapminder)
```



## `filter()`: Indizieren von Zeilen

Die Funktion `filter()` erwartet logische Ausdrücke als Input und gibt die Zeilen zurück, für die die Kombination der verwendeten logischen Ausdrücke ein `TRUE` ergibt.

```{r}
filter(gapminder, lifeExp < 29)
filter(gapminder, country == "Rwanda", year > 1979)
filter(gapminder, country %in% c("Rwanda", "Afghanistan"))
```

Zum Vergleich kann man sich einen R Standardbefehl anschauen, der zum gleichen Ergebnis führt:

```{r eval = FALSE}
gapminder[gapminder$lifeExp < 29, ] 
subset(gapminder, country == "Rwanda" & year > 1979) 
## subset funktioniert ähnlich wie filter
subset(gapminder, country %in% c("Rwanda", "Afghanistan"))
```

Wir erkennen sofort, dass wir mithilfe von `dplyr` sehr leicht den Datensatz aufteilen können, basierend auf der Tatsache ob Bedingungen erfüllt werden oder eben nicht.    

Daher solltet ihr unter keinen Umständen eure Daten so unterteilen, wie hier:

```{r eval = FALSE}
auswahl <- gapminder[241:252, ]
```

Warum ist das eine blöde Idee?

* Der Befehl dokumentiert sich nicht selbst. Was ist das Besondere an den Zeilen 241 bis 252?

* Der Befehl ist fehleranfällig. Diese Codezeile wird zu anderen Ergebnissen führen, wenn jemand die Zeilenreihenfolge von `gapminder` ändert, z.B. die Daten vor diesem Befehl erst sortiert.

Ganz anders verhält es sich mit diesem Beispiel:
```{r eval = FALSE}
filter(gapminder, country == "Canada")
```

Der Befehl erklärt sich von selbst und ist ziemlich robust.

## Der Pipe-Operator

Bevor es weitergeht, wollen wir aber den Pipe-Operator, den das Tidyverse aus dem [magrittr]-Paket von Stefan Bache importiert, vorstellen. Mithilfe des Pipe-Operators ist man in der Lage Befehle für mehrere Operationen auszuführen, ohne sie ineinander zu verschachteln. Diese neue Syntax führt zu Code, der viel einfacher zu schreiben und zu lesen ist.

>Und so sieht er aus: `%>%`. 

Das entsprechende RStudio Tastenkürzel lautet: Ctrl+Shift+M (Windows), Cmd+Shift+M (Mac).

Erstmal ein Beispiel

```{r}
gapminder %>% head()
```

Man erkennt sofort, der Befehl ist äquivalent zu `head(gapminder)`. Der Pipe-Operator nimmt das Objekt auf der linken Seite und leitet es in den Funktionsaufruf auf der rechten Seite weiter - er gibt es buchstäblich als erstes Argument ein.

Und natürlich kann man immer noch weitere Argumente für die Funktion auf der rechten Seite angeben. Um die ersten 3 Reihen von `gapminder` zu sehen, könnte man sagen: `head(gapminder, 3)` oder:

```{r}
gapminder %>% head(3)
```


Wahrscheinlich seid ihr aufgrund dieses Beispiels noch nicht besonders beeindruckt vom Pipe-Operator `%>%`, aber das sollte sich noch ändern.


## Mit `select()` Variablen auswählen


Verwendet  `select()`, um aus den Daten verschiedene Variablen (Spalten) auszuwählen. Hier kommt eine typische Verwendung von `select()`:

```{r}
select(gapminder, year, lifeExp)
```

Und nun noch kombiniert mit `head()` über den Pipe-Operator:


```{r}
gapminder %>%
  select(year, lifeExp) %>%
  head(4)
```

Der letzte Befehl nochmal in Worten: 

"Nimm `gapminder`, wähle die Variablen `year` und `lifeExp` und zeige dann die ersten 4 Zeilen an."

### Jetzt nochmal ein Vergleich zu R Standardbefehlen

Hier sind die Daten für Kambodscha, allerdings nur die Variablen `year` und `lifeExp`:

```{r}
gapminder %>%
  filter(country == "Cambodia") %>%
  select(year, lifeExp)
```

Das gleiche Ergebnis würde man mit diesem R Standardbefehl erhalten:

```{r end_dplyr}
gapminder[gapminder$country == "Cambodia", c("year", "lifeExp")]
```

Ich hoffe, ihr stimmt mir zu,  dass der `dplyr` Befehl deutlich leichter zu lesen ist.

## Pure, predictable, pipeable

Bisher haben wir nur etwas an der Oberfläche von `dplyr` gekratzt, trotzdem möchten wir auf ein Schlüsselprinzip hinweisen, das du vielleicht langsam zu schätzen lernen wirst. 

Die Verben (Hauptfunktionen) von dplyr, wie z.B. `filter()` und `select()`, sind [pure functions](https://en.wikipedia.org/wiki/Pure_function). Dazu schreibt Hadley Wickham im Kapitel [Functions](https://adv-r.hadley.nz/functions.html) in seinem [Advanced R] Buch [-@wickham2019]:

> The functions that are the easiest to understand and reason about are pure functions: functions that always map the same input to the same output and have no other impact on the workspace. In other words, pure functions have no side effects: they don’t affect the state of the world in any way apart from the value they return.

Tatsächlich sind diese Verben ein Spezialfall reiner Funktionen: sie nehmen als Input und Output denselben Objekttyp an, i.d.R. ein data frame.

Die Daten sind für all diese Funktionen auch __stets__ das erste Inputargument.



## Aufgabe

Die `dplyr` Einführung geht weiter im Kapitel [Mehr zu `dplyr`](#dplyr-single). Bearbeitet aber vorher den letzten Abschnitte des [Work with Data](https://rstudio.cloud/learn/primers/2) Primers:


[Deriving Information with dplyr](https://rstudio.cloud/learn/primers/2.3) zeigt euch wie ihr über bestehenden Variablen neue Variablen definiert und leicht zusammenfassende Statistiken innerhalb vorab definiertert Gruppen berechnet.


```{r links, child="links.md"}
```