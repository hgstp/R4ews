[{"path":"index.html","id":"willkommen-zu-r4ews","chapter":"Willkommen zu R4ews","heading":"Willkommen zu R4ews","text":"Willkommen zur R Ergänzung zur Einführung die Wahrscheinlichkeitstheorie und Statistik. Im Rahmen dieser Ergänzung lernen wirDaten untersuchen, aufbereiten, visualisieren und analysieren,Wir wollen das reproduzierbar, wiederverwendbar und gemeinsam nutzbar machen, und vor allem wollen wir alles mit R machen.Auf dieser Website geht es um alles, bei der Datenanalyse auftaucht außer um statistische Modellierung und Schlussfolgerungen. Dieser Teil der statistischen Analyse erfolgt der Vorlesung Einführung die Wahrscheinlichkeitstheorie und Statistik.Das Design von R4ews wurde durch die Notwendigkeit motiviert, mehr Ausgewogenheit der angewandten statistischen Ausbildung zu schaffen. Datenanalysten verbringen viel Zeit mit der Projekt-Organisation, der Datenbereinigung und -aufbereitung sowie der Kommunikation. Diese Tätigkeiten können einen tiefgreifenden Einfluss auf die Qualität und Glaubwürdigkeit einer Analyse haben. Dennoch werden diese Fähigkeiten selten vermittelt, obwohl sie wichtig und notwendig sind. R4ews versucht diese Lücke etwas zu verkleinern.Das Material wird kontinuierlich über das Semester hinweg ergänzt/erweitert/verbessert.Letzte Änderung:","code":"\ndate()\n#> [1] \"Mon Oct  4 15:27:16 2021\""},{"path":"index.html","id":"beteiligte-personen","chapter":"Willkommen zu R4ews","heading":"Beteiligte Personen","text":"","code":""},{"path":"index.html","id":"kolophon","chapter":"Willkommen zu R4ews","heading":"Kolophon","text":"Dieses Buch wurde bookdown innerhalb von RStudio geschrieben.Teile des Buches basieren auf stat545.com. Alle Änderungen wurden gemäß der Creative Commons Attribution-ShareAlike 4.0 International License durchgeführt.Wir bedanken uns bei den Autor*innen von stat545 für das großartige Material.Die aktuelle Version dieses Buchs wurde miterstellt","code":"#> Finding R package dependencies ... Done!\n#>  setting  value                       \n#>  version  R version 4.0.3 (2020-10-10)\n#>  os       macOS Catalina 10.15.7      \n#>  system   x86_64, darwin17.0          \n#>  ui       X11                         \n#>  language (EN)                        \n#>  collate  en_US.UTF-8                 \n#>  ctype    en_US.UTF-8                 \n#>  tz       Europe/Berlin               \n#>  date     2021-10-04"},{"path":"index.html","id":"lizenz","chapter":"Willkommen zu R4ews","heading":"Lizenz","text":"Diese Arbeit ist lizenziert unter Creative Commons Attribution-ShareAlike 4.0 International License.","code":""},{"path":"install.html","id":"install","chapter":"Kapitel 1 Installieren von R und RStudio","heading":"Kapitel 1 Installieren von R und RStudio","text":"","code":""},{"path":"install.html","id":"r-und-rstudio","chapter":"Kapitel 1 Installieren von R und RStudio","heading":"1.1 R und RStudio","text":"Installieren Sie R, eine freie Softwareumgebung für statistische Berechnungen und Grafiken von CRAN, dem Comprehensive R Archive Network. Wir empfehle Ihnen dringend, eine vorkompilierte Binärdistribution für Ihr Betriebssystem zu installieren - benutzen Sie die Links oben auf der CRAN Seite!Installieren Sie R, eine freie Softwareumgebung für statistische Berechnungen und Grafiken von CRAN, dem Comprehensive R Archive Network. Wir empfehle Ihnen dringend, eine vorkompilierte Binärdistribution für Ihr Betriebssystem zu installieren - benutzen Sie die Links oben auf der CRAN Seite!Installieren Sie die IDE von RStudio (steht für integrated development environment), eine leistungsfähige Benutzeroberfläche für R. Holen Sie sich die Open-Source-Edition von RStudio Desktop.\nEs ist vorteilhaft die Preview version zu installieren. der Regel ist sie bereits sehr stabil und man hat Zugriff auf die neusten Features.\nNatürlich gibt es auch offizielle Veröffentlichungen .\nRStudio wird mit einem Text Editor geliefert, dass es nicht unmittelbar erforderlich ist, einen separaten, eigenständigen Editor zu installieren.\nRStudio kann eine Schnittstelle zu Git(Hub) bilden. Sie müssen jedoch alle Git(Hub)-Installationen selbst vornehmen. Wir kommen später auf diesen Punkt zurück.\nInstallieren Sie die IDE von RStudio (steht für integrated development environment), eine leistungsfähige Benutzeroberfläche für R. Holen Sie sich die Open-Source-Edition von RStudio Desktop.Es ist vorteilhaft die Preview version zu installieren. der Regel ist sie bereits sehr stabil und man hat Zugriff auf die neusten Features.Natürlich gibt es auch offizielle Veröffentlichungen .RStudio wird mit einem Text Editor geliefert, dass es nicht unmittelbar erforderlich ist, einen separaten, eigenständigen Editor zu installieren.RStudio kann eine Schnittstelle zu Git(Hub) bilden. Sie müssen jedoch alle Git(Hub)-Installationen selbst vornehmen. Wir kommen später auf diesen Punkt zurück.Wenn Sie eine bereits vorhandene R und/oder RStudio Installation haben, empfehlen wir Ihnen dringend, beide neu zu installieren und aktuell wie möglich zu halten.Wenn Sie R aktualisieren, müssen Sie alle Pakete, die Sie installiert haben, aktualisieren. Der unten stehende Befehl sollte Ihnen den Anfang machen, obwohl Sie möglicherweise weitere Argumente angeben müssen, wenn Sie z.B. eine nicht standardmäßige Bibliothek für Ihre Pakete verwendet haben.\n\nupdate.packages(ask = FALSE, checkBuilt = TRUE)\nBemerkung: hier wird nur nach Updates auf CRAN gesucht. Wenn Sie also ein Paket verwenden, das z.B. nur auf GitHub lebt, müssen Sie manuell aktualisieren, z.B. über devtools::install_github().Wenn Sie R aktualisieren, müssen Sie alle Pakete, die Sie installiert haben, aktualisieren. Der unten stehende Befehl sollte Ihnen den Anfang machen, obwohl Sie möglicherweise weitere Argumente angeben müssen, wenn Sie z.B. eine nicht standardmäßige Bibliothek für Ihre Pakete verwendet haben.Bemerkung: hier wird nur nach Updates auf CRAN gesucht. Wenn Sie also ein Paket verwenden, das z.B. nur auf GitHub lebt, müssen Sie manuell aktualisieren, z.B. über devtools::install_github().","code":"\nupdate.packages(ask = FALSE, checkBuilt = TRUE)"},{"path":"install.html","id":"funktioniert-ausprobieren","chapter":"Kapitel 1 Installieren von R und RStudio","heading":"1.2 Funktioniert? Ausprobieren","text":"Starten Sie RStudio auf Ihrem Computer. Sie sollten ein Fenster ähnlich zu diesem Screenshot, erhalten.Starten Sie RStudio auf Ihrem Computer. Sie sollten ein Fenster ähnlich zu diesem Screenshot, erhalten.Setzen Sie den Cursor den Bereich mit der Bezeichnung Konsole, wo Sie mit R interagieren können. Erstellen Sie ein einfaches Objekt mit einem Code wieSetzen Sie den Cursor den Bereich mit der Bezeichnung Konsole, wo Sie mit R interagieren können. Erstellen Sie ein einfaches Objekt mit einem Code wie(gefolgt von Enter oder Return). Inspizieren Sie dann das x-Objekt durch Eingabe von x gefolgt von Enter oder Return. Sie sollten den Wert 8 auf dem Bildschirm sehen. Wenn ja, haben Sie R und RStudio erfolgreich installiert.","code":"\nx <- 2 * 4"},{"path":"install.html","id":"add-on-packages","chapter":"Kapitel 1 Installieren von R und RStudio","heading":"1.3 Add-on packages","text":"R ist ein erweiterbares System und viele Menschen teilen nützlichen Code, den sie als Paket entwickelt haben, über CRAN und GitHub. Um ein Paket von CRAN zu installieren, z.B. das Paket tidyverse (ist genauer gesagt eine Kollektion von Paketen), kann man folgenden Befehl verwendenMit der Option dependencies = TRUE achten wir darauf, dass alle für tidyverse notwendigen Pakete, ebenfalls installiert werden.","code":"\ninstall.packages(\"tidyverse\", dependencies = TRUE)"},{"path":"install.html","id":"rstudio-primers","chapter":"Kapitel 1 Installieren von R und RStudio","heading":"1.4 RStudio Primers","text":"Ein guter Startpunkt für verschiedene R Themen sind die RStudio primers.Im Laufe des Kurses werden sie die PrimersThe BasicsWork DataVisualize Datadurcharbeiten.","code":""},{"path":"install.html","id":"aufgabe","chapter":"Kapitel 1 Installieren von R und RStudio","heading":"1.5 Aufgabe","text":"Wir beginnen mit Basics. Hier wird unterschieden Programming und Visualization Basics.Programming Basics beinhaltet Grundlagen zu Objekttypen, Funktionen und deren Argumente, Listen (eigentlich sind alle Objekte Listen, nur unterschiedlich speziell) und Paketen.Visualization Basics erklärt erste Schritte der Verwendung des ggplot2 Pakets, mit dem wir uns später noch eingehend beschäftigen werden.Bearbeiten sie eigenständig den Basics Primer.","code":""},{"path":"r-basics.html","id":"r-basics","chapter":"Kapitel 2 R Basics und Arbeitsabläufe","heading":"Kapitel 2 R Basics und Arbeitsabläufe","text":"","code":""},{"path":"r-basics.html","id":"ein-paar-grundlagen-für-das-arbeiten-mit-r","chapter":"Kapitel 2 R Basics und Arbeitsabläufe","heading":"2.1 Ein paar Grundlagen für das Arbeiten mit R","text":"Aktueller Stand: Du hast bereits den Programming Basics Primer absolviert und nun willst du anfangen mit deiner RStudio/R Installation zu arbeiten arbeiten.Es geht los indem du RStudio startest. Beachte dabei die Standardfensterbereiche:Console (links)Environment / History (oben rechts)Files / Plots / Packages / Help (unten rechtes)Bemerkung: Die Standardanordnung der Fenster kannst du neben vielen anderen Dingen nach deinen Vorstellungen ändern/anpassen: Customizing RStudio.Gehen nun die Konsole um mit R zu interagieren. Erstelle die nachfolgende Zuordnung und schau dir das erstellte Objekt genauer :Alle R Befehle, die ein Objekte erstellen (“Zuweisungen”), haben die Form:Du wirst im weiteren Verlauf noch viele Zuweisungen vornehmen, und es ist tatsächlich etwas mühsam den Operator <- zu tippen. Sei aber trotzdem nicht faul und benutze = stattdessen - auch wenn es theoretisch funktionieren würde. Aber später kann die Verwendung von = für Zuweisungen zu Verwirrung führen. Verwende stattdessen RStudio die Tastenkombination: Alt + - (Minuszeichen).Beachte, dass RStudio automatisch <- mit Leerzeichen umgibt, eine nützliche Codeformatierung demonstriert. Code ist selbst einem guten Tag eher schlecht zu lesen. Gönne daher deinen Augen eine Pause und verwende (ausreichend) Leerzeichen.RStudio bietet viele praktische Tastaturkürzel . Eine Übersicht erhält man auch mit Alt+Shift+K.Objektnamen dürfen nicht mit einer Ziffer beginnen und bestimmte andere Zeichen wie ein Komma oder ein Leerzeichen nicht enthalten. Es ist daher ratsam, sich eine [Konvention zur Abgrenzung von Wörtern][wiki-snake-case] Objektnamen zu überlegen.Wir werden stets die erste Variante verwenden.Führe nun nachfolgenden Befehl ausIn deinem Workspace ist nun das Objekt this_is_a_really_long_name vorhanden. Probiere mithilfe dieses Objekts die Vervollständigungsfunktion von RStudio aus: Gib die ersten paar Zeichen ein, drücke anschließend die TAB Taste, fügen weitere Zeichen hinzu, bis Eindeutigkeit hergestellt ist(wenn sonst wenig deinem Workspace ist, dann ist das schnell erreicht), und drücke dann die Eingabetaste.Führe nun den Befehlaus, um anschließend den Inhalt des Objekts anzuzeigen.Die Objekte jennyrocks und jeny_rocks sind natürlich nicht vorhanden und somit führen beide Befehle zu einer Fehlermeldung. Man muss also absolut exakt sein mit seinen Befehlen.R verfügt über eine überwältigende Sammlung eingebauter Funktionen, die nach folgendem Schema aufgerufen werden:Als nächstes wollen wir die Funktion seq() verwenden, die reguläre Zahlensequenzen erzeugt. Dabei wollen wir noch ein weiteres hilfreiches Feature von RStudio demonstrieren.Tippe se und drücke dann die TAB Taste. einem Pop-Fenster werden dir mögliche Vervollständigungen angezeigt. Der Befehl seq() kann dann durch weiteres Tippen oder über die Auswahlmöglichkeit (Pfeiltasten nach oben/unten) festgelegt werden. Zu jeder Auswahlmöglichkeit wird auch noch eine Kurzform der entsprechenden Hilfeseite angezeigt. Fügt man jetzt die öffnende runde Klammer hinzu, wird die zugehörige schließende runde Klammer automatisch hinzugefügt. Tippe anschließend 1, 10 (das geschieht automatisch innerhalb der runden Klammern) und Return. RStudio beendet auch den Klammerausdruck für dich. IDEs sind großartig.Der letzte Befehl zeigt auch ganz gut, wie R Funktionsargumente auflöst. Sie können immer der Form Name = Wert angeben werden. Aber der Name muss nicht angegeben werden, wie man sieht. solchen Fällen versucht R, nach der Position aufzulösen. wird oben angenommen, dass wir eine Sequenz bei 1 starten wollen, also = 1, und diese bis 10 laufen soll, daher = 10. Da wir keine Schrittweite angegeben haben, wird der Standardwert für verwendet, der diesem Fall gleich 1 ist.Bei Funktionen, die man oft aufruft, kann man gut diese Auflösung nach Position für das erste und vielleicht auch das zweite Argument verwenden. Danach ist es aber ratsam immer mit Name = Wert zu arbeiten um falsche Zuweisungen (verschiedene Argumente können vom gleichen Typ sein, sodass eine falsche Zuweisung nicht automatisch zu einer Fehlermeldung führt) zu vermeiden.Analog zur Unterstützung mit den runden Klammern, werden auch schließende Anführungszeichen automatisch ergänzt, wie man folgendem Beispiel sieht.Nach einer Zuweisung wird der entsprechende Wert des Objekts nicht angezeigt. Daher ist man vielleicht dazu geneigt das Objekt gleich erneut aufzurufenDiese typische Aktion kann verkürzt werden, indem die Zuweisung Klammern gesetzt wird, wodurch die Zuweisung und ein Befehl “Drucke auf den Bildschirm” erfolgen.Nicht alle Funktionen haben (oder erfordern) Argumente:Schau dir nun deinen Workspace - im oberen rechten Fensterbereich (bei Standardeinstellung) siehst du unter Environment den Inhalt deines Workspaces. Der Workspace ist der Ort, dem sich benutzerdefinierte Objekte ansammeln. Eine Liste dieser Objekte kannst du auch mit diesen Befehlen erhalten:Wenn du nun das Objekt mit dem Namen y entfernen möchtest, kannst du dies wie folgt machen:Alles löschen kannst du mit dem Befehloder du klickst auf den Besen im Environment Fenster von RStudio.","code":"\nx <- 3 * 4\nx\n#> [1] 12\nobjectName <- valuei_use_snake_case\nother.people.use.periods\nevenOthersUseCamelCase\nthis_is_a_really_long_name <- 2.5\njenny_rocks <- 2 ^ 3\njennyrocks\n#> Error in eval(expr, envir, enclos): object 'jennyrocks' not found\njeny_rocks\n#> Error in eval(expr, envir, enclos): object 'jeny_rocks' not foundfunctionName(arg1 = val1, arg2 = val2, and so on)\nseq(1, 10)\n#>  [1]  1  2  3  4  5  6  7  8  9 10\nyo <- \"hello world\"\ny <- seq(1, 10)\ny\n#>  [1]  1  2  3  4  5  6  7  8  9 10\n(y <- seq(1, 10))\n#>  [1]  1  2  3  4  5  6  7  8  9 10\ndate()\n#> [1] \"Mon Oct  4 15:27:20 2021\"\nobjects()\n#> [1] \"check_quietly\"              \"install_quietly\"           \n#> [3] \"jenny_rocks\"                \"pretty_install\"            \n#> [5] \"shhh_check\"                 \"this_is_a_really_long_name\"\n#> [7] \"x\"                          \"y\"                         \n#> [9] \"yo\"\nls()\n#> [1] \"check_quietly\"              \"install_quietly\"           \n#> [3] \"jenny_rocks\"                \"pretty_install\"            \n#> [5] \"shhh_check\"                 \"this_is_a_really_long_name\"\n#> [7] \"x\"                          \"y\"                         \n#> [9] \"yo\"\nrm(y)\nrm(list = ls())"},{"path":"r-basics.html","id":"workspace-und-working-directory","chapter":"Kapitel 2 R Basics und Arbeitsabläufe","heading":"2.2 Workspace und working directory","text":"Ziemlich schnell wird der Fall eintreten, dass du mit deiner R Arbeit (z.B. Bearbeitung eines Hausaufgaben Projekts) noch nicht fertig bist obwohl es Zeit wird R zu beenden. Natürlich willst du aber zu einem späteren Zeitpunkt mit der Analyse weitermachen wo du aufgehört hast.Etwas später wird es ein, dass du Daten R einlesen und anschließend numerische Ergebnisse erzeugen willst, die du dann schließlich auch wieder exportieren willst.Und nochmal später wird es (vielleicht) sein, dass du R gleichzeitig mehreren Analysen arbeitest, die du aber unbedingt getrennt halten willst/sollst.Um diese Situationen zu bewältigen, musst du zwei Entscheidungen treffen:betrachtest du deiner Analyse als “Ergebnis”, d.h. wirst du dauerhaft speichern?betrachtest du deiner Analyse als “Ergebnis”, d.h. wirst du dauerhaft speichern?Wo “lebt” deine Analyse?Wo “lebt” deine Analyse?","code":""},{"path":"r-basics.html","id":"workspace-.rdata","chapter":"Kapitel 2 R Basics und Arbeitsabläufe","heading":"2.2.1 Workspace, .RData","text":"Du startest gerade deine R Reise. Daher wäre es Okay, wenn du deinen Workspace als die “Ergebnis” deiner Analyse betrachtest. Ziemlich bald, solltest du aber davon (vielleicht durch uns) überzeugt sein, dass deine R Skripte das Ergebnis deiner Analyse sind (beiden Fällen hängt das Ergebnis möglicherweise natürlich auch von Input Daten ab).\nDie Daten zusammen mit deinem R Code erlauben es dir jederzeit alle Ergebnisse zu reproduzieren und das ist die entscheidende Eigenschaft.Betrachtest du deinen Workspace als das Ergebnis deiner Analyse, dann musst du bei einem erneuten Analysedurchlauf (leicht veränderte Aufgabenstellung, …) entweder erneut eine Menge Tippen (natürlich fehleranfällig ist) oder deine R History nach den nötigen Befehlen durchwühlen. Anstatt “becoming expert managing R history”, solltest du deinen R Code sauber ein Skript speichern, sodass er dir für weitere Analysen zur Verfügung steht.Der Workspace Ansatz wird “begünstigt” durch die Tatsache, dass RStudio beim Beenden der Session automatisch wissen ob der Workspace gespeichert werden soll. Das wollen wir mal ausprobieren.Beende R/RStudio, entweder über das Menü oder du tippst q() die Konsole. Dann erhältst du eine Eingabeaufforderung wie diese:Save workspace image ~/.Rdata?Merke dir welchem Verzeichnis die Datei gespeichert wird und dann klick auf Save.Gehe das Verzeichnis mit dem gespeicherten Workspace Image und kontrolliere ob die Datei .RData vorhanden ist. Du wirst dort auch die Datei .Rhistory finden, die alle Befehle deiner letzten Sitzung enthält.Nun starte erneut RStudio. der Konsole siehst du einen Befehl, der ungefähr aussiehtund angibt, dass dein gespeicherter Workspace wiederhergestellt wurde. Unter Environment solltest du die gleichen Objekte wie zuvor sehen. History enthält die gespeicherten Befehle aus der letzten Sitzung. Aber diese Art, analytische Arbeit zu beginnen und zu beenden, würde nicht lange gut gehen. Daher fangen wir gleich mal damit die automatische Nachfrage nach dem Speichern des Workspaces abzuwählen. Öffne dazu die Global Options (unter Tools)und setze Save workspace .RData exit auf Never. Nun wirst du nie mehr gefragt ob du deinen Workspace speichern willst. Sehr wohl wirst du aber weiterhin gefragt ob du ungesicherte Änderungen deinem R Skript speichern willst, sobald du RStudio beenden willst.","code":"[Workspace loaded from ~/.RData]"},{"path":"r-basics.html","id":"working-directory","chapter":"Kapitel 2 R Basics und Arbeitsabläufe","heading":"2.2.2 Working directory","text":"Jeder Prozess, der auf deinem Computer läuft, hat einen Bezug zu seinem “Arbeitsverzeichnis”. R ist dies der Ort, dem R standardmäßig nach Dateien suchen würde oder der Ort wo alle Dateien, die du auf die Festplatte schreiben willst, abgelegt werden. Möglicherweise ist dein aktuelles Arbeitsverzeichnis das Verzeichnis, das du oben gerade untersucht hast um die .RData Datei zu finden.Du kannst dir dein aktuelles Arbeitsverzeichnis anzeigen lassen mit dem BefehlAber es wird auch oben der RStudio Konsole direkt angezeigt.Es wäre schon, wenn das Arbeitsverzeichnis Abhängigkeit vom jeweils zu bearbeitenden Projekt leicht sinnvoll gesetzt werden könnte. Im nächsten Abschnitt sehen wir, dass genau das möglich ist.","code":"\ngetwd()"},{"path":"r-basics.html","id":"rprojs","chapter":"Kapitel 2 R Basics und Arbeitsabläufe","heading":"2.3 RStudio Projects","text":"Alle zu einem Projekt gehörenden Dateien - Eingabedaten, R Skripte, Analyseergebnisse, Grafiken - einem Ort zu bündeln, ist eine weise und gängige Praxis, dass RStudio über seine Projects genau da ermöglicht.Lass uns ein Projekt für den Kurs anlegen. Dazu wählen wir oben rechts im RStudio Fenster Project: (None) -> New ProjectDanach wählen wir New Directory -> New Project und geben abschließend einen passenden Verzeichnisnamen ein (dabei beachten wir den Speicherort des neuen Verzeichnisses)Wir nehmen nun , dass du ein RStudio Projekt angelegt und dieses auch geöffnet hast. Dann benötigen wir als Nächstes ein wenig R Code. Dazu tippen wir den unten stehenden Code (ausnahmsweise) die KonsoleJetzt nehmen wir mal das wäre ein guter Start einer Analyse, die wir durchführen wollen. Daher würdest du das Ergebnis gerne abspeichern. Unter History kannst du alle obigen Befehle markieren und anschließend “Source” klicken. Daraufhin wird sich ein neues Fenster mit einem R Skript - das natürlich die Befehle enthält - öffnen. Das Skript kannst du abspeichern und standardmäßig wird es deinen Projektordner gespeichert werden (aber natürlich könntest man den Speicherort dieser Stelle auch ändern/frei wählen).Nun beende das Projekt (Close Project der rechten oberen Ecke). Wenn du willst, kannst du dir auch den Inhalt deines Projektordners anschauen, z.B. das PDF öffnen.Danach öffnest du das Projekt wieder. Dir wird auffallen, dass alles dem Zustand ist, wie du das Projekt verlassen hast, z.B. Objekte im Arbeitsbereich, die Befehlshistorie, welche Dateien zur Bearbeitung geöffnet sind, wo wir uns im Dateisystembrowser befinden, das Arbeitsverzeichnis für den R-Prozess usw. dies sind gute Dinge.Nun ändern ein paar Dinge deinem Code. Sinnvoll wäre z.B. Anfang die Stichprobenlänge n zu definieren und z.B. auf n <- 40 setzen. Dann\nsollten alle festen 40er Werte durch n ersetzt werden. Anschließend kannst\ndu noch ein paar andere Dinge ändern, z.B. die Steigung b, die Farbe der Linie … auch immer. Übe nun die verschiedenen Möglichkeiten, den Code erneut auszuführen:Führe Zeile für Zeile aus indem du entweder das Tastenkürzel Command + Enter oder die Maus (auf “Run” klicken der oberen rechten Ecke des Editor-Fensters) verwendest.Führe Zeile für Zeile aus indem du entweder das Tastenkürzel Command + Enter oder die Maus (auf “Run” klicken der oberen rechten Ecke des Editor-Fensters) verwendest.Das gesamte Dokument durchlaufen lassen per Tastenkürzel Shift + Command +S oder Maus (klicken auf “Source” der oberen rechten Ecke des Editor-Fensters)Das gesamte Dokument durchlaufen lassen per Tastenkürzel Shift + Command +S oder Maus (klicken auf “Source” der oberen rechten Ecke des Editor-Fensters)Anschließend kannst du dir das PDF anschauen und die Änderungen bewundern.Eines Tages wirst du vor der Aufgabe stehen eine Grafik neu zu gestalten oder einfach nur verstehen wollen, woher sie stammt. Wenn du (relevante) Grafiken einer Datei (mit R Code und niemals über die Maus oder die Zwischenablage) speicherst und dabei sinnvolle Dateinamen/Speicherorte (innerhalb des zugehörigen Projekts) benutzt, werden dich solche Aufgaben nie vor große Probleme stellen.","code":"\na <- 2\nb <- -3\nsig_sq <- 0.5\nx <- runif(40)\ny <- a + b * x + rnorm(40, sd = sqrt(sig_sq))\n(x_n <- mean(x))\n#> [1] 0.493\nwrite(x_n, \"data/mittelwert_x.txt\")\nplot(x, y)\nabline(a, b, col = \"purple\")\ndev.print(pdf, \"img/scatterplot.pdf\")\n#> quartz_off_screen \n#>                 2"},{"path":"r-basics.html","id":"zuletzt-noch","chapter":"Kapitel 2 R Basics und Arbeitsabläufe","heading":"2.4 Zuletzt noch","text":"Es ist üblich, R-Skripte mit einem .R oder .r Suffix zu speichern. Befolge diese Konvention, außer du hast einen sehr außergewöhnlichen Grund, es nicht zu tun.Kommentare beginnen mit einem oder mehreren #-Symbolen. Verwende Kommentare.. RStudio hilft dir dabei ausgewählte Zeilen mit Ctrl+Shift+C (Windows und Linux) oder Command+Shif+C (Mac) zu kommentieren oder vorhandene Kommentare wieder zu entfernen.Dieser Workflow wird dir Zukunft gute Dienste leisten:Erstelle ein RStudio Projekt für ein analytisches ProjektSpeichere alle Input Dateien innerhalb des Projekts (wir werden bald über den Import sprechen)Bewahre deine Skripte dort auf; bearbeite sie und führen sie dort ausSpeichere den Output innerhalb des Projekts (wie z.B. das PDF im letzten Beispiel)Du solltest es vermeiden die Maus für Teile deines Workflows zu verwenden, wie z.B. das Laden eines Datensatzes oder das Speichern einer Grafik. Das ist sehr wichtig für die Reproduzierbarkeit und um im Nachhinein feststellen zu können, wie eine numerische Tabelle oder eine PDF-Datei tatsächlich erzeugt wurde (eine Suche auf der lokalen Festplatte nach dem entsprechenden Dateinamen unter den .R-Dateien führt zum entsprechenden Skript).","code":""},{"path":"version-control.html","id":"version-control","chapter":"Kapitel 3 Git, GitHub, and RStudio","heading":"Kapitel 3 Git, GitHub, and RStudio","text":"Wir wissen nicht ob Versionskontrolle bereits ein Thema war mit dem du dich beschäftigt hast. Wenn nicht, solltest du mit ein paar Worten zu Git und GitHub von Jenny Byran (Autorin von STAT 545) starten.Ziel dieses Abschnitts wird es sein, dass dueinen GitHub Account anlegst (falls nicht schon vorhanden)einen GitHub Account anlegst (falls nicht schon vorhanden)Git auf deinem Computer installierstGit auf deinem Computer installierstdich bei Git vorstellstdich bei Git vorstellstalles zusammenfügst und deine Verbindung zu GitHub testestalles zusammenfügst und deine Verbindung zu GitHub testestabschließend noch RStudio ins Spiel bringst und RStudio mit Git und GitHub verbindestabschließend noch RStudio ins Spiel bringst und RStudio mit Git und GitHub verbindestBemerkung: Unter 5. wirst du ermutigt deine GitHub Zugangsdaten auf deinem Computer zu speichern. Wir können diesen Schritt nur empfehlen.Das Buch Happy Git GitHub useR enthält noch viele weitere hilfreiche Git/GitHub Informationen. Auf manche kommen wir vielleicht im Laufe des Kurses noch zu sprechen. Andere sind vielleicht zu einem späteren Zeitpunkt interessant, wenn du anspruchsvolleren Git Projekten arbeitest.","code":""},{"path":"r-markdown.html","id":"r-markdown","chapter":"Kapitel 4 R Markdown","heading":"Kapitel 4 R Markdown","text":"Ausgewählte Hausaufgaben wirst du als R Markdown Dokument abgeben. R Markdown ist eine sehr zugängliche Methode zur Erstellung von Dokumenten, die Prosa Text mit durch R-Code erzeugten Tabellen und Abbildungen kombinieren.Ein möglicher R Markdown Workflow, der eine Interaktion mit Git, GitHub, und RStudio beinhaltet, wird vorgestellt auf der Seite:Test drive R Markdown","code":""},{"path":"basic-data-care.html","id":"basic-data-care","chapter":"Kapitel 5 Letzte Vorbereitungen …","heading":"Kapitel 5 Letzte Vorbereitungen …","text":"Jetzt ist es der Zeit, sich zu vergewissern welchem Verzeichnis auf deinem Computer du dich befindest. Falls du ein RStudio Projekt nutzt, sollte diese Frage leicht zu beantworten sein. Falls du trotzdem unsicher bist, gib getwd() der Konsole ein, um das aktuelle Arbeitsverzeichnis zu sehen.Alle nachfolgenden Code Beispiele wollen wir abspeichern einer .R Datei, die wir im aktuellen Arbeitsverzeichnis abspeichern wollen. Idealerweise geben wir dieser Datei noch einen Namen, wie etwa datenanalyse_teil_1.R, der uns schon viel über den möglichen Inhalt erzählt.\nAlternativ können wir alle Befehle natürlich auch eine R Markdown Datei schreiben, siehe Test drive R Markdown.Prinzipiell geht es den folgenden Abschnitten um Datenmanagement. Es werden aber auch immer wieder ein paar Grafiken zu sehen sein. Dies ist aber kein Problem, da wir ja bereits den Data Visualization Basics Primerbesucht haben und den nötigen Background haben.","code":""},{"path":"basic-data-care.html","id":"data-frames-sind-fantastisch","chapter":"Kapitel 5 Letzte Vorbereitungen …","heading":"5.1 Data Frames sind fantastisch","text":"Das Standardformat für Daten ist ein data frame. Die meisten Funktionen zur Inferenz, Modellierung und graphischen Darstellung erwarten, dass ihnen über ein data = Argument ein data frame übergeben wird. Dies gilt für die Basis R schon seit langem.Die als tidyverse bekannte Kollektion von Paketen geht noch einen Schritt weiter und priorisiert ausdrücklich die Verarbeitung von data frames. Tatsächlich priorisiert tidyverse eine besondere Art von data frames, die als “tibble” bezeichnet wird.Data frames - im Gegensatz zu allgemeinen Arrays oder speziell Matrizen R - können Variablen unterschiedlicher Typen enthalten, wie z. B. Textdaten (Subjekt-ID oder Name), quantitative Daten (Anzahl der weißen Blutkörperchen) und kategoriale Informationen (behandelt vs. unbehandelt). Genauer gesagt können data frames unterschiedliche Spalten aus unterschiedlichen Datentypen bestehen. Innerhalb einer Spalte müssen aber alle Einträge vom gleichen Typ sein.Daten aus einer Datenanalyse bestehen immer aus mehr als einem Datentyp. Aus diesem Grund können Matrizen oder Arrays nicht zur Datenanalyse verwendet werden, da man sonst mit verschiedenen, unverbundenen Objekten (Matrizen, Arrays) arbeiten müsste und diese nur schwer koordinieren kann.","code":""},{"path":"basic-data-care.html","id":"gapminder-data","chapter":"Kapitel 5 Letzte Vorbereitungen …","heading":"5.2 Gapminder data","text":"Wir werden mit einigen der Daten aus dem [Gapminder-Projekt] (https://www.gapminder.org)arbeiten. Die Daten sind im gapminder Paket enthalten, welches wir über CRAN installieren können:Um die Daten zu verwenden, müssen wir das Paket natürlich auch noch laden","code":"\ninstall.packages(\"gapminder\")\nlibrary(gapminder)"},{"path":"basic-data-care.html","id":"die-gapminder-daten-sind-ein-tibble","chapter":"Kapitel 5 Letzte Vorbereitungen …","heading":"5.3 Die gapminder Daten sind ein “tibble”","text":"Durch das Laden des gapminder Pakets haben wir nun Zugriff auf einen Datenobjekt mit demselben Namen. Schau dir nun mithilfe der Funktion str() die Struktur des Objekts .str() liefert eine vernünftige Beschreibung von fast allem, und im schlimmsten Fall kann tatsächlich auch nichts “Schlimmes” passieren. Aus dem Output erkennen wir, dass der Datensatz 1704 Beobachtungen enthält.Auf der anderen Seite hätten wir durch direkten Aufruf von gapminder den Inhalt auch direkt auf den Bildschirm schreiben können. Aber vielleicht hast du schon mal einen größeren Datensatz aufgerufen und zögerst nun etwas, da große Datensätze einfach die Konsole füllen und nur sehr wenig Einblick bieten.Dies ist der erste große Sieg für tibbles. Tidyverse bietet eine spezielle data frame Variante : ein “tibble”. Dies wird auch verdeutlicht, wenn man sich z.B. die Klasse des gapminder Objekts anschautSchau, es ist immer noch ein reguläres data frame, aber eben auch ein tibble.Jetzt können wir gapminder einfach auf den Bildschirm anzeigen! Da es sich um ein tibble handelt, wird nur das Wichtigste angezeigt und deine Konsole läuft nicht voll.Wenn du mit einem reinen data frame arbeitest - und dieses Feature magst - kannst du es mit as_tibble() ein tibble transformieren.Weitere Möglichkeiten, grundlegende Informationen zu einem data frame abzufragen:Ein bisschen deskriptive Statistik zum Inhalt eines data frames erhältst du mit summary():Bemerkung: summary() ist eine generische Funktion. Für eine gegebene Klasse (des Inputs) bestimmt die generische Funktion die passende Methode. Die Funktion summary() besitzt die folgenden Methoden:Obwohl wir uns formell noch nicht eingehender mit der Visualisierung beschäftigt haben, ist es wichtig ein paar Grafiken zu erzeugen um einen ersten Eindruck über den Datensatz zu bekommen. Auf der anderen Seite werden die Grafiken aber auch nicht (viel) aufwendiger als im Data Visualisation Basics PrimerGrafiken dieser Art werden wir zu einem späteren Zeitpunkt noch genauer behandeln. Dann sprechen wir auch über deren Inhalt.Wir schauen uns nochmal die Ausgabe von str() , um darüber zu sprechen, ein data frame genau ist.Ein data frame ist ein Sonderfall einer Liste, die R verwendet wird, um gut wie alles aufzunehmen. Data frames sind ein Spezialfall, bei dem die Länge jedes Listenelements gleich ist.Nehmen wir mal , dass wir eine Beschreibung der Variablenzusammen mit den Daten abspeichern wollen. Dazu könnten wir ein tibbleerzeugen, das die Beschreibungen enthält. Dieses data frame hat nun die Dimension 6x2. Trotzdem können wir es mit gapminder kombinieren, wenn wir beide tibbles einer Liste abspeichern","code":"\nstr(gapminder)\n#> tibble [1,704 × 6] (S3: tbl_df/tbl/data.frame)\n#>  $ country  : Factor w/ 142 levels \"Afghanistan\",..: 1 1 1 1 1 1 1 1 1 1 ...\n#>  $ continent: Factor w/ 5 levels \"Africa\",\"Americas\",..: 3 3 3 3 3 3 3 3 3 3 ...\n#>  $ year     : int [1:1704] 1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 ...\n#>  $ lifeExp  : num [1:1704] 28.8 30.3 32 34 36.1 ...\n#>  $ pop      : int [1:1704] 8425333 9240934 10267083 11537966 13079460 14880372..\n#>  $ gdpPercap: num [1:1704] 779 821 853 836 740 ...\nclass(gapminder)\n#> [1] \"tbl_df\"     \"tbl\"        \"data.frame\"\ngapminder\n#> # A tibble: 1,704 x 6\n#>    country     continent  year lifeExp      pop gdpPercap\n#>    <fct>       <fct>     <int>   <dbl>    <int>     <dbl>\n#>  1 Afghanistan Asia       1952    28.8  8425333      779.\n#>  2 Afghanistan Asia       1957    30.3  9240934      821.\n#>  3 Afghanistan Asia       1962    32.0 10267083      853.\n#>  4 Afghanistan Asia       1967    34.0 11537966      836.\n#>  5 Afghanistan Asia       1972    36.1 13079460      740.\n#>  6 Afghanistan Asia       1977    38.4 14880372      786.\n#>  7 Afghanistan Asia       1982    39.9 12881816      978.\n#>  8 Afghanistan Asia       1987    40.8 13867957      852.\n#>  9 Afghanistan Asia       1992    41.7 16317921      649.\n#> 10 Afghanistan Asia       1997    41.8 22227415      635.\n#> # … with 1,694 more rows\nlibrary(tidyverse)\nas_tibble(iris)\n#> # A tibble: 150 x 5\n#>    Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n#>           <dbl>       <dbl>        <dbl>       <dbl> <fct>  \n#>  1          5.1         3.5          1.4         0.2 setosa \n#>  2          4.9         3            1.4         0.2 setosa \n#>  3          4.7         3.2          1.3         0.2 setosa \n#>  4          4.6         3.1          1.5         0.2 setosa \n#>  5          5           3.6          1.4         0.2 setosa \n#>  6          5.4         3.9          1.7         0.4 setosa \n#>  7          4.6         3.4          1.4         0.3 setosa \n#>  8          5           3.4          1.5         0.2 setosa \n#>  9          4.4         2.9          1.4         0.2 setosa \n#> 10          4.9         3.1          1.5         0.1 setosa \n#> # … with 140 more rows\nnames(gapminder)\n#> [1] \"country\"   \"continent\" \"year\"      \"lifeExp\"   \"pop\"       \"gdpPercap\"\nncol(gapminder)\n#> [1] 6\nlength(gapminder)\n#> [1] 6\ndim(gapminder)\n#> [1] 1704    6\nnrow(gapminder)\n#> [1] 1704\nsummary(gapminder)\n#>         country        continent        year         lifeExp    \n#>  Afghanistan:  12   Africa  :624   Min.   :1952   Min.   :23.6  \n#>  Albania    :  12   Americas:300   1st Qu.:1966   1st Qu.:48.2  \n#>  Algeria    :  12   Asia    :396   Median :1980   Median :60.7  \n#>  Angola     :  12   Europe  :360   Mean   :1980   Mean   :59.5  \n#>  Argentina  :  12   Oceania : 24   3rd Qu.:1993   3rd Qu.:70.8  \n#>  Australia  :  12                  Max.   :2007   Max.   :82.6  \n#>  (Other)    :1632                                               \n#>       pop             gdpPercap     \n#>  Min.   :6.00e+04   Min.   :   241  \n#>  1st Qu.:2.79e+06   1st Qu.:  1202  \n#>  Median :7.02e+06   Median :  3532  \n#>  Mean   :2.96e+07   Mean   :  7215  \n#>  3rd Qu.:1.96e+07   3rd Qu.:  9325  \n#>  Max.   :1.32e+09   Max.   :113523  \n#> \nmethods(summary)\n#>  [1] summary,ANY-method             summary,DBIObject-method      \n#>  [3] summary.aov                    summary.aovlist*              \n#>  [5] summary.aspell*                summary.check_packages_in_dir*\n#>  [7] summary.connection             summary.data.frame            \n#>  [9] summary.Date                   summary.default               \n#> [11] summary.Duration*              summary.ecdf*                 \n#> [13] summary.factor                 summary.ggplot*               \n#> [15] summary.glm                    summary.haven_labelled*       \n#> [17] summary.hcl_palettes*          summary.infl*                 \n#> [19] summary.Interval*              summary.lm                    \n#> [21] summary.loess*                 summary.manova                \n#> [23] summary.matrix                 summary.mlm*                  \n#> [25] summary.nls*                   summary.packageStatus*        \n#> [27] summary.Period*                summary.POSIXct               \n#> [29] summary.POSIXlt                summary.ppr*                  \n#> [31] summary.prcomp*                summary.princomp*             \n#> [33] summary.proc_time              summary.rlang_error*          \n#> [35] summary.rlang_trace*           summary.srcfile               \n#> [37] summary.srcref                 summary.stepfun               \n#> [39] summary.stl*                   summary.table                 \n#> [41] summary.tukeysmooth*           summary.vctrs_sclr*           \n#> [43] summary.vctrs_vctr*            summary.warnings              \n#> see '?methods' for accessing help and source code\nggplot(gapminder, mapping = aes(x = year, y = lifeExp)) +\n         geom_point()\nggplot(gapminder, mapping = aes(x = gdpPercap, y = lifeExp)) +\n         geom_point()\nggplot(gapminder, mapping = aes(x = log(gdpPercap), y = lifeExp)) +\n         geom_point()\nstr(gapminder)\n#> tibble [1,704 × 6] (S3: tbl_df/tbl/data.frame)\n#>  $ country  : Factor w/ 142 levels \"Afghanistan\",..: 1 1 1 1 1 1 1 1 1 1 ...\n#>  $ continent: Factor w/ 5 levels \"Africa\",\"Americas\",..: 3 3 3 3 3 3 3 3 3 3 ...\n#>  $ year     : int [1:1704] 1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 ...\n#>  $ lifeExp  : num [1:1704] 28.8 30.3 32 34 36.1 ...\n#>  $ pop      : int [1:1704] 8425333 9240934 10267083 11537966 13079460 14880372..\n#>  $ gdpPercap: num [1:1704] 779 821 853 836 740 ...\nnames(gapminder)\n#> [1] \"country\"   \"continent\" \"year\"      \"lifeExp\"   \"pop\"       \"gdpPercap\"\n(desc <- tibble(variables = names(gapminder),\n               desc = c(\"factor with 142 levels\", \"factor with 5 levels\",\n                        \"ranges from 1952 to 2007 in increments of 5 years\",\n                        \"life expectancy at birth, in years\",\n                        \"population\",\"GDP per capita (US$, inflation-adjusted)\")))\n#> # A tibble: 6 x 2\n#>   variables desc                                             \n#>   <chr>     <chr>                                            \n#> 1 country   factor with 142 levels                           \n#> 2 continent factor with 5 levels                             \n#> 3 year      ranges from 1952 to 2007 in increments of 5 years\n#> 4 lifeExp   life expectancy at birth, in years               \n#> 5 pop       population                                       \n#> 6 gdpPercap GDP per capita (US$, inflation-adjusted)\ngapminder_desc <- list(gapminder, desc)\nstr(gapminder_desc)\n#> List of 2\n#>  $ : tibble [1,704 × 6] (S3: tbl_df/tbl/data.frame)\n#>   ..$ country  : Factor w/ 142 levels \"Afghanistan\",..: 1 1 1 1 1 1 1 1 1 1 ...\n#>   ..$ continent: Factor w/ 5 levels \"Africa\",\"Americas\",..: 3 3 3 3 3 3 3 3 3 ..\n#>   ..$ year     : int [1:1704] 1952 1957 1962 1967 1972 1977 1982 1987 1992 199..\n#>   ..$ lifeExp  : num [1:1704] 28.8 30.3 32 34 36.1 ...\n#>   ..$ pop      : int [1:1704] 8425333 9240934 10267083 11537966 13079460 14880..\n#>   ..$ gdpPercap: num [1:1704] 779 821 853 836 740 ...\n#>  $ : tibble [6 × 2] (S3: tbl_df/tbl/data.frame)\n#>   ..$ variables: chr [1:6] \"country\" \"continent\" \"year\" \"lifeExp\" ...\n#>   ..$ desc     : chr [1:6] \"factor with 142 levels\" \"factor with 5 levels\" \"r\".."},{"path":"basic-data-care.html","id":"variablen-in-einem-data-frame","chapter":"Kapitel 5 Letzte Vorbereitungen …","heading":"5.4 Variablen in einem Data Frame","text":"Um eine einzelne Variable aus einem data frame anzusprechen, kann man mit dem Dollarzeichen $ arbeiten. Wir schauen uns dazu die numerische Variable lifeExp .Zusätzlich wollen wir die noch die Verteilung von lifeExp visualisieren und plotten dazu ein Histogramm. Da wir dazu ggplot() verwenden, können wir lifeExp wieder direkt aufrufen.Alternativ können wir die Einträge eines data frames auch über die eckigen Klammern [] indizieren.Dabei spezifiziert der Eintrag links vom Komma die Zeilen und der Wert rechts davon die Spalten. Dies ist hilfreich, wenn man auf einzelne Werte zugreifen . Aber beim Aufruf einer kompletten Variable (Spalte) ist die $ Notation sicherlich vorteilhaft.Die Variable year ist eine ganzzahlige Variable, aber da es wenige unterschiedliche Werte gibt, funktioniert sie auch ein wenig wie eine kategoriale Variable.Die Variablen country und continent enthalten rein kategorische Informationen, die R (häufig) als factor gespeichert werden.Die Levels von continent sind “Afrika”, “America” usw., und das ist es, einem normalerweise R angezeigt werden sollte, wenn man eine Faktorvariable aufruft. Im Allgemeinen sind die Levels von Menschen lesbare Zeichenfolgen, wie “male/female” und “control/treated”. Aber vergiss niemals, dass R diese Information kodierter Form speichert. Schauen dir zum Beispiel das Ergebnis von str(gapminder$continent) , falls du skeptisch sein solltest.Faktorvariablen haben Vor- und Nachteil. Im weiteren Verlauf zeigen wir sowohl die Vor- wie auch die Nachteile. Generell ist aber durchaus , dass die Vorteile überwiegen.Als Nächstes erstellen wir mit der Funktion table() eine Häufigkeitstabelle für die Variable count. Dieser Inhalt wird anschließend visualisiert über die Funktion geom_bar(). Die entsprechende Berechnung der Häufigkeitstabelle wird dabei aber sowohl von table() wie auch von geom_bar() (über die statistische Transformation stat_count()) durchgeführt, oder anders gesagt, wir können geom_bar() den Datensatz (hier gapminder) anstatt von vorab berechneten Werten übergeben.den folgenden Abbildungen sehen wir, wie Faktoren Zahlen umgesetzt werden können. Der continent-Faktor lässt sich durch das ggplot2-Paket leicht “Facetten” oder Farben und eine Legende abbilden.Die Erstellung von Grafiken mit ggplot2 werden wir noch genauer besprechen. Daher kannst du dich also ruhig zurücklehnen und die Plots genießen oder blind kopieren/einfügen.","code":"\nhead(gapminder$lifeExp)\n#> [1] 28.8 30.3 32.0 34.0 36.1 38.4\nsummary(gapminder$lifeExp)\n#>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n#>    23.6    48.2    60.7    59.5    70.8    82.6\nggplot(gapminder, mapping = aes(x = lifeExp)) + \n  geom_histogram()\n#> `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\nsummary(gapminder[,\"lifeExp\"])\n#>     lifeExp    \n#>  Min.   :23.6  \n#>  1st Qu.:48.2  \n#>  Median :60.7  \n#>  Mean   :59.5  \n#>  3rd Qu.:70.8  \n#>  Max.   :82.6\nsummary(gapminder$year)\n#>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n#>    1952    1966    1980    1980    1993    2007\ntable(gapminder$year)\n#> \n#> 1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 2002 2007 \n#>  142  142  142  142  142  142  142  142  142  142  142  142\nclass(gapminder$continent)\n#> [1] \"factor\"\nsummary(gapminder$continent)\n#>   Africa Americas     Asia   Europe  Oceania \n#>      624      300      396      360       24\nlevels(gapminder$continent)\n#> [1] \"Africa\"   \"Americas\" \"Asia\"     \"Europe\"   \"Oceania\"\nnlevels(gapminder$continent)\n#> [1] 5\nstr(gapminder$continent)\n#>  Factor w/ 5 levels \"Africa\",\"Americas\",..: 3 3 3 3 3 3 3 3 3 3 ...\ntable(gapminder$continent)\n#> \n#>   Africa Americas     Asia   Europe  Oceania \n#>      624      300      396      360       24\nggplot(gapminder, aes(x = continent)) + geom_bar()\n# wir initialisieren ein grafik (ohne inhalt)\np <- ggplot(filter(gapminder, continent != \"Oceania\"),\n            aes(x = gdpPercap, y = lifeExp))  \np <- p + scale_x_log10() # auf der x-achse soll eine log skala verwendet werden\np + geom_point() # ein scatterplot\np + geom_point(aes(color = continent)) # für verschiedene kontinente werden verschiedene farben verwendet\np + geom_point(alpha = (1/3), size = 3) + # punkte mit transparenz\n  geom_smooth(lwd = 3, se = FALSE) # geglätter zusammenhang\n#> `geom_smooth()` using method = 'gam' and formula 'y ~ s(x, bs = \"cs\")'\np + geom_point(alpha = (1/3), size = 3) + \n  facet_wrap(~ continent) + # für jeden kontinent wird eine eigener\n  # plot (innerhalb einer grafik) erzeugt\n  geom_smooth(lwd = 1.5, se = FALSE)\n#> `geom_smooth()` using method = 'loess' and formula 'y ~ x'"},{"path":"basic-data-care.html","id":"recap","chapter":"Kapitel 5 Letzte Vorbereitungen …","heading":"5.5 Recap","text":"Benutze data frames!!!Benutze data frames!!!Benutze tidyverse!!! Dadurch wird eine spezielle Art von data frames, ein “tibble”, bereitgestellt, die neben anderen Vorteilen ein nettes Standarddruckverhalten aufweist.Benutze tidyverse!!! Dadurch wird eine spezielle Art von data frames, ein “tibble”, bereitgestellt, die neben anderen Vorteilen ein nettes Standarddruckverhalten aufweist.Im Zweifelsfall kannst du dir immer Inhalte anzeigen lassen über str() oder im Fall eines tibbles, einfach das tibble selbst aufrufen.Im Zweifelsfall kannst du dir immer Inhalte anzeigen lassen über str() oder im Fall eines tibbles, einfach das tibble selbst aufrufen.Sei dir immer über die Anzahl Zeilen und Spalten deiner data frames bewusst.Sei dir immer über die Anzahl Zeilen und Spalten deiner data frames bewusst.Sei dir im Klaren welche Art (numerisch, kategorial, …) von Variablen deinen data frames enthalten sind.Sei dir im Klaren welche Art (numerisch, kategorial, …) von Variablen deinen data frames enthalten sind.Benutze factors!!! Aber mach das bewusst und mit Vorsicht.Benutze factors!!! Aber mach das bewusst und mit Vorsicht.Führe für jede Variable eine grundlegende statistische und visuelle Überprüfung durch.Führe für jede Variable eine grundlegende statistische und visuelle Überprüfung durch.Ruf Variablen mit ihrem Namen auf, z.B. gapminder$lifeExp, nicht mit der Spaltennummer. Dein Code wird dadurch robuster und lesbarer sein.Ruf Variablen mit ihrem Namen auf, z.B. gapminder$lifeExp, nicht mit der Spaltennummer. Dein Code wird dadurch robuster und lesbarer sein.","code":""},{"path":"dplyr-intro.html","id":"dplyr-intro","chapter":"Kapitel 6 Einführung in dplyr","heading":"Kapitel 6 Einführung in dplyr","text":"","code":""},{"path":"dplyr-intro.html","id":"einstieg","chapter":"Kapitel 6 Einführung in dplyr","heading":"6.1 Einstieg","text":"dplyr ist ein Paket zur Datenmanipulation, entwickelt von Hadley Wickham und Romain Francois. erster Linie es schnell und ausdrucksstark sein. Es wird als Teil des “Metapakets” tidyverse installiert und gehört als Kernpaket zu den Paketen, die über library(tidyverse) geladen werden.Die Wurzeln von dplyr liegen einem früheren Paket mit dem Namen plyr, das zum Ziel hat die “split-apply-combine”-Strategie der Datenanalyse (Wickham 2011) umzusetzen. Wo plyr noch einen vielfältigen Satz von Ein- und Ausgaben abdeckt (z.B. Arrays, data frames, Listen), hat dplyr einen klaren Fokus auf data frames oder, im Tidyverse, tibbles.dplyr bietet schnelle Alternativen zu den R Standardfunktionen: subset(), apply(), [sl]apply(), tapply(), aggregate(), split(), .call(), (), within(), und mehr. Ferner kann man dplyr nutzen um über Zeilen oder Gruppen von Zeilen zu iterieren, eine schnelle Alternative zur Nutzung von Schleifen darstellt.","code":""},{"path":"dplyr-intro.html","id":"wie-immer-laden-wir-zu-beginn-tidyverse","chapter":"Kapitel 6 Einführung in dplyr","heading":"6.1.1 Wie immer, laden wir zu Beginn tidyverse","text":"Der Fokus liegt diesem Abschnitt auf dplyr. Aber da wir immer wieder auch Funktionen aus anderen “tidyverse-Paketen” nutzen, laden wir stets tidyverse.Zusätzlich wollen wir auch noch gapminder laden.","code":"\nlibrary(tidyverse)\n#> ── Attaching packages ─────────────────────────────────────── tidyverse 1.3.1 ──\n#> ✓ ggplot2 3.3.5     ✓ purrr   0.3.4\n#> ✓ tibble  3.1.2     ✓ dplyr   1.0.7\n#> ✓ tidyr   1.1.3     ✓ stringr 1.4.0\n#> ✓ readr   2.0.1     ✓ forcats 0.5.1\n#> ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n#> x dplyr::filter() masks stats::filter()\n#> x dplyr::lag()    masks stats::lag()\nlibrary(gapminder)"},{"path":"dplyr-intro.html","id":"filter-indizieren-von-zeilen","chapter":"Kapitel 6 Einführung in dplyr","heading":"6.2 filter(): Indizieren von Zeilen","text":"filter() nimmt logische Ausdrücke und gibt die Zeilen zurück, für die der logische Ausdruck ein TRUE ergibt.Zum Vergleich kann man sich einen R Standardbefehl anschauen, der zum gleichen Ergebnis führt:Unter keinen Umständen solltest du allerdings deine Daten unterteilen, wie hier:Warum ist das eine blöde Idee?Es ist nicht selbstdokumentierend. ist das Besondere den Zeilen 241 bis 252?Es ist fehleranfällig. Diese Codezeile wird zu anderen Ergebnissen führen, wenn jemand die Zeilenreihenfolge von gapminder ändert, z.B. die Daten früher im Skript sortiert.Dieser Aufruf erklärt sich von selbst und ist ziemlich robust.","code":"\nfilter(gapminder, lifeExp < 29)\n#> # A tibble: 2 x 6\n#>   country     continent  year lifeExp     pop gdpPercap\n#>   <fct>       <fct>     <int>   <dbl>   <int>     <dbl>\n#> 1 Afghanistan Asia       1952    28.8 8425333      779.\n#> 2 Rwanda      Africa     1992    23.6 7290203      737.\nfilter(gapminder, country == \"Rwanda\", year > 1979)\n#> # A tibble: 6 x 6\n#>   country continent  year lifeExp     pop gdpPercap\n#>   <fct>   <fct>     <int>   <dbl>   <int>     <dbl>\n#> 1 Rwanda  Africa     1982    46.2 5507565      882.\n#> 2 Rwanda  Africa     1987    44.0 6349365      848.\n#> 3 Rwanda  Africa     1992    23.6 7290203      737.\n#> 4 Rwanda  Africa     1997    36.1 7212583      590.\n#> 5 Rwanda  Africa     2002    43.4 7852401      786.\n#> 6 Rwanda  Africa     2007    46.2 8860588      863.\nfilter(gapminder, country %in% c(\"Rwanda\", \"Afghanistan\"))\n#> # A tibble: 24 x 6\n#>    country     continent  year lifeExp      pop gdpPercap\n#>    <fct>       <fct>     <int>   <dbl>    <int>     <dbl>\n#>  1 Afghanistan Asia       1952    28.8  8425333      779.\n#>  2 Afghanistan Asia       1957    30.3  9240934      821.\n#>  3 Afghanistan Asia       1962    32.0 10267083      853.\n#>  4 Afghanistan Asia       1967    34.0 11537966      836.\n#>  5 Afghanistan Asia       1972    36.1 13079460      740.\n#>  6 Afghanistan Asia       1977    38.4 14880372      786.\n#>  7 Afghanistan Asia       1982    39.9 12881816      978.\n#>  8 Afghanistan Asia       1987    40.8 13867957      852.\n#>  9 Afghanistan Asia       1992    41.7 16317921      649.\n#> 10 Afghanistan Asia       1997    41.8 22227415      635.\n#> # … with 14 more rows\ngapminder[gapminder$lifeExp < 29, ] \nsubset(gapminder, country == \"Rwanda\" & year > 1979) ## subset funktioniert ähnlich wir filter\nauswahl <- gapminder[241:252, ]\nfilter(gapminder, country == \"Canada\")"},{"path":"dplyr-intro.html","id":"der-pipe-operator","chapter":"Kapitel 6 Einführung in dplyr","heading":"6.3 Der Pipe-Operator","text":"Bevor es weitergeht, wollen wir aber den Pipe-Operator, den das Tidyverse aus dem magrittr-Paket von Stefan Bache importiert, vorstellen. Mithilfe des Pipe-Operators ist man der Lage Befehle für mehrere Operationen auszuführen, ohne sie ineinander zu verschachteln. Diese neue Syntax führt zu Code, der viel einfacher zu schreiben und zu lesen ist.Und sieht er aus: %>%. Das entsprechende RStudio Tastenkürzel lautet: Ctrl+Shift+M (Windows), Cmd+Shift+M (Mac).Erstmal ein BeispielDu siehst, der Befehl ist äquivalent zu head(gapminder). Der Pipe-Operator nimmt das Objekt auf der linken Seite und leitet es den Funktionsaufruf auf der rechten Seite weiter - er gibt es buchstäblich als erstes Argument ein.Keine Angst, du kannst immer noch weitere Argumente für die Funktion auf der rechten Seite angeben! Um die ersten 3 Reihen von gapminder zu sehen, könnte man sagen: head(gapminder, 3) oder:Du bist wahrscheinlich noch nicht sehr beeindruckt, aber das sollte sich noch ändern.","code":"\ngapminder %>% head()\n#> # A tibble: 6 x 6\n#>   country     continent  year lifeExp      pop gdpPercap\n#>   <fct>       <fct>     <int>   <dbl>    <int>     <dbl>\n#> 1 Afghanistan Asia       1952    28.8  8425333      779.\n#> 2 Afghanistan Asia       1957    30.3  9240934      821.\n#> 3 Afghanistan Asia       1962    32.0 10267083      853.\n#> 4 Afghanistan Asia       1967    34.0 11537966      836.\n#> 5 Afghanistan Asia       1972    36.1 13079460      740.\n#> 6 Afghanistan Asia       1977    38.4 14880372      786.\ngapminder %>% head(3)\n#> # A tibble: 3 x 6\n#>   country     continent  year lifeExp      pop gdpPercap\n#>   <fct>       <fct>     <int>   <dbl>    <int>     <dbl>\n#> 1 Afghanistan Asia       1952    28.8  8425333      779.\n#> 2 Afghanistan Asia       1957    30.3  9240934      821.\n#> 3 Afghanistan Asia       1962    32.0 10267083      853."},{"path":"dplyr-intro.html","id":"mit-select-variablen-auswählen","chapter":"Kapitel 6 Einführung in dplyr","heading":"6.4 Mit select() Variablen auswählen","text":"Nun zurück zu dplyr….Verwende select(), um aus den Daten verschiedene Variablen (Spalten) auszuwählen. Hier kommt eine typische Verwendung von select():Und nun noch kombiniert mit head() über den Pipe-Operator:Worten: “Nimm gapminder, wähle die Variablen year und lifeExp und zeige dann die ersten 4 Zeilen .”","code":"\nselect(gapminder, year, lifeExp)\n#> # A tibble: 1,704 x 2\n#>     year lifeExp\n#>    <int>   <dbl>\n#>  1  1952    28.8\n#>  2  1957    30.3\n#>  3  1962    32.0\n#>  4  1967    34.0\n#>  5  1972    36.1\n#>  6  1977    38.4\n#>  7  1982    39.9\n#>  8  1987    40.8\n#>  9  1992    41.7\n#> 10  1997    41.8\n#> # … with 1,694 more rows\ngapminder %>%\n  select(year, lifeExp) %>%\n  head(4)\n#> # A tibble: 4 x 2\n#>    year lifeExp\n#>   <int>   <dbl>\n#> 1  1952    28.8\n#> 2  1957    30.3\n#> 3  1962    32.0\n#> 4  1967    34.0"},{"path":"dplyr-intro.html","id":"jetzt-nochmal-ein-vergleich-zu-r-standardbefehlen","chapter":"Kapitel 6 Einführung in dplyr","heading":"6.5 Jetzt nochmal ein Vergleich zu R Standardbefehlen","text":"Hier sind die Daten für Kambodscha, aber nur bestimmte Variablen:und würde ein typischer R Standardbefehl aussehen:der zum gleichen Ergebnis führt. Wir würden sagen, dass der dplyr Befehl deutlich leichter zu lesen ist.","code":"\ngapminder %>%\n  filter(country == \"Cambodia\") %>%\n  select(year, lifeExp)\n#> # A tibble: 12 x 2\n#>     year lifeExp\n#>    <int>   <dbl>\n#>  1  1952    39.4\n#>  2  1957    41.4\n#>  3  1962    43.4\n#>  4  1967    45.4\n#>  5  1972    40.3\n#>  6  1977    31.2\n#>  7  1982    51.0\n#>  8  1987    53.9\n#>  9  1992    55.8\n#> 10  1997    56.5\n#> 11  2002    56.8\n#> 12  2007    59.7\ngapminder[gapminder$country == \"Cambodia\", c(\"year\", \"lifeExp\")]\n#> # A tibble: 12 x 2\n#>     year lifeExp\n#>    <int>   <dbl>\n#>  1  1952    39.4\n#>  2  1957    41.4\n#>  3  1962    43.4\n#>  4  1967    45.4\n#>  5  1972    40.3\n#>  6  1977    31.2\n#>  7  1982    51.0\n#>  8  1987    53.9\n#>  9  1992    55.8\n#> 10  1997    56.5\n#> 11  2002    56.8\n#> 12  2007    59.7"},{"path":"dplyr-intro.html","id":"pure-predictable-pipeable","chapter":"Kapitel 6 Einführung in dplyr","heading":"6.6 Pure, predictable, pipeable","text":"Bisher haben wir nur etwas der Oberfläche von dplyr gekratzt, trotzdem möchten wir auf ein Schlüsselprinzipien hinweisen, die du vielleicht langsam zu schätzen lernen wirst.Die Verben (Hauptfunktionen) von dplyr, wie z.B. filter() und select(), sind pure functions. Dazu schreibt Hadley Wickham Functions chapter seinem Advanced R Buch (2015a):functions easiest understand reason pure functions: functions always map input output impact workspace. words, pure functions side effects: don’t affect state world way apart value return.Tatsächlich sind diese Verben ein Spezialfall reiner Funktionen: sie nehmen als Input und Output denselben Objekttyp , .d.R. ein data frame.Die Daten sind für diese Funktionen aus stets das erste Inputargument.Die dplyr Einführung geht weiter im Kapitel Mehr zu dplyr.","code":""},{"path":"dplyr-single.html","id":"dplyr-single","chapter":"Kapitel 7 Mehr zu dplyr","heading":"Kapitel 7 Mehr zu dplyr","text":"","code":""},{"path":"dplyr-single.html","id":"wo-stehen-wir","chapter":"Kapitel 7 Mehr zu dplyr","heading":"7.1 Wo stehen wir?","text":"Kapitel 6, Einführung dplyr, haben wir bereits zwei sehr wichtige Verben sowie einen Operator vorgestellt und verwendet:filter() zum Auswählen spezieller Zeilen eines Datensatzesselect() zum Auswählen spezieller Variablen eines Datensatzesden Pipe-Operator %>%, der das Objekt auf der linken Seite überführt als erstes Funktionsargument der Funktion auf der rechten SeiteWir haben auch die Rolle von dplyr innerhalb des tidyverse besprochen:dplyr ist ein Kernpaket der tidyverse Kollektion von Paketen. Da wir die anderen oft beiläufig benutzen, werden wir stets dplyr und die anderen über library(tidyverse) laden.","code":""},{"path":"dplyr-single.html","id":"falls-noch-nicht-geschehen-lade-dplyr-und-gapminder","chapter":"Kapitel 7 Mehr zu dplyr","heading":"7.2 Falls noch nicht geschehen: lade dplyr und gapminder","text":"Wir starten wieder mit dem Laden von dplyr (über tidyverse)und gapminder","code":"\nlibrary(tidyverse)\n#> ── Attaching packages ─────────────────────────────────────── tidyverse 1.3.1 ──\n#> ✓ ggplot2 3.3.5     ✓ purrr   0.3.4\n#> ✓ tibble  3.1.2     ✓ dplyr   1.0.7\n#> ✓ tidyr   1.1.3     ✓ stringr 1.4.0\n#> ✓ readr   2.0.1     ✓ forcats 0.5.1\n#> ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n#> x dplyr::filter() masks stats::filter()\n#> x dplyr::lag()    masks stats::lag()\nlibrary(gapminder)"},{"path":"dplyr-single.html","id":"mitmutate-neue-variablen-erstellen","chapter":"Kapitel 7 Mehr zu dplyr","heading":"7.3 Mitmutate() neue Variablen erstellen","text":"Wir starten mit dem Anlegen einer Kopie von gapminder, die wir dann nach unseren Vorstellungen verändern (wäre aber auch nichts passiert, wenn wir alles mit gapminder durchführen würden).Unser Ziel ist es, dass GDP pro Land anzugeben. Das sollte machbar sein, da schließlich das Pro-Kopf-GDP wie auch die Bevölkerungszahl im Datensatz enthalten sind. Multiplizieren beider Variablen liefert uns das gewünschte Ergebnis.mutate() ist eine Funktion, die neue Variablen definiert und ein tibble einfügt. Du kannst auf bestehende Variablen einfach über ihren Namen zugreifen.Hmmmm … diese GDP-Zahlen sind ziemlich groß und abstrakt. dem Zusammenhang, bedenke den Ratschlag von Randall Munroe:One thing bothers large numbers presented without context… “added zero number, sentence containing mean something different ?” answer “”, maybe number business sentence first place.Vielleicht wäre es für die Betrachter unseres tibbles sinnvoller, beim Pro-Kopf-GDP zu bleiben. Aber wäre, wenn wir das Pro-Kopf-GDP angeben würde, Relation zu irgendeinem Vergleichsland. Wir könnten alles Bezug auf die entsprechenden Daten aus Deutschland angeben.Dazu müssen wir eine neue Variable erstellen, die gdpPercap geteilt durch die deutschen gdpPercap Werte ist, wobei wir darauf achten müssen, dass wir immer zwei Zahlen teilen, die sich auf dasselbe Jahr beziehen.Wie können wir das schaffen:Deutschland Beobachtungen einem Objekt ger_gap speichernErstellen Sie eine neue temporäre Variable tmp my_gap:\nDie gdpPercap-Variable aus tmp aufrufen.\nMit rep() die gdpPerap Wert aus tmp einmal pro Land im my_gap reproduzieren, damit ein Vektor, der die gleiche Anzahl Beobachtungen wie my_gap hat.\nDie gdpPercap-Variable aus tmp aufrufen.Mit rep() die gdpPerap Wert aus tmp einmal pro Land im my_gap reproduzieren, damit ein Vektor, der die gleiche Anzahl Beobachtungen wie my_gap hat.Dividieren der gdpPercap Werte durch die deutschen Zahlen.Löschen der temporäre Variable tmp my_gap.Beachte, dass mutate() neue Variablen sequentiell erstellt, dass du auf frühere Variablen (wie tmp) verweisen kannst um spätere Variablen (wie gdpPercapRel) zu definieren. Nachdem eine Variable nicht mehr benötigt wird, kannst du sie einfach auf NULL setzen.Hat das funktioniert? Einfach mal die Werte von gdpPercapRel für Deutschland anschauen. Sollten besser alle 1 sein!Ich nehme Deutschland ist ein Land mit einem “hohen GDP” pro Kopf, daher gehe ich davon aus, dass die Verteilung von gdpPercapRel unter 1 liegt, möglicherweise sogar weit darunter. Aber besser mal nachschauen ob dem ist:Die Zahlen des relativen Pro-Kopf-GDP liegen im deutlich unter 1. Wir sehen, dass die meisten Länder, die diesem Datensatz erfasst werden, über den gesamten Zeitraum im Vergleich zu Deutschland ein wesentlich niedrigeres Pro-Kopf-GDP aufweisen.Tipp: Vertraue niemandem. Einschließlich (besonders?) dir selbst. Versuche immer, einen Weg zu finden, um zu überprüfen, ob du das gemacht hast, du tun wolltest. Sei nicht schockiert, wenn du manchmal feststellen musst, dass dem nicht ist.","code":"\nmy_gap <- gapminder\nmy_gap %>%\n  mutate(gdp = pop * gdpPercap)\n#> # A tibble: 1,704 x 7\n#>    country     continent  year lifeExp      pop gdpPercap          gdp\n#>    <fct>       <fct>     <int>   <dbl>    <int>     <dbl>        <dbl>\n#>  1 Afghanistan Asia       1952    28.8  8425333      779.  6567086330.\n#>  2 Afghanistan Asia       1957    30.3  9240934      821.  7585448670.\n#>  3 Afghanistan Asia       1962    32.0 10267083      853.  8758855797.\n#>  4 Afghanistan Asia       1967    34.0 11537966      836.  9648014150.\n#>  5 Afghanistan Asia       1972    36.1 13079460      740.  9678553274.\n#>  6 Afghanistan Asia       1977    38.4 14880372      786. 11697659231.\n#>  7 Afghanistan Asia       1982    39.9 12881816      978. 12598563401.\n#>  8 Afghanistan Asia       1987    40.8 13867957      852. 11820990309.\n#>  9 Afghanistan Asia       1992    41.7 16317921      649. 10595901589.\n#> 10 Afghanistan Asia       1997    41.8 22227415      635. 14121995875.\n#> # … with 1,694 more rows\nger_gap <- my_gap %>%\n  filter(country == \"Germany\")\n\nmy_gap <- my_gap %>%\n  mutate(tmp = rep(ger_gap$gdpPercap, nlevels(country)),\n         gdpPercapRel = gdpPercap / tmp,\n         tmp = NULL)\nmy_gap %>% \n  filter(country == \"Germany\") %>% \n  select(country, year, gdpPercapRel)\n#> # A tibble: 12 x 3\n#>    country  year gdpPercapRel\n#>    <fct>   <int>        <dbl>\n#>  1 Germany  1952            1\n#>  2 Germany  1957            1\n#>  3 Germany  1962            1\n#>  4 Germany  1967            1\n#>  5 Germany  1972            1\n#>  6 Germany  1977            1\n#>  7 Germany  1982            1\n#>  8 Germany  1987            1\n#>  9 Germany  1992            1\n#> 10 Germany  1997            1\n#> 11 Germany  2002            1\n#> 12 Germany  2007            1\nsummary(my_gap$gdpPercapRel)\n#>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n#>    0.01    0.07    0.19    0.37    0.51   15.17"},{"path":"dplyr-single.html","id":"mit-arrange-die-zeilenreihenfolge-ändern","chapter":"Kapitel 7 Mehr zu dplyr","heading":"7.4 Mit arrange() die Zeilenreihenfolge ändern","text":"arrange() ordnet die Zeilen einem data frame neu . Stellen dir vor, du möchtest die Daten nach Jahr und Land und nicht nach Land und Jahr geordnet haben.Oder vielleicht willst du nur die Daten aus 2007 sehen, angeordnet entsprechend der Lebenserwartung.Das war nicht du wolltest. Du wolltest nach absteigender Lebenserwartung sortieren. Dann verwende desc().Ein Tipp Ende: verlasse dich bei deinen Analysen NIEMALS darauf, dass Zeilen oder Variablen einer bestimmten Reihenfolge stehen. Aber manchmal man Tabellen anderen präsentieren und dabei macht es durchaus Sinn die Zeilenreihenfolge je nach Fragestellung anzupassen.","code":"\nmy_gap %>%\n  arrange(year, country)\n#> # A tibble: 1,704 x 7\n#>    country     continent  year lifeExp      pop gdpPercap gdpPercapRel\n#>    <fct>       <fct>     <int>   <dbl>    <int>     <dbl>        <dbl>\n#>  1 Afghanistan Asia       1952    28.8  8425333      779.       0.109 \n#>  2 Albania     Europe     1952    55.2  1282697     1601.       0.224 \n#>  3 Algeria     Africa     1952    43.1  9279525     2449.       0.343 \n#>  4 Angola      Africa     1952    30.0  4232095     3521.       0.493 \n#>  5 Argentina   Americas   1952    62.5 17876956     5911.       0.827 \n#>  6 Australia   Oceania    1952    69.1  8691212    10040.       1.41  \n#>  7 Austria     Europe     1952    66.8  6927772     6137.       0.859 \n#>  8 Bahrain     Asia       1952    50.9   120447     9867.       1.38  \n#>  9 Bangladesh  Asia       1952    37.5 46886859      684.       0.0958\n#> 10 Belgium     Europe     1952    68    8730405     8343.       1.17  \n#> # … with 1,694 more rows\nmy_gap %>%\n  filter(year == 2007) %>%\n  arrange(lifeExp)\n#> # A tibble: 142 x 7\n#>    country                continent  year lifeExp     pop gdpPercap gdpPercapRel\n#>    <fct>                  <fct>     <int>   <dbl>   <int>     <dbl>        <dbl>\n#>  1 Swaziland              Africa     2007    39.6  1.13e6     4513.       0.140 \n#>  2 Mozambique             Africa     2007    42.1  2.00e7      824.       0.0256\n#>  3 Zambia                 Africa     2007    42.4  1.17e7     1271.       0.0395\n#>  4 Sierra Leone           Africa     2007    42.6  6.14e6      863.       0.0268\n#>  5 Lesotho                Africa     2007    42.6  2.01e6     1569.       0.0488\n#>  6 Angola                 Africa     2007    42.7  1.24e7     4797.       0.149 \n#>  7 Zimbabwe               Africa     2007    43.5  1.23e7      470.       0.0146\n#>  8 Afghanistan            Asia       2007    43.8  3.19e7      975.       0.0303\n#>  9 Central African Repub… Africa     2007    44.7  4.37e6      706.       0.0219\n#> 10 Liberia                Africa     2007    45.7  3.19e6      415.       0.0129\n#> # … with 132 more rows\nmy_gap %>%\n  filter(year == 2007) %>%\n  arrange(desc(lifeExp))\n#> # A tibble: 142 x 7\n#>    country          continent  year lifeExp       pop gdpPercap gdpPercapRel\n#>    <fct>            <fct>     <int>   <dbl>     <int>     <dbl>        <dbl>\n#>  1 Japan            Asia       2007    82.6 127467972    31656.        0.984\n#>  2 Hong Kong, China Asia       2007    82.2   6980412    39725.        1.23 \n#>  3 Iceland          Europe     2007    81.8    301931    36181.        1.12 \n#>  4 Switzerland      Europe     2007    81.7   7554661    37506.        1.17 \n#>  5 Australia        Oceania    2007    81.2  20434176    34435.        1.07 \n#>  6 Spain            Europe     2007    80.9  40448191    28821.        0.896\n#>  7 Sweden           Europe     2007    80.9   9031088    33860.        1.05 \n#>  8 Israel           Asia       2007    80.7   6426679    25523.        0.793\n#>  9 France           Europe     2007    80.7  61083916    30470.        0.947\n#> 10 Canada           Americas   2007    80.7  33390141    36319.        1.13 \n#> # … with 132 more rows"},{"path":"dplyr-single.html","id":"mit-rename-schöne-namen-vergeben","chapter":"Kapitel 7 Mehr zu dplyr","heading":"7.5 Mit rename() “schöne” Namen vergeben","text":"Ein paar der Namen gapminder sind nicht besonders hübsch, wie z.B. lifeExp. life expectancy wären ja schließlich zwei Worte und daher finde ich (persönliche Meinung) es schöner dies auch im Variablennamen zu sehenDie Änderungen haben wir jetzt aber nicht abgespeichert (auch wenn sie schön waren), da wir den nachfolgenden Code auch weiterhin ausführen könnten ohne die Änderung der Variablennamen durchgeführt zu haben.Bemerkung: Mit select() könnten wir bei der Auswahl von Variablen auch deren Namen änderneverything() wählt alle übrigen (außer gdpPercap) Variablen. Da gdpPercap erster Stelle gewählt wurde, wird die Variable auch zur ersten Spalte.","code":"\nmy_gap %>%\n  rename(life_exp = lifeExp,\n         gdp_percap = gdpPercap,\n         gdp_percap_rel = gdpPercapRel)\n#> # A tibble: 1,704 x 7\n#>    country     continent  year life_exp      pop gdp_percap gdp_percap_rel\n#>    <fct>       <fct>     <int>    <dbl>    <int>      <dbl>          <dbl>\n#>  1 Afghanistan Asia       1952     28.8  8425333       779.         0.109 \n#>  2 Afghanistan Asia       1957     30.3  9240934       821.         0.0806\n#>  3 Afghanistan Asia       1962     32.0 10267083       853.         0.0661\n#>  4 Afghanistan Asia       1967     34.0 11537966       836.         0.0567\n#>  5 Afghanistan Asia       1972     36.1 13079460       740.         0.0411\n#>  6 Afghanistan Asia       1977     38.4 14880372       786.         0.0383\n#>  7 Afghanistan Asia       1982     39.9 12881816       978.         0.0444\n#>  8 Afghanistan Asia       1987     40.8 13867957       852.         0.0346\n#>  9 Afghanistan Asia       1992     41.7 16317921       649.         0.0245\n#> 10 Afghanistan Asia       1997     41.8 22227415       635.         0.0229\n#> # … with 1,694 more rows\nmy_gap %>%\n  filter(country == \"Burundi\", year > 1996) %>% \n  select(yr = year, lifeExp, gdpPercap) %>% \n  select(gdpPercap, everything())\n#> # A tibble: 3 x 3\n#>   gdpPercap    yr lifeExp\n#>       <dbl> <int>   <dbl>\n#> 1      463.  1997    45.3\n#> 2      446.  2002    47.4\n#> 3      430.  2007    49.6"},{"path":"dplyr-single.html","id":"group_by-macht-das-r-leben-einfacher","chapter":"Kapitel 7 Mehr zu dplyr","heading":"7.6 group_by() macht das R Leben einfacher","text":"Nehmen wir mal , dass uns die Antwort auf die Frage “welchem Land ist die Lebenserwartung innerhalb von 5 Jahren stärksten gesunken?” interessiert.dplyr bietet uns mächtige Hilfsmittel um diese Frage zu beantworten:group_by() fügt dem Datensatz eine zusätzliche Struktur hinzu – Gruppierungsinformationen – die die Grundlage für Berechnungen innerhalb der Gruppen bilden.group_by() fügt dem Datensatz eine zusätzliche Struktur hinzu – Gruppierungsinformationen – die die Grundlage für Berechnungen innerhalb der Gruppen bilden.summarise() nimmt einen Datensatz mit \\(n\\)-Beobachtungen, berechnet die angeforderten Zusammenfassungen und gibt einen Datensatz mit einer Beobachtung (falls nur eine Zusammenfassung angefordert wurde) zurück.summarise() nimmt einen Datensatz mit \\(n\\)-Beobachtungen, berechnet die angeforderten Zusammenfassungen und gibt einen Datensatz mit einer Beobachtung (falls nur eine Zusammenfassung angefordert wurde) zurück.Window Funktionen nehmen einen Datensatz mit \\(n\\)-Beobachtungen und geben einen Datensatz mit \\(n\\)-Beobachtungen zurück.Window Funktionen nehmen einen Datensatz mit \\(n\\)-Beobachtungen und geben einen Datensatz mit \\(n\\)-Beobachtungen zurück.mutate() und summarise() berücksichtigen Gruppen.mutate() und summarise() berücksichtigen Gruppen.Kombiniert mit den Verben, die du bereits kennst, kannst du mit diesen neuen Werkzeugen eine extrem vielfältige Reihe von Problemen relativ einfach lösen.","code":""},{"path":"dplyr-single.html","id":"die-dinge-aufzählen","chapter":"Kapitel 7 Mehr zu dplyr","heading":"7.6.1 Die Dinge aufzählen","text":"Beginnen wir mit dem einfachen Zählen. Wie viele Beobachtungen haben wir pro Kontinent?Lassen uns hier kurz innehalten und über das tidyverse nachdenken. Du könntest dir mit table() die gleichen absoluten Häufigkeiten berechnen.Aber das Objekt der Klasse table, das zurückgegeben wird, macht die nachfolgenden Berechnungen einfach etwas kniffliger, als es dir lieb ist. Zum Beispiel ist es zu schade, dass die Namen der Kontinente nur als Namen und nicht als richtige Faktor zusammen mit den berechneten Werten zurückgegeben werden. Dies ist ein Beispiel dafür, wie das tidyverse Übergänge glättet, bei denen die Ausgabe von Schritt die Eingabe von Schritt + 1 werden soll.Die tally() Funktion ist eine Komfortfunktion, die weiß, wie man Zeilen zählt und dabei Gruppen berücksichtigt.Die Funktion count() bietet noch mehr Komfort. Sie kann sowohl gruppieren als auch zählen.wäre, wenn uns nicht nur die Anzahl Beobachtungen pro Kontinent interessiert, sondern auch die Anzahl unterschiedlichen Ländern pro Kontinent. Da wir mehrere Zusammenfassungen innerhalb von summarise() berechnen. Verwenden Sie die Funktion n_distinct(), um die Anzahl der einzelnen Länder innerhalb jedes Kontinents zu zählen.","code":"\nmy_gap %>%\n  group_by(continent) %>%\n  summarise(n = n())\n#> # A tibble: 5 x 2\n#>   continent     n\n#>   <fct>     <int>\n#> 1 Africa      624\n#> 2 Americas    300\n#> 3 Asia        396\n#> 4 Europe      360\n#> 5 Oceania      24\ntable(gapminder$continent)\n#> \n#>   Africa Americas     Asia   Europe  Oceania \n#>      624      300      396      360       24\nstr(table(gapminder$continent))\n#>  'table' int [1:5(1d)] 624 300 396 360 24\n#>  - attr(*, \"dimnames\")=List of 1\n#>   ..$ : chr [1:5] \"Africa\" \"Americas\" \"Asia\" \"Europe\" ...\nmy_gap %>%\n  group_by(continent) %>%\n  tally()\n#> # A tibble: 5 x 2\n#>   continent     n\n#>   <fct>     <int>\n#> 1 Africa      624\n#> 2 Americas    300\n#> 3 Asia        396\n#> 4 Europe      360\n#> 5 Oceania      24\nmy_gap %>% \n  count(continent)\n#> # A tibble: 5 x 2\n#>   continent     n\n#>   <fct>     <int>\n#> 1 Africa      624\n#> 2 Americas    300\n#> 3 Asia        396\n#> 4 Europe      360\n#> 5 Oceania      24\nmy_gap %>%\n  group_by(continent) %>%\n  summarise(n = n(),\n            n_countries = n_distinct(country))\n#> # A tibble: 5 x 3\n#>   continent     n n_countries\n#>   <fct>     <int>       <int>\n#> 1 Africa      624          52\n#> 2 Americas    300          25\n#> 3 Asia        396          33\n#> 4 Europe      360          30\n#> 5 Oceania      24           2"},{"path":"dplyr-single.html","id":"deskriptive-statistiken-mit-summarise","chapter":"Kapitel 7 Mehr zu dplyr","heading":"7.6.2 Deskriptive Statistiken mit summarise()","text":"Kombination mit summarise() können wir eine Vielzahl verschiedenen Funktionen verwenden. Einige davon berechnen klassische deskriptive Statistiken:allen betrachteten Fällen seien \\(x_1,\\dots,x_n\\) numerische Beobachtungen.mean() berechnet das arithmetische Mittel der Beo\\[\\overline x_n = \\frac{1}{n} \\sum_{=1}^n x_i\\,.\\]mean() berechnet das arithmetische Mittel der Beo\\[\\overline x_n = \\frac{1}{n} \\sum_{=1}^n x_i\\,.\\]median() berechnet den Median\n\\[x_{0.5} = \\begin{cases}\nx_{\\left(\\frac{n+1}{2}\\right)}, &  n\\ \\text{ungerade},\\\\\n\\frac{1}{2}\\left(x_{\\left(\\frac{n}{2}\\right)} + x_{\\left(\\frac{n}{2}+1\\right)}\\right), & n\\ \\text{gerade}\n\\end{cases}\\,.\\]median() berechnet den Median\n\\[x_{0.5} = \\begin{cases}\nx_{\\left(\\frac{n+1}{2}\\right)}, &  n\\ \\text{ungerade},\\\\\n\\frac{1}{2}\\left(x_{\\left(\\frac{n}{2}\\right)} + x_{\\left(\\frac{n}{2}+1\\right)}\\right), & n\\ \\text{gerade}\n\\end{cases}\\,.\\]var() berechnet die empirische Varianz\n\\[s_n^2 = \\frac{1}{n-1} \\sum_{=1}^n (x_i - \\overline x_n)^2\\,.\\]var() berechnet die empirische Varianz\n\\[s_n^2 = \\frac{1}{n-1} \\sum_{=1}^n (x_i - \\overline x_n)^2\\,.\\]sd() berechnet die empirische Standardabweichung\n\\[s_n = \\sqrt{s_n^2}\\,.\\]sd() berechnet die empirische Standardabweichung\n\\[s_n = \\sqrt{s_n^2}\\,.\\]IQR() berechnet den Interquartilsabstand\n\\[IQR = x_{0.75} - x_{0.25}\\,,\\]\nwobei \\(x_{0.25}\\) und \\(x_{0.75}\\) das empirische 0.25 bzw. 0.75 Quantil bezeichnen.IQR() berechnet den Interquartilsabstand\n\\[IQR = x_{0.75} - x_{0.25}\\,,\\]\nwobei \\(x_{0.25}\\) und \\(x_{0.75}\\) das empirische 0.25 bzw. 0.75 Quantil bezeichnen.min() berechnet das Minimum\n\\[x_{(1)} = \\min(x_1,\\dots,x_n)\\,.\\]min() berechnet das Minimum\n\\[x_{(1)} = \\min(x_1,\\dots,x_n)\\,.\\]und max() berechnet demnach das Maximum\n\\[x_{(n)} = \\max(x_1,\\dots,x_n)\\,.\\]und max() berechnet demnach das Maximum\n\\[x_{(n)} = \\max(x_1,\\dots,x_n)\\,.\\]Auch wenn dies statistisch gesehen unklug sein mag, lass uns die durchschnittliche Lebenserwartung pro Kontinenten berechnen.summarise_at() wendet die gleiche(n) Zusammenfassungs-Funktion(en) auf mehrere Variablen . Lass uns die durchschnittliche Lebenserwartung sowie den Median und das Pro-Kopf-GDP nach Kontinenten pro Jahr berechnen… aber nur für 1952 und 2007.Konzentrieren wir uns nur auf Asien. Wie hoch ist die minimale und maximale Lebenserwartung pro Jahr?Natürlich wäre es viel interessanter zu sehen, welches Land diese extremen Beobachtungen beigetragen hat. Kommt das Minimum (Maximum) immer aus dem gleichen Land? Wir gehen dem Kürze mit Window Funktionen nach.","code":"\nmy_gap %>%\n  group_by(continent) %>%\n  summarise(avg_lifeExp = mean(lifeExp))\n#> # A tibble: 5 x 2\n#>   continent avg_lifeExp\n#>   <fct>           <dbl>\n#> 1 Africa           48.9\n#> 2 Americas         64.7\n#> 3 Asia             60.1\n#> 4 Europe           71.9\n#> 5 Oceania          74.3\nmy_gap %>%\n  filter(year %in% c(1952, 2007)) %>%\n  group_by(continent, year) %>%\n  summarise_at(vars(lifeExp, gdpPercap), list(mean, median))\n#> # A tibble: 10 x 6\n#> # Groups:   continent [5]\n#>    continent  year lifeExp_fn1 gdpPercap_fn1 lifeExp_fn2 gdpPercap_fn2\n#>    <fct>     <int>       <dbl>         <dbl>       <dbl>         <dbl>\n#>  1 Africa     1952        39.1         1253.        38.8          987.\n#>  2 Africa     2007        54.8         3089.        52.9         1452.\n#>  3 Americas   1952        53.3         4079.        54.7         3048.\n#>  4 Americas   2007        73.6        11003.        72.9         8948.\n#>  5 Asia       1952        46.3         5195.        44.9         1207.\n#>  6 Asia       2007        70.7        12473.        72.4         4471.\n#>  7 Europe     1952        64.4         5661.        65.9         5142.\n#>  8 Europe     2007        77.6        25054.        78.6        28054.\n#>  9 Oceania    1952        69.3        10298.        69.3        10298.\n#> 10 Oceania    2007        80.7        29810.        80.7        29810.\nmy_gap %>%\n  filter(continent == \"Asia\") %>%\n  group_by(year) %>%\n  summarise(min_lifeExp = min(lifeExp), max_lifeExp = max(lifeExp))\n#> # A tibble: 12 x 3\n#>     year min_lifeExp max_lifeExp\n#>    <int>       <dbl>       <dbl>\n#>  1  1952        28.8        65.4\n#>  2  1957        30.3        67.8\n#>  3  1962        32.0        69.4\n#>  4  1967        34.0        71.4\n#>  5  1972        36.1        73.4\n#>  6  1977        31.2        75.4\n#>  7  1982        39.9        77.1\n#>  8  1987        40.8        78.7\n#>  9  1992        41.7        79.4\n#> 10  1997        41.8        80.7\n#> 11  2002        42.1        82  \n#> 12  2007        43.8        82.6"},{"path":"dplyr-single.html","id":"gruppierte-veränderungen","chapter":"Kapitel 7 Mehr zu dplyr","heading":"7.7 Gruppierte Veränderungen","text":"Manchmal möchte man die \\(n\\)-Zeilen für jede Gruppe nicht zu einer Zeile zusammenfassen. Stattdessen möchte man die Gruppen behalten, aber innerhalb dieser Gruppen rechnen.","code":""},{"path":"dplyr-single.html","id":"berechnungen-innerhalb-der-gruppen","chapter":"Kapitel 7 Mehr zu dplyr","heading":"7.7.1 Berechnungen innerhalb der Gruppen","text":"Machen wir eine neue Variable, die die gewonnenen (verlorenen) Lebenserwartungsjahre im Vergleich zu 1952 für jedes einzelne Land angibt. Wir gruppieren nach Ländern und verwenden mutate(), um eine neue Variable zu erstellen. Die Funktion first() extrahiert dabei den ersten Wert aus einem Vektor. Beachte, dass first() mit dem Vektor der Lebenserwartungen jeder Ländergruppe arbeitet.Innerhalb eines Landes nehmen wir die Differenz zwischen der Lebenserwartung im Jahr \\(\\) und der Lebenserwartung im Jahr 1952. Daher sehen wir für 1952 immer Nullen und für die meisten Länder eine Folge von positiven und steigenden Zahlen.","code":"\nmy_gap %>% \n  group_by(country) %>% \n  select(country, year, lifeExp) %>% \n  mutate(lifeExp_gain = lifeExp - first(lifeExp)) %>% \n  filter(year < 1963)\n#> # A tibble: 426 x 4\n#> # Groups:   country [142]\n#>    country      year lifeExp lifeExp_gain\n#>    <fct>       <int>   <dbl>        <dbl>\n#>  1 Afghanistan  1952    28.8         0   \n#>  2 Afghanistan  1957    30.3         1.53\n#>  3 Afghanistan  1962    32.0         3.20\n#>  4 Albania      1952    55.2         0   \n#>  5 Albania      1957    59.3         4.05\n#>  6 Albania      1962    64.8         9.59\n#>  7 Algeria      1952    43.1         0   \n#>  8 Algeria      1957    45.7         2.61\n#>  9 Algeria      1962    48.3         5.23\n#> 10 Angola       1952    30.0         0   \n#> # … with 416 more rows"},{"path":"dplyr-single.html","id":"window-functions","chapter":"Kapitel 7 Mehr zu dplyr","heading":"7.7.2 Window Funktionen","text":"Window Funktionen nehmen \\(n\\)-Eingaben entgegen und geben \\(n\\)-Ausgaben zurück. Außerdem hängt die Ausgabe von allen Werten ab. ist rank() eine Window Funktion, aber log() ist es nicht.Betrachten wir noch einmal die schlechtesten und besten Lebenserwartungen Asien im Laufe der Zeit, behalten aber Informationen darüber bei, welches Land diese Extremwerte beisteuert.Wir sehen, dass (min = Afghanistan, max = Japan) das häufigste Ergebnis ist, aber Kambodscha und Israel tauchen jeweils mindestens einmal als min bzw. max auf.\nAber wäre es nicht schön, eine Zeile pro Jahr zu haben?Wie hat das eigentlich funktioniert? Dazu schauen wir uns die Beobachtungen aus Asien mal direkt .Jetzt wenden wir eine Window Funktion – min_rank(). Da asia nach Jahren gruppiert ist, operiert min_rank() innerhalb von Mini-Datensätzen, jeder für ein bestimmtes Jahr. Auf die Variable LifeExp angewandt, liefert min_rank() den Rang der beobachteten Lebenserwartung jedes Landes.Bemerkung: Der min-Teil gibt nur , wie die Verbindungen unterbrochen werden.Neben dem Minimum gibt es aber auch noch eine Reihe weiterer Alternative, wie z.B. den DurchschnittDann schauen wir uns die Ränge der Lebenserwartung innerhalb eines Jahres mal explizit für ein paar Länder, sowohl der (Standard-) aufsteigenden als auch der absteigenden Reihenfolge.Da wir im zweiten Schritt nach einigen Ländern filtern, erzeugen wir im ersten Schritt mit mutate() die gewünschten Werte und weisen sie neuen Variablen zu.Afghanistan neigt dazu, 1 der le_rank-Variablen zu haben, Japan neigt dazu, 1 der le_desc_rank-Variablen zu haben und andere Länder, wie Thailand, zeigen deutlich weniger extreme Ränge.Damit sollte der ursprüngliche filter() Befehlauch klar sein.Diese beiden Sätze von Rängen werden --fly, innerhalb der Jahresgruppe, gebildet, und filter() behält Zeilen mit Rang weniger als 2. Da wir dies für aufsteigende und absteigende Ränge tun, erhalten wir sowohl den minimalen als auch den maximalen Rang.Wenn wir nur das Minimum ODER das Maximum gewollt hätten, hätte auch ein alternativer Ansatz mit top_n() funktioniert.","code":"\nmy_gap %>%\n  filter(continent == \"Asia\") %>%\n  select(year, country, lifeExp) %>%\n  group_by(year) %>%\n  filter(min_rank(desc(lifeExp)) < 2 | min_rank(lifeExp) < 2) %>% \n  arrange(year) %>%\n  print(n = Inf)  # erzwingt eine Ausgabe aller Zeilen\n#> # A tibble: 24 x 3\n#> # Groups:   year [12]\n#>     year country     lifeExp\n#>    <int> <fct>         <dbl>\n#>  1  1952 Afghanistan    28.8\n#>  2  1952 Israel         65.4\n#>  3  1957 Afghanistan    30.3\n#>  4  1957 Israel         67.8\n#>  5  1962 Afghanistan    32.0\n#>  6  1962 Israel         69.4\n#>  7  1967 Afghanistan    34.0\n#>  8  1967 Japan          71.4\n#>  9  1972 Afghanistan    36.1\n#> 10  1972 Japan          73.4\n#> 11  1977 Cambodia       31.2\n#> 12  1977 Japan          75.4\n#> 13  1982 Afghanistan    39.9\n#> 14  1982 Japan          77.1\n#> 15  1987 Afghanistan    40.8\n#> 16  1987 Japan          78.7\n#> 17  1992 Afghanistan    41.7\n#> 18  1992 Japan          79.4\n#> 19  1997 Afghanistan    41.8\n#> 20  1997 Japan          80.7\n#> 21  2002 Afghanistan    42.1\n#> 22  2002 Japan          82  \n#> 23  2007 Afghanistan    43.8\n#> 24  2007 Japan          82.6\n(asia <- my_gap %>%\n  filter(continent == \"Asia\") %>%\n  select(year, country, lifeExp) %>%\n  group_by(year))\n#> # A tibble: 396 x 3\n#> # Groups:   year [12]\n#>     year country     lifeExp\n#>    <int> <fct>         <dbl>\n#>  1  1952 Afghanistan    28.8\n#>  2  1957 Afghanistan    30.3\n#>  3  1962 Afghanistan    32.0\n#>  4  1967 Afghanistan    34.0\n#>  5  1972 Afghanistan    36.1\n#>  6  1977 Afghanistan    38.4\n#>  7  1982 Afghanistan    39.9\n#>  8  1987 Afghanistan    40.8\n#>  9  1992 Afghanistan    41.7\n#> 10  1997 Afghanistan    41.8\n#> # … with 386 more rows\nrank(c(1,3,3,5), ties.method = \"min\")\n#> [1] 1 2 2 4\nrank(c(1,3,3,5))\n#> [1] 1.0 2.5 2.5 4.0\nasia %>%\n  mutate(le_rank = min_rank(lifeExp),\n         le_desc_rank = min_rank(desc(lifeExp))) %>% \n  filter(country %in% c(\"Afghanistan\", \"Japan\", \"Thailand\"), year > 1995)\n#> # A tibble: 9 x 5\n#> # Groups:   year [3]\n#>    year country     lifeExp le_rank le_desc_rank\n#>   <int> <fct>         <dbl>   <int>        <int>\n#> 1  1997 Afghanistan    41.8       1           33\n#> 2  2002 Afghanistan    42.1       1           33\n#> 3  2007 Afghanistan    43.8       1           33\n#> 4  1997 Japan          80.7      33            1\n#> 5  2002 Japan          82        33            1\n#> 6  2007 Japan          82.6      33            1\n#> 7  1997 Thailand       67.5      12           22\n#> 8  2002 Thailand       68.6      12           22\n#> 9  2007 Thailand       70.6      12           22\nfilter(min_rank(desc(lifeExp)) < 2 | min_rank(lifeExp) < 2)\nmy_gap %>%\n  filter(continent == \"Asia\") %>%\n  select(year, country, lifeExp) %>%\n  arrange(year) %>%\n  group_by(year) %>%\n  #top_n(1, wt = lifeExp)        ## für das Minimum\n  top_n(1, wt = desc(lifeExp)) ## bzw. das Maximum\n#> # A tibble: 12 x 3\n#> # Groups:   year [12]\n#>     year country     lifeExp\n#>    <int> <fct>         <dbl>\n#>  1  1952 Afghanistan    28.8\n#>  2  1957 Afghanistan    30.3\n#>  3  1962 Afghanistan    32.0\n#>  4  1967 Afghanistan    34.0\n#>  5  1972 Afghanistan    36.1\n#>  6  1977 Cambodia       31.2\n#>  7  1982 Afghanistan    39.9\n#>  8  1987 Afghanistan    40.8\n#>  9  1992 Afghanistan    41.7\n#> 10  1997 Afghanistan    41.8\n#> 11  2002 Afghanistan    42.1\n#> 12  2007 Afghanistan    43.8"},{"path":"dplyr-single.html","id":"großes-finale","chapter":"Kapitel 7 Mehr zu dplyr","heading":"7.8 Großes Finale","text":"Beantworten wir also die Frage: Welches Land hat den stärksten Rückgang der Lebenserwartung um 5 Jahre erlebt?Die Beobachtungsfrequenz im Datensatz ist fünf Jahre, d.h. wir haben Daten für 1952, 1957 usw. Dies bedeutet also, dass die Veränderungen der Lebenserwartung zwischen benachbarten Zeitpunkten betrachtet werden müssen.Zum jetzigen Zeitpunkt ist das einfach zu einfach, also lasst es uns, wenn wir schon dabei sind, nach Kontinenten machen.Denk ruhig eine Weile über das Ergebnis nach. Meistens sieht man hier trockenen Statistiken über die durchschnittliche Lebenserwartung, wie Völkermord aussieht.Unterteile den Code, beginnend von oben, Stücke und überprüfe die einzelnen Zwischenergebnisse. wurde der Code auch geschrieben/entwickelt, mit vielen Fehlern und Verfeinerungen auf dem Weg.","code":"\nmy_gap %>%\n  select(country, year, continent, lifeExp) %>%\n  group_by(continent, country) %>%\n  # für jedes Land werden die Unterschiede berechnet\n  mutate(le_delta = lifeExp - lag(lifeExp)) %>% \n  ## für jedes Land wird nur der kleinste Wert behalten\n  summarise(worst_le_delta = min(le_delta, na.rm = TRUE)) %>% \n  ## nun wird noch pro Kontinent, die Zeile mit dem kleinsten Wert ausgegeben\n  top_n(-1, wt = worst_le_delta) %>% \n  arrange(worst_le_delta)\n#> `summarise()` has grouped output by 'continent'. You can override using the `.groups` argument.\n#> # A tibble: 5 x 3\n#> # Groups:   continent [5]\n#>   continent country     worst_le_delta\n#>   <fct>     <fct>                <dbl>\n#> 1 Africa    Rwanda             -20.4  \n#> 2 Asia      Cambodia            -9.10 \n#> 3 Americas  El Salvador         -1.51 \n#> 4 Europe    Montenegro          -1.46 \n#> 5 Oceania   Australia            0.170"},{"path":"dplyr-single.html","id":"literatur","chapter":"Kapitel 7 Mehr zu dplyr","heading":"7.9 Literatur","text":"dieser Stelle sei noch auf die dplyr Webseite und das Kapitel\nData transformation R Data Science (Wickham Grolemund 2016) verwiesen.","code":""},{"path":"import-export.html","id":"import-export","chapter":"Kapitel 8 Daten I/O","heading":"Kapitel 8 Daten I/O","text":"","code":""},{"path":"import-export.html","id":"überblick","chapter":"Kapitel 8 Daten I/O","heading":"8.1 Überblick","text":"Wir haben die Gapminder-Daten als tibble aus dem gapminder Paket geladen. Wir haben im letzten Abschnitt weder Daten noch abgeleitete Ergebnisse explizit eine Datei geschrieben. Im wirklichen Leben wirst du aber ständig Daten, die Tabellenform vorliegen, R ein- und auslesen. Manchmal muss das sogar für Daten geschehen, die nicht Tabellenform vorliegen.Wie macht man das? Worauf muss man aufpassen?","code":""},{"path":"import-export.html","id":"daten-import","chapter":"Kapitel 8 Daten I/O","heading":"8.1.1 Daten Import","text":"Für den Daten Import gibt es im Allgemeinen zwei Möglichkeiten:“Überrasche mich!” Diese Haltung musst du einnehmen, wenn du zum ersten Mal einen Datensatz erhältst. Du musst einfach froh, wenn du die Daten ohne Fehler importieren konntest. Dann schaust du dir das Ergebnis , entdeckst Fehler den Daten und/oder beim Import. Du behebst sie und beginnst nochmal von vorne.“Ein weiterer Tag im Paradies.” Das ist die Einstellung, wenn du einen aufgeräumten Datensatz einliest, den du vorher einem oder mehreren Reinigungsskripten wahnsinnig aufgeräumt haben. Es sollte keine Überraschungen geben.Im zweiten Fall, und im weiteren Verlauf des ersten Falles, lernst du tatsächlich eine Menge darüber, wie die Daten sind/sein sollten. Ein wichtiger Import-Ratschlag: Verwende die Argumente der Importfunktion, um weit wie möglich und schnell wie möglich zu kommen. Anfängercode hat oft eine Menge unnötigen nachträglichen Aufwand. Lese die Hilfe zu den Importfunktionen und nutzen die Argumente maximal aus, um den Import zu steuern.","code":""},{"path":"import-export.html","id":"daten-export","chapter":"Kapitel 8 Daten I/O","heading":"8.1.2 Daten Export","text":"Es wird viele Gelegenheiten geben, bei denen du Daten aus R exportieren willst. Zwei wichtige Beispiele:einen gesäuberten Datensatz der bereit ist analysiert zu werden, den du heldenhaft aus recht unordentlichen Daten erstellt hastein numerisches Ergebnis aus einer Datenaggregation oder Modellierung oder einer statistischen SchlussfolgerungErster Tipp: Der Output von heute ist der Input von morgen. Denke die Schmerzen zurück, die du selbst beim Import von fremden Daten erlitten hast, und fügen dir nicht selbst solche Schmerzen zu!Zweiter Tipp: Sei nicht zu clever. Eine einfache Textdatei, die von einem Menschen einem Texteditor lesbar ist, sollte dein Standard sein, bis du einen guten Grund dafür hast, dass dies nicht funktionieren wird. Das Lesen und Schreiben exotische Formate wird das erste sein, Zukunft oder auf einem anderen Computer kaputtgehen wird. Es schafft auch Barrieren für jeden, der ein anderes Toolkit hat als du. Strebe nach Zukunfts- und Idiotensicherheit.Wie passt das zu unserer Betonung der dynamischen Berichterstattung über R Markdown? Es gibt für alles eine Zeit und einen Ort. Es gibt Projekte und Dokumente, bei denen du dich intensiv mit knitr und rmarkdown beschäftigen kannst/willst/musst. Aber es gibt viele gute Gründe, warum (Teile von) einer Analyse nicht (nur) einen dynamischen Bericht eingebettet werden sollten. Vielleicht bist du gerade dabei Daten zu bereinigen, um einen Datensatz für eine nachfolgende Analyse zu erzeugen. Vielleicht leistet du einen kleinen, aber entscheidenden Beitrag zu einem gigantischen Multi-Autoren-Papier. Etc. Denke auch daran, dass es natürlich auch noch andere Werkzeuge und Arbeitsabläufe gibt, um etwas reproduzierbar zu machen: z.B. make.","code":""},{"path":"import-export.html","id":"load-the-tidyverse","chapter":"Kapitel 8 Daten I/O","heading":"8.2 Load the tidyverse","text":"Das Hauptpaket, das wir verwenden werden, ist readr, welches Alternativen zu den Standardfunktionen read.table() und write.table() bietet. Trotzdem laden wir standardmäßig einfach wieder tidyverse.","code":"\nlibrary(tidyverse)\n#> ── Attaching packages ─────────────────────────────────────── tidyverse 1.3.1 ──\n#> ✓ ggplot2 3.3.5     ✓ purrr   0.3.4\n#> ✓ tibble  3.1.2     ✓ dplyr   1.0.7\n#> ✓ tidyr   1.1.3     ✓ stringr 1.4.0\n#> ✓ readr   2.0.1     ✓ forcats 0.5.1\n#> ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n#> x dplyr::filter() masks stats::filter()\n#> x dplyr::lag()    masks stats::lag()"},{"path":"import-export.html","id":"einlesen-der-gapminder-daten","chapter":"Kapitel 8 Daten I/O","heading":"8.3 Einlesen der Gapminder Daten","text":"Die Gapminder Daten könnten wir natürlich wie zuvor über das Laden des gapminder Pakets verfügbar machen. Da es diesem Abschnitt aber um das Einlesen von Daten geht, versuchen wir die Daten als .tsv Datei (tab-separated values - sind sie im Paket gespeichert) einzulesen. Aber dies bedeutet natürlich, dass wir die entsprechende .tsv Datei erst mal finden müssen. Dabei hilft uns glücklicherweise das fs Paket.Nachdem wir jetzt den Speicherort der Datei kennen, können wir versuchen sie einzulesen.","code":"\nlibrary(fs)\n(gap_tsv <- path_package(\"gapminder\", \"extdata\", \"gapminder.tsv\"))\n#> /Library/Frameworks/R.framework/Versions/4.0/Resources/library/gapminder/extdata/gapminder.tsv"},{"path":"import-export.html","id":"einlesen-von-daten-in-tabellenform","chapter":"Kapitel 8 Daten I/O","heading":"8.4 Einlesen von Daten in Tabellenform","text":"Die Haupt-Funktion zum Einlesen von Daten readr ist read_delim(). Hier verwenden wir eine Variante, read_tsv(), für tabulatorgetrennte Daten:Über den Tabulator Spalten einer Datentabelle zu trennen, ist natürlich nur eine Variante neben weiteren Alternativen wie Komma, Strichpunkt, Leerzeichen, …Für Komma getrennte Daten würde man beispielsweise read_csv() verwenden. Für volle Flexibilität bei der Angabe des Trennzeichens kannst du aber jederzeit direkt read_delim() verwenden.Der auffälligste Unterschied zwischen den readr-Funktionen und der Standardfunktion read.table()ist, dass readr standardmäßig Characters NICHT Faktoren umwandelt. Im Großen und Ganzen ist dies ein besseres Standardverhalten, obwohl es natürlich immer wieder vorkommen wird, dass du einzelne Variablen nach dem Einlesen einen Faktoren umwandeln wirst. Aber lass dich davon nicht täuschen - im Allgemeinen wirst du durch die Verwendung von readr nach dem Einlesen weniger Anpassungen machen müssen im Vergleich zum Standardvorgehen.Fazit: Benutze readr::read_delim() und “Freunde”.Die Gapminder-Daten sind zu sauber und einfach, um die großartigen Funktionen von readr zur Geltung zu bringen. Ein Blick Introduction readr zeigt aber noch viele weitere Anpassungsmöglichkeiten der readr Funktionen.","code":"\ngapminder <- read_tsv(gap_tsv)\n#> Rows: 1704 Columns: 6\n#> ── Column specification ────────────────────────────────────────────────────────\n#> Delimiter: \"\\t\"\n#> chr (2): country, continent\n#> dbl (4): year, lifeExp, pop, gdpPercap\n#> \n#> ℹ Use `spec()` to retrieve the full column specification for this data.\n#> ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\nglimpse(gapminder)\n#> Rows: 1,704\n#> Columns: 6\n#> $ country   <chr> \"Afghanistan\", \"Afghanistan\", \"Afghanistan\", \"Afghanistan\", …\n#> $ continent <chr> \"Asia\", \"Asia\", \"Asia\", \"Asia\", \"Asia\", \"Asia\", \"Asia\", \"Asi…\n#> $ year      <dbl> 1952, 1957, 1962, 1967, 1972, 1977, 1982, 1987, 1992, 1997, …\n#> $ lifeExp   <dbl> 28.8, 30.3, 32.0, 34.0, 36.1, 38.4, 39.9, 40.8, 41.7, 41.8, …\n#> $ pop       <dbl> 8425333, 9240934, 10267083, 11537966, 13079460, 14880372, 12…\n#> $ gdpPercap <dbl> 779, 821, 853, 836, 740, 786, 978, 852, 649, 635, 727, 975, …"},{"path":"import-export.html","id":"daten-exportieren","chapter":"Kapitel 8 Daten I/O","heading":"8.5 Daten exportieren","text":"Bevor wir etwas exportieren können, müssen (das ist natürlich nicht richtig - niemand zwingt uns dazu) etwas berechnen, das es wert ist, exportiert zu werden. Lass uns eine Zusammenfassung der maximalen Lebenserwartung auf Länderebene erstellen.Das gap_life_exp data frame ist ein Beispiel für ein Zwischenergebnis, das wir für die Zukunft und für nachgelagerte Analysen oder Visualisierungen speichern wollen.Die Haupt-Exportfunktion readr ist write_delim(). Für verschiedene Dateiformate gibt es auch hier wieder verschiedene Komfortfunktionen. Lass uns write_csv() benutzen, um eine kommagetrennte Datei zu erhalten.Schauen wir uns die ersten paar Zeilen von gap_life_exp.csv . Dazu kannst du entweder die Datei öffnen oder, im Terminal, head darauf anwenden.Das sieht recht ordentlich aus, obwohl es keine sichtbare Ausrichtung oder Trennung Spalten gibt. Hätten wir die Basisfunktion read.csv() benutzt, würden wir Zeilennamen und viele Anführungszeichen sehen, es sei denn, wir hätten diese Features explizit abgeschaltet. Das schönere Standardverhalten ist daher der Hauptgrund, warum wir readr::write_csv() gegenüber write.csv() bevorzugen.Es ist nicht wirklich fair, sich über den Mangel sichtbarer Ausrichtung zu beklagen, schließlich erzeugen wir Dateien, die der Computer lesen soll. Falls du wirklich der Datei “herumstöbern” willst, benutze View() RStudio oder öffnen die Datei mit einem Spreadsheet Programm (!). Aber erliege NIE der Versuchung, dort Datenmanipulationen vorzunehmen … gehe zurück zu R und schreibe dort die Befehle, die du die nächsten 15 Mal ausführen kannst, wenn du diesen Datensatz (oder Datensätze derselben Form) importieren/bereinigen/aggregieren/exportieren willst.","code":"\ngap_life_exp <- gapminder %>%\n  group_by(country, continent) %>% \n  summarise(life_exp = max(lifeExp)) %>% \n  ungroup()\n#> `summarise()` has grouped output by 'country'. You can override using the `.groups` argument.\ngap_life_exp\n#> # A tibble: 142 x 3\n#>    country     continent life_exp\n#>    <chr>       <chr>        <dbl>\n#>  1 Afghanistan Asia          43.8\n#>  2 Albania     Europe        76.4\n#>  3 Algeria     Africa        72.3\n#>  4 Angola      Africa        42.7\n#>  5 Argentina   Americas      75.3\n#>  6 Australia   Oceania       81.2\n#>  7 Austria     Europe        79.8\n#>  8 Bahrain     Asia          75.6\n#>  9 Bangladesh  Asia          64.1\n#> 10 Belgium     Europe        79.4\n#> # … with 132 more rows\nwrite_csv(gap_life_exp, \"data/gap_life_exp.csv\")country,continent,life_exp\nAfghanistan,Asia,43.828\nAlbania,Europe,76.423\nAlgeria,Africa,72.301\nAngola,Africa,42.731\nArgentina,Americas,75.32"},{"path":"import-export.html","id":"daten-über-eine-api","chapter":"Kapitel 8 Daten I/O","heading":"8.6 Daten über eine API","text":"Interessante Datensätze sind der Treibstoff für ein gutes Data Science Projekt. APIs (Application Programming Interface) sind eine weitere sehr nützliche Methode, um auf interessante Daten zuzugreifen.Anstatt einen Datensatz herunterladen zu müssen, ermöglichen APIs Daten direkt von bestimmten Websites über eine Schnittstelle anzufordern. Viele große Webseiten wie Twitter und Facebook ermöglichen über APIs den Zugriff auf Teile ihrer Daten.Wir werden die Grundlagen des Zugriffs auf eine API besprechen. Dazu benötigst du aber keine Vorwissen bzgl. APIs.","code":""},{"path":"import-export.html","id":"einführung","chapter":"Kapitel 8 Daten I/O","heading":"8.6.1 Einführung","text":"API ist ein allgemeiner Begriff für den Ort, dem ein Computerprogramm mit einem anderen oder mit sich selbst interagiert. Wir sprechen über Web-APIs, bei denen zwei verschiedene Computer - ein Client und ein Server - miteinander interagieren, um Daten anzufordern bzw. bereitzustellen.APIs bieten eine ausgefeilte Möglichkeit Daten von einer Website anzufordern. Wenn eine Website wie Twitter eine API einrichtet, richten sie im Wesentlichen einen Computer ein, der auf Datenanfragen wartet.Sobald dieser Computer eine Datenanforderung empfängt, verarbeitet er die Daten selbst und sendet sie den Computer, der sie angefordert hat. Unsere Aufgabe als Anforderer der Daten wird es sein R Code zu schreiben, der die Anforderung erstellt und dem Computer, auf dem die API läuft, mitteilt, wir benötigen. Dieser Computer liest dann unseren Code, verarbeitet die Anfrage und gibt schön formatierte Daten zurück, die mithilfe existierender R Pakete verarbeitet werden können..","code":""},{"path":"import-export.html","id":"erstellen-von-api-anforderungen-in-r","chapter":"Kapitel 8 Daten I/O","heading":"8.6.2 Erstellen von API-Anforderungen in R","text":"Um mit APIs R zu arbeiten, müssen wir ein paar neue Pakete laden (und vorher natürlich installieren). Konkret werden wir mit den Paketen httr und jsonlite arbeiten. Sie spielen bei der Einbindung der APIs unterschiedliche Rollen, aber beide sind unverzichtbar.Vermutlich hast du die beiden Pakete bisher nicht installiert. Daher ist der erste Schritt die beiden Pakete zu installierenund anschließend zu laden","code":"\ninstall.packages(c(\"httr\", \"jsonlite\"))\nlibrary(httr)\nlibrary(jsonlite)\n#> \n#> Attaching package: 'jsonlite'\n#> The following object is masked from 'package:purrr':\n#> \n#>     flatten"},{"path":"import-export.html","id":"unsere-erste-api-anfrage-stellen","chapter":"Kapitel 8 Daten I/O","heading":"8.6.3 Unsere erste API-Anfrage stellen","text":"Der erste Schritt, um Daten von einer API zu erhalten, ist die eigentliche Anfrage R. Diese Anfrage wird den Computer-Server geschickt, der über die API verfügt, und wenn alles reibungslos verläuft, wird er eine Antwort zurücksenden.Es gibt verschiedene Arten von Anfragen, die man einen API-Server stellen kann. Diese Arten von Anfragen entsprechen verschiedenen Aktionen, die der Server ausführen soll.Für unsere Zwecke fragen wir lediglich nach Daten, einer GET-Anfrage entspricht. Andere Arten von Anfragen sind z.B. POST und PUT, aber diese sind für uns nicht von Interesse und daher brauchen wir uns darum nicht zu kümmern.Um eine GET-Anfrage zu erstellen, müssen wir die GET() Funktion aus dem httr Paket verwenden. Die GET() Funktion benötigt als Input eine URL, die die Adresse des Servers angibt, den die Anforderung gesendet werden soll.Als Beispiel werden wir mit der Open Notify API arbeiten, die Daten zu verschiedenen NASA-Projekten enthält. Mithilfe der Open Notify API können wir uns über den Standort der Internationalen Raumstation informieren und erfahren, wie viele Personen sich derzeit im Weltraum aufhalten.Wir beginnen damit, dass wir unsere Anfrage mit der GET() Funktion stellen und die URL der API angeben:Die Ausgabe der Funktion GET() ist eine Liste, die alle Informationen enthält, die vom API-Server zurückgegeben werden.","code":"\njdata <- GET(\"http://api.open-notify.org/astros.json\")"},{"path":"import-export.html","id":"get-ausgabe","chapter":"Kapitel 8 Daten I/O","heading":"8.6.4 GET() Ausgabe","text":"Schauen wir uns einmal , wie die Variable jdata der R-Konsole aussieht:Als erstes fällt auf, dass die URL enthalten ist, die die GET-Anfrage gesendet wurde. Außerdem sehen wir das Datum und die Uhrzeit, zu der die Anfrage gestellt wurde, sowie die Größe der Antwort.Die Information Content-Type gibt uns eine Vorstellung davon, welche Form die Daten haben. Diese spezielle Antwort besagt, dass die Daten ein JSON-Format annehmen, womit auch klar ist warum wir das Paket jsonlite ebenfalls geladen haben.Der Status verdient eine besondere Aufmerksamkeit. Status bezieht sich auf den Erfolg oder Misserfolg der API-Anfrage, und er wird Form einer Zahl angegeben. Die zurückgegebene Nummer gibt Auskunft darüber, ob die Anfrage erfolgreich war oder nicht, und kann auch einige Gründe für einen möglichen Misserfolg nennen.Die Zahl 200 ist das, wir sehen wollen. Sie entspricht einem erfolgreichen Antrag, und das ist es, wir hier haben. Eine Übersicht über weitere Status Codes findet man z.B. auf dieser [Webseite](https://www.restapitutorial.com/httpstatuscodes.html.","code":"\njdata\n#> Response [http://api.open-notify.org/astros.json]\n#>   Date: 2021-10-04 13:27\n#>   Status: 200\n#>   Content-Type: application/json\n#>   Size: 355 B"},{"path":"import-export.html","id":"handling-json-data","chapter":"Kapitel 8 Daten I/O","heading":"8.6.5 Handling JSON Data","text":"JSON steht für JavaScript Object Notation. Während JavaScript eine weitere Programmiersprache ist, liegt unser Schwerpunkt bei JSON auf seiner Struktur. JSON ist nützlich, weil es von einem Computer leicht lesbar ist, und aus diesem Grund ist es zur primären Art und Weise geworden, wie Daten über APIs transportiert werden. Die meisten APIs senden ihre Antworten im JSON-Format.JSON ist als eine Reihe von Schlüssel-Werte-Paaren formatiert, wobei ein bestimmtes Wort (“Schlüssel”) mit einem bestimmten Wert assoziiert ist. Ein Beispiel für diese Schlüssel-Wert-Struktur ist unten dargestellt:ihrem aktuellen Zustand sind die Daten der Variablen jdata nicht verwendbar. Die Daten sind als Unicode-Rohdaten jdata enthalten, und müssen das JSON-Format konvertiert werden.Dazu müssen wir zunächst den rohen Unicode Character Daten konvertieren, die dem oben gezeigten JSON-Format ähneln. Die Funktion rawToChar() führt genau diese Aufgabe aus:Die resultierende Zeichenfolge sieht zwar recht unordentlich aus, aber es liegt wirklich die JSON-Struktur vor.Ausgehend von diesem Character Vektor können wir nun mit fromJSON() aus dem jsonlite alles ein Listenformat transformieren.Die fromJSON() Funktion benötigt einen Character Vektor, der die JSON-Struktur enthält, die wir aus der Ausgabe von rawToChar() erhalten haben. Wenn wir also diese beiden Funktionen aneinanderreihen, erhalten wir die gewünschten Daten einem Format, das wir R leichter bearbeiten können.Die Liste data hat drei Elemente. Uns interessiert erster Linie das Data Frame people.Also, da haben wir unsere Antwort: Zum Zeitpunkt des letzten Updates Mon Oct 4 15:27:37 2021 von R4ews befanden sich 7 Personen im Weltraum. Aber wenn du alles selbst ausprobierst, könnten es auch schon wieder andere Namen und eine andere Anzahl sein. Das ist einer der Vorteile von APIs - im Gegensatz zu herunterladbaren Datensätzen werden sie im Allgemeinen Echtzeit oder nahezu Echtzeit aktualisiert, dass sie eine großartige Möglichkeit darstellen, Zugang zu sehr aktuellen Daten zu erhalten.diesem Beispiel haben wir einen sehr unkomplizierten API-Workflow durchlaufen. Die meisten APIs erfordern, dass Sie demselben allgemeinen Muster folgen, aber dabei können sie durchaus komplexer sein.unserem Beispiel war es ausreichen nur die URL anzugeben. Aber einige APIs verlangen durchaus mehr Informationen vom Benutzer. Im letzten Teil dieser Einführung gehen wir darauf ein, wie du der API mit deiner Anfrage zusätzliche Informationen zur Verfügung stellen kannst.","code":"{\n    “name”: “Jane Doe”,\n    “number_of_skills”: 2\n}\nrawToChar(jdata$content)\n#> [1] \"{\\\"people\\\": [{\\\"craft\\\": \\\"ISS\\\", \\\"name\\\": \\\"Mark Vande Hei\\\"}, {\\\"craft\\\": \\\"ISS\\\", \\\"name\\\": \\\"Oleg Novitskiy\\\"}, {\\\"craft\\\": \\\"ISS\\\", \\\"name\\\": \\\"Pyotr Dubrov\\\"}, {\\\"craft\\\": \\\"ISS\\\", \\\"name\\\": \\\"Thomas Pesquet\\\"}, {\\\"craft\\\": \\\"ISS\\\", \\\"name\\\": \\\"Megan McArthur\\\"}, {\\\"craft\\\": \\\"ISS\\\", \\\"name\\\": \\\"Shane Kimbrough\\\"}, {\\\"craft\\\": \\\"ISS\\\", \\\"name\\\": \\\"Akihiko Hoshide\\\"}], \\\"number\\\": 7, \\\"message\\\": \\\"success\\\"}\"\ndata <-  fromJSON(rawToChar(jdata$content))\nglimpse(data)\n#> List of 3\n#>  $ people :'data.frame': 7 obs. of  2 variables:\n#>   ..$ craft: chr [1:7] \"ISS\" \"ISS\" \"ISS\" \"ISS\" ...\n#>   ..$ name : chr [1:7] \"Mark Vande Hei\" \"Oleg Novitskiy\" \"Pyotr Dubrov\" \"Thom\"..\n#>  $ number : int 7\n#>  $ message: chr \"success\"\ndata$people\n#>   craft            name\n#> 1   ISS  Mark Vande Hei\n#> 2   ISS  Oleg Novitskiy\n#> 3   ISS    Pyotr Dubrov\n#> 4   ISS  Thomas Pesquet\n#> 5   ISS  Megan McArthur\n#> 6   ISS Shane Kimbrough\n#> 7   ISS Akihiko Hoshide"},{"path":"import-export.html","id":"apis-und-abfrageparameter","chapter":"Kapitel 8 Daten I/O","heading":"8.6.6 APIs und Abfrageparameter","text":"wäre, wenn wir wissen wollten, wann die ISS einen bestimmten Ort auf der Erde überfliegen würde? Die ISS Pass Times API von Open Notify verlangt von uns, dass wir zusätzliche Parameter angeben, bevor sie die gewünschten Daten zurückgeben kann.Wir müssen den Längen- und Breitengrad des Ortes angeben, nach dem wir im Rahmen unserer GET() Anfrage fragen. Sobald ein Längen- und Breitengrad angegeben ist, werden sie als Abfrageparameter mit der ursprünglichen URL kombiniert.Lass uns die API verwenden, um herauszufinden, wann die ISS Garching (auf 48.24896 Breiten- und 11.65101 Längengrad) passieren wird:Man muss der Dokumentation für die API, mit man arbeiten , nachsehen, ob es erforderliche Abfrageparameter gibt. Für die überwiegende Mehrheit der APIs, auf die du möglicherweise zugreifen möchtest, gibt es eine Dokumentation, die du lesen kannst (und lesen solltest), um ein klares Verständnis dafür zu erhalten, welche Parameter deine Anfrage erfordert.Wie auch immer, jetzt, da wir unsere Anfrage einschließlich der Standortparameter gestellt haben, können wir die Antwort mit den gleichen Funktionen überprüfen, die wir zuvor verwendet haben. Lass uns die Daten aus der Antwort extrahieren:Diese API gibt uns Zeiten Form von Unixzeit zurück. Unixzeit ist die Zeitspanne, die seit dem 1. Januar 1970 vergangen ist. Mithilfe der Funktion as_datetime() aus dem lubridate Paket können wir die Unixzeit aber leicht umrechnenWir haben hier wirklich nur die Basics Bezug auf APIs eingeführt. Aber hoffentlich hat dir diese Einführung trotzdem das Vertrauen gegeben, sich mit einigen komplexeren und leistungsfähigeren APIs auseinanderzusetzen, und trägt dadurch dazu bei, eine ganz neue Welt von Daten zu erschließen, die du erforschen kannst!","code":"\njdata <-  GET(\"http://api.open-notify.org/iss-pass.json\",\n    query = list(lat = 48.24896, lon = 11.65101))\ndata <- fromJSON(rawToChar(jdata$content))\ndata$response\n#>   duration   risetime\n#> 1      650 1633357190\n#> 2      652 1633363018\n#> 3      645 1633368830\n#> 4      497 1633374673\n#> 5      468 1633429262\nlubridate::as_datetime(data$response$risetime)\n#> [1] \"2021-10-04 14:19:50 UTC\" \"2021-10-04 15:56:58 UTC\"\n#> [3] \"2021-10-04 17:33:50 UTC\" \"2021-10-04 19:11:13 UTC\"\n#> [5] \"2021-10-05 10:21:02 UTC\""},{"path":"import-export.html","id":"weiteres-material","chapter":"Kapitel 8 Daten I/O","heading":"8.7 Weiteres Material","text":"Hier sein noch auf das Kapitel Data import im Buch R Data Science von Hadley Wickham und Garrett Grolemund (2016) verwiesen für weitere Information zum Daten Import.","code":""},{"path":"tidy.html","id":"tidy","chapter":"Kapitel 9 tidy ?","heading":"Kapitel 9 tidy ?","text":"Idealerweise liegt ein Datensatz vor, dass er gut von einem Computer gelesen werden kann. der Regel sind die Datensätze, mit denen wir uns beschäftigen, ja umfangreich, d.h. der Mensch den Datensatz ja gar nicht (ein-)lesen. Trotzdem sind Datensätze oft anders angelegt (der Mensch trifft die Entscheidung über das Layout).Der Computer kann einen Datensatz gut verarbeiten, wenn wir den Datensatz als tidy bezeichnen können. Hauptmerkmal von einem tidy Datensatz:Jede Spalte ist eine VariableJede Zeile ist eine BeobachtungUntidy data mag z.B. der Grund dafür sein, dass Du mit einer Abbildung kämpfst. Daher lohnt es sich immer mal inne zu halten um zu überlegen, ob die Daten tidy sind. Unordnung ist eine häufige, oft übersehene Ursache für Qualen bei der Datenanalyse und -visualisierung.","code":""},{"path":"tidy.html","id":"lord-of-the-rings","chapter":"Kapitel 9 tidy ?","heading":"9.1 Lord of the Rings","text":"Von Jenny Byran (Autorin von STAT 545) habe ich folgenden Beispieldatensatz übernommen: Data Lord Rings TrilogyWir haben eine Tabelle pro Film. jeder Tabelle haben wir die Gesamtzahl der gesprochenen Wörter, von Charakteren verschiedener Kategorien und Geschlechter.Stell dir vor, diese drei Tabellen als separate Arbeitsblätter einer Excel-Arbeitsmappe zu finden. Oder einigen Zellen Rande eines Arbeitsblatts, das die zugrunde liegenden Rohdaten enthält. Oder als Tabellen auf einer Webseite oder einem Word-Dokument.Das Format der Tabellen macht es für einen Menschen einfach, die Anzahl der von weiblichen Elfen “Two Towers” gesprochenen Wörter nachzuschlagen. Aber dieses Format macht es für einen Computer ziemlich schwer, solche Zählungen herauszuziehen und, noch wichtiger ist, damit zu rechnen oder sie grafisch darzustellen.Diese Aufgabe ist dann wieder nicht einfach, da die Daten untidy sind: Die Inhalte der Spalte Female und Male enthalten nicht die Information über das Geschlecht. Auf der anderen Seite sind Wert der Variable (noch nicht vorhanden) Words auf zwei Spalten verteilt.","code":""},{"path":"tidy.html","id":"tidy-lord-of-the-rings-data","chapter":"Kapitel 9 tidy ?","heading":"9.2 Tidy Lord of the Rings data","text":"sauberer Form sehen die Daten folgendermaßen aus:Beachte, dass tidy data im Allgemeinen höher und schmaler sind. Bestimmte Elemente werden oft wiederholt, z. B. Hobbit. Aus diesen Gründen lehnen wir tidy Daten oft instinktiv als ineffizient oder hässlich ab. Aber, solange du nicht das Endprodukt für eine textuelle Präsentation von Daten erstellst, solltest du diesen Instinkt ignorieren.","code":""},{"path":"tidy.html","id":"vorteile-von-tidy-data","chapter":"Kapitel 9 tidy ?","heading":"9.3 Vorteile von tidy data","text":"Wenn die Daten ordentlicher Form vorliegen, ist es naheliegend, einen Computer zu holen, um weitere Zusammenfassungen zu machen oder eine Abbildung zu erstellen.dieser Form können wir nun leicht folgende Fragen beantworten:Wie viele Wörter haben die männlichen Hobbits insgesamt gesprochen?Wie viele Wörter haben die männlichen Hobbits insgesamt gesprochen?Dominiert eine bestimmte Race einen Film? Unterscheidet sich die dominierende Race den Filmen?Dominiert eine bestimmte Race einen Film? Unterscheidet sich die dominierende Race den Filmen?","code":""},{"path":"tidy.html","id":"wie-viele-wörter-haben-die-männlichen-hobbits-insgesamt-gesprochen","chapter":"Kapitel 9 tidy ?","heading":"9.3.0.1 Wie viele Wörter haben die männlichen Hobbits insgesamt gesprochen?","text":"Nun braucht es nur noch ein kleines bisschen Code, um die Gesamtwortzahl für beide Geschlechter aller Kategorien über alle Filme hinweg zu berechnen. Die Gesamtzahl der von männlichen Hobbits gesprochenen Wörter ist 8780. Hier war es wichtig, alle Wortzählungen einer einzigen Variable zu haben, innerhalb eines Data Frames, der auch eine Variable für Geschlecht und Kategorie enthielt.","code":"\nlibrary(tidyverse)\nlotr_tidy %>% \n  count(Gender, Race, wt = Words)## # A tibble: 6 x 3\n##   Gender Race       n\n##   <chr>  <chr>  <dbl>\n## 1 Female Elf     1743\n## 2 Female Hobbit    16\n## 3 Female Man      669\n## 4 Male   Elf     1994\n## 5 Male   Hobbit  8780\n## 6 Male   Man     8043"},{"path":"tidy.html","id":"dominiert-eine-bestimmte-kategorie-einen-film-unterscheidet-sich-die-dominierende-kategorie-in-den-filmen","chapter":"Kapitel 9 tidy ?","heading":"9.3.0.2 Dominiert eine bestimmte Kategorie einen Film? Unterscheidet sich die dominierende Kategorie in den Filmen?","text":"Zunächst summieren wir über die Geschlechter hinweg, um die Wortzahlen für die verschiedenen Kategorien nach Film zu erhalten.Wir können ganz genau auf diese Zahlen starren, um die Frage zu beantworten. Aber noch schöner ist es, die gerade berechneten Wortzahlen einem Balkendiagramm darzustellen.Hobbits sind “Fellowhip Ring” stark vertreten, während die Menschen “Two Towers” viel mehr Leinwandzeit hatten. Ebenso prominent waren sie im letzten Film, “Return King”.Auch hier war es wichtig, alle Daten einem einzigen Data Frame zu haben, alle Wortzählungen einer einzigen Variable und zugehörige Variablen für Film und Kategorie.Im nächsten Schritt schauen wir uns nun , wie man aus den obigen drei Tabellen eine sauberen Datensatz erzeugt.","code":"\n(by_race_film <- lotr_tidy %>% \n   group_by(Film, Race) %>% \n   summarize(Words = sum(Words)))## `summarise()` has grouped output by 'Film'. You can override using the `.groups` argument.## # A tibble: 9 x 3\n## # Groups:   Film [3]\n##   Film                       Race   Words\n##   <chr>                      <chr>  <dbl>\n## 1 The Fellowship Of The Ring Elf     2200\n## 2 The Fellowship Of The Ring Hobbit  3658\n## 3 The Fellowship Of The Ring Man     1995\n## 4 The Return Of The King     Elf      693\n## 5 The Return Of The King     Hobbit  2675\n## 6 The Return Of The King     Man     2727\n## 7 The Two Towers             Elf      844\n## 8 The Two Towers             Hobbit  2463\n## 9 The Two Towers             Man     3990\nggplot(by_race_film, aes(x = Film, y = Words, fill = Race)) + \n  geom_bar(stat = \"identity\", position = \"dodge\") +\n  coord_flip() + guides(fill = guide_legend(reverse = TRUE)) + \n  scale_fill_brewer(palette = \"Set1\")"},{"path":"tidy.html","id":"untidy-lord-of-the-rings-data","chapter":"Kapitel 9 tidy ?","heading":"9.4 Untidy Lord of the Rings data","text":"Wir importieren nun die Daten, die den drei filmspezifischen Wortzählungstabellen dargestellt wurden.Für jede Tabelle existiert eine eigene csv Datei:The_Fellowship_Of_The_Ring.csvThe_Two_Towers.csvThe_Return_Of_The_King.csv","code":"\nfship <- read_csv(file.path(\"data\", \"The_Fellowship_Of_The_Ring.csv\"))## Rows: 3 Columns: 4## ── Column specification ────────────────────────────────────────────────────────\n## Delimiter: \",\"\n## chr (2): Film, Race\n## dbl (2): Female, Male## \n## ℹ Use `spec()` to retrieve the full column specification for this data.\n## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\nttow <- read_csv(file.path(\"data\", \"The_Two_Towers.csv\"))## Rows: 3 Columns: 4## ── Column specification ────────────────────────────────────────────────────────\n## Delimiter: \",\"\n## chr (2): Film, Race\n## dbl (2): Female, Male## \n## ℹ Use `spec()` to retrieve the full column specification for this data.\n## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\nrking <- read_csv(file.path(\"data\", \"The_Return_Of_The_King.csv\")) ## Rows: 3 Columns: 4## ── Column specification ────────────────────────────────────────────────────────\n## Delimiter: \",\"\n## chr (2): Film, Race\n## dbl (2): Female, Male## \n## ℹ Use `spec()` to retrieve the full column specification for this data.\n## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\nrking## # A tibble: 3 x 4\n##   Film                   Race   Female  Male\n##   <chr>                  <chr>   <dbl> <dbl>\n## 1 The Return Of The King Elf       183   510\n## 2 The Return Of The King Hobbit      2  2673\n## 3 The Return Of The King Man       268  2459"},{"path":"tidy.html","id":"und-nun-alles-zusammen","chapter":"Kapitel 9 tidy ?","heading":"9.5 Und nun alles zusammen","text":"Wir haben jetzt ein Data Frame pro Film, jeweils mit den vier VariablenDer erste Schritt beim Aufräumen dieser Daten besteht darin, sie zu einem Data Frame zusammenzufügen, indem wir die drei Data Frames zeilenweise stapeln. Dazu können wir die Funktion dplyr::bind_rows() verwenden.Das Zusammensetzen eines großen Datenobjekts aus vielen kleinen ist eine relativ übliche Aufgabe bei der Datenaufbereitung. Wenn die Teile ähnlich sind wie hier, ist es schön, sie gleich zu einem Objekt zusammenzusetzen. anderen Szenarien müsst du möglicherweise einige Nacharbeiten den einzelnen Objekten vornehmen, bevor sie gut zusammengefügt werden können.Wenn möglich, sollte man die einzelnen Stücke früh wie möglich\nzusammensetzen, denn es ist einfacher und effizienter, ein einzelnes Objekt aufzuräumen als 20 oder 1000.","code":"\nnames(rking)## [1] \"Film\"   \"Race\"   \"Female\" \"Male\"\nlotr_untidy <- bind_rows(fship, ttow, rking)\nlotr_untidy## # A tibble: 9 x 4\n##   Film                       Race   Female  Male\n##   <chr>                      <chr>   <dbl> <dbl>\n## 1 The Fellowship Of The Ring Elf      1229   971\n## 2 The Fellowship Of The Ring Hobbit     14  3644\n## 3 The Fellowship Of The Ring Man         0  1995\n## 4 The Two Towers             Elf       331   513\n## 5 The Two Towers             Hobbit      0  2463\n## 6 The Two Towers             Man       401  3589\n## 7 The Return Of The King     Elf       183   510\n## 8 The Return Of The King     Hobbit      2  2673\n## 9 The Return Of The King     Man       268  2459"},{"path":"tidy.html","id":"nun-können-wir-aufräumen","chapter":"Kapitel 9 tidy ?","heading":"9.6 Nun können wir aufräumen","text":"Wir verletzen immer noch eines der Grundprinzipien von tidy data. Die Anzahl gesprochenen Wörtern ist eine grundlegende Variable unserem Datensatz und sie ist derzeit auf zwei Variablen verteilt, Female und Male. Konzeptionell müssen wir die Wortanzahl einer einzigen Variable zusammenfassen und eine neue Variable Gender erstellen, um zu verfolgen, ob die jeweilige Anzahl Worten von Frauen oder Männern gesprochen wurde. Dies Aufgabe können wir mit der Funktion tidyr::pivot_longer() bearbeiten.Um unseren obigen Aufruf von pivot_longer() zu erklären, lesen wir ihn links nach rechts: Nach der Auswahl des Datensatzes lotr_untidy haben wird die Spalten Female und Male genommen und ihre Werte eine einzige neue Variable Words zusammengefasst. Dies erzwang die Erstellung einer neuen Variable Gender, die angibt, ob ein bestimmter Wert von Words von Female oder Male stammt. Alle anderen Variablen, wie Film, bleiben unverändert und werden einfach nach Bedarf repliziert. Die Dokumentation für pivot_longer() gibt weitere Beispiele und dokumentiert zusätzliche Argumente.Wenn man sich diese Arbeit gemacht hat, dann macht es schon Sinn sich auch das Ergebnis abzuspeichernTrotzdem solltet ihr auch bei/nach der Datenaufbereitung auch die Skripte zur Datenaufbereitung wie auch die Originaldaten abspeichern.","code":"\nlotr_tidy <-\n  pivot_longer(lotr_untidy, cols = c(\"Female\", \"Male\"), names_to = 'Gender', \n               values_to = 'Words')\nlotr_tidy## # A tibble: 18 x 4\n##    Film                       Race   Gender Words\n##    <chr>                      <chr>  <chr>  <dbl>\n##  1 The Fellowship Of The Ring Elf    Female  1229\n##  2 The Fellowship Of The Ring Elf    Male     971\n##  3 The Fellowship Of The Ring Hobbit Female    14\n##  4 The Fellowship Of The Ring Hobbit Male    3644\n##  5 The Fellowship Of The Ring Man    Female     0\n##  6 The Fellowship Of The Ring Man    Male    1995\n##  7 The Two Towers             Elf    Female   331\n##  8 The Two Towers             Elf    Male     513\n##  9 The Two Towers             Hobbit Female     0\n## 10 The Two Towers             Hobbit Male    2463\n## 11 The Two Towers             Man    Female   401\n## 12 The Two Towers             Man    Male    3589\n## 13 The Return Of The King     Elf    Female   183\n## 14 The Return Of The King     Elf    Male     510\n## 15 The Return Of The King     Hobbit Female     2\n## 16 The Return Of The King     Hobbit Male    2673\n## 17 The Return Of The King     Man    Female   268\n## 18 The Return Of The King     Man    Male    2459\nwrite_csv(lotr_tidy, path = file.path(\"data\", \"lotr_tidy.csv\"))## Warning: The `path` argument of `write_csv()` is deprecated as of readr 1.4.0.\n## Please use the `file` argument instead."},{"path":"tidy.html","id":"und-jetzt-noch-ein-bisschen-schmutzig-machen","chapter":"Kapitel 9 tidy ?","heading":"9.7 Und jetzt noch ein bisschen “schmutzig” machen","text":"Manchmal (aber nicht häufig) ist es doch nötig die Daten im Wide Format zu haben. Daher wollen wir zum Schluss die gerade gesäuberten LOTR Daten nochmal ein bisschen untidy machen.Dazu arbeiten wir mit den Funktion tidyr::pivot_wider(). Wir nehmen nun die Ausprägungen der Variable Race (anschließend dann Gender) als Variablennamen der neu zu bildenden Variablen. Die Werte dieser neuen Variablen sind durch die Variable Words festgelegt.Das erste Beispiel hat immer noch 6 Beobachtungen, zwei pro Film. Nehmen wir mal , dass wir aber nur eine Beobachtung pro Film haben wollen. Dazu müssten wir die möglichen Kombinationen aus Race und Gender neuen/weiteren Variablen zusammenfassen. Dies können wir über die Funktion tidyr::unite() erreichen.Kombination mit pivot_wider() ergibt sich soZum Schluss könnten wir jetzt auch noch alles zurück auf Anfang stellen und die\ndrei Datensätze vom Anfang wiederherstellenWir erhalten eine Liste mit drei Elemente, die deren Inhalt den drei Tabellen vom Anfang entspricht. Die Daten zu “Return King” sind beispielsweise im zweiten Element enthalten.","code":"\n## Race\nlotr_tidy %>% \n  pivot_wider(names_from = Race, values_from = Words)## # A tibble: 6 x 5\n##   Film                       Gender   Elf Hobbit   Man\n##   <chr>                      <chr>  <dbl>  <dbl> <dbl>\n## 1 The Fellowship Of The Ring Female  1229     14     0\n## 2 The Fellowship Of The Ring Male     971   3644  1995\n## 3 The Two Towers             Female   331      0   401\n## 4 The Two Towers             Male     513   2463  3589\n## 5 The Return Of The King     Female   183      2   268\n## 6 The Return Of The King     Male     510   2673  2459\n## Gender\nlotr_tidy %>% \n  pivot_wider(names_from = Gender, values_from = Words)## # A tibble: 9 x 4\n##   Film                       Race   Female  Male\n##   <chr>                      <chr>   <dbl> <dbl>\n## 1 The Fellowship Of The Ring Elf      1229   971\n## 2 The Fellowship Of The Ring Hobbit     14  3644\n## 3 The Fellowship Of The Ring Man         0  1995\n## 4 The Two Towers             Elf       331   513\n## 5 The Two Towers             Hobbit      0  2463\n## 6 The Two Towers             Man       401  3589\n## 7 The Return Of The King     Elf       183   510\n## 8 The Return Of The King     Hobbit      2  2673\n## 9 The Return Of The King     Man       268  2459\nlotr_tidy %>% \n  unite(Race_Gender, Race, Gender)## # A tibble: 18 x 3\n##    Film                       Race_Gender   Words\n##    <chr>                      <chr>         <dbl>\n##  1 The Fellowship Of The Ring Elf_Female     1229\n##  2 The Fellowship Of The Ring Elf_Male        971\n##  3 The Fellowship Of The Ring Hobbit_Female    14\n##  4 The Fellowship Of The Ring Hobbit_Male    3644\n##  5 The Fellowship Of The Ring Man_Female        0\n##  6 The Fellowship Of The Ring Man_Male       1995\n##  7 The Two Towers             Elf_Female      331\n##  8 The Two Towers             Elf_Male        513\n##  9 The Two Towers             Hobbit_Female     0\n## 10 The Two Towers             Hobbit_Male    2463\n## 11 The Two Towers             Man_Female      401\n## 12 The Two Towers             Man_Male       3589\n## 13 The Return Of The King     Elf_Female      183\n## 14 The Return Of The King     Elf_Male        510\n## 15 The Return Of The King     Hobbit_Female     2\n## 16 The Return Of The King     Hobbit_Male    2673\n## 17 The Return Of The King     Man_Female      268\n## 18 The Return Of The King     Man_Male       2459\nlotr_tidy %>% \n  unite(Race_Gender, Race, Gender) %>% \n  pivot_wider(names_from = Race_Gender, values_from = Words)## # A tibble: 3 x 7\n##   Film         Elf_Female Elf_Male Hobbit_Female Hobbit_Male Man_Female Man_Male\n##   <chr>             <dbl>    <dbl>         <dbl>       <dbl>      <dbl>    <dbl>\n## 1 The Fellows…       1229      971            14        3644          0     1995\n## 2 The Two Tow…        331      513             0        2463        401     3589\n## 3 The Return …        183      510             2        2673        268     2459\n(sep_list <- lotr_tidy %>% \n  pivot_wider(names_from = Gender, values_from = Words) %>%\n   group_split(Film))## <list_of<\n##   tbl_df<\n##     Film  : character\n##     Race  : character\n##     Female: double\n##     Male  : double\n##   >\n## >[3]>\n## [[1]]\n## # A tibble: 3 x 4\n##   Film                       Race   Female  Male\n##   <chr>                      <chr>   <dbl> <dbl>\n## 1 The Fellowship Of The Ring Elf      1229   971\n## 2 The Fellowship Of The Ring Hobbit     14  3644\n## 3 The Fellowship Of The Ring Man         0  1995\n## \n## [[2]]\n## # A tibble: 3 x 4\n##   Film                   Race   Female  Male\n##   <chr>                  <chr>   <dbl> <dbl>\n## 1 The Return Of The King Elf       183   510\n## 2 The Return Of The King Hobbit      2  2673\n## 3 The Return Of The King Man       268  2459\n## \n## [[3]]\n## # A tibble: 3 x 4\n##   Film           Race   Female  Male\n##   <chr>          <chr>   <dbl> <dbl>\n## 1 The Two Towers Elf       331   513\n## 2 The Two Towers Hobbit      0  2463\n## 3 The Two Towers Man       401  3589\nsep_list[[2]]## # A tibble: 3 x 4\n##   Film                   Race   Female  Male\n##   <chr>                  <chr>   <dbl> <dbl>\n## 1 The Return Of The King Elf       183   510\n## 2 The Return Of The King Hobbit      2  2673\n## 3 The Return Of The King Man       268  2459"},{"path":"tidy.html","id":"literatur-1","chapter":"Kapitel 9 tidy ?","heading":"9.8 Literatur","text":"Tidy data Kapitel R Data Science, Garrett Grolemund Hadley Wickham\ntidyr Paket\ntidyr PaketBad Data Handbook Q. Ethan McCallum, published O’Reilly.\nChapter 3: Data Intended Human Consumption, Machine Consumption Paul Murrell.\nChapter 3: Data Intended Human Consumption, Machine Consumption Paul Murrell.Tidy data Hadley Wickham. Journal Statistical Software. Vol. 59, Issue 10, Sep 2014. http://www.jstatsoft.org/v59/i10","code":""},{"path":"graphics-overview.html","id":"graphics-overview","chapter":"Kapitel 10 Einführung","heading":"Kapitel 10 Einführung","text":"Das Paket ggplot2 verwendet eine Grammatik beim Erzeugen von Grafiken. Diese basiert aufWilkinson (2005): Grammar Graphics, Springer.Dadurchist eine starke Abstraktion bei der Definition einer Grafik möglichsteht ein sehr flexibles Grafiksystem zur Verfügung.","code":""},{"path":"graphics-overview.html","id":"ggplot2-laden","chapter":"Kapitel 10 Einführung","heading":"10.1 ggplot2 laden","text":"Wie zuvor auch, laden wir stets das komplette tidyverse. Man weiß ja vorher nie genau man alles braucht.","code":"\nlibrary(tidyverse)\n#> ── Attaching packages ─────────────────────────────────────── tidyverse 1.3.1 ──\n#> ✓ ggplot2 3.3.5     ✓ purrr   0.3.4\n#> ✓ tibble  3.1.2     ✓ dplyr   1.0.7\n#> ✓ tidyr   1.1.3     ✓ stringr 1.4.0\n#> ✓ readr   2.0.1     ✓ forcats 0.5.1\n#> ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n#> x dplyr::filter() masks stats::filter()\n#> x dplyr::lag()    masks stats::lag()"},{"path":"graphics-overview.html","id":"idee","chapter":"Kapitel 10 Einführung","heading":"10.2 Idee","text":"Die grundlegende Idee des ggplot2 Ansatzes zum Erstellen von Grafiken, besteht darin die Bausteine eines Plots unabhängig voneinander zu definieren. Ein Plot besteht immer aus:Daten (als data.frame oder tibble)KoordinatensystemSkalageometrisches Objekt zur Darstellung (geom)Zusätzlich kann er aber auch nochstatistische Transformationen (stat)verschiedene Facetten…enthalten.Die einzelnen Teile eines Plots werden dann mit dem + Operator zusammengefügt.Initialisiert wird ein Plot mit ggplot(). Ohne weitere Bestandteile wird aber nur eine leere Grafik erzeugtIn den folgenden Abschnitten lernen wir daher wie weitere Bestandteile zum Plot hinzugefügt werden.","code":"\nlibrary(gapminder)\nggplot(gapminder) "},{"path":"graphics-overview.html","id":"ein-einfacher-scatterplot","chapter":"Kapitel 10 Einführung","heading":"10.3 Ein einfacher Scatterplot","text":"Wir schauen uns zum Start einfach mal für Deutschland den Verlauf des gdpPercap über die Zeit .diesem einfachen Beispiel haben wir bereits gesehen, dass ggplot() über den Pipe-Operator verknüpft werden kann.","code":"\ngapminder %>%\n  filter(country == \"Germany\") %>% # auswählen der Daten \n  ggplot(aes(x = year, y = gdpPercap)) +  # plot initialisieren\n  geom_point() # punkte zum Darstellen der Daten verwenden"},{"path":"bausteine.html","id":"bausteine","chapter":"Kapitel 11 Bausteine","heading":"Kapitel 11 Bausteine","text":"","code":""},{"path":"bausteine.html","id":"aes","chapter":"Kapitel 11 Bausteine","heading":"11.1 Aesthetics","text":"Mit der Funktion aes() lässt sich das Aussehen der Grafik regeln (nicht der Inhalt). Wir können z.B.die Position: x und ydie Farbe: color und filldie Form: shapeden Linientyp: linetypedie Größe der Symbol: sizefestlegen. Nicht jedes aesthetic kann allerdings mit allen verfügbaren geoms kombiniert werden. macht z.B. der linetype ja wenig Sinn geom_point(). Ein Übersicht der möglichen aesthetics findet man der Hilfe jeder geom-FunktionIn der aes() Funktion sollten die Daten den Wert der Argumente bestimmen. Werden Argumente auf fixe Werte gesetzt, sind sie außerhalb der aes() Funktion zu setzen.einem Plot der gdpPercap Daten für Deutschland und Frankreich wollen wir anhand von unterschiedlichen Farben die Daten der beiden Länder unterscheiden. Dazu müssen wir nur colour innerhalb von aes() den Wert country zuweisen.","code":"geom_point {ggplot2}    R Documentation\nPoints\nDescription\nThe point geom is used to create scatterplots. The scatterplot is most useful for displaying the relationship between two continuous variables. It can be used to compare one continuous and one categorical variable, or two categorical variables, but a variation like geom_jitter(), geom_count(), or geom_bin2d() is usually more appropriate. A bubblechart is a scatterplot with a third variable mapped to the size of points.\n\nUsage\ngeom_point(\n  mapping = NULL,\n  data = NULL,\n  stat = \"identity\",\n  position = \"identity\",\n  ...,\n  na.rm = FALSE,\n  show.legend = NA,\n  inherit.aes = TRUE\n)\n\n...\n\nAesthetics\ngeom_point() understands the following aesthetics (required aesthetics are in bold):\n\nx\n\ny\n\nalpha\n\ncolour\n\nfill\n\ngroup\n\nshape\n\nsize\n\nstroke\n\nLearn more about setting these aesthetics in vignette(\"ggplot2-specs\").\n\ngapminder %>%\n  filter(country %in% c(\"Germany\",\"France\")) %>% # auswählen der Daten \n  ggplot(aes(x = year, y = gdpPercap, colour = country)) +  \n  geom_point(size = 3) # size wird auf einen fixen Wert gesetzt (außerhalb von aes())"},{"path":"bausteine.html","id":"geoms","chapter":"Kapitel 11 Bausteine","heading":"11.2 Geoms","text":"Mit den geom_xx() Funktionen stellen wir die Daten als geometrische Formen einer Grafik dar. Jede ggplot2 Grafik benötigt daher mindestens ein geom. Beispiele sindgeom_point()geom_line()geom_histogram()Da wir nicht alle verfügbaren geoms auflisten können, sei dieser Stelle auf die ggplot2 Seite verwiesen.Wir haben hier die gleichen Daten visualisiert. Allerdings ist das Ergebnis doch recht unterschiedlich. Der Scatterplot zeigt alle (abgesehen von überzeichnen) Daten, wohingegen mit geom_smooth() eine geglätteter Zusammenhang dargestellt wird.Interessant sind hier natürlich die wenigen großen gdpPercap WerteKuwait hat über den gesamten Zeitraum hohe GDP Werte. Aber zu Beginn der Aufzeichnungen waren die Werte Bezug auf die damals noch recht kleine Populationsgröße außergewöhnlich hoch.Einem ggplot Objekt können wir nicht nur ein geom zuordnen. Prinzipiell können wir beliebig viele weitere geoms hinzufügen. Wir können also die gerade durchgeführte Glättung der Daten auch\ndirekt zum Scatterplot hinzufügenWählen wir die Farbe der geometrischen Objekte anhand einer Faktorvariable, erhalten wir automatisch eine entsprechende Legende\nBeachte auch, dass wir colour nur für geom_point() gewählt haben. Die Glättung erfolgt weiterhin über alle Daten und nicht separat für jeden Kontinent. Aber das wäre natürlich auch möglich. Dazu können wir colour wieder global ggplot() definieren.Die Punkte sind mir etwas zu groß und der Linientyp gefällt mir auch nicht diesem Plot. Aber das lässt sich schnell ändern.","code":"\ngapminder %>%\n  ggplot(aes(x = year, y = gdpPercap)) +  \n  geom_point() \n\n\ngapminder %>%\n  ggplot(aes(x = year, y = gdpPercap)) +  \n  geom_smooth() \n#> `geom_smooth()` using method = 'gam' and formula 'y ~ s(x, bs = \"cs\")'\ngapminder %>%\n  filter(gdpPercap > 50000)\n#> # A tibble: 6 x 6\n#>   country continent  year lifeExp     pop gdpPercap\n#>   <fct>   <fct>     <int>   <dbl>   <int>     <dbl>\n#> 1 Kuwait  Asia       1952    55.6  160000   108382.\n#> 2 Kuwait  Asia       1957    58.0  212846   113523.\n#> 3 Kuwait  Asia       1962    60.5  358266    95458.\n#> 4 Kuwait  Asia       1967    64.6  575003    80895.\n#> 5 Kuwait  Asia       1972    67.7  841934   109348.\n#> 6 Kuwait  Asia       1977    69.3 1140357    59265.\ngapminder %>%\n  ggplot(aes(x = year, y = gdpPercap)) +  \n  geom_point() +\n  geom_smooth() \n#> `geom_smooth()` using method = 'gam' and formula 'y ~ s(x, bs = \"cs\")'\ngapminder %>%\n  ggplot(aes(x = year, y = gdpPercap)) +  \n  geom_point(aes(colour = continent)) +\n  geom_smooth() \n#> `geom_smooth()` using method = 'gam' and formula 'y ~ s(x, bs = \"cs\")'\ngapminder %>%\n  ggplot(aes(x = year, y = gdpPercap, colour = continent)) +  \n  geom_point() +\n  geom_smooth() \n#> `geom_smooth()` using method = 'loess' and formula 'y ~ x'\ngapminder %>%\n  ggplot(aes(x = year, y = gdpPercap, colour = continent)) +  \n  geom_point(size = 0.9) +\n  geom_smooth(linetype = 2) \n#> `geom_smooth()` using method = 'loess' and formula 'y ~ x'"},{"path":"bausteine.html","id":"stat-trans","chapter":"Kapitel 11 Bausteine","heading":"11.3 Statistische Transformationen","text":"Jede geom_xx() Funktion besitzt eine Default Statistik, die berechnet wird.Bei einem Scatterplot ist dies nur die Identität.Ein Balkendiagramm verwendet anderseitsdie Transformation count, Sinn macht, da ja gezählt werden muss/soll wie viele Beobachtungen die jeweilige Kategorie fallen.Der Aufruf der stat_xx() Funktion ist oftmals einfacher über die entsprechende geom_xx() Funktion, aber natürlich kann die stat_xx() Funktion auch direkt aufgerufen werden.Jedes geom hat zwar ein Default-Transformation, aber natürlich können oftmals noch weitere Transformationen berechnet/genutzt werden. Im Abschnitt Computed variables der Hilfe zu einem geom sieht man alle verfügbaren TransformationenFür geom_bar() sind diesDie relativen Häufigkeiten berechnet man also über prop. Dazu muss die y-Variable auf prop gesetzt werden. Da der Aufrufaber nach einer Variable prop suchen würde, muss eine alternative Notation diesem Fall verwendet werdenDas sieht jetzt noch nicht wie wir das erwartet haben. Die\nrelativen Häufigkeiten wurden innerhalb der fünf Gruppen berechnet und nicht über alle Beobachtungen. D.h. wir müssen der Funktion noch sagen, dass es nur eine Gruppe geben soll.","code":"\nargs(geom_point)\n#> function (mapping = NULL, data = NULL, stat = \"identity\", position = \"identity\", \n#>     ..., na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) \n#> NULL\nargs(geom_bar)\n#> function (mapping = NULL, data = NULL, stat = \"count\", position = \"stack\", \n#>     ..., width = NULL, na.rm = FALSE, orientation = NA, show.legend = NA, \n#>     inherit.aes = TRUE) \n#> NULL\nggplot(gapminder, aes(x = continent)) + \n  geom_bar()\n\nggplot(gapminder, aes(x = continent)) + \n  stat_count()Computed variables\n\ncount\nnumber of points in bin\n\nprop\ngroupwise proportion\n\n\nggplot(gapminder, aes(x = continent, y = prop))\nggplot(gapminder, aes(x = continent, y = ..prop..)) + \n  geom_bar()\nggplot(gapminder, aes(x = continent, y = ..prop..)) + \n  geom_bar(aes(group = 1))"},{"path":"bausteine.html","id":"scales","chapter":"Kapitel 11 Bausteine","heading":"11.4 scales","text":"Scales steuern die Zuordnung von Daten zu aesthetics. Sie nehmen deine Daten und bestimmen damit Größe, Farbe, Position oder Form von Objekten. Sie erlauben dir auch die Achsen und die Legend nach deinen Vorstellungen anzupassen. Du kannst sicher mit ggplot2 Grafiken erstellen, ohne zu wissen, wie scales funktionieren, aber wenn du scales verstehst und lernst, wie du sie einstellen kannst, wirst du viel mehr Kontrolle über deine Grafiken bekommen.Neben weiteren Möglichkeiten können wir über scales alsocolor und fillpositionsizeshapeline typedurch Verwendung der scale_\"aesthetic\"_\"type\" Funktionen modifizieren. Argumente dieser Funktionen sind z.B. name, limits, breaks oder labels.Zuerst spielen wir etwas mit Farben. Dazu plotten wir erneut year gegen gdpPercap und wählen für jeden Kontinent eine eigene Farbe. Da wir die Farben über colour definieren, verwenden wir danach die Funktionen scale_colour_xxx() (im Vergleich zu z.B. scale_fill_brewer()).diesem Beispiel haben wir also die Farbe über eine vorgegebene Palette, Grau-Stufen bzw. manuell gewählt. Im letzten Beispiel haben wir zusätzlich noch den Titel der Legende geändert über das name Argument.Die Achsenbeschriftung der y-Achse ist nicht wirklich schön, weil nicht unbedingt selbsterklärend. Daher ändern wir im nächsten Schritt die Achsenbeschriftung.Da es sich bei gdpPercap um eine stetige Variable handelt, haben wir scale_y_continuous() verwendet (im Gegensatz zu scale_y_discrete()) um die Achsenbeschriftung zu ändern. Über die Hilfsfunktion labs() können wir die Beschriftung der Grafik aber auch einfacher/intuitiver ändern.Die frühen Kuwait-Beobachtungen ziehen die y-Achse stark auseinander. Daher könnte man etwas den Plot hinein zoomen wollen. Dazu kann man das Koordinatensystem anpassen übercoord_cartasian(). Alternativ könnte man auch mit der Funktion ylim() arbeiten (analog existiert natürlich auch xlmin()). Verwendet man xlim() bzw. ylim(), werden alle Datenpunkte, die nicht im zu plottenden Bereich liegen, aber nicht nur nicht gezeichnet, sondern auch aus dem Datensatz (für diesen einen Plot) entfernt. Dies hat Auswirkungen auf Teile des Plots, die auf statistische Transformationen basieren, die mithilfe der vorhanden Daten berechnet wurden.der rechten Grafik ist der Verlauf der Kurven unverändert. der linken Grafik hingegen liegt die Kurve für Asien nun deutlich unter der Kurve für Amerika bis Mitte der 80er Jahre.Andere mögliche Positionsänderungen ergeben sich durch Skalierungen der Achsen wie scale_x_log10(), scale_y_sqrt() oderFür weitere Optionen sei hier auf die online Version der neuesten Auflage von ggplot2 (Wickham 2009) verwiesen.","code":"\n(p <- gapminder %>%\n  ggplot(aes(x = year, y = gdpPercap, colour = continent)) +  \n  geom_point(size = 0.9) +\n  geom_smooth(linetype = 2) )\n#> `geom_smooth()` using method = 'loess' and formula 'y ~ x'\n\np + scale_colour_brewer(palette = \"Set1\") # Farbpaletten von http://colorbrewer2.org/\n#> `geom_smooth()` using method = 'loess' and formula 'y ~ x'\n\np + scale_colour_grey(start = 0.1, end = 0.9) # keine so gute Wahl\n#> `geom_smooth()` using method = 'loess' and formula 'y ~ x'\n\np + scale_colour_manual(values = c(\"blue\", \"gold\", \"sienna1\", \"sienna4\", \"hotpink1\", \"hotpink4\"), name = \"Kontinent\")\n#> `geom_smooth()` using method = 'loess' and formula 'y ~ x'\np <- p + scale_colour_manual(values = c(\"blue\", \"gold\", \"sienna1\", \"sienna4\", \"hotpink1\", \"hotpink4\"))\n\np + scale_y_continuous(\"GDP pro Kopf\")\n#> `geom_smooth()` using method = 'loess' and formula 'y ~ x'\n(p <- p + labs(x = \"Jahr\", y = \"GDP pro Kopf\",\n         title = \"Monoton steigendes GDP pro Kopf\",\n         subtitle = \"Gestrichelte Linie zeigt Durchschnittswerte über alle Länder pro Kontinent\"))\n#> `geom_smooth()` using method = 'loess' and formula 'y ~ x'\np + ylim(0,55000)\n#> `geom_smooth()` using method = 'loess' and formula 'y ~ x'\n#> Warning: Removed 6 rows containing non-finite values\n#> (stat_smooth).\n#> Warning: Removed 6 rows containing missing values\n#> (geom_point).\n(p <- p + coord_cartesian(ylim = c(0, 55000)))\n#> `geom_smooth()` using method = 'loess' and formula 'y ~ x'\np + scale_x_reverse()\n#> `geom_smooth()` using method = 'loess' and formula 'y ~ x'"},{"path":"bausteine.html","id":"facets","chapter":"Kapitel 11 Bausteine","heading":"11.5 facets","text":"Datensätze lassen sich oftmals bzgl. vorhandener Variablen gruppieren. Dann man Zusammenhänge weiterer Variablen innerhalb dieser Gruppen darstellen. Entsteht die Gruppierung aufgrund einer Variable, kannst du mit facet_wrap() arbeitenIn der letzten Grafik verwenden alle fünf Plots die gleiche Skala auf der y-Achse um die Vergleichbarkeit der Werte zu erhöhen. manchen Fällen mag dies aber störend sein. Mit dem Argument scale kannst du die Skala “befreien”.Erfolgt die Gruppierung anhand von zwei Variablen, bietet facet_grid() eine passende Aufteilung des Grafikfensters. Neben dem Kontinent betrachten wir nun auch noch ob die Populationsgröße des Landes im entsprechenden Jahr größer als 5000000 ist, oder eben nicht.Für Ozeanien erhalten wir z.B. eine Unterteilung Australien (TRUE) und Neuseeland (FALSE).","code":"\ngapminder %>%\n  ggplot(aes(x = year, y = gdpPercap )) +  \n  geom_point(size = 0.9) +\n  geom_smooth(linetype = 2) +\n  facet_wrap(~ continent, ncol = 2)\n#> `geom_smooth()` using method = 'loess' and formula 'y ~ x'\ngapminder %>%\n  ggplot(aes(x = year, y = gdpPercap )) +  \n  geom_point(size = 0.9) +\n  geom_smooth(linetype = 2) +\n  facet_wrap(~ continent, ncol = 2, scales = \"free\")\n#> `geom_smooth()` using method = 'loess' and formula 'y ~ x'\ngapminder %>%\n  group_by(continent) %>%\n  ggplot(aes(x = year, y = gdpPercap )) +  \n  geom_point(size = 0.9) +\n  geom_smooth(linetype = 2) +\n  facet_grid(continent ~ pop > 5000000, scales = \"free\")\n#> `geom_smooth()` using method = 'loess' and formula 'y ~ x'"},{"path":"bausteine.html","id":"themes","chapter":"Kapitel 11 Bausteine","heading":"11.6 themes","text":"Abschließend wollen wir noch über verschiedene themes sprechen. Über themes kann man das Aussehen der nicht datenbezogenen Elemente einer Grafik verändern, wie z.B.die Beschriftungenden Hintergrunddie Legende….Eine Reihe von themes sind bereits vorhanden, wobei theme_gray() das Default theme ist. Siehe auch ?theme_gray().Wir möchten nun gerne folgende Änderungen der Grafik vornehmen:die Größe der Achsenbeschriftung änderndie Gitterlinien ohne Beschriftung entferneneine Überschrift hinzufügendie Legende die Grafik verschiebendie Hintergrundfarbe der Grafik und der Legende ändernDie meisten dieser Änderungen können wir mit theme() durchführen.Ob das nun alles schön aussieht, sei dahingestellt, aber es zeigt durchaus die vorhandenen Möglichkeiten.man gewisse Einstellung öfter verwenden, kann man diese auch einem theme Objekt speichern und wiederverwenden.","code":"\np\n#> `geom_smooth()` using method = 'loess' and formula 'y ~ x'\np + theme_bw()\n#> `geom_smooth()` using method = 'loess' and formula 'y ~ x'\np + theme_dark()\n#> `geom_smooth()` using method = 'loess' and formula 'y ~ x'\np + theme_minimal()\n#> `geom_smooth()` using method = 'loess' and formula 'y ~ x'\np +\n  theme(\n    axis.text = element_text(size = 14),\n    legend.key = element_rect(fill = \"navy\"),\n    legend.background = element_rect(fill = \"green\"),\n    legend.position = \"bottom\",\n    panel.grid.major = element_line(colour = \"grey40\"),\n    panel.grid.minor = element_blank(),\n    panel.background = element_rect(fill = \"navy\")\n  )\n#> `geom_smooth()` using method = 'loess' and formula 'y ~ x'\nmein_theme <- theme(\n    axis.text = element_text(size = 14),\n    legend.key = element_rect(fill = \"hotpink3\"),\n    panel.grid.major = element_line(colour = \"grey40\"),\n    panel.grid.minor = element_blank(),\n    panel.background = element_rect(fill = \"navy\")\n  )\nclass(mein_theme)\n#> [1] \"theme\" \"gg\"\np + mein_theme\n#> `geom_smooth()` using method = 'loess' and formula 'y ~ x'"},{"path":"bausteine.html","id":"buch-zum-paket","chapter":"Kapitel 11 Bausteine","heading":"11.7 Buch zum Paket","text":"Dieser Abschnitt konnte nur einen kleinen Einblick die Möglichkeiten des ggplot2 Pakets geben. Eine ausführliche Beschreibung findet man im Buch zum Paket.","code":""},{"path":"packages.html","id":"packages","chapter":"Kapitel 12 Pakete","heading":"Kapitel 12 Pakete","text":"Bei einem Paket handelt es sich umeine strukturierte, standardisierte Einheit, welche aus R Code, Dokumentation, Daten und (möglicherweise) externem Quellcode besteht.Wie man ein Paket installiert und lädt, ist uns mittlerweile bekannt. Jetzt wollen wir eigene Pakete erstellen.Gute Gründe für die Verwendung von Paketen:dynamisches Laden und Entladen des Pakets (Speicherplatz\nsparend)dynamisches Laden und Entladen des Pakets (Speicherplatz\nsparend)einfache Installation und Update von lokalen Datenträgern oder über\ndas Web, innerhalb von R oder über die Kommandozeile des\nBetriebssystemseinfache Installation und Update von lokalen Datenträgern oder über\ndas Web, innerhalb von R oder über die Kommandozeile des\nBetriebssystemsValidierung: R bietet Befehle zur groben Überprüfung von Code,\nDokumentation und Installierbarkeit, sowie, falls man möchte,\nÜberprüfung von Berechnungsergebnissen.Validierung: R bietet Befehle zur groben Überprüfung von Code,\nDokumentation und Installierbarkeit, sowie, falls man möchte,\nÜberprüfung von Berechnungsergebnissen.einfache Verteilung der Software Dritte; Beispieldatensätze können auch ins Paket!einfache Verteilung der Software Dritte; Beispieldatensätze können auch ins Paket!","code":""},{"path":"packages.html","id":"struktur","chapter":"Kapitel 12 Pakete","heading":"12.1 Struktur","text":"Ein Paket besteht aus einigen Standard–Dateien und Verzeichnissen:DESCRIPTION: Informationen über das Paket (Autor,\nLizenz, Titel, Abhängigkeiten, …)R/: R Code .R Dateienman/: Dokumentationen (im *.Rd Format) der einzelnen FunktionenNAMESPACE: Information über die zu “exportierenden” Funktionendata/: Datenbeispielesrc/: kompilierter C, C++ oder Fortran Codetests/: Testroutinen zur Validierung des PaketsBei der Erzeugung der Struktur (wie auch weiteren Schritten bei der Entwicklung) sollte man viel wie möglich automatisieren. Wir verwenden dazu die von Hadley Wickham bereitgestellten Werkzeuge.Falls noch nicht geschehen, sollte manausführen. Diese Pakete erleichtern Kombination mit RStudio das Erstellen von Paketen.","code":"\ninstall.packages(c(\"devtools\", \"roxygen2\", \"testthat\"))"},{"path":"packages.html","id":"c-compiler","chapter":"Kapitel 12 Pakete","heading":"12.2 C Compiler","text":"Um alle Möglichkeiten bei der Erstellung von R-Paketen ausnützen zu können, brauchst du außerdem einen Compiler und noch ein paar andere Werkzeuge. Dies ist aber vermutlich erst dann wirklich nötig, wenn du Pakete bauen willst, die C- oder C++-Code enthalten (nicht Teil des Kurses). RStudio sollte dich auch warnen und dir Unterstützung anbieten, sobald du versuchen solltest, etwas zu tun, das die Einrichtung einer Entwicklungsumgebung erfordert.Mit has_devel() kannst du aber bereits auch jetzt mal überprüfen ob dein System vielleicht schon bereit istDies scheint bei mir der Fall zu sein.","code":"\nlibrary(devtools)\nhas_devel()\n#> Your system is ready to build packages!"},{"path":"packages.html","id":"r-code","chapter":"Kapitel 12 Pakete","heading":"12.3 R Code","text":"Das Verzeichnis R/ ist der wichtigste Bestandteil eines Pakets, da dort der komplette R Code liegt.\nDieses Verzeichnis (wie auch andere Teile) erzeugt man mit der Funktion devtools::create(), z.B.Dieser Befehl erzeugt das Verzeichnis Pfad_zum_Paket/Paketname, welcheseine RStudio Projektdatei, Paketname.Rprojein R/ Verzeichniseine DESCRIPTION Dateieine NAMESPACE Dateienthält. Allen R Code, der im Paket enthalten sein soll, kopiert man anschließend das Verzeichnis Pfad_zum_Paket/Paketname/R.Innerhalb eines Pakets ist es nun einfach den kompletten R Code (nach Änderungen) neu zu laden.devtools::load_all() lädt allen R Code neu. RStudio auch über Strg + Shift + L möglich.RStudio kann man mit Strg + Shift + B das Paket installieren, R neu starten und anschließend das Paket über library() neu laden.Dadurch ergibt sich der folgende ArbeitsablaufR Dateien im Editor bearbeitenStrg + Shift + L (oder Strg + Shift + B) ausführenCode der Konsole überprüfenDas Ganze (falls nötig) wiederholen","code":"\ncreate(\"Pfad_zum_Paket/Paketname\")"},{"path":"packages.html","id":"verschiedene-typen","chapter":"Kapitel 12 Pakete","heading":"12.4 Verschiedene Typen","text":"Man unterscheidet fünf verschiedene Typen: source, bundled, binary, installed und memory.source: Die source Version eines Pakets besteht aus dem Verzeichnis Paketnamesource: Die source Version eines Pakets besteht aus dem Verzeichnis Paketnamebundled: Komprimiert man das Verzeichnis eine .tar.gz Datei spricht man von einem “gebündelten” Paket. Dieser Typ stellt eher einen Zwischenschritt dar. Mit devtools::build() kann aber eine solche Version erzeugt werden. Weitere Unterschiede zu einer source Version sind für uns erst mal nicht von Interesse.bundled: Komprimiert man das Verzeichnis eine .tar.gz Datei spricht man von einem “gebündelten” Paket. Dieser Typ stellt eher einen Zwischenschritt dar. Mit devtools::build() kann aber eine solche Version erzeugt werden. Weitere Unterschiede zu einer source Version sind für uns erst mal nicht von Interesse.binary: Ein gebündeltes Paket kann von anderen R Nutzern nur installiert werden, wenn sie selbst über die entsprechenden “Werkzeuge” (Rtools, …) verfügen. Binary Pakete bestehen auch nur aus einer Datei, können aber von anderen R Nutzern auch ohne weitere “Werkzeuge” installiert werden. Allerdings sind binary Pakete plattformspezifisch. Ein Windows binary Paket kann also z.B. nicht auf einem Mac installiert werden. Erzeugt wird eine binary Version z.B. mit devtools::build(binary = TRUE).binary: Ein gebündeltes Paket kann von anderen R Nutzern nur installiert werden, wenn sie selbst über die entsprechenden “Werkzeuge” (Rtools, …) verfügen. Binary Pakete bestehen auch nur aus einer Datei, können aber von anderen R Nutzern auch ohne weitere “Werkzeuge” installiert werden. Allerdings sind binary Pakete plattformspezifisch. Ein Windows binary Paket kann also z.B. nicht auf einem Mac installiert werden. Erzeugt wird eine binary Version z.B. mit devtools::build(binary = TRUE).installed: Ein installiertes Paket ist ein eine R Library entpacktes binary Paket. Zu diesem Zustand kann man über mehrere Wege gelangen, z.B.\ninstall.packages(): CRAN binary -> installed\ninstall.packages(type = source): CRAN source -> bundled -> installed\ninstall(): source -> installed\ninstalled: Ein installiertes Paket ist ein eine R Library entpacktes binary Paket. Zu diesem Zustand kann man über mehrere Wege gelangen, z.B.install.packages(): CRAN binary -> installedinstall.packages(type = source): CRAN source -> bundled -> installedinstall(): source -> installedMit devtools::install_github() können source Pakete aus eine GitHub Projekt installiert werden.memory: Um mit einem Paket zu arbeiten muss es den Speicher geladen werden. Dies geschieht mit library() (installierte Pakete) oder load_all() (beim Entwickeln von Paketen).","code":""},{"path":"packages.html","id":"description","chapter":"Kapitel 12 Pakete","heading":"12.5 DESCRIPTION","text":"Die DESCRIPTION Datei enthält Informationen über das Paket und ist ein essentieller Bestandteil jedes Pakets. Der Befehlerzeugt die DESCRIPTION Dateiim Ordner meinR4EWSpckg.Die wichtigsten Felder einer DESCRIPTION Datei sind dadurch vorhanden (und müssen gefüllt werden). Über die Punkte Imports und Suggests (nicht automatisch vorhanden) kann festgelegt werden welche anderen R Pakete zwingend notwendig bzw. hilfreich sind für das eigene Paket.Pakete Imports werden beim Installieren des eigenen Pakets ebenfalls installiert, falls diese noch nicht vorhanden sind. Pakete Suggests werden nicht automatisch installiert.Überkann z.B. das Paket dplyr dem Punkt Imports hinzugefügt werden. usethis::use_package(type = \"Suggests\") fügt Suggests weitere Pakete hinzu.","code":"\nusethis::create_package(\"meinR4EWSpckg\")Package: meinR4EWSpckg\nType: Package\nTitle: What the Package Does (Title Case)\nVersion: 0.1.0\nAuthor: Who wrote it\nMaintainer: The package maintainer <yourself@somewhere.net>\nDescription: More about what it does (maybe more than one line)\n    Use four spaces when indenting paragraphs within the Description.\nLicense: What license is it under?\nEncoding: UTF-8\nLazyData: true\nusethis::use_package(\"dplyr\")"},{"path":"packages.html","id":"name-titel-beschreibung","chapter":"Kapitel 12 Pakete","heading":"12.5.1 Name, Titel, Beschreibung","text":"Der Name (Package) eines Pakets darf Buchstaben, Zahlen und . enthalten und sollte mit dem Verzeichnisname übereinstimmen.Title und Description sollten beschreiben das Paket genau macht. Description ist dabei deutlich ausführlicher und enthält daher .d.R. mehrere Zeilen. Nach einem Zeilenumbruch sollte 4 Leerzeichen eingerückt werden. Ein Beispiel wäre","code":"Title: An implementation of the Grammar of Graphics\nDescription: An implementation of the grammar of graphics in R. \n    It combines the advantages of both base and lattice graphics: \n    conditioning and shared axes are handled automatically, and \n    you can still build up a plot step by step from multiple data \n    sources. It also implements a sophisticated multidimensional \n    conditioning system and a consistent interface to map data \n    to aesthetic attributes. See the ggplot2 website for more \n    information, documentation and examples."},{"path":"packages.html","id":"autoren","chapter":"Kapitel 12 Pakete","heading":"12.5.2 Autoren","text":"Über das Feld Authors@R können die Autoren des Pakets angegeben werden. dieser Stelle kann\nder DESCRIPTION Datei R Code verwendet werden um die nötigen Informationengiven, family: Vor- und Nachnameemail: E-Mailadresserole: Rolle der Person. Wichtige Beispiele sind\ncre: Ersteller oder Maintainer\naut: hat wichtige Beiträge zum Paket erbracht\nctb: hat kleinere Beiträge zum Paket erbracht\ncre: Ersteller oder Maintaineraut: hat wichtige Beiträge zum Paket erbrachtctb: hat kleinere Beiträge zum Paket erbrachtMit der Funktion person() können diese Informationen nun angegeben werdenDer Output von person() sieht dann folgendermaßen aus","code":"Authors@R: person(given = \"Stephan\", family = \"Haug\", \n                  email = \"haug@tum.de\", \n                  role = c(\"cre\", \"aut\"))\nperson(given = \"Stephan\", family = \"Haug\", \n                  email = \"haug@tum.de\", \n                  role = c(\"cre\", \"aut\"))\n#> [1] \"Stephan Haug <haug@tum.de> [cre, aut]\""},{"path":"packages.html","id":"version","chapter":"Kapitel 12 Pakete","heading":"12.5.3 Version","text":"devtools::create() legt die Default-Version auf 0.1.0 fest. Generell sollte die Versionsnummer aber aus drei Teilen bestehen und die Form x.y.z haben, wobei x die Nummer für größere Updates, y die Nummer für kleinere Updates und z die Nummer für Korrekturen ist.Die aktuelle Version von ggplot2 ist z.B.Für Pakete, die sich der Entwicklung befinden, bietet es sich noch einen vierten Teil anzufügen und mit der Versionsnummer 0.0.0.9000 zu starten.Nach diesen Anpassung könnte die DESCRIPTION Datei also aussehenDer Punkt Lizenz ist für erstmal nachgeordnet. Wer aber mehr über die Wahl einer passenden Lizenz erfahren möchte, den verweisen wir gerene auf das Kapitel Licensing R packages.","code":"\npackageVersion(\"ggplot2\")\n#> [1] '3.3.5'Package: meinR4EWSpckg\nType: Package\nTitle: Paket zu R4ews, das ...\nVersion: 0.0.0.9000\nAuthors@R: person(given = \"Stephan\", family = \"Haug\", \n                  email = \"haug@tum.de\", \n                  role = c(\"cre\", \"aut\"))\nDescription: Paket, das im Rahmen des R Projekts R4ews entstanden ist.\n    Das Paket bietet ...\nLicense: What license is it under?\nEncoding: UTF-8\nLazyData: true\nImports: \n    dplyr"},{"path":"packages.html","id":"pakete-dokumentation","chapter":"Kapitel 12 Pakete","heading":"12.6 Pakete: Dokumentation","text":"Ein wichtiger Teil eines Pakets ist die ausreichende Dokumentation (wichtiger) Funktionen. Dokumentationen werden als .Rd (LaTeX ähnliches Format) Dateien im Verzeichnis man/ abgelegt. Das Paket roxygen2 bietet eine komfortable Möglichkeit aus Funktionskommentaren (einem speziellen Format) eine .Rd Datei zu erzeugen.Ablauf:roxygen Kommentare die .R Datei einfügendevtools::document() ausführen um Kommentare .Rd Datei zu konvertierenDokumentation mit ? betrachtengegebenenfalls alles wiederholenroxygen Kommentare beginnen mit #'.Wir fügen eine Datei add_2.R mit Inhaltdem Verzeichnis meinR4EWSpckg/R hinzu.Der Befehl devtools::document() (ausgeführt im Verzeichnis meinR4EWSpckg - source Paket) erzeugt dann die Datei meinR4EWSpckg/man/add_2.RdAlle roxygen Kommentare beginnen mit #' und sind unterteilt verschiedene Tags der Form @name_tag beschreibung. Vor dem ersten Tag kommen allerdingsTitel: erste Zeile des KommentarsBeschreibung der Funktion: zweiter Abschnitt des Kommentars (länger als Titel)Details zur Funktion: dritter Abschnitt des Kommentars (länger als die Beschreibung) - optionalIn unserem Beispiel wurde der Titel auch gleich als Beschreibung (da nicht explizit angegeben) verwendet.Die drei wichtigsten Tags zum Kommentieren einer Funktion sind: @param, @examples und @return.\nWeitere Tags sind im Abschnitt Documenting functions des Buchs R packages beschrieben.Mit den Befehlen \\emph{}, \\strong{}, \\code{} und \\pkg{} (Paketname) kann der Text formatiert werden.Ebenso können Links zu anderen Dokumentationen\\code{\\link{function}}: Funktion function im eigenen Paket\\code{\\link[devtools]{load_all}}: Funktionen aus anderen Paketen, hier devtools::load_alloder dem Netz\\url{http://rstudio.com}\\href{http://rstudio.com}{RStudio}\\email{haug@@tum.de} (@@ ist nötig, da @ für die Tags reserviert ist)Weitere Möglichkeiten der Formatierung findest du im Abschnitt Text formatting des Buch R packages.","code":"#' Addiere zwei Zahlen\n#' \n#' @param x Eine Zahl.\n#' @param y Eine Zahl.\n#' @return Die Summe von \\code{x} und \\code{y}.\n#' @examples\n#' add_2(1, 1)\n#' add_2(10, 1)\nadd_2 <- function(x, y) {\n  x + y\n}% Generated by roxygen2 (4.0.2): do not edit by hand\n\\name{add_2}\n\\alias{add_2}\n\\title{Addiere zwei Zahlen}\n\\usage{\nadd_2(x, y)\n}\n\\arguments{\n\\item{x}{Eine Zahl.}\n\n\\item{y}{Eine Zahl.}\n}\n\\value{\nDie Summe von \\code{x} und \\code{y}.\n}\n\\description{\nAddiere zwei Zahlen\n}\n\\examples{\nadd_2(1, 1)\nadd_2(10, 1)\n}\n"},{"path":"packages.html","id":"namespace","chapter":"Kapitel 12 Pakete","heading":"12.7 NAMESPACE","text":"Es ist nicht nur für das Erstellen von Paketen hilfreich das Konzept eines NAMESPACE verstanden zu haben, sondern auch für das generelle Arbeiten mit R. Man unterscheidet dabei Import NAMESPACES und Export NAMESPACES.Import legt dabei fest wie die Funktion eines Pakets eine Funktion einem anderen Paket findet. Betrachten wir z.B.Diese Funktion ist definiert Abhängigkeit von dim() aus dem base Paket.Auch wenn wir die Funktiondefinieren, findet nrow() trotzdem die “richtige” Funktionda sie den NAMESPACE des base Pakets verwendet.Export legt fest welche Funktionen eines Pakets außerhalb des Pakets zur Verfügung stehen sollen. Dies müssen/sollten nicht alle Funktionen sein. Ein Paket kann also interne Funktionen haben, die nur intern verwendet werden können.Über den Operator :: wird explizit auf den NAMESPACE eines Pakets zugegriffen. Auf diese Art und Weise vermeidet man auch Konflikte zwischen Funktionen aus verschiedenen Paketen, die aber den gleichem Namen haben. einem solchen Fall kommt es darauf welches Paket zuletzt geladen wurde. Dieses findet man dann zuerst im SuchpfadIn der NAMESPACE Datei beschreibenexport(): exportiert FunktionenexportPattern(): exportiert alle Funktionen, die zu einem bestimmten Schema passenS3method(): exportiert S3 Methodenden Export undimport(): importiert alle Funktionen aus einem PaketimportFrom(): importiert eine bestimmte Funktion aus einem PaketuseDynLib(): importiert eine Funktion aus Cden Import.Export-Einträge der NAMESPACE Datei können leicht über roxygen Kommentare erzeugt werden.\nÜber einen @export Tag wird angegeben welche Funktion exportiert werden sollJe nach Objekttyp wird dann export(), exportPattern() oder S3method() im NAMESPACE verwendet. Generell sollte man sich die Regel halten lieber weniger als mehr Funktionen zu exportieren, wenn man das Paket Dritte weitergeben .Beim Importieren sollte man noch restriktiver sein. Man sollte über Imports der DESCRIPTION Datei sicherstellen, dass alle notwendigen Pakete installiert und geladen sind. Danach kann einfach über den :: Operator eigenen Funktionen auf Funktionen aus anderen geladenen Paketen zugegriffen werden, also z.B. pkg_name::funktion_aus_pkg_name().Dies erhöht die spätere Lesbarkeit der eigenen Programme und vermeidet potentielle Konflikte, die beim Importieren mehrerer Pakete - die dann wieder Funktionen mit gleichem Namen besitzen - auftreten können.Muss eine Funktion häufig verwendet werden - und man nicht dauernd :: verwenden - sollte man über importFrom() eher nur die Funktion und nicht das ganze Paket importieren.","code":"\nnrow\n#> function (x) \n#> dim(x)[1L]\n#> <bytecode: 0x7fd926e42800>\n#> <environment: namespace:base>\ndim <- function(x) c(1,1)\ndim(mtcars)\n#> [1] 1 1\nnrow(mtcars)\n#> [1] 32\nsearch()\n#>  [1] \".GlobalEnv\"        \"package:devtools\"  \"package:usethis\"  \n#>  [4] \"package:stats\"     \"package:graphics\"  \"package:grDevices\"\n#>  [7] \"package:utils\"     \"package:datasets\"  \"package:methods\"  \n#> [10] \"Autoloads\"         \"package:base\"#' @export\nexport_function <- function(...){\n  ... \n}"},{"path":"packages.html","id":"daten-einbinden","chapter":"Kapitel 12 Pakete","heading":"12.8 Daten einbinden","text":"Daten, die das Paket enthalten sollte, legt man im Verzeichnis /data ab. Als Format sollte man .rda wählen (ist aber kein Muss). Der einfachste Weg dies zu berücksichtigen ist die Funktion usethis::use_data() zu verwenden.Dieser Befehl speichert die Objekte x und mtcars den Dateien data/x.rda und data/mtcars.rda ab. Der Dateiname stimmt also mit dem Objektnamen überein.Datensätze sollten auf jeden Fall dokumentiert werden. Dazu fügt man einfach eine der .R Dateien im Verzeichnis /R einen weiteren roxygen2 Absatz ein. Für das Dokumentieren von Datensätzen stehen zwei weitere Tags bereit. Über @format beschreibt man das genaue Format der Daten, z.B. die einzelnen Spalten eines Data Frames, und mit @source gibt man (falls vorhanden) die Datenquelle .Die Beschreibung des Datensatzes x könnte also z.B. aussehen","code":"\nx <- sample(1:100, 50, replace = TRUE)\nusethis::use_data(x, mtcars)#' Mein Datensatz\n#' \n#' Ein Datensatz bestehend aus 50 Zahlen gezogen aus den \n#' Zahlen 1 bis 100 mit Zuruecklegen\n#' \n#' @format Ein Integer Vektor der Laenge 50\n\"x\""},{"path":"packages.html","id":"c-special-topic","chapter":"Kapitel 12 Pakete","heading":"12.9 C++ (Special Topic)","text":"man seinem Paket R Funktionen verwenden, die mithilfe von Rcpp aus kompiliertem C++ Code entstanden sind, sollte man zur Vorbereitungausführen. Danach ist das das Verzeichnis /src angelegt und Rcpp zu den Feldern LinkingTo und Imports der DESCRIPTION Datei hinzugefügt. Außerdem wird man aufgefordert die roxygen Tagsin eine der .R Dateien einzufügen.Ebenso wie die .R Dateien kann auch die .cpp Dateien die roxygen Dokumentation eingefügt werden. Allerdings verwendet man //' statt #'.","code":"\nusethis::use_rcpp()#' @useDynLib meinR4EWSpckg\n#' @importFrom Rcpp sourceCpp#include <Rcpp.h>\nusing namespace Rcpp;\n\n//' Multipliziere eine Zahl mit 2\n//' \n//' @param x Ein Integer.\n//' @export\n// [[Rcpp::export]]\nint malZwei(int x) {\n   return x * 2;\n}"},{"path":"packages.html","id":"git-und-githubgitlab","chapter":"Kapitel 12 Pakete","heading":"12.10 Git und GitHub/GitLab","text":"Benutze für jedes deiner Pakete (mag es auch noch klein sein) Git. Beim Anlegen des Projekts (zur Erstellung des Pakets) über RStudio, kann leicht ein lokales Git repository initialisiert werdenSoll zusätzlich ein remote repository verwendet werden, kann man (im Standardfall) ein neues repository auf GitLab (oder GitHub) anlegen. Es sollte den gleichen Namen bekommen wie das Paket (lokales Git repository). Danach kannst du im Terminal Befehle der Formausführen.Angenommen es existiert bereits ein remote repository und das Paket soll dort “verwaltet” werden. Dann kannst du einfach dieses repository klonenDanach existiert im Verzeichnis, dem der Befehl ausgeführt wurde, das Unterverzeichnis paketName. R kannst du anschließend den Befehlausführen (im Verzeichnis, welches das Git repository paketName enthält). Danach kannst du die Änderungen speichern über einen commit Befehlund pushen","code":"git remote add origin https://gitlab.lrz.de/vw99xyz/paketName.git\ngit push -u origin mastergit clone https://gitlab.lrz.de/vw99xyz/paketName.git\ndevtools::create(\"paketName\")git add -A\ngit commit -m \"paket struktur angelegt\"git push"},{"path":"packages.html","id":"literatur-2","chapter":"Kapitel 12 Pakete","heading":"12.11 Literatur","text":"Diese Folien haben einen kleinen Einblick das Erstellen eigener Pakete gegeben. Allerdings wurden viele weitere Aspekte nicht angesprochen. Weitere Informationen zu R Paketen findet man z.B. im Buch R packages von Hadley Wickham (2015b).","code":""},{"path":"funktionen.html","id":"funktionen","chapter":"Kapitel 13 Funktionen","heading":"Kapitel 13 Funktionen","text":"Wie jeder anderen Programmierumgebung, besteht auch R die Möglichkeit eigene Funktionen zu definieren.Eine der wichtigsten Erkenntnisse dabei ist die Tatsache, dass auch Funktionen Objekte sind. Generell ist R alles ein Objekt.Neue Funktionen werden mit der Funktion function() erzeugt.","code":""},{"path":"funktionen.html","id":"bestandteile-von-funktionen","chapter":"Kapitel 13 Funktionen","heading":"13.1 Bestandteile von Funktionen","text":"Alle R Funktionen bestehen aus den drei Teilen:formals(), Argumente, die den Funktionsaufruf “regeln”body(), der eigentliche Codeenvironment(), Verweis auf die Funktionseingabe","code":"\nf <- function(x) x + sin(x)\nformals(f)## $x\nbody(f)## x + sin(x)\nenvironment(f)## <environment: R_GlobalEnv>"},{"path":"funktionen.html","id":"body","chapter":"Kapitel 13 Funktionen","heading":"13.2 body()","text":"Wie alle Objekte R, besitzen auch Funktionen Attribute. Ein data frame besitzt z.B. die Attribute names, class und row.namesEine Funktion besitzt hingegen die AttributeDen Unterschied zu body() sehen wir im folgenden Beispiel.","code":"\nattributes(iris)## $names\n## [1] \"Sepal.Length\" \"Sepal.Width\"  \"Petal.Length\" \"Petal.Width\"  \"Species\"     \n## \n## $class\n## [1] \"data.frame\"\n## \n## $row.names\n##   [1]   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18\n##  [19]  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36\n##  [37]  37  38  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54\n##  [55]  55  56  57  58  59  60  61  62  63  64  65  66  67  68  69  70  71  72\n##  [73]  73  74  75  76  77  78  79  80  81  82  83  84  85  86  87  88  89  90\n##  [91]  91  92  93  94  95  96  97  98  99 100 101 102 103 104 105 106 107 108\n## [109] 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126\n## [127] 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144\n## [145] 145 146 147 148 149 150\nattributes(f)## $srcref\n## function(x) x + sin(x)\nf <- function(x){\n  # Summe von x und sin(x)#\n  x + sin(x)\n}\nbody(f)## {\n##     x + sin(x)\n## }\nattr(f, \"srcref\")## function(x){\n##   # Summe von x und sin(x)#\n##   x + sin(x)\n## }"},{"path":"funktionen.html","id":"einfache-funktionen","chapter":"Kapitel 13 Funktionen","heading":"13.3 “Einfache” Funktionen","text":"Es gibt eine Ausnahme von der obigen Regel, dass Funktionen aus drei Teilen bestehen. Die primitive functions wie sum(), sin() oder exp() rufen direkt über die Funktion .Primitive() C Code auf, enthalten somit keinen R Code und daher sind alle drei Teile gleich NULL.","code":"\nformals(sin)## NULL\nbody(sin)## NULL\nenvironment(sin)## NULL"},{"path":"funktionen.html","id":"jede-operation-ist-ein-funktionsaufruf","chapter":"Kapitel 13 Funktionen","heading":"13.4 Jede Operation ist ein Funktionsaufruf","text":"“understand computations R, two slogans helpful:\nEverything exists object.\nEverything happens function call.”\n— John ChambersAlle Operationen bestehen aus Funktionsaufrufen. Somit auch +, -, /,:, , , oder []und $. Dies sieht man z.B. diesem Beispieloder auch diesem BeispielenDie Verwendung von ` erlaubt den Zugriff auf reservierte Ausdrücke.Eine sinnvolle Anwendung dieser Zugriffsmethode liegt der Kombination mit den apply Funktionen (apply(), lapply(), sapply, mapply(), tapply()). Diese wenden eine zu übergebende Funktion auf weitere Inputgrößen wie Listen oder Data Frames .","code":"\nx <- 10 \ny <- 5\nx + y## [1] 15\n`+`(x, y)## [1] 15\nfor (i in 1:2) print(i)## [1] 1\n## [1] 2\n`for`(i, 1:2, print(i))## [1] 1\n## [1] 2\nx[3]## [1] NA\n`[`(x, 3)## [1] NA\nx <- list(1:3, 4:9, 10:12)\nsapply(x, `[`, 2)## [1]  2  5 11\nsapply(x, function(x) x[2])## [1]  2  5 11"},{"path":"funktionen.html","id":"lapply-sapply","chapter":"Kapitel 13 Funktionen","heading":"13.5 lapply, sapply","text":"sapply() ist eine Version von lapply(), die - wenn möglich - eine “vereinfachte” Ausgabe liefert.","code":"\nx <- list(1:3, 4:6, 7:9)\nlapply(x, `+`, 3)## [[1]]\n## [1] 4 5 6\n## \n## [[2]]\n## [1] 7 8 9\n## \n## [[3]]\n## [1] 10 11 12\nis.matrix(sapply(x, `+`, 3))## [1] TRUE"},{"path":"funktionen.html","id":"funktionsargumente","chapter":"Kapitel 13 Funktionen","heading":"13.6 Funktionsargumente","text":"Funktionen besitzen formelle Argumente, denen beim Funktionsaufruf (oder per Default) Werte zugewiesen werden. Beim Aufruf können die Argumente durch ihre Position, den vollen oder teilweisen Namen ausgewählt werden.Der folgende Aufruf kann aber nicht funktionieren.Generell sollte man die zwei, drei wichtigsten Inputgrößen den Beginn stellen. Alle anderen sollten eher nicht durch die Position ausgewählt werden. Dabei ist der vollständige Namen sicherlich zu bevorzugen.Funktionsargumenten können Default-Werte zugeordnet werden. Dabei können Default-Werte auch Abhängigkeit anderer Argumente definiert werden.","code":"\nf <- function(abc, bcd, bdc) c(abc, bcd, bdc)\nf(3, 2, 1)## [1] 3 2 1\nf(2, 1, abc=3)## [1] 3 2 1\nf(2, 1, a=3)## [1] 3 2 1\nf(3, b=2, 1)## Error in f(3, b = 2, 1): argument 2 matches multiple formal arguments\nf <- function(a = 1, b = 2) {\n  c(a, b)\n}\nf()## [1] 1 2\ng <- function(a = 1, b = a * 2) {\n  c(a, b)\n}\ng(a=10)## [1] 10 20"},{"path":"funktionen.html","id":"funktionsargumente-lazy-evaluation","chapter":"Kapitel 13 Funktionen","heading":"13.7 Funktionsargumente: Lazy Evaluation","text":"R wertet Funktionsargumente nur aus, wenn diese tatsächlich benützt werden. Dies entspricht der Idee der Lazy Evaluation.Mit force() kann man die Auswertung eines Arguments erzwingen.Benutzt man eine verschachtelte Funktion Kombination mit lapply() oder einer Schleife, kann die Lazy Evaluation entscheidend sein.x wird beim ersten Aufruf von addiere_zu_1bis10() ausgewertet. Bis dahin ist x aber bereits von 1 bis 10 “gelaufen” und hat damit den Wert 10. Somit wird stets 10 zum Input addiert.Erzwingt man die Auswertung, erhält man das gewünschte Ergebnis.Bisher schien die Lazy Evaluation eher nachteilig. Sie kann aber auch Vorteile haben. Die Befehleerzeugen keinen Fehler, obwohl NULL>0 keinen zulässigen Input für darstellt. Da !.null(x) bereits FALSE liefert, wird die zweite Abfrage nicht mehr ausgewertet.Hauptvorteil ist aber die Effizienz. Nur notwendige Ausdrücke werden ausgewertet.","code":"\nf <- function(x) {\n  10\n}\nf(stop(\"x ist nicht 10\"))## [1] 10\nf <- function(x) {\n  force(x)\n  10\n}\nf(stop(\"x ist nicht 10\"))## Error in force(x): x ist nicht 10\naddiere_x <- function(x){\n  function(y) x+y\n}\naddiere_zu_1bis10 <- lapply(1:10, addiere_x)\naddiere_zu_1bis10[[1]](10)## [1] 11\naddiere_zu_1bis10[[5]](10)## [1] 15\naddiere_x <- function(x){\n  force(x)\n  function(y) x+y\n}\naddiere_zu_1bis10 <- lapply(1:10, addiere_x)\naddiere_zu_1bis10[[1]](10)## [1] 11\naddiere_zu_1bis10[[5]](10)## [1] 15\nx <- NULL\nif (!is.null(x) && x > 0) {\n\n}"},{"path":"funktionen.html","id":"funktionsargumente-...","chapter":"Kapitel 13 Funktionen","heading":"13.8 Funktionsargumente: ...","text":"Für eine Funktion kann das formale ... Drei-Punkte Argument verwendet werden. Alle nicht über Position und/oder Name zugeordneten Argumente werden durch ... aufgenommen. der Regel werden über ... Argumente übergeben, die innerhalb der Funktion andere Funktionen weitergegeben werden.... erhöht also offensichtlich die Flexibilität. Ein Nachteil ist, dass falsch geschriebene Argumente keinen Fehler erzeugen und alle Argumente nach ... voll ausgeschrieben werden müssen.","code":"\nsumme_plus2 <- function(x, ...){\n  x <- x+2\n  sum(x, ...)\n}\nsumme_plus2(c(1, 3, 5))## [1] 15\nsumme_plus2(c(1, 3, NA), na.rm = TRUE)## [1] 8\nsum(1, 2, NA, rm.na = TRUE)## [1] NA\nsum(1, 2, NA, na.rm = TRUE)## [1] 3"},{"path":"funktionen.html","id":"funktionsrückgabe","chapter":"Kapitel 13 Funktionen","heading":"13.9 Funktionsrückgabe","text":"Wir haben den Beispielen bereits gesehen wie die Rückgabe funktioniert. Der letzte Ausdruck, der ausgewertet wird, bildet die Rückgabe.Falls bereits zu einem früheren Zeitpunkte eine Rückgabe erfolgen soll (z.B. STOP Kriterium erfüllt) und diese speziell gekennzeichnet werden soll, kann die Funktion return() verwendet werden.Funktionen können nur ein Objekt zurückgeben. Soll die Ausgabe einer Funktion aus mehreren Objekten bestehen, schreibt man diese einfach eine Liste und gibt die Liste zurück.","code":"\nf <- function(x) {\n  if (x < 10) {\n    0\n  } else {\n    10\n  }\n}\nf(5)## [1] 0\nf(15)## [1] 10\nf <- function(x) {\n  if (x < 10) {\n    n_output <- 0\n    t_output <- \"eingabe war kleiner 10\"\n  } else {\n    n_output <- 10\n    t_output <- \"eingabe war größer oder gleich 10\"\n\n  }\n  \n  output <- list(n_output, t_output)\n  return(output) \n}\nf(5)## [[1]]\n## [1] 0\n## \n## [[2]]\n## [1] \"eingabe war kleiner 10\"\nf(15)## [[1]]\n## [1] 10\n## \n## [[2]]\n## [1] \"eingabe war größer oder gleich 10\""},{"path":"funktionen.html","id":"mehr-zu","chapter":"Kapitel 13 Funktionen","heading":"13.10 mehr zu …","text":"Wenn ihr mehr zufunctionsenvironmentsfunctional programmingobject-oriented programming…wissen wollt, dann findet ihr (fast) alle Antworten auf eure Fragen im Buch Advanced R von Hadley Wickham (2015a).","code":""},{"path":"envscop.html","id":"envscop","chapter":"Kapitel 14 Environments und Scoping","heading":"Kapitel 14 Environments und Scoping","text":"","code":""},{"path":"envscop.html","id":"zuordnungen","chapter":"Kapitel 14 Environments und Scoping","heading":"14.1 Zuordnungen","text":"Wie weiß R welchen Wert es welchem Symbol zuordnen soll?Warum wählt R nicht die Standardfunktion sqrt() aus dem base Paket?Wenn R einem Symbol einen Wert zuordnet, dann durchsucht R eine Reihe von environments (bereits im Abschnitt Funktionen gesehen) nach dem passenden Wert. Gesucht wird folgender ReihenfolgeDas Global Environment wird durchsucht.Die namespaces (dazu später mehr) der Pakete auf der search Liste werden durchsucht.Das global environment (der Workspace) wird immer zuerst und base immer zuletzt durchsucht.Die search Liste wird also beeinflusst durch die von uns geladenen Pakete.Man beachte, dass R die Namen von Daten- und Funktionsobjekten unterscheiden kann.","code":"\nsqrt(2)## [1] 1.414214\nsqrt <- function(x) x^2\nsqrt(2)## [1] 4\nsearch()## [1] \".GlobalEnv\"        \"package:stats\"     \"package:graphics\" \n## [4] \"package:grDevices\" \"package:utils\"     \"package:datasets\" \n## [7] \"package:methods\"   \"Autoloads\"         \"package:base\"\nlibrary(ggplot2)\nsearch()##  [1] \".GlobalEnv\"        \"package:ggplot2\"   \"package:stats\"    \n##  [4] \"package:graphics\"  \"package:grDevices\" \"package:utils\"    \n##  [7] \"package:datasets\"  \"package:methods\"   \"Autoloads\"        \n## [10] \"package:base\"\n(sqrt <- 2)## [1] 2\nsqrt(2)## [1] 1.414214"},{"path":"envscop.html","id":"environments","chapter":"Kapitel 14 Environments und Scoping","heading":"14.2 Environments","text":"Ein Environment verbindet eine Menge von Namen mit einer entsprechenden Menge von Werten. Environments sind ähnlich zu einer Liste, aber es gibt entscheidende Unterschiededie Namen der Objekte einem Environment sind eindeutigdie Objekte eines Environments sind nicht geordnetjedes Environment besitzt ein parent Environment, außer emptyenv()Die Einträge von search() sind die Eltern des Global Environment. Mit new.env() kann auch ein neues Environment erzeugt werden.Bemerkung: Die meisten Environments erzeugt man durch die Verwendung von Funktionen.","code":"\nneues_env <- new.env()\nneues_env$eins <- c(1, 2)\nneues_env$zwei <- c(\"a\", \"b\")\nls(neues_env)## [1] \"eins\" \"zwei\"\nparent.env(neues_env)## <environment: R_GlobalEnv>"},{"path":"envscop.html","id":"scoping-rules","chapter":"Kapitel 14 Environments und Scoping","heading":"14.3 Scoping Rules","text":"Der Sichtbarkeitsbereich von Variablen (Scope) wird über Scoping Rules festgelegt. R verwendet static scoping oder auch lexical scoping genannt (eine Alternative ist das dynamic scoping).f hat die formellen Argumente x und y sowie die freie Variable z. Die Scoping Rule bestimmt wie Werte freien Variablen zugeordnet werden. R bedeutet diesDer Wert freier Variablen (einer Funktion) wird dem Environment gesucht, dem die Funktion definiert wurde.","code":"\nf <- function(x, y){\n  x + y/z\n}"},{"path":"envscop.html","id":"static-scoping","chapter":"Kapitel 14 Environments und Scoping","heading":"14.4 Static scoping","text":"Oftmals werden Funktionen im Globalen Environment definiert. Die Werte freier Variablen sollten dann im Workspace zu finden sein. Dieses “Verhalten” wird von den meisten “Nutzern” erwartet und als sinnvoll angesehen.Allerdings können Funktionen auch innerhalb von Funktionen definiert werden. diesem Fall ist das Environment der body einer anderen Funktion.bilde_potenz() liefert somit eine Funktion als Ausgabe.Sucht man nach einer Variable und/oder möchte man ihren Wert ausgeben, kann man mit den Funktionen exists() und get() arbeiten. Beide verwenden static scoping.Schauen wir uns nun den closure (Funktion + zugehöriges Environment) von zweite_potenz() und dritte_potenz() genauer .","code":"\nbilde_potenz <- function(n){\n  potenz <- function(x)\n    x^n\n}\nzweite_potenz <- bilde_potenz(2)\ndritte_potenz <- bilde_potenz(3)\nget(\"eins\", envir = neues_env)## [1] 1 2\nx <- 1\nexists(\"x\", envir = neues_env)## [1] TRUE\nexists(\"x\", envir = neues_env, inherits = FALSE)## [1] FALSE\nls(environment(zweite_potenz))## [1] \"n\"      \"potenz\"\nget(\"n\", envir = environment(zweite_potenz))## [1] 2\nls(environment(dritte_potenz))## [1] \"n\"      \"potenz\"\nget(\"n\", envir = environment(dritte_potenz))## [1] 3"},{"path":"envscop.html","id":"anwendungsbeispiel","chapter":"Kapitel 14 Environments und Scoping","heading":"14.5 Anwendungsbeispiel","text":"Wir betrachten als Anwendungsbeispiel die Minimierung der Funktion\\[\n  l_x(\\mu,\\sigma^2) =-\\left(-\\frac{n}{2}\\log(2\\pi\\sigma^2)-\\frac1{2\\sigma^2}\\sum_{=1}^n(x_i-\\mu)^2\\right)\\,,\n  \\]\nwobei \\(x_i, =1,\\dots,n,\\) bekannte Größen sind. Die obigen Funktion ist der negative log-Likelihood einer Normalverteilung mit Parametern \\(\\mu\\) und \\(\\sigma^2\\), aber das spielt hier keine Rolle.Optimierungsroutinen wie optim(), nlm() oder optimize() erwarten als Eingabe eine\nFunktion, deren Argumente die zu optimierenden Parameterwerte sind. Oftmals (wie im obigen Beispiel) hängen Funktionen aber von weiteren Werten ab.Die Funktion ist geschrieben, dass einer der beiden Parameter fixiert werden kann.Fixieren wir nun \\(\\mu\\) gleich 1, erhält manBemerkung: Wir verwenden optimize() anstatt optim(), da letztere nicht für eindimensionale Optimierung geeignet ist.Durch Übergabe aller weiteren Größen im Environmentkonnte die Funktion l_x() nur als Funktion der unbekannten Parameter im\n.GlobalEnv definiert werden.Es muss also keine Liste weiterer Argumente der Optimierungs- funktion übergeben werden.","code":"\nnegLogLik <- function(data, fix = c(FALSE, FALSE)){\n  param <- fix\n  function(theta){\n    param[!fix] <- theta\n    mu <- param[1]\n    sigma_2 <- param[2]\n    l_x <- -( -length(data)/2 * log(2 * pi * sigma_2 )\n              - sum((data-mu)^2) / (2*sigma_2))\n    l_x\n  }\n}\nset.seed(1234)\nx <- rnorm(1000, mean = 1, sd = 2)\nl_x <- negLogLik(x)\nl_x## function(theta){\n##     param[!fix] <- theta\n##     mu <- param[1]\n##     sigma_2 <- param[2]\n##     l_x <- -( -length(data)/2 * log(2 * pi * sigma_2 )\n##               - sum((data-mu)^2) / (2*sigma_2))\n##     l_x\n##   }\n## <bytecode: 0x7fd6d3de5f58>\n## <environment: 0x7fd6ccd31588>\nls(environment(l_x))## [1] \"data\"  \"fix\"   \"param\"\noptim(par = c(0, 1), fn = l_x)$par## [1] 0.9465684 3.9744817\nl_x <- negLogLik(x, fix = c(1, FALSE))\noptimize(f = l_x, interval = c(1e-6, 10))$minimum## [1] 3.97759\nls(environment(l_x))## [1] \"data\"  \"fix\"   \"param\"\nparent.env(environment(l_x))## <environment: R_GlobalEnv>"},{"path":"fragen.html","id":"fragen","chapter":"Kapitel 15 Fragen und Anregungen aus der Übung","heading":"Kapitel 15 Fragen und Anregungen aus der Übung","text":"","code":""},{"path":"fragen.html","id":"quantilsfunktion","chapter":"Kapitel 15 Fragen und Anregungen aus der Übung","heading":"15.1 Quantilsfunktion","text":"Als Beispiel betrachten wir die Quantilsfunktion\\[Q: (0,1) \\\\mathbb{R}, y \\mapsto \\text{inf}\\{x\\\\mathbb{R}: F(x)\\geq y\\}\\]der \\(N(5,4)\\) Verteilung. Diese Funktion können wir mit qnorm() berechnen und mithilfe von stat_function() dann plottenDer Grafik können wir z.B. entnehmen, dass das 0.25 Quantil \\(q_{0.25}\\) der \\(N(5,4)\\) ungefähr den Wert 3.65 hat. Der genaue Wert lautet\\(q_{0.25}\\) ist also der Wert, sodass die Wahrscheinlichkeit (unter der \\(N(5,4)\\) Verteilung) Werte kleiner oder gleich \\(q_{0.25}\\) anzunehmen, gleich 0.25 ist","code":"\nlibrary(tidyverse)\nggplot(data.frame(x=c(0,1)), aes(x)) +\n  stat_function(fun = \"qnorm\", args = list(mean = 5, sd = 2),\n                colour = \"blue\") + ylab(\"Q(x)\") +\n  geom_hline(yintercept = qnorm(0.25, mean = 5, sd = 2), colour = \"gold\") +\n  scale_y_continuous(breaks=round(qnorm(c(0.05, 0.25, 0.5, 0.75, 0.95), mean = 5, sd = 2), 2) ) +\n  theme_minimal()\n(q_025 <- qnorm(0.25, mean = 5, sd = 2))## [1] 3.65102\npnorm(q_025, mean = 5, sd = 2)## [1] 0.25"},{"path":"fragen.html","id":"qq-plot","chapter":"Kapitel 15 Fragen und Anregungen aus der Übung","heading":"15.1.1 QQ-Plot","text":"Nun erzeugen wir 500 Pseudo-Zufallszahlen mit \\(N(5,4)\\) Verteilung.Für diese Pseudo-Zufallszahlen berechnen wir nun die geordnete Stichprobe sowie die relativen Häufigkeiten (funktioniert hier einfach, da es sich um eine st)Die beiden Grafiken sehen ähnlich aus. Aber ein Vergleich von zwei getrennten Grafiken ist natürlich nicht einfach. Da die Werte auf der jeweiligen x-Achse nicht von großem Interesse sind, plottet man daher einfach die empirischen und theoretischen Quantile gegeneinander.","code":"\ndf <- tibble(x = rnorm(500, mean = 5, sd = 2))\ndf %>%\n  mutate(ord_x = sort(x), p = ecdf(ord_x)(ord_x)) %>%\n  ggplot(aes(x = p, y = ord_x)) + geom_point(colour = \"blue\") + \n  geom_hline(yintercept = qnorm(0.25, mean = 5, sd = 2), colour = \"gold\") +\n  scale_y_continuous(breaks=round(qnorm(c(0.05, 0.25, 0.5, 0.75, 0.95), mean = 5, sd = 2), 2) ) +\n  ylab(\"emp. Quantile\") + theme_minimal()\nggplot(df, aes(sample = x)) + \n  stat_qq(distribution = qnorm, dparams = list(mean = 5, sd = 2)) +\n  stat_qq_line(distribution = qnorm, dparams = list(mean = 5, sd = 2)) +\n  theme_minimal()"},{"path":"literatur-3.html","id":"literatur-3","chapter":"Literatur","heading":"Literatur","text":"","code":""}]
