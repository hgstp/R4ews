[
["index.html", "R4ews MA0009 Willkommen zur R Ergänzung zur Einführung in die Wahrscheinlichkeitstheorie und Statistik Beteiligte Personen Kolophon Lizenz", " R4ews MA0009 Stephan Haug Willkommen zur R Ergänzung zur Einführung in die Wahrscheinlichkeitstheorie und Statistik Im Rahmen dieser Ergänzung lernen wir Daten untersuchen, aufbereiten, visualisieren und analysieren, Wir wollen all das reproduzierbar, wiederverwendbar und gemeinsam nutzbar machen, und vor allem wollen wir alles mit R machen. Auf dieser Website geht es um alles, was bei der Datenanalyse auftaucht außer um statistische Modellierung und Schlussfolgerungen. Dieser Teil der statistischen Analyse erfolgt in der Vorlesung Einführung in die Wahrscheinlichkeitstheorie und Statistik. Das Design von R4ews wurde durch die Notwendigkeit motiviert, mehr Ausgewogenheit in der angewandten statistischen Ausbildung zu schaffen. Datenanalysten verbringen viel Zeit mit der Projekt-Organisation, der Datenbereinigung und -aufbereitung sowie der Kommunikation. Diese Tätigkeiten können einen tiefgreifenden Einfluss auf die Qualität und Glaubwürdigkeit einer Analyse haben. Dennoch werden diese Fähigkeiten selten vermittelt, obwohl sie so wichtig und notwendig sind. R4ews zielt darauf ab, diese Lücke zu schließen. Das Material wird kontinuierlich über das Semester hinweg ergänzt/erweitert/verbessert. Letzte Änderung: date() #&gt; [1] &quot;Wed Dec 2 23:00:28 2020&quot; Beteiligte Personen Kolophon Dieses Buch wurde in bookdown innerhalb von RStudio geschrieben. Teile des Buches basieren auf stat545.com. Alle Änderungen wurden gemäß der Creative Commons Attribution-ShareAlike 4.0 International License durchgeführt. Wir bedanken uns bei den Autor*innen von stat545 für das großartige Material. Die aktuelle Version dieses Buchs wurde mit #&gt; Finding R package dependencies ... Done! #&gt; setting value #&gt; version R version 4.0.2 (2020-06-22) #&gt; os macOS 10.16 #&gt; system x86_64, darwin17.0 #&gt; ui X11 #&gt; language (EN) #&gt; collate en_US.UTF-8 #&gt; ctype en_US.UTF-8 #&gt; tz Europe/Berlin #&gt; date 2020-12-02 erstellt Lizenz Diese Arbeit ist lizenziert unter Creative Commons Attribution-ShareAlike 4.0 International License. "],
["install.html", "Kapitel 1 Installieren von R und RStudio 1.1 R und RStudio 1.2 Funktioniert? Ausprobieren 1.3 Add-on packages 1.4 RStudio Primers 1.5 Aufgabe", " Kapitel 1 Installieren von R und RStudio 1.1 R und RStudio Installieren Sie R, eine freie Softwareumgebung für statistische Berechnungen und Grafiken von CRAN, dem Comprehensive R Archive Network. Wir empfehle Ihnen dringend, eine vorkompilierte Binärdistribution für Ihr Betriebssystem zu installieren - benutzen Sie die Links oben auf der CRAN Seite! Installieren Sie die IDE von RStudio (steht für integrated development environment), eine leistungsfähige Benutzeroberfläche für R. Holen Sie sich die Open-Source-Edition von RStudio Desktop. Es ist vorteilhaft die Preview version zu installieren. In der Regel ist sie bereits sehr stabil und man hat so Zugriff auf die neusten Features. Natürlich gibt es auch offizielle Veröffentlichungen here. RStudio wird mit einem Text Editor geliefert, so dass es nicht unmittelbar erforderlich ist, einen separaten, eigenständigen Editor zu installieren. RStudio kann eine Schnittstelle zu Git(Hub) bilden. Sie müssen jedoch alle Git(Hub)-Installationen selbst vornehmen. Wir kommen später auf diesen Punkt zurück. Wenn Sie eine bereits vorhandene R und/oder RStudio Installation haben, empfehlen wir Ihnen dringend, beide neu zu installieren und so aktuell wie möglich zu halten. Wenn Sie R aktualisieren, müssen Sie alle Pakete, die Sie installiert haben, aktualisieren. Der unten stehende Befehl sollte Ihnen den Anfang machen, obwohl Sie möglicherweise weitere Argumente angeben müssen, wenn Sie z.B. eine nicht standardmäßige Bibliothek für Ihre Pakete verwendet haben. update.packages(ask = FALSE, checkBuilt = TRUE) Bemerkung: hier wird nur nach Updates auf CRAN gesucht. Wenn Sie also ein Paket verwenden, das z.B. nur auf GitHub lebt, müssen Sie manuell aktualisieren, z.B. über devtools::install_github(). 1.2 Funktioniert? Ausprobieren Starten Sie RStudio auf Ihrem Computer. Sie sollten ein Fenster ähnlich zu diesem Screenshot, erhalten. Setzen Sie den Cursor in den Bereich mit der Bezeichnung Konsole, wo Sie mit R interagieren können. Erstellen Sie ein einfaches Objekt mit einem Code wie x &lt;- 2 * 4 (gefolgt von Enter oder Return). Inspizieren Sie dann das x-Objekt durch Eingabe von x gefolgt von Enter oder Return. Sie sollten den Wert 8 auf dem Bildschirm sehen. Wenn ja, haben Sie R und RStudio erfolgreich installiert. 1.3 Add-on packages R ist ein erweiterbares System und viele Menschen teilen nützlichen Code, den sie als Paket entwickelt haben, über CRAN und GitHub. Um ein Paket von CRAN zu installieren, z.B. das Paket tidyverse (ist genauer gesagt eine Kollektion von Paketen), kann man folgenden Befehl verwenden install.packages(&quot;tidyverse&quot;, dependencies = TRUE) Mit der Option dependencies = TRUE achten wir darauf, dass alle für tidyverse notwendigen Pakete, ebenfalls installiert werden. 1.4 RStudio Primers Ein guter Startpunkt für verschiedene R Themen sind die RStudio primers. Im Laufe des Kurses werden sie die Primers The Basics Work with Data Visualize Data durcharbeiten. 1.5 Aufgabe Wir beginnen mit The Basics. Hier wird unterschieden in Programming und Visualization Basics. Programming Basics beinhaltet Grundlagen zu Objekttypen, Funktionen und deren Argumente, Listen (eigentlich sind alle Objekte Listen, nur unterschiedlich speziell) und Paketen. Visualization Basics erklärt erste Schritte in der Verwendung des ggplot2 Pakets, mit dem wir uns später noch eingehend beschäftigen werden. Bearbeiten sie eigenständig den Basics Primer. "],
["r-basics.html", "Kapitel 2 R Basics und Arbeitsabläufe 2.1 Ein paar Grundlagen für das Arbeiten mit R 2.2 Workspace und working directory 2.3 RStudio Projects 2.4 Zuletzt noch", " Kapitel 2 R Basics und Arbeitsabläufe 2.1 Ein paar Grundlagen für das Arbeiten mit R Aktueller Stand: Du hast bereits den Programming Basics Primer absolviert und nun willst du anfangen mit deiner RStudio/R Installation zu arbeiten arbeiten. Es geht los indem du RStudio startest. Beachte dabei die Standardfensterbereiche: Console (links) Environment / History (oben rechts) Files / Plots / Packages / Help (unten rechtes) Bemerkung: Die Standardanordnung der Fenster kannst du neben vielen anderen Dingen nach deinen Vorstellungen ändern/anpassen: Customizing RStudio. Gehen nun in die Konsole um mit R zu interagieren. Erstelle die nachfolgende Zuordnung und schau dir das erstellte Objekt genauer an: x &lt;- 3 * 4 x #&gt; [1] 12 Alle R Befehle, die ein Objekte erstellen (“Zuweisungen”), haben die Form: objectName &lt;- value Du wirst im weiteren Verlauf noch viele Zuweisungen vornehmen, und es ist tatsächlich etwas mühsam den Operator &lt;- zu tippen. Sei aber trotzdem nicht faul und benutze = stattdessen - auch wenn es theoretisch funktionieren würde. Aber später kann die Verwendung von = für Zuweisungen zu Verwirrung führen. Verwende stattdessen in RStudio die Tastenkombination: Alt + - (Minuszeichen). Beachte, dass RStudio automatisch &lt;- mit Leerzeichen umgibt, was eine nützliche Codeformatierung demonstriert. Code ist selbst an einem guten Tag eher schlecht zu lesen. Gönne daher deinen Augen eine Pause und verwende (ausreichend) Leerzeichen. RStudio bietet viele praktische Tastaturkürzel an. Eine Übersicht erhält man auch mit Alt+Shift+K. Objektnamen dürfen nicht mit einer Ziffer beginnen und bestimmte andere Zeichen wie ein Komma oder ein Leerzeichen nicht enthalten. Es ist daher ratsam, sich eine Konvention zur Abgrenzung von Wörtern in Objektnamen zu überlegen. i_use_snake_case other.people.use.periods evenOthersUseCamelCase Wir werden stets die erste Variante verwenden. Führe nun nachfolgenden Befehl aus this_is_a_really_long_name &lt;- 2.5 In deinem Workspace ist nun das Objekt this_is_a_really_long_name vorhanden. Probiere mithilfe dieses Objekts die Vervollständigungsfunktion von RStudio aus: Gib die ersten paar Zeichen ein, drücke anschließend die TAB Taste, fügen weitere Zeichen hinzu, bis Eindeutigkeit hergestellt ist(wenn sonst wenig in deinem Workspace ist, dann ist das schnell erreicht), und drücke dann die Eingabetaste. Führe nun den Befehl jenny_rocks &lt;- 2 ^ 3 aus, um anschließend den Inhalt des Objekts anzuzeigen. jennyrocks #&gt; Error in eval(expr, envir, enclos): object &#39;jennyrocks&#39; not found jeny_rocks #&gt; Error in eval(expr, envir, enclos): object &#39;jeny_rocks&#39; not found Die Objekte jennyrocks und jeny_rocks sind natürlich nicht vorhanden und somit führen beide Befehle zu einer Fehlermeldung. Man muss also absolut exakt sein mit seinen Befehlen. R verfügt über eine überwältigende Sammlung eingebauter Funktionen, die nach folgendem Schema aufgerufen werden: functionName(arg1 = val1, arg2 = val2, and so on) Als nächstes wollen wir die Funktion seq() verwenden, die reguläre Zahlensequenzen erzeugt. Dabei wollen wir noch ein weiteres hilfreiches Feature von RStudio demonstrieren. Tippe se und drücke dann die TAB Taste. In einem Pop-Up Fenster werden dir mögliche Vervollständigungen angezeigt. Der Befehl seq() kann dann durch weiteres Tippen oder über die Auswahlmöglichkeit (Pfeiltasten nach oben/unten) festgelegt werden. Zu jeder Auswahlmöglichkeit wird auch noch eine Kurzform der entsprechenden Hilfeseite angezeigt. Fügt man jetzt die öffnende runde Klammer hinzu, so wird die zugehörige schließende runde Klammer automatisch hinzugefügt. Tippe anschließend 1, 10 (das geschieht automatisch innerhalb der runden Klammern) und Return. RStudio beendet auch den Klammerausdruck für dich. IDEs sind großartig. seq(1, 10) #&gt; [1] 1 2 3 4 5 6 7 8 9 10 Der letzte Befehl zeigt auch ganz gut, wie R Funktionsargumente auflöst. Sie können immer in der Form Name = Wert angeben werden. Aber der Name muss nicht angegeben werden, wie man sieht. In solchen Fällen versucht R, nach der Position aufzulösen. So wird oben angenommen, dass wir eine Sequenz bei 1 starten wollen, also from = 1, und diese bis 10 laufen soll, daher to = 10. Da wir keine Schrittweite angegeben haben, wird der Standardwert für by verwendet, der in diesem Fall gleich 1 ist. Bei Funktionen, die man oft aufruft, kann man gut diese Auflösung nach Position für das erste und vielleicht auch das zweite Argument verwenden. Danach ist es aber ratsam immer mit Name = Wert zu arbeiten um falsche Zuweisungen (verschiedene Argumente können vom gleichen Typ sein, sodass eine falsche Zuweisung nicht automatisch zu einer Fehlermeldung führt) zu vermeiden. Analog zur Unterstützung mit den runden Klammern, werden auch schließende Anführungszeichen automatisch ergänzt, wie man in folgendem Beispiel sieht. yo &lt;- &quot;hello world&quot; Nach einer Zuweisung wird der entsprechende Wert des Objekts nicht angezeigt. Daher ist man vielleicht dazu geneigt das Objekt gleich erneut aufzurufen y &lt;- seq(1, 10) y #&gt; [1] 1 2 3 4 5 6 7 8 9 10 Diese typische Aktion kann verkürzt werden, indem die Zuweisung in Klammern gesetzt wird, wodurch die Zuweisung und ein Befehl “Drucke auf den Bildschirm” erfolgen. (y &lt;- seq(1, 10)) #&gt; [1] 1 2 3 4 5 6 7 8 9 10 Nicht alle Funktionen haben (oder erfordern) Argumente: date() #&gt; [1] &quot;Wed Dec 2 23:00:33 2020&quot; Schau dir nun deinen Workspace an - im oberen rechten Fensterbereich (bei Standardeinstellung) siehst du unter Environment den Inhalt deines Workspaces. Der Workspace ist der Ort, an dem sich benutzerdefinierte Objekte ansammeln. Eine Liste dieser Objekte kannst du auch mit diesen Befehlen erhalten: objects() #&gt; [1] &quot;check_quietly&quot; &quot;install_quietly&quot; #&gt; [3] &quot;jenny_rocks&quot; &quot;pretty_install&quot; #&gt; [5] &quot;shhh_check&quot; &quot;this_is_a_really_long_name&quot; #&gt; [7] &quot;x&quot; &quot;y&quot; #&gt; [9] &quot;yo&quot; ls() #&gt; [1] &quot;check_quietly&quot; &quot;install_quietly&quot; #&gt; [3] &quot;jenny_rocks&quot; &quot;pretty_install&quot; #&gt; [5] &quot;shhh_check&quot; &quot;this_is_a_really_long_name&quot; #&gt; [7] &quot;x&quot; &quot;y&quot; #&gt; [9] &quot;yo&quot; Wenn du nun das Objekt mit dem Namen y entfernen möchtest, kannst du dies wie folgt machen: rm(y) Alles löschen kannst du mit dem Befehl rm(list = ls()) oder du klickst auf den Besen im Environment Fenster von RStudio. 2.2 Workspace und working directory Ziemlich schnell wird der Fall eintreten, dass du mit deiner R Arbeit (z.B. Bearbeitung eines Hausaufgaben Projekts) noch nicht fertig bist obwohl es Zeit wird R zu beenden. Natürlich willst du aber zu einem späteren Zeitpunkt mit der Analyse weitermachen wo du aufgehört hast. Etwas später wird es so ein, dass du Daten in R einlesen und anschließend numerische Ergebnisse erzeugen willst, die du dann schließlich auch wieder exportieren willst. Und nochmal später wird es (vielleicht) so sein, dass du in R gleichzeitig an mehreren Analysen arbeitest, die du aber unbedingt getrennt halten willst/sollst. Um diese Situationen zu bewältigen, musst du zwei Entscheidungen treffen: Was betrachtest du an deiner Analyse als “Ergebnis”, d.h. was wirst du dauerhaft speichern? Wo “lebt” deine Analyse? 2.2.1 Workspace, .RData Du startest gerade deine R Reise. Daher wäre es Okay, wenn du deinen Workspace als die “Ergebnis” deiner Analyse betrachtest. Ziemlich bald, solltest du aber davon (vielleicht durch uns) überzeugt sein, dass deine R Skripte das Ergebnis deiner Analyse sind (in beiden Fällen hängt das Ergebnis möglicherweise natürlich auch von Input Daten ab). Die Daten zusammen mit deinem R Code erlauben es dir jederzeit alle Ergebnisse zu reproduzieren und das ist die entscheidende Eigenschaft. Betrachtest du deinen Workspace als das Ergebnis deiner Analyse, dann musst du bei einem erneuten Analysedurchlauf (leicht veränderte Aufgabenstellung, …) entweder erneut eine Menge Tippen (was natürlich fehleranfällig ist) oder deine R History nach den nötigen Befehlen durchwühlen. Anstatt “becoming an expert on managing the R history”, solltest du deinen R Code sauber in ein Skript speichern, sodass er dir für weitere Analysen zur Verfügung steht. Der Workspace Ansatz wird “begünstigt” durch die Tatsache, dass RStudio beim Beenden der Session automatisch wissen will ob der Workspace gespeichert werden soll. Das wollen wir mal ausprobieren. Beende R/RStudio, entweder über das Menü oder du tippst q() in die Konsole. Dann erhältst du eine Eingabeaufforderung wie diese: Save workspace image to ~/.Rdata? Merke dir in welchem Verzeichnis die Datei gespeichert wird und dann klick auf Save. Gehe in das Verzeichnis mit dem gespeicherten Workspace Image und kontrolliere ob die Datei .RData vorhanden ist. Du wirst dort auch die Datei .Rhistory finden, die alle Befehle deiner letzten Sitzung enthält. Nun starte erneut RStudio. In der Konsole siehst du einen Befehl, der ungefähr so aussieht [Workspace loaded from ~/.RData] und angibt, dass dein gespeicherter Workspace wiederhergestellt wurde. Unter Environment solltest du die gleichen Objekte wie zuvor sehen. History enthält die gespeicherten Befehle aus der letzten Sitzung. Aber diese Art, analytische Arbeit zu beginnen und zu beenden, würde so nicht lange gut gehen. Daher fangen wir gleich mal damit an die automatische Nachfrage nach dem Speichern des Workspaces abzuwählen. Öffne dazu die Global Options (unter Tools) und setze Save workspace to .RData on exit auf Never. Nun wirst du nie mehr gefragt ob du deinen Workspace speichern willst. Sehr wohl wirst du aber weiterhin gefragt ob du ungesicherte Änderungen in deinem R Skript speichern willst, sobald du RStudio beenden willst. 2.2.2 Working directory Jeder Prozess, der auf deinem Computer läuft, hat einen Bezug zu seinem “Arbeitsverzeichnis”. In R ist dies der Ort, an dem R standardmäßig nach Dateien suchen würde oder der Ort wo alle Dateien, die du auf die Festplatte schreiben willst, abgelegt werden. Möglicherweise ist dein aktuelles Arbeitsverzeichnis das Verzeichnis, das du oben gerade untersucht hast um die .RData Datei zu finden. Du kannst dir dein aktuelles Arbeitsverzeichnis anzeigen lassen mit dem Befehl getwd() Aber es wird auch oben an der RStudio Konsole direkt angezeigt. Es wäre schon, wenn das Arbeitsverzeichnis in Abhängigkeit vom jeweils zu bearbeitenden Projekt leicht sinnvoll gesetzt werden könnte. Im nächsten Abschnitt sehen wir, dass genau das möglich ist. 2.3 RStudio Projects Alle zu einem Projekt gehörenden Dateien - Eingabedaten, R Skripte, Analyseergebnisse, Grafiken - an einem Ort zu bündeln, ist eine so weise und gängige Praxis, dass RStudio über seine Projects genau da ermöglicht. Lass uns ein Projekt für den Kurs anlegen. Dazu wählen wir oben rechts im RStudio Fenster Project: (None) -&gt; New Project Danach wählen wir New Directory -&gt; New Project und geben abschließend einen passenden Verzeichnisnamen ein (dabei beachten wir den Speicherort des neuen Verzeichnisses) Wir nehmen nun an, dass du ein RStudio Projekt angelegt und dieses auch geöffnet hast. Dann benötigen wir als Nächstes ein wenig R Code. Dazu tippen wir den unten stehenden Code (ausnahmsweise) in die Konsole a &lt;- 2 b &lt;- -3 sig_sq &lt;- 0.5 x &lt;- runif(40) y &lt;- a + b * x + rnorm(40, sd = sqrt(sig_sq)) (x_n &lt;- mean(x)) #&gt; [1] 0.524 write(x_n, &quot;mittelwert_x.txt&quot;) plot(x, y) abline(a, b, col = &quot;purple&quot;) dev.print(pdf, &quot;scatterplot.pdf&quot;) #&gt; quartz_off_screen #&gt; 2 Jetzt nehmen wir mal an das wäre ein guter Start einer Analyse, die wir durchführen wollen. Daher würdest du das Ergebnis gerne abspeichern. Unter History kannst du alle obigen Befehle markieren und anschließend “To Source” klicken. Daraufhin wird sich ein neues Fenster mit einem R Skript - das natürlich die Befehle enthält - öffnen. Das Skript kannst du abspeichern und standardmäßig wird es in deinen Projektordner gespeichert werden (aber natürlich könntest man den Speicherort an dieser Stelle auch ändern/frei wählen). Nun beende das Projekt (Close Project in der rechten oberen Ecke). Wenn du willst, kannst du dir auch den Inhalt deines Projektordners anschauen, z.B. das PDF öffnen. Danach öffnest du das Projekt wieder. Dir wird auffallen, dass alles in dem Zustand ist, wie du das Projekt verlassen hast, z.B. Objekte im Arbeitsbereich, die Befehlshistorie, welche Dateien zur Bearbeitung geöffnet sind, wo wir uns im Dateisystembrowser befinden, das Arbeitsverzeichnis für den R-Prozess usw. All dies sind gute Dinge. Nun ändern ein paar Dinge an deinem Code. Sinnvoll wäre z.B. am Anfang die Stichprobenlänge n zu definieren und z.B. auf n &lt;- 40 setzen. Dann sollten alle festen 40er Werte durch n ersetzt werden. Anschließend kannst du noch ein paar andere Dinge ändern, z.B. die Steigung b, die Farbe der Linie … was auch immer. Übe nun die verschiedenen Möglichkeiten, den Code erneut auszuführen: Führe Zeile für Zeile aus indem du entweder das Tastenkürzel Command + Enter oder die Maus (auf “Run” klicken in der oberen rechten Ecke des Editor-Fensters) verwendest. Das gesamte Dokument durchlaufen lassen per Tastenkürzel Shift + Command +S oder Maus (klicken auf “Source” in der oberen rechten Ecke des Editor-Fensters) Anschließend kannst du dir das PDF anschauen und die Änderungen bewundern. Eines Tages wirst du vor der Aufgabe stehen eine Grafik neu zu gestalten oder einfach nur verstehen wollen, woher sie stammt. Wenn du (relevante) Grafiken in einer Datei (mit R Code und niemals über die Maus oder die Zwischenablage) speicherst und dabei sinnvolle Dateinamen/Speicherorte (innerhalb des zugehörigen Projekts) benutzt, werden dich solche Aufgaben nie vor große Probleme stellen. 2.4 Zuletzt noch Es ist üblich, R-Skripte mit einem .R oder .r Suffix zu speichern. Befolge diese Konvention, außer du hast einen sehr außergewöhnlichen Grund, es nicht zu tun. Kommentare beginnen mit einem oder mehreren #-Symbolen. Verwende Kommentare.. RStudio hilft dir dabei ausgewählte Zeilen mit Ctrl+Shift+C (Windows und Linux) oder Command+Shif+C (Mac) zu kommentieren oder vorhandene Kommentare wieder zu entfernen. Dieser Workflow wird dir in Zukunft gute Dienste leisten: Erstelle ein RStudio Projekt für ein analytisches Projekt Speichere alle Input Dateien innerhalb des Projekts (wir werden bald über den Import sprechen) Bewahre deine Skripte dort auf; bearbeite sie und führen sie dort aus Speichere den Output innerhalb des Projekts (wie z.B. das PDF im letzten Beispiel) Du solltest es vermeiden die Maus für Teile deines Workflows zu verwenden, wie z.B. das Laden eines Datensatzes oder das Speichern einer Grafik. Das ist sehr wichtig für die Reproduzierbarkeit und um im Nachhinein feststellen zu können, wie eine numerische Tabelle oder eine PDF-Datei tatsächlich erzeugt wurde (eine Suche auf der lokalen Festplatte nach dem entsprechenden Dateinamen unter den .R-Dateien führt zum entsprechenden Skript). "],
["version-control.html", "Kapitel 3 Git, GitHub, and RStudio", " Kapitel 3 Git, GitHub, and RStudio Wir wissen nicht ob Versionskontrolle bereits ein Thema war mit dem du dich beschäftigt hast. Wenn nicht, solltest du mit ein paar Worten zu Git und GitHub von Jenny Byran (Autorin von STAT 545) starten. Ziel dieses Abschnitts wird es sein, dass du einen GitHub Account anlegst (falls nicht schon vorhanden) Git auf deinem Computer installierst dich bei Git vorstellst alles zusammenfügst und deine Verbindung zu GitHub testest abschließend noch RStudio ins Spiel bringst und RStudio mit Git und GitHub verbindest Bemerkung: Unter 5. wirst du ermutigt deine GitHub Zugangsdaten auf deinem Computer zu speichern. Wir können diesen Schritt nur empfehlen. Das Buch Happy Git and GitHub for the useR enthält noch viele weitere hilfreiche Git/GitHub Informationen. Auf manche kommen wir vielleicht im Laufe des Kurses noch zu sprechen. Andere sind vielleicht zu einem späteren Zeitpunkt interessant, wenn du an anspruchsvolleren Git Projekten arbeitest. "],
["r-markdown.html", "Kapitel 4 R Markdown", " Kapitel 4 R Markdown Ausgewählte Hausaufgaben wirst du als R Markdown Dokument abgeben. R Markdown ist eine sehr zugängliche Methode zur Erstellung von Dokumenten, die Prosa Text mit durch R-Code erzeugten Tabellen und Abbildungen kombinieren. Ein möglicher R Markdown Workflow, der eine Interaktion mit Git, GitHub, und RStudio beinhaltet, wird vorgestellt auf der Seite: Test drive R Markdown "],
["basic-data-care.html", "Kapitel 5 Letzte Vorbereitungen … 5.1 Data Frames sind fantastisch 5.2 Gapminder data 5.3 Die gapminder Daten sind ein “tibble” 5.4 Variablen in einem Data Frame 5.5 Recap", " Kapitel 5 Letzte Vorbereitungen … Jetzt ist es an der Zeit, sich zu vergewissern in welchem Verzeichnis auf deinem Computer du dich befindest. Falls du ein RStudio Projekt nutzt, sollte diese Frage leicht zu beantworten sein. Falls du trotzdem unsicher bist, gib getwd() in der Konsole ein, um das aktuelle Arbeitsverzeichnis zu sehen. Alle nachfolgenden Code Beispiele wollen wir abspeichern in einer .R Datei, die wir im aktuellen Arbeitsverzeichnis abspeichern wollen. Idealerweise geben wir dieser Datei noch einen Namen, wie etwa datenanalyse_teil_1.R, der uns schon viel über den möglichen Inhalt erzählt. Alternativ können wir alle Befehle natürlich auch in eine R Markdown Datei schreiben, siehe Test drive R Markdown. Prinzipiell geht es in den folgenden Abschnitten um Datenmanagement. Es werden aber auch immer wieder ein paar Grafiken zu sehen sein. Dies ist aber kein Problem, da wir ja bereits den Data Visualization Basics Primer besucht haben und so den nötigen Background haben. 5.1 Data Frames sind fantastisch Das Standardformat für Daten ist ein data frame. Die meisten Funktionen zur Inferenz, Modellierung und graphischen Darstellung erwarten, dass ihnen über ein data = Argument ein data frame übergeben wird. Dies gilt für die Basis R schon seit langem. Die als tidyverse bekannte Kollektion von Paketen geht noch einen Schritt weiter und priorisiert ausdrücklich die Verarbeitung von data frames. Tatsächlich priorisiert tidyverse eine besondere Art von data frames, die als “tibble” bezeichnet wird. Data frames - im Gegensatz zu allgemeinen Arrays oder speziell Matrizen in R - können Variablen unterschiedlicher Typen enthalten, wie z. B. Textdaten (Subjekt-ID oder Name), quantitative Daten (Anzahl der weißen Blutkörperchen) und kategoriale Informationen (behandelt vs. unbehandelt). Genauer gesagt können in data frames unterschiedliche Spalten aus unterschiedlichen Datentypen bestehen. Innerhalb einer Spalte müssen aber alle Einträge vom gleichen Typ sein. Daten aus einer Datenanalyse bestehen immer aus mehr als einem Datentyp. Aus diesem Grund können Matrizen oder Arrays nicht zur Datenanalyse verwendet werden, da man sonst mit verschiedenen, unverbundenen Objekten (Matrizen, Arrays) arbeiten müsste und diese nur schwer koordinieren kann. 5.2 Gapminder data Wir werden mit einigen der Daten aus dem [Gapminder-Projekt] (https://www.gapminder.org) arbeiten. Die Daten sind im gapminder Paket enthalten, welches wir über CRAN installieren können: install.packages(&quot;gapminder&quot;) Um die Daten zu verwenden, müssen wir das Paket natürlich auch noch laden library(gapminder) 5.3 Die gapminder Daten sind ein “tibble” Durch das Laden des gapminder Pakets haben wir nun Zugriff auf einen Datenobjekt mit demselben Namen. Schau dir nun mithilfe der Funktion str() die Struktur des Objekts an. str(gapminder) #&gt; tibble [1,704 × 6] (S3: tbl_df/tbl/data.frame) #&gt; $ country : Factor w/ 142 levels &quot;Afghanistan&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ continent: Factor w/ 5 levels &quot;Africa&quot;,&quot;Americas&quot;,..: 3 3 3 3 3 3 3 3 3 3 ... #&gt; $ year : int [1:1704] 1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 ... #&gt; $ lifeExp : num [1:1704] 28.8 30.3 32 34 36.1 ... #&gt; $ pop : int [1:1704] 8425333 9240934 10267083 11537966 13079460 14880372.. #&gt; $ gdpPercap: num [1:1704] 779 821 853 836 740 ... str() liefert eine vernünftige Beschreibung von fast allem, und im schlimmsten Fall kann tatsächlich auch nichts “Schlimmes” passieren. Aus dem Output erkennen wir, dass der Datensatz 1704 Beobachtungen enthält. Auf der anderen Seite hätten wir durch direkten Aufruf von gapminder den Inhalt auch direkt auf den Bildschirm schreiben können. Aber vielleicht hast du schon mal einen größeren Datensatz aufgerufen und zögerst nun etwas, da große Datensätze einfach die Konsole füllen und nur sehr wenig Einblick bieten. Dies ist der erste große Sieg für tibbles. Tidyverse bietet eine spezielle data frame Variante an: ein “tibble”. Dies wird auch verdeutlicht, wenn man sich z.B. die Klasse des gapminder Objekts anschaut class(gapminder) #&gt; [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; Schau, es ist immer noch ein reguläres data frame, aber eben auch ein tibble. Jetzt können wir gapminder einfach auf den Bildschirm anzeigen! Da es sich um ein tibble handelt, wird nur das Wichtigste angezeigt und deine Konsole läuft nicht voll. gapminder #&gt; # A tibble: 1,704 x 6 #&gt; country continent year lifeExp pop gdpPercap #&gt; &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 Afghanistan Asia 1952 28.8 8425333 779. #&gt; 2 Afghanistan Asia 1957 30.3 9240934 821. #&gt; 3 Afghanistan Asia 1962 32.0 10267083 853. #&gt; 4 Afghanistan Asia 1967 34.0 11537966 836. #&gt; 5 Afghanistan Asia 1972 36.1 13079460 740. #&gt; 6 Afghanistan Asia 1977 38.4 14880372 786. #&gt; 7 Afghanistan Asia 1982 39.9 12881816 978. #&gt; 8 Afghanistan Asia 1987 40.8 13867957 852. #&gt; 9 Afghanistan Asia 1992 41.7 16317921 649. #&gt; 10 Afghanistan Asia 1997 41.8 22227415 635. #&gt; # … with 1,694 more rows Wenn du mit einem reinen data frame arbeitest - und dieses Feature magst - kannst du es mit as_tibble() in ein tibble transformieren. library(tidyverse) as_tibble(iris) #&gt; # A tibble: 150 x 5 #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; #&gt; 1 5.1 3.5 1.4 0.2 setosa #&gt; 2 4.9 3 1.4 0.2 setosa #&gt; 3 4.7 3.2 1.3 0.2 setosa #&gt; 4 4.6 3.1 1.5 0.2 setosa #&gt; 5 5 3.6 1.4 0.2 setosa #&gt; 6 5.4 3.9 1.7 0.4 setosa #&gt; 7 4.6 3.4 1.4 0.3 setosa #&gt; 8 5 3.4 1.5 0.2 setosa #&gt; 9 4.4 2.9 1.4 0.2 setosa #&gt; 10 4.9 3.1 1.5 0.1 setosa #&gt; # … with 140 more rows Weitere Möglichkeiten, grundlegende Informationen zu einem data frame abzufragen: names(gapminder) #&gt; [1] &quot;country&quot; &quot;continent&quot; &quot;year&quot; &quot;lifeExp&quot; &quot;pop&quot; &quot;gdpPercap&quot; ncol(gapminder) #&gt; [1] 6 length(gapminder) #&gt; [1] 6 dim(gapminder) #&gt; [1] 1704 6 nrow(gapminder) #&gt; [1] 1704 Ein bisschen deskriptive Statistik zum Inhalt eines data frames erhältst du mit summary(): summary(gapminder) #&gt; country continent year lifeExp #&gt; Afghanistan: 12 Africa :624 Min. :1952 Min. :23.6 #&gt; Albania : 12 Americas:300 1st Qu.:1966 1st Qu.:48.2 #&gt; Algeria : 12 Asia :396 Median :1980 Median :60.7 #&gt; Angola : 12 Europe :360 Mean :1980 Mean :59.5 #&gt; Argentina : 12 Oceania : 24 3rd Qu.:1993 3rd Qu.:70.8 #&gt; Australia : 12 Max. :2007 Max. :82.6 #&gt; (Other) :1632 #&gt; pop gdpPercap #&gt; Min. :6.00e+04 Min. : 241 #&gt; 1st Qu.:2.79e+06 1st Qu.: 1202 #&gt; Median :7.02e+06 Median : 3532 #&gt; Mean :2.96e+07 Mean : 7215 #&gt; 3rd Qu.:1.96e+07 3rd Qu.: 9325 #&gt; Max. :1.32e+09 Max. :113523 #&gt; Bemerkung: summary() ist eine generische Funktion. Für eine gegebene Klasse (des Inputs) bestimmt die generische Funktion die passende Methode. Die Funktion summary() besitzt die folgenden Methoden: methods(summary) #&gt; [1] summary,ANY-method summary,DBIObject-method #&gt; [3] summary.aov summary.aovlist* #&gt; [5] summary.aspell* summary.check_packages_in_dir* #&gt; [7] summary.connection summary.data.frame #&gt; [9] summary.Date summary.default #&gt; [11] summary.Duration* summary.ecdf* #&gt; [13] summary.factor summary.ggplot* #&gt; [15] summary.glm summary.haven_labelled* #&gt; [17] summary.hcl_palettes* summary.infl* #&gt; [19] summary.Interval* summary.lm #&gt; [21] summary.loess* summary.manova #&gt; [23] summary.matrix summary.mlm* #&gt; [25] summary.nls* summary.packageStatus* #&gt; [27] summary.Period* summary.POSIXct #&gt; [29] summary.POSIXlt summary.ppr* #&gt; [31] summary.prcomp* summary.princomp* #&gt; [33] summary.proc_time summary.rlang_error* #&gt; [35] summary.rlang_trace* summary.srcfile #&gt; [37] summary.srcref summary.stepfun #&gt; [39] summary.stl* summary.table #&gt; [41] summary.tukeysmooth* summary.vctrs_sclr* #&gt; [43] summary.vctrs_vctr* summary.warnings #&gt; see &#39;?methods&#39; for accessing help and source code Obwohl wir uns formell noch nicht eingehender mit der Visualisierung beschäftigt haben, ist es wichtig ein paar Grafiken zu erzeugen um einen ersten Eindruck über den Datensatz zu bekommen. Auf der anderen Seite werden die Grafiken aber auch nicht (viel) aufwendiger als im Data Visualisation Basics Primer ggplot(gapminder, mapping = aes(x = year, y = lifeExp)) + geom_point() ggplot(gapminder, mapping = aes(x = gdpPercap, y = lifeExp)) + geom_point() ggplot(gapminder, mapping = aes(x = log(gdpPercap), y = lifeExp)) + geom_point() Grafiken dieser Art werden wir zu einem späteren Zeitpunkt noch genauer behandeln. Dann sprechen wir auch über deren Inhalt. Wir schauen uns nochmal die Ausgabe von str() an, um darüber zu sprechen, was ein data frame genau ist. str(gapminder) #&gt; tibble [1,704 × 6] (S3: tbl_df/tbl/data.frame) #&gt; $ country : Factor w/ 142 levels &quot;Afghanistan&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ continent: Factor w/ 5 levels &quot;Africa&quot;,&quot;Americas&quot;,..: 3 3 3 3 3 3 3 3 3 3 ... #&gt; $ year : int [1:1704] 1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 ... #&gt; $ lifeExp : num [1:1704] 28.8 30.3 32 34 36.1 ... #&gt; $ pop : int [1:1704] 8425333 9240934 10267083 11537966 13079460 14880372.. #&gt; $ gdpPercap: num [1:1704] 779 821 853 836 740 ... Ein data frame ist ein Sonderfall einer Liste, die in R verwendet wird, um so gut wie alles aufzunehmen. Data frames sind ein Spezialfall, bei dem die Länge jedes Listenelements gleich ist. Nehmen wir mal an, dass wir eine Beschreibung der Variablen names(gapminder) #&gt; [1] &quot;country&quot; &quot;continent&quot; &quot;year&quot; &quot;lifeExp&quot; &quot;pop&quot; &quot;gdpPercap&quot; zusammen mit den Daten abspeichern wollen. Dazu könnten wir ein tibble (desc &lt;- tibble(variables = names(gapminder), desc = c(&quot;factor with 142 levels&quot;, &quot;factor with 5 levels&quot;, &quot;ranges from 1952 to 2007 in increments of 5 years&quot;, &quot;life expectancy at birth, in years&quot;, &quot;population&quot;,&quot;GDP per capita (US$, inflation-adjusted)&quot;))) #&gt; # A tibble: 6 x 2 #&gt; variables desc #&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 country factor with 142 levels #&gt; 2 continent factor with 5 levels #&gt; 3 year ranges from 1952 to 2007 in increments of 5 years #&gt; 4 lifeExp life expectancy at birth, in years #&gt; 5 pop population #&gt; 6 gdpPercap GDP per capita (US$, inflation-adjusted) erzeugen, das die Beschreibungen enthält. Dieses data frame hat nun die Dimension 6x2. Trotzdem können wir es mit gapminder kombinieren, wenn wir beide tibbles in einer Liste abspeichern gapminder_desc &lt;- list(gapminder, desc) str(gapminder_desc) #&gt; List of 2 #&gt; $ : tibble [1,704 × 6] (S3: tbl_df/tbl/data.frame) #&gt; ..$ country : Factor w/ 142 levels &quot;Afghanistan&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... #&gt; ..$ continent: Factor w/ 5 levels &quot;Africa&quot;,&quot;Americas&quot;,..: 3 3 3 3 3 3 3 3 3 .. #&gt; ..$ year : int [1:1704] 1952 1957 1962 1967 1972 1977 1982 1987 1992 199.. #&gt; ..$ lifeExp : num [1:1704] 28.8 30.3 32 34 36.1 ... #&gt; ..$ pop : int [1:1704] 8425333 9240934 10267083 11537966 13079460 14880.. #&gt; ..$ gdpPercap: num [1:1704] 779 821 853 836 740 ... #&gt; $ : tibble [6 × 2] (S3: tbl_df/tbl/data.frame) #&gt; ..$ variables: chr [1:6] &quot;country&quot; &quot;continent&quot; &quot;year&quot; &quot;lifeExp&quot; ... #&gt; ..$ desc : chr [1:6] &quot;factor with 142 levels&quot; &quot;factor with 5 levels&quot; &quot;r&quot;.. 5.4 Variablen in einem Data Frame Um eine einzelne Variable aus einem data frame anzusprechen, kann man mit dem Dollarzeichen $ arbeiten. Wir schauen uns dazu die numerische Variable lifeExp an. head(gapminder$lifeExp) #&gt; [1] 28.8 30.3 32.0 34.0 36.1 38.4 summary(gapminder$lifeExp) #&gt; Min. 1st Qu. Median Mean 3rd Qu. Max. #&gt; 23.6 48.2 60.7 59.5 70.8 82.6 Zusätzlich wollen wir die noch die Verteilung von lifeExp visualisieren und plotten dazu ein Histogramm. Da wir dazu ggplot() verwenden, können wir lifeExp wieder direkt aufrufen. ggplot(gapminder, mapping = aes(x = lifeExp)) + geom_histogram() #&gt; `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Alternativ können wir die Einträge eines data frames auch über die eckigen Klammern [] indizieren. summary(gapminder[,&quot;lifeExp&quot;]) #&gt; lifeExp #&gt; Min. :23.6 #&gt; 1st Qu.:48.2 #&gt; Median :60.7 #&gt; Mean :59.5 #&gt; 3rd Qu.:70.8 #&gt; Max. :82.6 Dabei spezifiziert der Eintrag links vom Komma die Zeilen und der Wert rechts davon die Spalten. Dies ist hilfreich, wenn man auf einzelne Werte zugreifen will. Aber beim Aufruf einer kompletten Variable (Spalte) ist die $ Notation sicherlich vorteilhaft. Die Variable year ist eine ganzzahlige Variable, aber da es so wenige unterschiedliche Werte gibt, funktioniert sie auch ein wenig wie eine kategoriale Variable. summary(gapminder$year) #&gt; Min. 1st Qu. Median Mean 3rd Qu. Max. #&gt; 1952 1966 1980 1980 1993 2007 table(gapminder$year) #&gt; #&gt; 1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 2002 2007 #&gt; 142 142 142 142 142 142 142 142 142 142 142 142 Die Variablen country und continent enthalten rein kategorische Informationen, die in R (häufig) als factor gespeichert werden. class(gapminder$continent) #&gt; [1] &quot;factor&quot; summary(gapminder$continent) #&gt; Africa Americas Asia Europe Oceania #&gt; 624 300 396 360 24 levels(gapminder$continent) #&gt; [1] &quot;Africa&quot; &quot;Americas&quot; &quot;Asia&quot; &quot;Europe&quot; &quot;Oceania&quot; nlevels(gapminder$continent) #&gt; [1] 5 Die Levels von continent sind “Afrika”, “America” usw., und das ist es, was einem normalerweise in R angezeigt werden sollte, wenn man eine Faktorvariable aufruft. Im Allgemeinen sind die Levels von Menschen lesbare Zeichenfolgen, wie “male/female” und “control/treated”. Aber vergiss niemals, dass R diese Information in kodierter Form speichert. Schauen dir zum Beispiel das Ergebnis von str(gapminder$continent) an, falls du skeptisch sein solltest. str(gapminder$continent) #&gt; Factor w/ 5 levels &quot;Africa&quot;,&quot;Americas&quot;,..: 3 3 3 3 3 3 3 3 3 3 ... Faktorvariablen haben Vor- und Nachteil. Im weiteren Verlauf zeigen wir sowohl die Vor- wie auch die Nachteile. Generell ist aber durchaus so, dass die Vorteile überwiegen. Als Nächstes erstellen wir mit der Funktion table() eine Häufigkeitstabelle für die Variable count. Dieser Inhalt wird anschließend visualisiert über die Funktion geom_bar(). Die entsprechende Berechnung der Häufigkeitstabelle wird dabei aber sowohl von table() wie auch von geom_bar() (über die statistische Transformation stat_count()) durchgeführt, oder anders gesagt, wir können an geom_bar() den Datensatz (hier gapminder) anstatt von vorab berechneten Werten übergeben. table(gapminder$continent) #&gt; #&gt; Africa Americas Asia Europe Oceania #&gt; 624 300 396 360 24 ggplot(gapminder, aes(x = continent)) + geom_bar() In den folgenden Abbildungen sehen wir, wie Faktoren in Zahlen umgesetzt werden können. Der continent-Faktor lässt sich durch das ggplot2-Paket leicht in “Facetten” oder Farben und eine Legende abbilden. Die Erstellung von Grafiken mit ggplot2 werden wir noch genauer besprechen. Daher kannst du dich also ruhig zurücklehnen und die Plots genießen oder blind kopieren/einfügen. # wir initialisieren ein grafik (ohne inhalt) p &lt;- ggplot(filter(gapminder, continent != &quot;Oceania&quot;), aes(x = gdpPercap, y = lifeExp)) p &lt;- p + scale_x_log10() # auf der x-achse soll eine log skala verwendet werden p + geom_point() # ein scatterplot p + geom_point(aes(color = continent)) # für verschiedene kontinente werden verschiedene farben verwendet p + geom_point(alpha = (1/3), size = 3) + # punkte mit transparenz geom_smooth(lwd = 3, se = FALSE) # geglätter zusammenhang #&gt; `geom_smooth()` using method = &#39;gam&#39; and formula &#39;y ~ s(x, bs = &quot;cs&quot;)&#39; p + geom_point(alpha = (1/3), size = 3) + facet_wrap(~ continent) + # für jeden kontinent wird eine eigener # plot (innerhalb einer grafik) erzeugt geom_smooth(lwd = 1.5, se = FALSE) #&gt; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; 5.5 Recap Benutze data frames!!! Benutze tidyverse!!! Dadurch wird eine spezielle Art von data frames, ein “tibble”, bereitgestellt, die neben anderen Vorteilen ein nettes Standarddruckverhalten aufweist. Im Zweifelsfall kannst du dir immer Inhalte anzeigen lassen über str() oder im Fall eines tibbles, einfach das tibble selbst aufrufen. Sei dir immer über die Anzahl an Zeilen und Spalten deiner data frames bewusst. Sei dir im Klaren welche Art (numerisch, kategorial, …) von Variablen in deinen data frames enthalten sind. Benutze factors!!! Aber mach das bewusst und mit Vorsicht. Führe für jede Variable eine grundlegende statistische und visuelle Überprüfung durch. Ruf Variablen mit ihrem Namen auf, z.B. gapminder$lifeExp, nicht mit der Spaltennummer. Dein Code wird dadurch robuster und lesbarer sein. "],
["dplyr-intro.html", "Kapitel 6 Einführung in dplyr 6.1 Einstieg 6.2 filter(): Indizieren von Zeilen 6.3 Der Pipe-Operator 6.4 Mit select() Variablen auswählen 6.5 Jetzt nochmal ein Vergleich zu R Standardbefehlen 6.6 Pure, predictable, pipeable", " Kapitel 6 Einführung in dplyr 6.1 Einstieg dplyr ist ein Paket zur Datenmanipulation, entwickelt von Hadley Wickham und Romain Francois. In erster Linie will es schnell und ausdrucksstark sein. Es wird als Teil des “Metapakets” tidyverse installiert und gehört als Kernpaket zu den Paketen, die über library(tidyverse) geladen werden. Die Wurzeln von dplyr liegen in einem früheren Paket mit dem Namen plyr, das zum Ziel hat die “split-apply-combine”-Strategie der Datenanalyse (Wickham 2011) umzusetzen. Wo plyr noch einen vielfältigen Satz von Ein- und Ausgaben abdeckt (z.B. Arrays, data frames, Listen), hat dplyr einen klaren Fokus auf data frames oder, im Tidyverse, tibbles. dplyr bietet schnelle Alternativen zu den R Standardfunktionen: subset(), apply(), [sl]apply(), tapply(), aggregate(), split(), do.call(), with(), within(), und mehr. Ferner kann man dplyr nutzen um über Zeilen oder Gruppen von Zeilen zu iterieren, was eine schnelle Alternative zur Nutzung von for Schleifen darstellt. 6.1.1 Wie immer, laden wir zu Beginn tidyverse Der Fokus liegt in diesem Abschnitt auf dplyr. Aber da wir immer wieder auch Funktionen aus anderen “tidyverse-Paketen” nutzen, laden wir stets tidyverse. library(tidyverse) #&gt; ── Attaching packages ─────────────────────────────────────────── tidyverse 1.3.0 ── #&gt; ✓ ggplot2 3.3.2 ✓ purrr 0.3.4 #&gt; ✓ tibble 3.0.3 ✓ dplyr 1.0.2 #&gt; ✓ tidyr 1.1.2 ✓ stringr 1.4.0 #&gt; ✓ readr 1.3.1 ✓ forcats 0.5.0 #&gt; ── Conflicts ────────────────────────────────────────────── tidyverse_conflicts() ── #&gt; x dplyr::filter() masks stats::filter() #&gt; x dplyr::lag() masks stats::lag() Zusätzlich wollen wir auch noch gapminder laden. library(gapminder) 6.2 filter(): Indizieren von Zeilen filter() nimmt logische Ausdrücke und gibt die Zeilen zurück, für die der logische Ausdruck ein TRUE ergibt. filter(gapminder, lifeExp &lt; 29) #&gt; # A tibble: 2 x 6 #&gt; country continent year lifeExp pop gdpPercap #&gt; &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 Afghanistan Asia 1952 28.8 8425333 779. #&gt; 2 Rwanda Africa 1992 23.6 7290203 737. filter(gapminder, country == &quot;Rwanda&quot;, year &gt; 1979) #&gt; # A tibble: 6 x 6 #&gt; country continent year lifeExp pop gdpPercap #&gt; &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 Rwanda Africa 1982 46.2 5507565 882. #&gt; 2 Rwanda Africa 1987 44.0 6349365 848. #&gt; 3 Rwanda Africa 1992 23.6 7290203 737. #&gt; 4 Rwanda Africa 1997 36.1 7212583 590. #&gt; 5 Rwanda Africa 2002 43.4 7852401 786. #&gt; 6 Rwanda Africa 2007 46.2 8860588 863. filter(gapminder, country %in% c(&quot;Rwanda&quot;, &quot;Afghanistan&quot;)) #&gt; # A tibble: 24 x 6 #&gt; country continent year lifeExp pop gdpPercap #&gt; &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 Afghanistan Asia 1952 28.8 8425333 779. #&gt; 2 Afghanistan Asia 1957 30.3 9240934 821. #&gt; 3 Afghanistan Asia 1962 32.0 10267083 853. #&gt; 4 Afghanistan Asia 1967 34.0 11537966 836. #&gt; 5 Afghanistan Asia 1972 36.1 13079460 740. #&gt; 6 Afghanistan Asia 1977 38.4 14880372 786. #&gt; 7 Afghanistan Asia 1982 39.9 12881816 978. #&gt; 8 Afghanistan Asia 1987 40.8 13867957 852. #&gt; 9 Afghanistan Asia 1992 41.7 16317921 649. #&gt; 10 Afghanistan Asia 1997 41.8 22227415 635. #&gt; # … with 14 more rows Zum Vergleich kann man sich einen R Standardbefehl anschauen, der zum gleichen Ergebnis führt: gapminder[gapminder$lifeExp &lt; 29, ] subset(gapminder, country == &quot;Rwanda&quot; &amp; year &gt; 1979) ## subset funktioniert ähnlich wir filter Unter keinen Umständen solltest du allerdings deine Daten so unterteilen, wie hier: auswahl &lt;- gapminder[241:252, ] Warum ist das eine blöde Idee? Es ist nicht selbstdokumentierend. Was ist das Besondere an den Zeilen 241 bis 252? Es ist fehleranfällig. Diese Codezeile wird zu anderen Ergebnissen führen, wenn jemand die Zeilenreihenfolge von gapminder ändert, z.B. die Daten früher im Skript sortiert. filter(gapminder, country == &quot;Canada&quot;) Dieser Aufruf erklärt sich von selbst und ist ziemlich robust. 6.3 Der Pipe-Operator Bevor es weitergeht, wollen wir aber den Pipe-Operator, den das Tidyverse aus dem magrittr-Paket von Stefan Bache importiert, vorstellen. Mithilfe des Pipe-Operators ist man in der Lage Befehle für mehrere Operationen auszuführen, ohne sie ineinander zu verschachteln. Diese neue Syntax führt zu Code, der viel einfacher zu schreiben und zu lesen ist. Und so sieht er aus: %&gt;%. Das entsprechende RStudio Tastenkürzel lautet: Ctrl+Shift+M (Windows), Cmd+Shift+M (Mac). Erstmal ein Beispiel gapminder %&gt;% head() #&gt; # A tibble: 6 x 6 #&gt; country continent year lifeExp pop gdpPercap #&gt; &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 Afghanistan Asia 1952 28.8 8425333 779. #&gt; 2 Afghanistan Asia 1957 30.3 9240934 821. #&gt; 3 Afghanistan Asia 1962 32.0 10267083 853. #&gt; 4 Afghanistan Asia 1967 34.0 11537966 836. #&gt; 5 Afghanistan Asia 1972 36.1 13079460 740. #&gt; 6 Afghanistan Asia 1977 38.4 14880372 786. Du siehst, der Befehl ist äquivalent zu head(gapminder). Der Pipe-Operator nimmt das Objekt auf der linken Seite und leitet es in den Funktionsaufruf auf der rechten Seite weiter - er gibt es buchstäblich als erstes Argument ein. Keine Angst, du kannst immer noch weitere Argumente für die Funktion auf der rechten Seite angeben! Um die ersten 3 Reihen von gapminder zu sehen, könnte man sagen: head(gapminder, 3) oder: gapminder %&gt;% head(3) #&gt; # A tibble: 3 x 6 #&gt; country continent year lifeExp pop gdpPercap #&gt; &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 Afghanistan Asia 1952 28.8 8425333 779. #&gt; 2 Afghanistan Asia 1957 30.3 9240934 821. #&gt; 3 Afghanistan Asia 1962 32.0 10267083 853. Du bist wahrscheinlich noch nicht sehr beeindruckt, aber das sollte sich noch ändern. 6.4 Mit select() Variablen auswählen Nun zurück zu dplyr…. Verwende select(), um aus den Daten verschiedene Variablen (Spalten) auszuwählen. Hier kommt eine typische Verwendung von select(): select(gapminder, year, lifeExp) #&gt; # A tibble: 1,704 x 2 #&gt; year lifeExp #&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 1952 28.8 #&gt; 2 1957 30.3 #&gt; 3 1962 32.0 #&gt; 4 1967 34.0 #&gt; 5 1972 36.1 #&gt; 6 1977 38.4 #&gt; 7 1982 39.9 #&gt; 8 1987 40.8 #&gt; 9 1992 41.7 #&gt; 10 1997 41.8 #&gt; # … with 1,694 more rows Und nun noch kombiniert mit head() über den Pipe-Operator: gapminder %&gt;% select(year, lifeExp) %&gt;% head(4) #&gt; # A tibble: 4 x 2 #&gt; year lifeExp #&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 1952 28.8 #&gt; 2 1957 30.3 #&gt; 3 1962 32.0 #&gt; 4 1967 34.0 In Worten: “Nimm gapminder, wähle die Variablen year und lifeExp und zeige dann die ersten 4 Zeilen an.” 6.5 Jetzt nochmal ein Vergleich zu R Standardbefehlen Hier sind die Daten für Kambodscha, aber nur bestimmte Variablen: gapminder %&gt;% filter(country == &quot;Cambodia&quot;) %&gt;% select(year, lifeExp) #&gt; # A tibble: 12 x 2 #&gt; year lifeExp #&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 1952 39.4 #&gt; 2 1957 41.4 #&gt; 3 1962 43.4 #&gt; 4 1967 45.4 #&gt; 5 1972 40.3 #&gt; 6 1977 31.2 #&gt; 7 1982 51.0 #&gt; 8 1987 53.9 #&gt; 9 1992 55.8 #&gt; 10 1997 56.5 #&gt; 11 2002 56.8 #&gt; 12 2007 59.7 und so würde ein typischer R Standardbefehl aussehen: gapminder[gapminder$country == &quot;Cambodia&quot;, c(&quot;year&quot;, &quot;lifeExp&quot;)] #&gt; # A tibble: 12 x 2 #&gt; year lifeExp #&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 1952 39.4 #&gt; 2 1957 41.4 #&gt; 3 1962 43.4 #&gt; 4 1967 45.4 #&gt; 5 1972 40.3 #&gt; 6 1977 31.2 #&gt; 7 1982 51.0 #&gt; 8 1987 53.9 #&gt; 9 1992 55.8 #&gt; 10 1997 56.5 #&gt; 11 2002 56.8 #&gt; 12 2007 59.7 der zum gleichen Ergebnis führt. Wir würden sagen, dass der dplyr Befehl deutlich leichter zu lesen ist. 6.6 Pure, predictable, pipeable Bisher haben wir nur etwas an der Oberfläche von dplyr gekratzt, trotzdem möchten wir auf ein Schlüsselprinzipien hinweisen, die du vielleicht langsam zu schätzen lernen wirst. Die Verben (Hauptfunktionen) von dplyr, wie z.B. filter() und select(), sind pure functions. Dazu schreibt Hadley Wickham Functions chapter in seinem Advanced R Buch (2015): The functions that are the easiest to understand and reason about are pure functions: functions that always map the same input to the same output and have no other impact on the workspace. In other words, pure functions have no side effects: they don’t affect the state of the world in any way apart from the value they return. Tatsächlich sind diese Verben ein Spezialfall reiner Funktionen: sie nehmen als Input und Output denselben Objekttyp an, i.d.R. ein data frame. Die Daten sind für all diese Funktionen aus stets das erste Inputargument. Die dplyr Einführung geht weiter im Kapitel Mehr zu dplyr. "],
["dplyr-single.html", "Kapitel 7 Mehr zu dplyr 7.1 Wo stehen wir? 7.2 Falls noch nicht geschehen: lade dplyr und gapminder 7.3 Mitmutate() neue Variablen erstellen 7.4 Mit arrange() die Zeilenreihenfolge ändern 7.5 Mit rename() “schöne” Namen vergeben 7.6 group_by() macht das R Leben einfacher 7.7 Gruppierte Veränderungen 7.8 Großes Finale 7.9 Weiteres Material", " Kapitel 7 Mehr zu dplyr 7.1 Wo stehen wir? In Kapitel 6, Einführung in dplyr, haben wir bereits zwei sehr wichtige Verben sowie einen Operator vorgestellt und verwendet: filter() zum Auswählen spezieller Zeilen eines Datensatzes select() zum Auswählen spezieller Variablen eines Datensatzes den Pipe-Operator %&gt;%, der das Objekt auf der linken Seite überführt als erstes Funktionsargument der Funktion auf der rechten Seite Wir haben auch die Rolle von dplyr innerhalb des tidyverse besprochen: dplyr ist ein Kernpaket der tidyverse Kollektion von Paketen. Da wir die anderen oft beiläufig benutzen, werden wir stets dplyr und die anderen über library(tidyverse) laden. 7.2 Falls noch nicht geschehen: lade dplyr und gapminder Wir starten wieder mit dem Laden von dplyr (über tidyverse) library(tidyverse) #&gt; ── Attaching packages ─────────────────────────────────────────── tidyverse 1.3.0 ── #&gt; ✓ ggplot2 3.3.2 ✓ purrr 0.3.4 #&gt; ✓ tibble 3.0.3 ✓ dplyr 1.0.2 #&gt; ✓ tidyr 1.1.2 ✓ stringr 1.4.0 #&gt; ✓ readr 1.3.1 ✓ forcats 0.5.0 #&gt; ── Conflicts ────────────────────────────────────────────── tidyverse_conflicts() ── #&gt; x dplyr::filter() masks stats::filter() #&gt; x dplyr::lag() masks stats::lag() und gapminder library(gapminder) 7.3 Mitmutate() neue Variablen erstellen Wir starten mit dem Anlegen einer Kopie von gapminder, die wir dann nach unseren Vorstellungen verändern (wäre aber auch nichts passiert, wenn wir alles mit gapminder durchführen würden). my_gap &lt;- gapminder Unser Ziel ist es, dass GDP pro Land anzugeben. Das sollte machbar sein, da schließlich das Pro-Kopf-GDP wie auch die Bevölkerungszahl im Datensatz enthalten sind. Multiplizieren beider Variablen liefert uns das gewünschte Ergebnis. mutate() ist eine Funktion, die neue Variablen definiert und in ein tibble einfügt. Du kannst auf bestehende Variablen einfach über ihren Namen zugreifen. my_gap %&gt;% mutate(gdp = pop * gdpPercap) #&gt; # A tibble: 1,704 x 7 #&gt; country continent year lifeExp pop gdpPercap gdp #&gt; &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Afghanistan Asia 1952 28.8 8425333 779. 6567086330. #&gt; 2 Afghanistan Asia 1957 30.3 9240934 821. 7585448670. #&gt; 3 Afghanistan Asia 1962 32.0 10267083 853. 8758855797. #&gt; 4 Afghanistan Asia 1967 34.0 11537966 836. 9648014150. #&gt; 5 Afghanistan Asia 1972 36.1 13079460 740. 9678553274. #&gt; 6 Afghanistan Asia 1977 38.4 14880372 786. 11697659231. #&gt; 7 Afghanistan Asia 1982 39.9 12881816 978. 12598563401. #&gt; 8 Afghanistan Asia 1987 40.8 13867957 852. 11820990309. #&gt; 9 Afghanistan Asia 1992 41.7 16317921 649. 10595901589. #&gt; 10 Afghanistan Asia 1997 41.8 22227415 635. 14121995875. #&gt; # … with 1,694 more rows Hmmmm … diese GDP-Zahlen sind ziemlich groß und abstrakt. In dem Zusammenhang, bedenke den Ratschlag von Randall Munroe: One thing that bothers me is large numbers presented without context… “If I added a zero to this number, would the sentence containing it mean something different to me?” If the answer is “no”, maybe the number has no business being in the sentence in the first place. Vielleicht wäre es für die Betrachter unseres tibbles sinnvoller, beim Pro-Kopf-GDP zu bleiben. Aber was wäre, wenn wir das Pro-Kopf-GDP angeben würde, in Relation zu irgendeinem Vergleichsland. Wir könnten alles in Bezug auf die entsprechenden Daten aus Deutschland angeben. Dazu müssen wir eine neue Variable erstellen, die gdpPercap geteilt durch die deutschen gdpPercap Werte ist, wobei wir darauf achten müssen, dass wir immer zwei Zahlen teilen, die sich auf dasselbe Jahr beziehen. Wie können wir das schaffen: Deutschland Beobachtungen in einem Objekt ger_gap speichern Erstellen Sie eine neue temporäre Variable tmp in my_gap: Die gdpPercap-Variable aus tmp aufrufen. Mit rep() die gdpPerap Wert aus tmp einmal pro Land im my_gap reproduzieren, damit ein Vektor, der die gleiche Anzahl an Beobachtungen wie my_gap hat. Dividieren der gdpPercap Werte durch die deutschen Zahlen. Löschen der temporäre Variable tmp in my_gap. ger_gap &lt;- my_gap %&gt;% filter(country == &quot;Germany&quot;) my_gap &lt;- my_gap %&gt;% mutate(tmp = rep(ger_gap$gdpPercap, nlevels(country)), gdpPercapRel = gdpPercap / tmp, tmp = NULL) Beachte, dass mutate() neue Variablen sequentiell erstellt, so dass du auf frühere Variablen (wie tmp) verweisen kannst um spätere Variablen (wie gdpPercapRel) zu definieren. Nachdem eine Variable nicht mehr benötigt wird, kannst du sie einfach auf NULL setzen. Hat das funktioniert? Einfach mal die Werte von gdpPercapRel für Deutschland anschauen. Sollten besser alle 1 sein! my_gap %&gt;% filter(country == &quot;Germany&quot;) %&gt;% select(country, year, gdpPercapRel) #&gt; # A tibble: 12 x 3 #&gt; country year gdpPercapRel #&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 Germany 1952 1 #&gt; 2 Germany 1957 1 #&gt; 3 Germany 1962 1 #&gt; 4 Germany 1967 1 #&gt; 5 Germany 1972 1 #&gt; 6 Germany 1977 1 #&gt; 7 Germany 1982 1 #&gt; 8 Germany 1987 1 #&gt; 9 Germany 1992 1 #&gt; 10 Germany 1997 1 #&gt; 11 Germany 2002 1 #&gt; 12 Germany 2007 1 Ich nehme an Deutschland ist ein Land mit einem “hohen GDP” pro Kopf, daher gehe ich davon aus, dass die Verteilung von gdpPercapRel unter 1 liegt, möglicherweise sogar weit darunter. Aber besser mal nachschauen ob dem so ist: summary(my_gap$gdpPercapRel) #&gt; Min. 1st Qu. Median Mean 3rd Qu. Max. #&gt; 0.01 0.07 0.19 0.37 0.51 15.17 Die Zahlen des relativen Pro-Kopf-GDP liegen im deutlich unter 1. Wir sehen, dass die meisten Länder, die in diesem Datensatz erfasst werden, über den gesamten Zeitraum im Vergleich zu Deutschland ein wesentlich niedrigeres Pro-Kopf-GDP aufweisen. Tipp: Vertraue niemandem. Einschließlich (besonders?) dir selbst. Versuche immer, einen Weg zu finden, um zu überprüfen, ob du das gemacht hast, was du tun wolltest. Sei nicht schockiert, wenn du manchmal feststellen musst, dass dem nicht so ist. 7.4 Mit arrange() die Zeilenreihenfolge ändern arrange() ordnet die Zeilen in einem data frame neu an. Stellen dir vor, du möchtest die Daten nach Jahr und Land und nicht nach Land und Jahr geordnet haben. my_gap %&gt;% arrange(year, country) #&gt; # A tibble: 1,704 x 7 #&gt; country continent year lifeExp pop gdpPercap gdpPercapRel #&gt; &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Afghanistan Asia 1952 28.8 8425333 779. 0.109 #&gt; 2 Albania Europe 1952 55.2 1282697 1601. 0.224 #&gt; 3 Algeria Africa 1952 43.1 9279525 2449. 0.343 #&gt; 4 Angola Africa 1952 30.0 4232095 3521. 0.493 #&gt; 5 Argentina Americas 1952 62.5 17876956 5911. 0.827 #&gt; 6 Australia Oceania 1952 69.1 8691212 10040. 1.41 #&gt; 7 Austria Europe 1952 66.8 6927772 6137. 0.859 #&gt; 8 Bahrain Asia 1952 50.9 120447 9867. 1.38 #&gt; 9 Bangladesh Asia 1952 37.5 46886859 684. 0.0958 #&gt; 10 Belgium Europe 1952 68 8730405 8343. 1.17 #&gt; # … with 1,694 more rows Oder vielleicht willst du nur die Daten aus 2007 sehen, angeordnet entsprechend der Lebenserwartung. my_gap %&gt;% filter(year == 2007) %&gt;% arrange(lifeExp) #&gt; # A tibble: 142 x 7 #&gt; country continent year lifeExp pop gdpPercap gdpPercapRel #&gt; &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Swaziland Africa 2007 39.6 1.13e6 4513. 0.140 #&gt; 2 Mozambique Africa 2007 42.1 2.00e7 824. 0.0256 #&gt; 3 Zambia Africa 2007 42.4 1.17e7 1271. 0.0395 #&gt; 4 Sierra Leone Africa 2007 42.6 6.14e6 863. 0.0268 #&gt; 5 Lesotho Africa 2007 42.6 2.01e6 1569. 0.0488 #&gt; 6 Angola Africa 2007 42.7 1.24e7 4797. 0.149 #&gt; 7 Zimbabwe Africa 2007 43.5 1.23e7 470. 0.0146 #&gt; 8 Afghanistan Asia 2007 43.8 3.19e7 975. 0.0303 #&gt; 9 Central African Repub… Africa 2007 44.7 4.37e6 706. 0.0219 #&gt; 10 Liberia Africa 2007 45.7 3.19e6 415. 0.0129 #&gt; # … with 132 more rows Das war nicht was du wolltest. Du wolltest nach absteigender Lebenserwartung sortieren. Dann verwende desc(). my_gap %&gt;% filter(year == 2007) %&gt;% arrange(desc(lifeExp)) #&gt; # A tibble: 142 x 7 #&gt; country continent year lifeExp pop gdpPercap gdpPercapRel #&gt; &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Japan Asia 2007 82.6 127467972 31656. 0.984 #&gt; 2 Hong Kong, China Asia 2007 82.2 6980412 39725. 1.23 #&gt; 3 Iceland Europe 2007 81.8 301931 36181. 1.12 #&gt; 4 Switzerland Europe 2007 81.7 7554661 37506. 1.17 #&gt; 5 Australia Oceania 2007 81.2 20434176 34435. 1.07 #&gt; 6 Spain Europe 2007 80.9 40448191 28821. 0.896 #&gt; 7 Sweden Europe 2007 80.9 9031088 33860. 1.05 #&gt; 8 Israel Asia 2007 80.7 6426679 25523. 0.793 #&gt; 9 France Europe 2007 80.7 61083916 30470. 0.947 #&gt; 10 Canada Americas 2007 80.7 33390141 36319. 1.13 #&gt; # … with 132 more rows Ein Tipp am Ende: verlasse dich bei deinen Analysen NIEMALS darauf, dass Zeilen oder Variablen in einer bestimmten Reihenfolge stehen. Aber manchmal will man Tabellen anderen präsentieren und dabei macht es durchaus Sinn die Zeilenreihenfolge je nach Fragestellung anzupassen. 7.5 Mit rename() “schöne” Namen vergeben Ein paar der Namen in gapminder sind nicht besonders hübsch, wie z.B. lifeExp. life expectancy wären ja schließlich zwei Worte und daher finde ich (persönliche Meinung) es schöner dies auch im Variablennamen zu sehen my_gap %&gt;% rename(life_exp = lifeExp, gdp_percap = gdpPercap, gdp_percap_rel = gdpPercapRel) #&gt; # A tibble: 1,704 x 7 #&gt; country continent year life_exp pop gdp_percap gdp_percap_rel #&gt; &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Afghanistan Asia 1952 28.8 8425333 779. 0.109 #&gt; 2 Afghanistan Asia 1957 30.3 9240934 821. 0.0806 #&gt; 3 Afghanistan Asia 1962 32.0 10267083 853. 0.0661 #&gt; 4 Afghanistan Asia 1967 34.0 11537966 836. 0.0567 #&gt; 5 Afghanistan Asia 1972 36.1 13079460 740. 0.0411 #&gt; 6 Afghanistan Asia 1977 38.4 14880372 786. 0.0383 #&gt; 7 Afghanistan Asia 1982 39.9 12881816 978. 0.0444 #&gt; 8 Afghanistan Asia 1987 40.8 13867957 852. 0.0346 #&gt; 9 Afghanistan Asia 1992 41.7 16317921 649. 0.0245 #&gt; 10 Afghanistan Asia 1997 41.8 22227415 635. 0.0229 #&gt; # … with 1,694 more rows Die Änderungen haben wir jetzt aber nicht abgespeichert (auch wenn sie schön waren), da wir den nachfolgenden Code auch weiterhin ausführen könnten ohne die Änderung der Variablennamen durchgeführt zu haben. Bemerkung: Mit select() könnten wir bei der Auswahl von Variablen auch deren Namen ändern my_gap %&gt;% filter(country == &quot;Burundi&quot;, year &gt; 1996) %&gt;% select(yr = year, lifeExp, gdpPercap) %&gt;% select(gdpPercap, everything()) #&gt; # A tibble: 3 x 3 #&gt; gdpPercap yr lifeExp #&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 463. 1997 45.3 #&gt; 2 446. 2002 47.4 #&gt; 3 430. 2007 49.6 everything() wählt alle übrigen (außer gdpPercap) Variablen. Da gdpPercap an erster Stelle gewählt wurde, wird die Variable auch zur ersten Spalte. 7.6 group_by() macht das R Leben einfacher Nehmen wir mal an, dass uns die Antwort auf die Frage “In welchem Land ist die Lebenserwartung innerhalb von 5 Jahren am stärksten gesunken?” interessiert. dplyr bietet uns mächtige Hilfsmittel um diese Frage zu beantworten: group_by() fügt dem Datensatz eine zusätzliche Struktur hinzu – Gruppierungsinformationen – die die Grundlage für Berechnungen innerhalb der Gruppen bilden. summarise() nimmt einen Datensatz mit \\(n\\)-Beobachtungen, berechnet die angeforderten Zusammenfassungen und gibt einen Datensatz mit einer Beobachtung (falls nur eine Zusammenfassung angefordert wurde) zurück. Window Funktionen nehmen einen Datensatz mit \\(n\\)-Beobachtungen und geben einen Datensatz mit \\(n\\)-Beobachtungen zurück. mutate() und summarise() berücksichtigen Gruppen. Kombiniert mit den Verben, die du bereits kennst, kannst du mit diesen neuen Werkzeugen eine extrem vielfältige Reihe von Problemen relativ einfach lösen. 7.6.1 Die Dinge aufzählen Beginnen wir mit dem einfachen Zählen. Wie viele Beobachtungen haben wir pro Kontinent? my_gap %&gt;% group_by(continent) %&gt;% summarise(n = n()) #&gt; `summarise()` ungrouping output (override with `.groups` argument) #&gt; # A tibble: 5 x 2 #&gt; continent n #&gt; &lt;fct&gt; &lt;int&gt; #&gt; 1 Africa 624 #&gt; 2 Americas 300 #&gt; 3 Asia 396 #&gt; 4 Europe 360 #&gt; 5 Oceania 24 Lassen uns hier kurz innehalten und über das tidyverse nachdenken. Du könntest dir mit table() die gleichen absoluten Häufigkeiten berechnen. table(gapminder$continent) #&gt; #&gt; Africa Americas Asia Europe Oceania #&gt; 624 300 396 360 24 str(table(gapminder$continent)) #&gt; &#39;table&#39; int [1:5(1d)] 624 300 396 360 24 #&gt; - attr(*, &quot;dimnames&quot;)=List of 1 #&gt; ..$ : chr [1:5] &quot;Africa&quot; &quot;Americas&quot; &quot;Asia&quot; &quot;Europe&quot; ... Aber das Objekt der Klasse table, das zurückgegeben wird, macht die nachfolgenden Berechnungen einfach etwas kniffliger, als es dir lieb ist. Zum Beispiel ist es zu schade, dass die Namen der Kontinente nur als Namen und nicht als richtige Faktor zusammen mit den berechneten Werten zurückgegeben werden. Dies ist ein Beispiel dafür, wie das tidyverse Übergänge glättet, bei denen die Ausgabe von Schritt i die Eingabe von Schritt i + 1 werden soll. Die tally() Funktion ist eine Komfortfunktion, die weiß, wie man Zeilen zählt und dabei Gruppen berücksichtigt. my_gap %&gt;% group_by(continent) %&gt;% tally() #&gt; # A tibble: 5 x 2 #&gt; continent n #&gt; &lt;fct&gt; &lt;int&gt; #&gt; 1 Africa 624 #&gt; 2 Americas 300 #&gt; 3 Asia 396 #&gt; 4 Europe 360 #&gt; 5 Oceania 24 Die Funktion count() bietet noch mehr Komfort. Sie kann sowohl gruppieren als auch zählen. my_gap %&gt;% count(continent) #&gt; # A tibble: 5 x 2 #&gt; continent n #&gt; &lt;fct&gt; &lt;int&gt; #&gt; 1 Africa 624 #&gt; 2 Americas 300 #&gt; 3 Asia 396 #&gt; 4 Europe 360 #&gt; 5 Oceania 24 Was wäre, wenn uns nicht nur die Anzahl an Beobachtungen pro Kontinent interessiert, sondern auch die Anzahl an unterschiedlichen Ländern pro Kontinent. Da wir mehrere Zusammenfassungen innerhalb von summarise() berechnen. Verwenden Sie die Funktion n_distinct(), um die Anzahl der einzelnen Länder innerhalb jedes Kontinents zu zählen. my_gap %&gt;% group_by(continent) %&gt;% summarise(n = n(), n_countries = n_distinct(country)) #&gt; `summarise()` ungrouping output (override with `.groups` argument) #&gt; # A tibble: 5 x 3 #&gt; continent n n_countries #&gt; &lt;fct&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 Africa 624 52 #&gt; 2 Americas 300 25 #&gt; 3 Asia 396 33 #&gt; 4 Europe 360 30 #&gt; 5 Oceania 24 2 7.6.2 Deskriptive Statistiken mit summarise() In Kombination mit summarise() können wir eine Vielzahl an verschiedenen Funktionen verwenden. Einige davon berechnen klassische deskriptive Statistiken: In allen betrachteten Fällen seien \\(x_1,\\dots,x_n\\) numerische Beobachtungen. mean() berechnet das arithmetische Mittel der Beo\\[\\overline x_n = \\frac{1}{n} \\sum_{i=1}^n x_i\\,.\\] median() berechnet den Median \\[x_{0.5} = \\begin{cases} x_{\\left(\\frac{n+1}{2}\\right)}, &amp; n\\ \\text{ungerade},\\\\ \\frac{1}{2}\\left(x_{\\left(\\frac{n}{2}\\right)} + x_{\\left(\\frac{n}{2}+1\\right)}\\right), &amp; n\\ \\text{gerade} \\end{cases}\\,.\\] var() berechnet die empirische Varianz \\[s_n^2 = \\frac{1}{n-1} \\sum_{i=1}^n (x_i - \\overline x_n)^2\\,.\\] sd() berechnet die empirische Standardabweichung \\[s_n = \\sqrt{s_n^2}\\,.\\] IQR() berechnet den Interquartilsabstand \\[IQR = x_{0.75} - x_{0.25}\\,,\\] wobei \\(x_{0.25}\\) und \\(x_{0.75}\\) das empirische 0.25 bzw. 0.75 Quantil bezeichnen. min() berechnet das Minimum \\[x_{(1)} = \\min(x_1,\\dots,x_n)\\,.\\] und max() berechnet demnach das Maximum \\[x_{(n)} = \\max(x_1,\\dots,x_n)\\,.\\] Auch wenn dies statistisch gesehen unklug sein mag, lass uns die durchschnittliche Lebenserwartung pro Kontinenten berechnen. my_gap %&gt;% group_by(continent) %&gt;% summarise(avg_lifeExp = mean(lifeExp)) #&gt; `summarise()` ungrouping output (override with `.groups` argument) #&gt; # A tibble: 5 x 2 #&gt; continent avg_lifeExp #&gt; &lt;fct&gt; &lt;dbl&gt; #&gt; 1 Africa 48.9 #&gt; 2 Americas 64.7 #&gt; 3 Asia 60.1 #&gt; 4 Europe 71.9 #&gt; 5 Oceania 74.3 summarise_at() wendet die gleiche(n) Zusammenfassungs-Funktion(en) auf mehrere Variablen an. Lass uns die durchschnittliche Lebenserwartung sowie den Median und das Pro-Kopf-GDP nach Kontinenten pro Jahr berechnen… aber nur für 1952 und 2007. my_gap %&gt;% filter(year %in% c(1952, 2007)) %&gt;% group_by(continent, year) %&gt;% summarise_at(vars(lifeExp, gdpPercap), list(mean, median)) #&gt; # A tibble: 10 x 6 #&gt; # Groups: continent [5] #&gt; continent year lifeExp_fn1 gdpPercap_fn1 lifeExp_fn2 gdpPercap_fn2 #&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Africa 1952 39.1 1253. 38.8 987. #&gt; 2 Africa 2007 54.8 3089. 52.9 1452. #&gt; 3 Americas 1952 53.3 4079. 54.7 3048. #&gt; 4 Americas 2007 73.6 11003. 72.9 8948. #&gt; 5 Asia 1952 46.3 5195. 44.9 1207. #&gt; 6 Asia 2007 70.7 12473. 72.4 4471. #&gt; 7 Europe 1952 64.4 5661. 65.9 5142. #&gt; 8 Europe 2007 77.6 25054. 78.6 28054. #&gt; 9 Oceania 1952 69.3 10298. 69.3 10298. #&gt; 10 Oceania 2007 80.7 29810. 80.7 29810. Konzentrieren wir uns nur auf Asien. Wie hoch ist die minimale und maximale Lebenserwartung pro Jahr? my_gap %&gt;% filter(continent == &quot;Asia&quot;) %&gt;% group_by(year) %&gt;% summarise(min_lifeExp = min(lifeExp), max_lifeExp = max(lifeExp)) #&gt; `summarise()` ungrouping output (override with `.groups` argument) #&gt; # A tibble: 12 x 3 #&gt; year min_lifeExp max_lifeExp #&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1952 28.8 65.4 #&gt; 2 1957 30.3 67.8 #&gt; 3 1962 32.0 69.4 #&gt; 4 1967 34.0 71.4 #&gt; 5 1972 36.1 73.4 #&gt; 6 1977 31.2 75.4 #&gt; 7 1982 39.9 77.1 #&gt; 8 1987 40.8 78.7 #&gt; 9 1992 41.7 79.4 #&gt; 10 1997 41.8 80.7 #&gt; 11 2002 42.1 82 #&gt; 12 2007 43.8 82.6 Natürlich wäre es viel interessanter zu sehen, welches Land diese extremen Beobachtungen beigetragen hat. Kommt das Minimum (Maximum) immer aus dem gleichen Land? Wir gehen dem in Kürze mit Window Funktionen nach. 7.7 Gruppierte Veränderungen Manchmal möchte man die \\(n\\)-Zeilen für jede Gruppe nicht zu einer Zeile zusammenfassen. Stattdessen möchte man die Gruppen behalten, aber innerhalb dieser Gruppen rechnen. 7.7.1 Berechnungen innerhalb der Gruppen Machen wir eine neue Variable, die die gewonnenen (verlorenen) Lebenserwartungsjahre im Vergleich zu 1952 für jedes einzelne Land angibt. Wir gruppieren nach Ländern und verwenden mutate(), um eine neue Variable zu erstellen. Die Funktion first() extrahiert dabei den ersten Wert aus einem Vektor. Beachte, dass first() mit dem Vektor der Lebenserwartungen in jeder Ländergruppe arbeitet. my_gap %&gt;% group_by(country) %&gt;% select(country, year, lifeExp) %&gt;% mutate(lifeExp_gain = lifeExp - first(lifeExp)) %&gt;% filter(year &lt; 1963) #&gt; # A tibble: 426 x 4 #&gt; # Groups: country [142] #&gt; country year lifeExp lifeExp_gain #&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Afghanistan 1952 28.8 0 #&gt; 2 Afghanistan 1957 30.3 1.53 #&gt; 3 Afghanistan 1962 32.0 3.20 #&gt; 4 Albania 1952 55.2 0 #&gt; 5 Albania 1957 59.3 4.05 #&gt; 6 Albania 1962 64.8 9.59 #&gt; 7 Algeria 1952 43.1 0 #&gt; 8 Algeria 1957 45.7 2.61 #&gt; 9 Algeria 1962 48.3 5.23 #&gt; 10 Angola 1952 30.0 0 #&gt; # … with 416 more rows Innerhalb eines Landes nehmen wir die Differenz zwischen der Lebenserwartung im Jahr \\(i\\) und der Lebenserwartung im Jahr 1952. Daher sehen wir für 1952 immer Nullen und für die meisten Länder eine Folge von positiven und steigenden Zahlen. 7.7.2 Window Funktionen Window Funktionen nehmen \\(n\\)-Eingaben entgegen und geben \\(n\\)-Ausgaben zurück. Außerdem hängt die Ausgabe von allen Werten ab. So ist rank() eine Window Funktion, aber log() ist es nicht. Betrachten wir noch einmal die schlechtesten und besten Lebenserwartungen in Asien im Laufe der Zeit, behalten aber Informationen darüber bei, welches Land diese Extremwerte beisteuert. my_gap %&gt;% filter(continent == &quot;Asia&quot;) %&gt;% select(year, country, lifeExp) %&gt;% group_by(year) %&gt;% filter(min_rank(desc(lifeExp)) &lt; 2 | min_rank(lifeExp) &lt; 2) %&gt;% arrange(year) %&gt;% print(n = Inf) # erzwingt eine Ausgabe aller Zeilen #&gt; # A tibble: 24 x 3 #&gt; # Groups: year [12] #&gt; year country lifeExp #&gt; &lt;int&gt; &lt;fct&gt; &lt;dbl&gt; #&gt; 1 1952 Afghanistan 28.8 #&gt; 2 1952 Israel 65.4 #&gt; 3 1957 Afghanistan 30.3 #&gt; 4 1957 Israel 67.8 #&gt; 5 1962 Afghanistan 32.0 #&gt; 6 1962 Israel 69.4 #&gt; 7 1967 Afghanistan 34.0 #&gt; 8 1967 Japan 71.4 #&gt; 9 1972 Afghanistan 36.1 #&gt; 10 1972 Japan 73.4 #&gt; 11 1977 Cambodia 31.2 #&gt; 12 1977 Japan 75.4 #&gt; 13 1982 Afghanistan 39.9 #&gt; 14 1982 Japan 77.1 #&gt; 15 1987 Afghanistan 40.8 #&gt; 16 1987 Japan 78.7 #&gt; 17 1992 Afghanistan 41.7 #&gt; 18 1992 Japan 79.4 #&gt; 19 1997 Afghanistan 41.8 #&gt; 20 1997 Japan 80.7 #&gt; 21 2002 Afghanistan 42.1 #&gt; 22 2002 Japan 82 #&gt; 23 2007 Afghanistan 43.8 #&gt; 24 2007 Japan 82.6 Wir sehen, dass (min = Afghanistan, max = Japan) das häufigste Ergebnis ist, aber Kambodscha und Israel tauchen jeweils mindestens einmal als min bzw. max auf. Aber wäre es nicht schön, eine Zeile pro Jahr zu haben? Wie hat das eigentlich funktioniert? Dazu schauen wir uns die Beobachtungen aus Asien mal direkt an. (asia &lt;- my_gap %&gt;% filter(continent == &quot;Asia&quot;) %&gt;% select(year, country, lifeExp) %&gt;% group_by(year)) #&gt; # A tibble: 396 x 3 #&gt; # Groups: year [12] #&gt; year country lifeExp #&gt; &lt;int&gt; &lt;fct&gt; &lt;dbl&gt; #&gt; 1 1952 Afghanistan 28.8 #&gt; 2 1957 Afghanistan 30.3 #&gt; 3 1962 Afghanistan 32.0 #&gt; 4 1967 Afghanistan 34.0 #&gt; 5 1972 Afghanistan 36.1 #&gt; 6 1977 Afghanistan 38.4 #&gt; 7 1982 Afghanistan 39.9 #&gt; 8 1987 Afghanistan 40.8 #&gt; 9 1992 Afghanistan 41.7 #&gt; 10 1997 Afghanistan 41.8 #&gt; # … with 386 more rows Jetzt wenden wir eine Window Funktion an – min_rank(). Da asia nach Jahren gruppiert ist, operiert min_rank() innerhalb von Mini-Datensätzen, jeder für ein bestimmtes Jahr. Auf die Variable LifeExp angewandt, liefert min_rank() den Rang der beobachteten Lebenserwartung jedes Landes. Bemerkung: Der min-Teil gibt nur an, wie die Verbindungen unterbrochen werden. rank(c(1,3,3,5), ties.method = &quot;min&quot;) #&gt; [1] 1 2 2 4 Neben dem Minimum gibt es aber auch noch eine Reihe weiterer Alternative, wie z.B. den Durchschnitt rank(c(1,3,3,5)) #&gt; [1] 1.0 2.5 2.5 4.0 Dann schauen wir uns die Ränge der Lebenserwartung innerhalb eines Jahres mal explizit an für ein paar Länder, sowohl in der (Standard-) aufsteigenden als auch in der absteigenden Reihenfolge. Da wir im zweiten Schritt nach einigen Ländern filtern, erzeugen wir im ersten Schritt mit mutate() die gewünschten Werte und weisen sie neuen Variablen zu. asia %&gt;% mutate(le_rank = min_rank(lifeExp), le_desc_rank = min_rank(desc(lifeExp))) %&gt;% filter(country %in% c(&quot;Afghanistan&quot;, &quot;Japan&quot;, &quot;Thailand&quot;), year &gt; 1995) #&gt; # A tibble: 9 x 5 #&gt; # Groups: year [3] #&gt; year country lifeExp le_rank le_desc_rank #&gt; &lt;int&gt; &lt;fct&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 1997 Afghanistan 41.8 1 33 #&gt; 2 2002 Afghanistan 42.1 1 33 #&gt; 3 2007 Afghanistan 43.8 1 33 #&gt; 4 1997 Japan 80.7 33 1 #&gt; 5 2002 Japan 82 33 1 #&gt; 6 2007 Japan 82.6 33 1 #&gt; 7 1997 Thailand 67.5 12 22 #&gt; 8 2002 Thailand 68.6 12 22 #&gt; 9 2007 Thailand 70.6 12 22 Afghanistan neigt dazu, 1 in der le_rank-Variablen zu haben, Japan neigt dazu, 1 in der le_desc_rank-Variablen zu haben und andere Länder, wie Thailand, zeigen deutlich weniger extreme Ränge. Damit sollte der ursprüngliche filter() Befehl filter(min_rank(desc(lifeExp)) &lt; 2 | min_rank(lifeExp) &lt; 2) auch klar sein. Diese beiden Sätze von Rängen werden on-the-fly, innerhalb der Jahresgruppe, gebildet, und filter() behält Zeilen mit Rang weniger als 2. Da wir dies für aufsteigende und absteigende Ränge tun, erhalten wir sowohl den minimalen als auch den maximalen Rang. Wenn wir nur das Minimum ODER das Maximum gewollt hätten, hätte auch ein alternativer Ansatz mit top_n() funktioniert. my_gap %&gt;% filter(continent == &quot;Asia&quot;) %&gt;% select(year, country, lifeExp) %&gt;% arrange(year) %&gt;% group_by(year) %&gt;% #top_n(1, wt = lifeExp) ## für das Minimum top_n(1, wt = desc(lifeExp)) ## bzw. das Maximum #&gt; # A tibble: 12 x 3 #&gt; # Groups: year [12] #&gt; year country lifeExp #&gt; &lt;int&gt; &lt;fct&gt; &lt;dbl&gt; #&gt; 1 1952 Afghanistan 28.8 #&gt; 2 1957 Afghanistan 30.3 #&gt; 3 1962 Afghanistan 32.0 #&gt; 4 1967 Afghanistan 34.0 #&gt; 5 1972 Afghanistan 36.1 #&gt; 6 1977 Cambodia 31.2 #&gt; 7 1982 Afghanistan 39.9 #&gt; 8 1987 Afghanistan 40.8 #&gt; 9 1992 Afghanistan 41.7 #&gt; 10 1997 Afghanistan 41.8 #&gt; 11 2002 Afghanistan 42.1 #&gt; 12 2007 Afghanistan 43.8 7.8 Großes Finale Beantworten wir also die Frage: Welches Land hat den stärksten Rückgang der Lebenserwartung um 5 Jahre erlebt? Die Beobachtungsfrequenz im Datensatz ist fünf Jahre, d.h. wir haben Daten für 1952, 1957 usw. Dies bedeutet also, dass die Veränderungen der Lebenserwartung zwischen benachbarten Zeitpunkten betrachtet werden müssen. Zum jetzigen Zeitpunkt ist das einfach zu einfach, also lasst es uns, wenn wir schon dabei sind, nach Kontinenten machen. my_gap %&gt;% select(country, year, continent, lifeExp) %&gt;% group_by(continent, country) %&gt;% # für jedes Land werden die Unterschiede berechnet mutate(le_delta = lifeExp - lag(lifeExp)) %&gt;% ## für jedes Land wird nur der kleinste Wert behalten summarise(worst_le_delta = min(le_delta, na.rm = TRUE)) %&gt;% ## nun wird noch pro Kontinent, die Zeile mit dem kleinsten Wert ausgegeben top_n(-1, wt = worst_le_delta) %&gt;% arrange(worst_le_delta) #&gt; `summarise()` regrouping output by &#39;continent&#39; (override with `.groups` argument) #&gt; # A tibble: 5 x 3 #&gt; # Groups: continent [5] #&gt; continent country worst_le_delta #&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; #&gt; 1 Africa Rwanda -20.4 #&gt; 2 Asia Cambodia -9.10 #&gt; 3 Americas El Salvador -1.51 #&gt; 4 Europe Montenegro -1.46 #&gt; 5 Oceania Australia 0.170 Denk ruhig eine Weile über das Ergebnis nach. Meistens sieht man hier in trockenen Statistiken über die durchschnittliche Lebenserwartung, wie Völkermord aussieht. Unterteile den Code, beginnend von oben, in Stücke und überprüfe die einzelnen Zwischenergebnisse. So wurde der Code auch geschrieben/entwickelt, mit vielen Fehlern und Verfeinerungen auf dem Weg. 7.9 Weiteres Material An dieser Stelle sei noch auf die dplyr Webseite und das Kapitel Data transformation in R for Data Science (Wickham and Grolemund 2016) verwiesen. "],
["import-export.html", "Kapitel 8 Daten I/O 8.1 Überblick 8.2 Load the tidyverse 8.3 Einlesen der Gapminder Daten 8.4 Einlesen von Daten in Tabellenform 8.5 Daten exportieren 8.6 Daten über eine API 8.7 Weiteres Material", " Kapitel 8 Daten I/O 8.1 Überblick Wir haben die Gapminder-Daten als tibble aus dem gapminder Paket geladen. Wir haben im letzten Abschnitt weder Daten noch abgeleitete Ergebnisse explizit in eine Datei geschrieben. Im wirklichen Leben wirst du aber ständig Daten, die in Tabellenform vorliegen, in R ein- und auslesen. Manchmal muss das sogar für Daten geschehen, die nicht in Tabellenform vorliegen. Wie macht man das? Worauf muss man aufpassen? 8.1.1 Daten Import Für den Daten Import gibt es im Allgemeinen zwei Möglichkeiten: “Überrasche mich!” Diese Haltung musst du einnehmen, wenn du zum ersten Mal einen Datensatz erhältst. Du musst einfach froh, wenn du die Daten ohne Fehler importieren konntest. Dann schaust du dir das Ergebnis an, entdeckst Fehler in den Daten und/oder beim Import. Du behebst sie und beginnst nochmal von vorne. “Ein weiterer Tag im Paradies.” Das ist die Einstellung, wenn du einen aufgeräumten Datensatz einliest, den du vorher in einem oder mehreren Reinigungsskripten wahnsinnig aufgeräumt haben. Es sollte keine Überraschungen geben. Im zweiten Fall, und im weiteren Verlauf des ersten Falles, lernst du tatsächlich eine Menge darüber, wie die Daten sind/sein sollten. Ein wichtiger Import-Ratschlag: Verwende die Argumente der Importfunktion, um so weit wie möglich und so schnell wie möglich zu kommen. Anfängercode hat oft eine Menge unnötigen nachträglichen Aufwand. Lese die Hilfe zu den Importfunktionen und nutzen die Argumente maximal aus, um den Import zu steuern. 8.1.2 Daten Export Es wird viele Gelegenheiten geben, bei denen du Daten aus R exportieren willst. Zwei wichtige Beispiele: einen gesäuberten Datensatz der bereit ist analysiert zu werden, den du heldenhaft aus recht unordentlichen Daten erstellt hast ein numerisches Ergebnis aus einer Datenaggregation oder Modellierung oder einer statistischen Schlussfolgerung Erster Tipp: Der Output von heute ist der Input von morgen. Denke an all die Schmerzen zurück, die du selbst beim Import von fremden Daten erlitten hast, und fügen dir nicht selbst solche Schmerzen zu! Zweiter Tipp: Sei nicht zu clever. Eine einfache Textdatei, die von einem Menschen in einem Texteditor lesbar ist, sollte dein Standard sein, bis du einen guten Grund dafür hast, dass dies nicht funktionieren wird. Das Lesen und Schreiben in exotische Formate wird das erste sein, was in Zukunft oder auf einem anderen Computer kaputtgehen wird. Es schafft auch Barrieren für jeden, der ein anderes Toolkit hat als du. Strebe nach Zukunfts- und Idiotensicherheit. Wie passt das zu unserer Betonung der dynamischen Berichterstattung über R Markdown? Es gibt für alles eine Zeit und einen Ort. Es gibt Projekte und Dokumente, bei denen du dich intensiv mit knitr und rmarkdown beschäftigen kannst/willst/musst. Aber es gibt viele gute Gründe, warum (Teile von) einer Analyse nicht (nur) in einen dynamischen Bericht eingebettet werden sollten. Vielleicht bist du gerade dabei Daten zu bereinigen, um einen Datensatz für eine nachfolgende Analyse zu erzeugen. Vielleicht leistet du einen kleinen, aber entscheidenden Beitrag zu einem gigantischen Multi-Autoren-Papier. Etc. Denke auch daran, dass es natürlich auch noch andere Werkzeuge und Arbeitsabläufe gibt, um etwas reproduzierbar zu machen: z.B. make. 8.2 Load the tidyverse Das Hauptpaket, das wir verwenden werden, ist readr, welches Alternativen zu den Standardfunktionen read.table() und write.table() bietet. Trotzdem laden wir standardmäßig einfach wieder tidyverse. library(tidyverse) #&gt; ── Attaching packages ─────────────────────────────────────────── tidyverse 1.3.0 ── #&gt; ✓ ggplot2 3.3.2 ✓ purrr 0.3.4 #&gt; ✓ tibble 3.0.3 ✓ dplyr 1.0.2 #&gt; ✓ tidyr 1.1.2 ✓ stringr 1.4.0 #&gt; ✓ readr 1.3.1 ✓ forcats 0.5.0 #&gt; ── Conflicts ────────────────────────────────────────────── tidyverse_conflicts() ── #&gt; x dplyr::filter() masks stats::filter() #&gt; x dplyr::lag() masks stats::lag() 8.3 Einlesen der Gapminder Daten Die Gapminder Daten könnten wir natürlich wie zuvor über das Laden des gapminder Pakets verfügbar machen. Da es in diesem Abschnitt aber um das Einlesen von Daten geht, versuchen wir die Daten als .tsv Datei (tab-separated values - so sind sie im Paket gespeichert) einzulesen. Aber dies bedeutet natürlich, dass wir die entsprechende .tsv Datei erst mal finden müssen. Dabei hilft uns glücklicherweise das fs Paket. library(fs) (gap_tsv &lt;- path_package(&quot;gapminder&quot;, &quot;extdata&quot;, &quot;gapminder.tsv&quot;)) #&gt; /Users/hgstp/Library/R/4.0/library/gapminder/extdata/gapminder.tsv Nachdem wir jetzt den Speicherort der Datei kennen, können wir versuchen sie einzulesen. 8.4 Einlesen von Daten in Tabellenform Die Haupt-Funktion zum Einlesen von Daten in readr ist read_delim(). Hier verwenden wir eine Variante, read_tsv(), für tabulatorgetrennte Daten: gapminder &lt;- read_tsv(gap_tsv) #&gt; Parsed with column specification: #&gt; cols( #&gt; country = col_character(), #&gt; continent = col_character(), #&gt; year = col_double(), #&gt; lifeExp = col_double(), #&gt; pop = col_double(), #&gt; gdpPercap = col_double() #&gt; ) glimpse(gapminder) #&gt; Rows: 1,704 #&gt; Columns: 6 #&gt; $ country &lt;chr&gt; &quot;Afghanistan&quot;, &quot;Afghanistan&quot;, &quot;Afghanistan&quot;, &quot;Afghanistan&quot;,… #&gt; $ continent &lt;chr&gt; &quot;Asia&quot;, &quot;Asia&quot;, &quot;Asia&quot;, &quot;Asia&quot;, &quot;Asia&quot;, &quot;Asia&quot;, &quot;Asia&quot;, &quot;As… #&gt; $ year &lt;dbl&gt; 1952, 1957, 1962, 1967, 1972, 1977, 1982, 1987, 1992, 1997,… #&gt; $ lifeExp &lt;dbl&gt; 28.8, 30.3, 32.0, 34.0, 36.1, 38.4, 39.9, 40.8, 41.7, 41.8,… #&gt; $ pop &lt;dbl&gt; 8425333, 9240934, 10267083, 11537966, 13079460, 14880372, 1… #&gt; $ gdpPercap &lt;dbl&gt; 779, 821, 853, 836, 740, 786, 978, 852, 649, 635, 727, 975,… Über den Tabulator Spalten in einer Datentabelle zu trennen, ist natürlich nur eine Variante neben weiteren Alternativen wie Komma, Strichpunkt, Leerzeichen, … Für Komma getrennte Daten würde man beispielsweise read_csv() verwenden. Für volle Flexibilität bei der Angabe des Trennzeichens kannst du aber jederzeit direkt read_delim() verwenden. Der auffälligste Unterschied zwischen den readr-Funktionen und der Standardfunktion read.table()ist, dass readr standardmäßig Characters NICHT in Faktoren umwandelt. Im Großen und Ganzen ist dies ein besseres Standardverhalten, obwohl es natürlich immer wieder vorkommen wird, dass du einzelne Variablen nach dem Einlesen in einen Faktoren umwandeln wirst. Aber lass dich davon nicht täuschen - im Allgemeinen wirst du durch die Verwendung von readr nach dem Einlesen weniger Anpassungen machen müssen im Vergleich zum Standardvorgehen. Fazit: Benutze readr::read_delim() und “Freunde”. Die Gapminder-Daten sind zu sauber und einfach, um die großartigen Funktionen von readr zur Geltung zu bringen. Ein Blick in Introduction to readr zeigt aber noch viele weitere Anpassungsmöglichkeiten der readr Funktionen. 8.5 Daten exportieren Bevor wir etwas exportieren können, müssen (das ist natürlich so nicht richtig - niemand zwingt uns dazu) etwas berechnen, das es wert ist, exportiert zu werden. Lass uns eine Zusammenfassung der maximalen Lebenserwartung auf Länderebene erstellen. gap_life_exp &lt;- gapminder %&gt;% group_by(country, continent) %&gt;% summarise(life_exp = max(lifeExp)) %&gt;% ungroup() #&gt; `summarise()` regrouping output by &#39;country&#39; (override with `.groups` argument) gap_life_exp #&gt; # A tibble: 142 x 3 #&gt; country continent life_exp #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 Afghanistan Asia 43.8 #&gt; 2 Albania Europe 76.4 #&gt; 3 Algeria Africa 72.3 #&gt; 4 Angola Africa 42.7 #&gt; 5 Argentina Americas 75.3 #&gt; 6 Australia Oceania 81.2 #&gt; 7 Austria Europe 79.8 #&gt; 8 Bahrain Asia 75.6 #&gt; 9 Bangladesh Asia 64.1 #&gt; 10 Belgium Europe 79.4 #&gt; # … with 132 more rows Das gap_life_exp data frame ist ein Beispiel für ein Zwischenergebnis, das wir für die Zukunft und für nachgelagerte Analysen oder Visualisierungen speichern wollen. Die Haupt-Exportfunktion in readr ist write_delim(). Für verschiedene Dateiformate gibt es auch hier wieder verschiedene Komfortfunktionen. Lass uns write_csv() benutzen, um eine kommagetrennte Datei zu erhalten. write_csv(gap_life_exp, &quot;gap_life_exp.csv&quot;) Schauen wir uns die ersten paar Zeilen von gap_life_exp.csv an. Dazu kannst du entweder die Datei öffnen oder, im Terminal, head darauf anwenden. country,continent,life_exp Afghanistan,Asia,43.828 Albania,Europe,76.423 Algeria,Africa,72.301 Angola,Africa,42.731 Argentina,Americas,75.32 Das sieht recht ordentlich aus, obwohl es keine sichtbare Ausrichtung oder Trennung in Spalten gibt. Hätten wir die Basisfunktion read.csv() benutzt, würden wir Zeilennamen und viele Anführungszeichen sehen, es sei denn, wir hätten diese Features explizit abgeschaltet. Das schönere Standardverhalten ist daher der Hauptgrund, warum wir readr::write_csv() gegenüber write.csv() bevorzugen. Es ist nicht wirklich fair, sich über den Mangel an sichtbarer Ausrichtung zu beklagen, schließlich erzeugen wir Dateien, die der Computer lesen soll. Falls du wirklich in der Datei “herumstöbern” willst, benutze View() in RStudio oder öffnen die Datei mit einem Spreadsheet Programm (!). Aber erliege NIE der Versuchung, dort Datenmanipulationen vorzunehmen … gehe zurück zu R und schreibe dort die Befehle, die du die nächsten 15 Mal ausführen kannst, wenn du diesen Datensatz (oder Datensätze derselben Form) importieren/bereinigen/aggregieren/exportieren willst. 8.6 Daten über eine API Interessante Datensätze sind der Treibstoff für ein gutes Data Science Projekt. APIs (Application Programming Interface) sind eine weitere sehr nützliche Methode, um auf interessante Daten zuzugreifen. Anstatt einen Datensatz herunterladen zu müssen, ermöglichen APIs Daten direkt von bestimmten Websites über eine Schnittstelle anzufordern. Viele große Webseiten wie Twitter und Facebook ermöglichen über APIs den Zugriff auf Teile ihrer Daten. Wir werden die Grundlagen des Zugriffs auf eine API besprechen. Dazu benötigst du aber keine Vorwissen bzgl. APIs. 8.6.1 Einführung API ist ein allgemeiner Begriff für den Ort, an dem ein Computerprogramm mit einem anderen oder mit sich selbst interagiert. Wir sprechen über Web-APIs, bei denen zwei verschiedene Computer - ein Client und ein Server - miteinander interagieren, um Daten anzufordern bzw. bereitzustellen. APIs bieten eine ausgefeilte Möglichkeit Daten von einer Website anzufordern. Wenn eine Website wie Twitter eine API einrichtet, richten sie im Wesentlichen einen Computer ein, der auf Datenanfragen wartet. Sobald dieser Computer eine Datenanforderung empfängt, verarbeitet er die Daten selbst und sendet sie an den Computer, der sie angefordert hat. Unsere Aufgabe als Anforderer der Daten wird es sein R Code zu schreiben, der die Anforderung erstellt und dem Computer, auf dem die API läuft, mitteilt, was wir benötigen. Dieser Computer liest dann unseren Code, verarbeitet die Anfrage und gibt schön formatierte Daten zurück, die mithilfe existierender R Pakete verarbeitet werden können.. 8.6.2 Erstellen von API-Anforderungen in R Um mit APIs in R zu arbeiten, müssen wir ein paar neue Pakete laden (und vorher natürlich installieren). Konkret werden wir mit den Paketen httr und jsonlite arbeiten. Sie spielen bei der Einbindung der APIs unterschiedliche Rollen, aber beide sind unverzichtbar. Vermutlich hast du die beiden Pakete bisher nicht installiert. Daher ist der erste Schritt die beiden Pakete zu installieren install.packages(c(&quot;httr&quot;, &quot;jsonlite&quot;)) und anschließend zu laden library(httr) library(jsonlite) #&gt; #&gt; Attaching package: &#39;jsonlite&#39; #&gt; The following object is masked from &#39;package:purrr&#39;: #&gt; #&gt; flatten 8.6.3 Unsere erste API-Anfrage stellen Der erste Schritt, um Daten von einer API zu erhalten, ist die eigentliche Anfrage in R. Diese Anfrage wird an den Computer-Server geschickt, der über die API verfügt, und wenn alles reibungslos verläuft, wird er eine Antwort zurücksenden. Es gibt verschiedene Arten von Anfragen, die man an einen API-Server stellen kann. Diese Arten von Anfragen entsprechen verschiedenen Aktionen, die der Server ausführen soll. Für unsere Zwecke fragen wir lediglich nach Daten, was einer GET-Anfrage entspricht. Andere Arten von Anfragen sind z.B. POST und PUT, aber diese sind für uns nicht von Interesse und daher brauchen wir uns darum nicht zu kümmern. Um eine GET-Anfrage zu erstellen, müssen wir die GET() Funktion aus dem httr Paket verwenden. Die GET() Funktion benötigt als Input eine URL, die die Adresse des Servers angibt, an den die Anforderung gesendet werden soll. Als Beispiel werden wir mit der Open Notify API arbeiten, die Daten zu verschiedenen NASA-Projekten enthält. Mithilfe der Open Notify API können wir uns über den Standort der Internationalen Raumstation informieren und erfahren, wie viele Personen sich derzeit im Weltraum aufhalten. Wir beginnen damit, dass wir unsere Anfrage mit der GET() Funktion stellen und die URL der API angeben: jdata &lt;- GET(&quot;http://api.open-notify.org/astros.json&quot;) Die Ausgabe der Funktion GET() ist eine Liste, die alle Informationen enthält, die vom API-Server zurückgegeben werden. 8.6.4 GET() Ausgabe Schauen wir uns einmal an, wie die Variable jdata in der R-Konsole aussieht: jdata #&gt; Response [http://api.open-notify.org/astros.json] #&gt; Date: 2020-12-02 22:00 #&gt; Status: 200 #&gt; Content-Type: application/json #&gt; Size: 356 B Als erstes fällt auf, dass die URL enthalten ist, an die die GET-Anfrage gesendet wurde. Außerdem sehen wir das Datum und die Uhrzeit, zu der die Anfrage gestellt wurde, sowie die Größe der Antwort. Die Information Content-Type gibt uns eine Vorstellung davon, welche Form die Daten haben. Diese spezielle Antwort besagt, dass die Daten ein JSON-Format annehmen, womit auch klar ist warum wir das Paket jsonlite ebenfalls geladen haben. Der Status verdient eine besondere Aufmerksamkeit. Status bezieht sich auf den Erfolg oder Misserfolg der API-Anfrage, und er wird in Form einer Zahl angegeben. Die zurückgegebene Nummer gibt Auskunft darüber, ob die Anfrage erfolgreich war oder nicht, und kann auch einige Gründe für einen möglichen Misserfolg nennen. Die Zahl 200 ist das, was wir sehen wollen. Sie entspricht einem erfolgreichen Antrag, und das ist es, was wir hier haben. Eine Übersicht über weitere Status Codes findet man z.B. auf dieser [Webseite](https://www.restapitutorial.com/httpstatuscodes.html. 8.6.5 Handling JSON Data JSON steht für JavaScript Object Notation. Während JavaScript eine weitere Programmiersprache ist, liegt unser Schwerpunkt bei JSON auf seiner Struktur. JSON ist nützlich, weil es von einem Computer leicht lesbar ist, und aus diesem Grund ist es zur primären Art und Weise geworden, wie Daten über APIs transportiert werden. Die meisten APIs senden ihre Antworten im JSON-Format. JSON ist als eine Reihe von Schlüssel-Werte-Paaren formatiert, wobei ein bestimmtes Wort (“Schlüssel”) mit einem bestimmten Wert assoziiert ist. Ein Beispiel für diese Schlüssel-Wert-Struktur ist unten dargestellt: { “name”: “Jane Doe”, “number_of_skills”: 2 } In ihrem aktuellen Zustand sind die Daten in der Variablen jdata nicht verwendbar. Die Daten sind als Unicode-Rohdaten in jdata enthalten, und müssen in das JSON-Format konvertiert werden. Dazu müssen wir zunächst den rohen Unicode in Character Daten konvertieren, die dem oben gezeigten JSON-Format ähneln. Die Funktion rawToChar() führt genau diese Aufgabe aus: rawToChar(jdata$content) #&gt; [1] &quot;{\\&quot;message\\&quot;: \\&quot;success\\&quot;, \\&quot;number\\&quot;: 7, \\&quot;people\\&quot;: [{\\&quot;craft\\&quot;: \\&quot;ISS\\&quot;, \\&quot;name\\&quot;: \\&quot;Sergey Ryzhikov\\&quot;}, {\\&quot;craft\\&quot;: \\&quot;ISS\\&quot;, \\&quot;name\\&quot;: \\&quot;Kate Rubins\\&quot;}, {\\&quot;craft\\&quot;: \\&quot;ISS\\&quot;, \\&quot;name\\&quot;: \\&quot;Sergey Kud-Sverchkov\\&quot;}, {\\&quot;craft\\&quot;: \\&quot;ISS\\&quot;, \\&quot;name\\&quot;: \\&quot;Mike Hopkins\\&quot;}, {\\&quot;craft\\&quot;: \\&quot;ISS\\&quot;, \\&quot;name\\&quot;: \\&quot;Victor Glover\\&quot;}, {\\&quot;craft\\&quot;: \\&quot;ISS\\&quot;, \\&quot;name\\&quot;: \\&quot;Shannon Walker\\&quot;}, {\\&quot;craft\\&quot;: \\&quot;ISS\\&quot;, \\&quot;name\\&quot;: \\&quot;Soichi Noguchi\\&quot;}]}&quot; Die resultierende Zeichenfolge sieht zwar recht unordentlich aus, aber es liegt wirklich die JSON-Struktur vor. Ausgehend von diesem Character Vektor können wir nun mit fromJSON() aus dem jsonlite alles in ein Listenformat transformieren. Die fromJSON() Funktion benötigt einen Character Vektor, der die JSON-Struktur enthält, die wir aus der Ausgabe von rawToChar() erhalten haben. Wenn wir also diese beiden Funktionen aneinanderreihen, erhalten wir die gewünschten Daten in einem Format, das wir in R leichter bearbeiten können. data &lt;- fromJSON(rawToChar(jdata$content)) glimpse(data) #&gt; List of 3 #&gt; $ message: chr &quot;success&quot; #&gt; $ number : int 7 #&gt; $ people :&#39;data.frame&#39;:\t7 obs. of 2 variables: #&gt; ..$ craft: chr [1:7] &quot;ISS&quot; &quot;ISS&quot; &quot;ISS&quot; &quot;ISS&quot; ... #&gt; ..$ name : chr [1:7] &quot;Sergey Ryzhikov&quot; &quot;Kate Rubins&quot; &quot;Sergey Kud-Sverchkov&quot;&quot;.. Die Liste data hat drei Elemente. Uns interessiert in erster Linie das Data Frame people. data$people #&gt; craft name #&gt; 1 ISS Sergey Ryzhikov #&gt; 2 ISS Kate Rubins #&gt; 3 ISS Sergey Kud-Sverchkov #&gt; 4 ISS Mike Hopkins #&gt; 5 ISS Victor Glover #&gt; 6 ISS Shannon Walker #&gt; 7 ISS Soichi Noguchi Also, da haben wir unsere Antwort: Zum Zeitpunkt des letzten Updates Wed Dec 2 23:00:59 2020 von R4ews befanden sich 7 Personen im Weltraum. Aber wenn du alles selbst ausprobierst, könnten es auch schon wieder andere Namen und eine andere Anzahl sein. Das ist einer der Vorteile von APIs - im Gegensatz zu herunterladbaren Datensätzen werden sie im Allgemeinen in Echtzeit oder nahezu in Echtzeit aktualisiert, so dass sie eine großartige Möglichkeit darstellen, Zugang zu sehr aktuellen Daten zu erhalten. In diesem Beispiel haben wir einen sehr unkomplizierten API-Workflow durchlaufen. Die meisten APIs erfordern, dass Sie demselben allgemeinen Muster folgen, aber dabei können sie durchaus komplexer sein. In unserem Beispiel war es ausreichen nur die URL anzugeben. Aber einige APIs verlangen durchaus mehr Informationen vom Benutzer. Im letzten Teil dieser Einführung gehen wir darauf ein, wie du der API mit deiner Anfrage zusätzliche Informationen zur Verfügung stellen kannst. 8.6.6 APIs und Abfrageparameter Was wäre, wenn wir wissen wollten, wann die ISS einen bestimmten Ort auf der Erde überfliegen würde? Die ISS Pass Times API von Open Notify verlangt von uns, dass wir zusätzliche Parameter angeben, bevor sie die gewünschten Daten zurückgeben kann. Wir müssen den Längen- und Breitengrad des Ortes angeben, nach dem wir im Rahmen unserer GET() Anfrage fragen. Sobald ein Längen- und Breitengrad angegeben ist, werden sie als Abfrageparameter mit der ursprünglichen URL kombiniert. Lass uns die API verwenden, um herauszufinden, wann die ISS Garching (auf 48.24896 Breiten- und 11.65101 Längengrad) passieren wird: jdata &lt;- GET(&quot;http://api.open-notify.org/iss-pass.json&quot;, query = list(lat = 48.24896, lon = 11.65101)) Man muss in der Dokumentation für die API, mit man arbeiten will, nachsehen, ob es erforderliche Abfrageparameter gibt. Für die überwiegende Mehrheit der APIs, auf die du möglicherweise zugreifen möchtest, gibt es eine Dokumentation, die du lesen kannst (und lesen solltest), um ein klares Verständnis dafür zu erhalten, welche Parameter deine Anfrage erfordert. Wie auch immer, jetzt, da wir unsere Anfrage einschließlich der Standortparameter gestellt haben, können wir die Antwort mit den gleichen Funktionen überprüfen, die wir zuvor verwendet haben. Lass uns die Daten aus der Antwort extrahieren: data &lt;- fromJSON(rawToChar(jdata$content)) data$response #&gt; duration risetime #&gt; 1 529 1606995479 #&gt; 2 650 1607001192 #&gt; 3 651 1607007003 #&gt; 4 651 1607012831 #&gt; 5 647 1607018643 Diese API gibt uns Zeiten in Form von Unixzeit zurück. Unixzeit ist die Zeitspanne, die seit dem 1. Januar 1970 vergangen ist. Mithilfe der Funktion as_datetime() aus dem lubridate Paket können wir die Unixzeit aber leicht umrechnen lubridate::as_datetime(data$response$risetime) #&gt; [1] &quot;2020-12-03 11:37:59 UTC&quot; &quot;2020-12-03 13:13:12 UTC&quot; #&gt; [3] &quot;2020-12-03 14:50:03 UTC&quot; &quot;2020-12-03 16:27:11 UTC&quot; #&gt; [5] &quot;2020-12-03 18:04:03 UTC&quot; Wir haben hier wirklich nur die Basics in Bezug auf APIs eingeführt. Aber hoffentlich hat dir diese Einführung trotzdem das Vertrauen gegeben, sich mit einigen komplexeren und leistungsfähigeren APIs auseinanderzusetzen, und trägt dadurch dazu bei, eine ganz neue Welt von Daten zu erschließen, die du erforschen kannst! 8.7 Weiteres Material Hier sein noch auf das Kapitel Data import im Buch R for Data Science von Hadley Wickham und Garrett Grolemund (2016) verwiesen für weitere Information zum Daten Import. "],
["literatur.html", "Literatur", " Literatur "]
]
