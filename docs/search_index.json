[
["index.html", "R4ews MA009 Willkommen zur R Ergänzung zur Einführung in die Wahrscheinlichkeitstheorie und Statistik Beteiligte Personen Kolophon Lizenz", " R4ews MA009 Stephan Haug Willkommen zur R Ergänzung zur Einführung in die Wahrscheinlichkeitstheorie und Statistik Im Rahmen dieser Ergänzung lernen wir Daten untersuchen, aufbereiten, visualisieren und analysieren, Wir wollen all das reproduzierbar, wiederverwendbar und gemeinsam nutzbar machen, und vor allem wollen wir alles mit R machen. Auf dieser Website geht es um alles, was bei der Datenanalyse auftaucht außer um statistische Modellierung und Schlussfolgerungen. Dieser Teil der statistischen Analyse erfolgt in der Vorlesung Einführung in die Wahrscheinlichkeitstheorie und Statistik. Das Design von R4ews wurde durch die Notwendigkeit motiviert, mehr Ausgewogenheit in der angewandten statistischen Ausbildung zu schaffen. Datenanalysten verbringen viel Zeit mit der Projekt-Organisation, der Datenbereinigung und -aufbereitung sowie der Kommunikation. Diese Tätigkeiten können einen tiefgreifenden Einfluss auf die Qualität und Glaubwürdigkeit einer Analyse haben. Dennoch werden diese Fähigkeiten selten vermittelt, obwohl sie so wichtig und notwendig sind. R4ews zielt darauf ab, diese Lücke zu schließen. Das Material wird kontinuierlich über das Semester hinweg ergänzt/erweitert/verbessert. Letzte Änderung: date() #&gt; [1] &quot;Thu Nov 19 09:35:59 2020&quot; Beteiligte Personen Kolophon Dieses Buch wurde in bookdown innerhalb von RStudio geschrieben. Teile des Buches basieren auf stat545.com. Alle Änderungen wurden gemäß der Creative Commons Attribution-ShareAlike 4.0 International License durchgeführt. Wir bedanken uns bei den Autor*innen von stat545 für das großartige Material. Die aktuelle Version dieses Buchs wurde mit #&gt; Finding R package dependencies ... Done! #&gt; setting value #&gt; version R version 4.0.2 (2020-06-22) #&gt; os macOS 10.16 #&gt; system x86_64, darwin17.0 #&gt; ui X11 #&gt; language (EN) #&gt; collate en_US.UTF-8 #&gt; ctype en_US.UTF-8 #&gt; tz Europe/Berlin #&gt; date 2020-11-19 erstellt Lizenz Diese Arbeit ist lizenziert unter Creative Commons Attribution-ShareAlike 4.0 International License. "],
["install.html", "Kapitel 1 Installieren von R und RStudio 1.1 R und RStudio 1.2 Funktioniert? Ausprobieren 1.3 Add-on packages 1.4 RStudio Primers 1.5 Aufgabe", " Kapitel 1 Installieren von R und RStudio 1.1 R und RStudio Installieren Sie R, eine freie Softwareumgebung für statistische Berechnungen und Grafiken von CRAN, dem Comprehensive R Archive Network. Wir empfehle Ihnen dringend, eine vorkompilierte Binärdistribution für Ihr Betriebssystem zu installieren - benutzen Sie die Links oben auf der CRAN Seite! Installieren Sie die IDE von RStudio (steht für integrated development environment), eine leistungsfähige Benutzeroberfläche für R. Holen Sie sich die Open-Source-Edition von RStudio Desktop. Es ist vorteilhaft die Preview version zu installieren. In der Regel ist sie bereits sehr stabil und man hat so Zugriff auf die neusten Features. Natürlich gibt es auch offizielle Veröffentlichungen here. RStudio wird mit einem Text Editor geliefert, so dass es nicht unmittelbar erforderlich ist, einen separaten, eigenständigen Editor zu installieren. RStudio kann eine Schnittstelle zu Git(Hub) bilden. Sie müssen jedoch alle Git(Hub)-Installationen selbst vornehmen. Wir kommen später auf diesen Punkt zurück. Wenn Sie eine bereits vorhandene R und/oder RStudio Installation haben, empfehlen wir Ihnen dringend, beide neu zu installieren und so aktuell wie möglich zu halten. Wenn Sie R aktualisieren, müssen Sie alle Pakete, die Sie installiert haben, aktualisieren. Der unten stehende Befehl sollte Ihnen den Anfang machen, obwohl Sie möglicherweise weitere Argumente angeben müssen, wenn Sie z.B. eine nicht standardmäßige Bibliothek für Ihre Pakete verwendet haben. update.packages(ask = FALSE, checkBuilt = TRUE) Bemerkung: hier wird nur nach Updates auf CRAN gesucht. Wenn Sie also ein Paket verwenden, das z.B. nur auf GitHub lebt, müssen Sie manuell aktualisieren, z.B. über devtools::install_github(). 1.2 Funktioniert? Ausprobieren Starten Sie RStudio auf Ihrem Computer. Sie sollten ein Fenster ähnlich zu diesem Screenshot, erhalten. Setzen Sie den Cursor in den Bereich mit der Bezeichnung Konsole, wo Sie mit R interagieren können. Erstellen Sie ein einfaches Objekt mit einem Code wie x &lt;- 2 * 4 (gefolgt von Enter oder Return). Inspizieren Sie dann das x-Objekt durch Eingabe von x gefolgt von Enter oder Return. Sie sollten den Wert 8 auf dem Bildschirm sehen. Wenn ja, haben Sie R und RStudio erfolgreich installiert. 1.3 Add-on packages R ist ein erweiterbares System und viele Menschen teilen nützlichen Code, den sie als Paket entwickelt haben, über CRAN und GitHub. Um ein Paket von CRAN zu installieren, z.B. das Paket tidyverse (ist genauer gesagt eine Kollektion von Paketen), kann man folgenden Befehl verwenden install.packages(&quot;tidyverse&quot;, dependencies = TRUE) Mit der Option dependencies = TRUE achten wir darauf, dass alle für tidyverse notwendigen Pakete, ebenfalls installiert werden. 1.4 RStudio Primers Ein guter Startpunkt für verschiedene R Themen sind die RStudio primers. Im Laufe des Kurses werden sie die Primers The Basics Work with Data Visualize Data durcharbeiten. 1.5 Aufgabe Wir beginnen mit The Basics. Hier wird unterschieden in Programming und Visualization Basics. Programming Basics beinhaltet Grundlagen zu Objekttypen, Funktionen und deren Argumente, Listen (eigentlich sind alle Objekte Listen, nur unterschiedlich speziell) und Paketen. Visualization Basics erklärt erste Schritte in der Verwendung des ggplot2 Pakets, mit dem wir uns später noch eingehend beschäftigen werden. Bearbeiten sie eigenständig den Basics Primer. "],
["r-basics.html", "Kapitel 2 R Basics und Arbeitsabläufe 2.1 Ein paar Grundlagen für das Arbeiten mit R 2.2 Workspace und working directory 2.3 RStudio Projects 2.4 Zuletzt noch", " Kapitel 2 R Basics und Arbeitsabläufe 2.1 Ein paar Grundlagen für das Arbeiten mit R Aktueller Stand: Du hast bereits den Programming Basics Primer absolviert und nun willst du anfangen mit deiner RStudio/R Installation zu arbeiten arbeiten. Es geht los indem du RStudio startest. Beachte dabei die Standardfensterbereiche: Console (links) Environment / History (oben rechts) Files / Plots / Packages / Help (unten rechtes) Bemerkung: Die Standardanordnung der Fenster kannst du neben vielen anderen Dingen nach deinen Vorstellungen ändern/anpassen: Customizing RStudio. Gehen nun in die Konsole um mit R zu interagieren. Erstelle die nachfolgende Zuordnung und schau dir das erstellte Objekt genauer an: x &lt;- 3 * 4 x #&gt; [1] 12 Alle R Befehle, die ein Objekte erstellen (“Zuweisungen”), haben die Form: objectName &lt;- value Du wirst im weiteren Verlauf noch viele Zuweisungen vornehmen, und es ist tatsächlich etwas mühsam den Operator &lt;- zu tippen. Sei aber trotzdem nicht faul und benutze = stattdessen - auch wenn es theoretisch funktionieren würde. Aber später kann die Verwendung von = für Zuweisungen zu Verwirrung führen. Verwende stattdessen in RStudio die Tastenkombination: Alt + - (Minuszeichen). Beachte, dass RStudio automatisch &lt;- mit Leerzeichen umgibt, was eine nützliche Codeformatierung demonstriert. Code ist selbst an einem guten Tag eher schlecht zu lesen. Gönne daher deinen Augen eine Pause und verwende (ausreichend) Leerzeichen. RStudio bietet viele praktische Tastaturkürzel an. Eine Übersicht erhält man auch mit Alt+Shift+K. Objektnamen dürfen nicht mit einer Ziffer beginnen und bestimmte andere Zeichen wie ein Komma oder ein Leerzeichen nicht enthalten. Es ist daher ratsam, sich eine Konvention zur Abgrenzung von Wörtern in Objektnamen zu überlegen. i_use_snake_case other.people.use.periods evenOthersUseCamelCase Wir werden stets die erste Variante verwenden. Führe nun nachfolgenden Befehl aus this_is_a_really_long_name &lt;- 2.5 In deinem Workspace ist nun das Objekt this_is_a_really_long_name vorhanden. Probiere mithilfe dieses Objekts die Vervollständigungsfunktion von RStudio aus: Gib die ersten paar Zeichen ein, drücke anschließend die TAB Taste, fügen weitere Zeichen hinzu, bis Eindeutigkeit hergestellt ist(wenn sonst wenig in deinem Workspace ist, dann ist das schnell erreicht), und drücke dann die Eingabetaste. Führe nun den Befehl jenny_rocks &lt;- 2 ^ 3 aus, um anschließend den Inhalt des Objekts anzuzeigen. jennyrocks #&gt; Error in eval(expr, envir, enclos): object &#39;jennyrocks&#39; not found jeny_rocks #&gt; Error in eval(expr, envir, enclos): object &#39;jeny_rocks&#39; not found Die Objekte jennyrocks und jeny_rocks sind natürlich nicht vorhanden und somit führen beide Befehle zu einer Fehlermeldung. Man muss also absolut exakt sein mit seinen Befehlen. R verfügt über eine überwältigende Sammlung eingebauter Funktionen, die nach folgendem Schema aufgerufen werden: functionName(arg1 = val1, arg2 = val2, and so on) Als nächstes wollen wir die Funktion seq() verwenden, die reguläre Zahlensequenzen erzeugt. Dabei wollen wir noch ein weiteres hilfreiches Feature von RStudio demonstrieren. Tippe se und drücke dann die TAB Taste. In einem Pop-Up Fenster werden dir mögliche Vervollständigungen angezeigt. Der Befehl seq() kann dann durch weiteres Tippen oder über die Auswahlmöglichkeit (Pfeiltasten nach oben/unten) festgelegt werden. Zu jeder Auswahlmöglichkeit wird auch noch eine Kurzform der entsprechenden Hilfeseite angezeigt. Fügt man jetzt die öffnende runde Klammer hinzu, so wird die zugehörige schließende runde Klammer automatisch hinzugefügt. Tippe anschließend 1, 10 (das geschieht automatisch innerhalb der runden Klammern) und Return. RStudio beendet auch den Klammerausdruck für dich. IDEs sind großartig. seq(1, 10) #&gt; [1] 1 2 3 4 5 6 7 8 9 10 Der letzte Befehl zeigt auch ganz gut, wie R Funktionsargumente auflöst. Sie können immer in der Form Name = Wert angeben werden. Aber der Name muss nicht angegeben werden, wie man sieht. In solchen Fällen versucht R, nach der Position aufzulösen. So wird oben angenommen, dass wir eine Sequenz bei 1 starten wollen, also from = 1, und diese bis 10 laufen soll, daher to = 10. Da wir keine Schrittweite angegeben haben, wird der Standardwert für by verwendet, der in diesem Fall gleich 1 ist. Bei Funktionen, die man oft aufruft, kann man gut diese Auflösung nach Position für das erste und vielleicht auch das zweite Argument verwenden. Danach ist es aber ratsam immer mit Name = Wert zu arbeiten um falsche Zuweisungen (verschiedene Argumente können vom gleichen Typ sein, sodass eine falsche Zuweisung nicht automatisch zu einer Fehlermeldung führt) zu vermeiden. Analog zur Unterstützung mit den runden Klammern, werden auch schließende Anführungszeichen automatisch ergänzt, wie man in folgendem Beispiel sieht. yo &lt;- &quot;hello world&quot; Nach einer Zuweisung wird der entsprechende Wert des Objekts nicht angezeigt. Daher ist man vielleicht dazu geneigt das Objekt gleich erneut aufzurufen y &lt;- seq(1, 10) y #&gt; [1] 1 2 3 4 5 6 7 8 9 10 Diese typische Aktion kann verkürzt werden, indem die Zuweisung in Klammern gesetzt wird, wodurch die Zuweisung und ein Befehl “Drucke auf den Bildschirm” erfolgen. (y &lt;- seq(1, 10)) #&gt; [1] 1 2 3 4 5 6 7 8 9 10 Nicht alle Funktionen haben (oder erfordern) Argumente: date() #&gt; [1] &quot;Thu Nov 19 09:36:03 2020&quot; Schau dir nun deinen Workspace an - im oberen rechten Fensterbereich (bei Standardeinstellung) siehst du unter Environment den Inhalt deines Workspaces. Der Workspace ist der Ort, an dem sich benutzerdefinierte Objekte ansammeln. Eine Liste dieser Objekte kannst du auch mit diesen Befehlen erhalten: objects() #&gt; [1] &quot;check_quietly&quot; &quot;install_quietly&quot; #&gt; [3] &quot;jenny_rocks&quot; &quot;pretty_install&quot; #&gt; [5] &quot;shhh_check&quot; &quot;this_is_a_really_long_name&quot; #&gt; [7] &quot;x&quot; &quot;y&quot; #&gt; [9] &quot;yo&quot; ls() #&gt; [1] &quot;check_quietly&quot; &quot;install_quietly&quot; #&gt; [3] &quot;jenny_rocks&quot; &quot;pretty_install&quot; #&gt; [5] &quot;shhh_check&quot; &quot;this_is_a_really_long_name&quot; #&gt; [7] &quot;x&quot; &quot;y&quot; #&gt; [9] &quot;yo&quot; Wenn du nun das Objekt mit dem Namen y entfernen möchtest, kannst du dies wie folgt machen: rm(y) Alles löschen kannst du mit dem Befehl rm(list = ls()) oder du klickst auf den Besen im Environment Fenster von RStudio. 2.2 Workspace und working directory Ziemlich schnell wird der Fall eintreten, dass du mit deiner R Arbeit (z.B. Bearbeitung eines Hausaufgaben Projekts) noch nicht fertig bist obwohl es Zeit wird R zu beenden. Natürlich willst du aber zu einem späteren Zeitpunkt mit der Analyse weitermachen wo du aufgehört hast. Etwas später wird es so ein, dass du Daten in R einlesen und anschließend numerische Ergebnisse erzeugen willst, die du dann schließlich auch wieder exportieren willst. Und nochmal später wird es (vielleicht) so sein, dass du in R gleichzeitig an mehreren Analysen arbeitest, die du aber unbedingt getrennt halten willst/sollst. Um diese Situationen zu bewältigen, musst du zwei Entscheidungen treffen: Was betrachtest du an deiner Analyse als “Ergebnis”, d.h. was wirst du dauerhaft speichern? Wo “lebt” deine Analyse? 2.2.1 Workspace, .RData Du startest gerade deine R Reise. Daher wäre es Okay, wenn du deinen Workspace als die “Ergebnis” deiner Analyse betrachtest. Ziemlich bald, solltest du aber davon (vielleicht durch uns) überzeugt sein, dass deine R Skripte das Ergebnis deiner Analyse sind (in beiden Fällen hängt das Ergebnis möglicherweise natürlich auch von Input Daten ab). Die Daten zusammen mit deinem R Code erlauben es dir jederzeit alle Ergebnisse zu reproduzieren und das ist die entscheidende Eigenschaft. Betrachtest du deinen Workspace als das Ergebnis deiner Analyse, dann musst du bei einem erneuten Analysedurchlauf (leicht veränderte Aufgabenstellung, …) entweder erneut eine Menge Tippen (was natürlich fehleranfällig ist) oder deine R History nach den nötigen Befehlen durchwühlen. Anstatt “becoming an expert on managing the R history”, solltest du deinen R Code sauber in ein Skript speichern, sodass er dir für weitere Analysen zur Verfügung steht. Der Workspace Ansatz wird “begünstigt” durch die Tatsache, dass RStudio beim Beenden der Session automatisch wissen will ob der Workspace gespeichert werden soll. Das wollen wir mal ausprobieren. Beende R/RStudio, entweder über das Menü oder du tippst q() in die Konsole. Dann erhältst du eine Eingabeaufforderung wie diese: Save workspace image to ~/.Rdata? Merke dir in welchem Verzeichnis die Datei gespeichert wird und dann klick auf Save. Gehe in das Verzeichnis mit dem gespeicherten Workspace Image und kontrolliere ob die Datei .RData vorhanden ist. Du wirst dort auch die Datei .Rhistory finden, die alle Befehle deiner letzten Sitzung enthält. Nun starte erneut RStudio. In der Konsole siehst du einen Befehl, der ungefähr so aussieht [Workspace loaded from ~/.RData] und angibt, dass dein gespeicherter Workspace wiederhergestellt wurde. Unter Environment solltest du die gleichen Objekte wie zuvor sehen. History enthält die gespeicherten Befehle aus der letzten Sitzung. Aber diese Art, analytische Arbeit zu beginnen und zu beenden, würde so nicht lange gut gehen. Daher fangen wir gleich mal damit an die automatische Nachfrage nach dem Speichern des Workspaces abzuwählen. Öffne dazu die Global Options (unter Tools) und setze Save workspace to .RData on exit auf Never. Nun wirst du nie mehr gefragt ob du deinen Workspace speichern willst. Sehr wohl wirst du aber weiterhin gefragt ob du ungesicherte Änderungen in deinem R Skript speichern willst, sobald du RStudio beenden willst. 2.2.2 Working directory Jeder Prozess, der auf deinem Computer läuft, hat einen Bezug zu seinem “Arbeitsverzeichnis”. In R ist dies der Ort, an dem R standardmäßig nach Dateien suchen würde oder der Ort wo alle Dateien, die du auf die Festplatte schreiben willst, abgelegt werden. Möglicherweise ist dein aktuelles Arbeitsverzeichnis das Verzeichnis, das du oben gerade untersucht hast um die .RData Datei zu finden. Du kannst dir dein aktuelles Arbeitsverzeichnis anzeigen lassen mit dem Befehl getwd() Aber es wird auch oben an der RStudio Konsole direkt angezeigt. Es wäre schon, wenn das Arbeitsverzeichnis in Abhängigkeit vom jeweils zu bearbeitenden Projekt leicht sinnvoll gesetzt werden könnte. Im nächsten Abschnitt sehen wir, dass genau das möglich ist. 2.3 RStudio Projects Alle zu einem Projekt gehörenden Dateien - Eingabedaten, R Skripte, Analyseergebnisse, Grafiken - an einem Ort zu bündeln, ist eine so weise und gängige Praxis, dass RStudio über seine Projects genau da ermöglicht. Lass uns ein Projekt für den Kurs anlegen. Dazu wählen wir oben rechts im RStudio Fenster Project: (None) -&gt; New Project Danach wählen wir New Directory -&gt; New Project und geben abschließend einen passenden Verzeichnisnamen ein (dabei beachten wir den Speicherort des neuen Verzeichnisses) Wir nehmen nun an, dass du ein RStudio Projekt angelegt und dieses auch geöffnet hast. Dann benötigen wir als Nächstes ein wenig R Code. Dazu tippen wir den unten stehenden Code (ausnahmsweise) in die Konsole a &lt;- 2 b &lt;- -3 sig_sq &lt;- 0.5 x &lt;- runif(40) y &lt;- a + b * x + rnorm(40, sd = sqrt(sig_sq)) (x_n &lt;- mean(x)) #&gt; [1] 0.461 write(x_n, &quot;mittelwert_x.txt&quot;) plot(x, y) abline(a, b, col = &quot;purple&quot;) dev.print(pdf, &quot;scatterplot.pdf&quot;) #&gt; quartz_off_screen #&gt; 2 Jetzt nehmen wir mal an das wäre ein guter Start einer Analyse, die wir durchführen wollen. Daher würdest du das Ergebnis gerne abspeichern. Unter History kannst du alle obigen Befehle markieren und anschließend “To Source” klicken. Daraufhin wird sich ein neues Fenster mit einem R Skript - das natürlich die Befehle enthält - öffnen. Das Skript kannst du abspeichern und standardmäßig wird es in deinen Projektordner gespeichert werden (aber natürlich könntest man den Speicherort an dieser Stelle auch ändern/frei wählen). Nun beende das Projekt (Close Project in der rechten oberen Ecke). Wenn du willst, kannst du dir auch den Inhalt deines Projektordners anschauen, z.B. das PDF öffnen. Danach öffnest du das Projekt wieder. Dir wird auffallen, dass alles in dem Zustand ist, wie du das Projekt verlassen hast, z.B. Objekte im Arbeitsbereich, die Befehlshistorie, welche Dateien zur Bearbeitung geöffnet sind, wo wir uns im Dateisystembrowser befinden, das Arbeitsverzeichnis für den R-Prozess usw. All dies sind gute Dinge. Nun ändern ein paar Dinge an deinem Code. Sinnvoll wäre z.B. am Anfang die Stichprobenlänge n zu definieren und z.B. auf n &lt;- 40 setzen. Dann sollten alle festen 40er Werte durch n ersetzt werden. Anschließend kannst du noch ein paar andere Dinge ändern, z.B. die Steigung b, die Farbe der Linie … was auch immer. Übe nun die verschiedenen Möglichkeiten, den Code erneut auszuführen: Führe Zeile für Zeile aus indem du entweder das Tastenkürzel Command + Enter oder die Maus (auf “Run” klicken in der oberen rechten Ecke des Editor-Fensters) verwendest. Das gesamte Dokument durchlaufen lassen per Tastenkürzel Shift + Command +S oder Maus (klicken auf “Source” in der oberen rechten Ecke des Editor-Fensters) Anschließend kannst du dir das PDF anschauen und die Änderungen bewundern. Eines Tages wirst du vor der Aufgabe stehen eine Grafik neu zu gestalten oder einfach nur verstehen wollen, woher sie stammt. Wenn du (relevante) Grafiken in einer Datei (mit R Code und niemals über die Maus oder die Zwischenablage) speicherst und dabei sinnvolle Dateinamen/Speicherorte (innerhalb des zugehörigen Projekts) benutzt, werden dich solche Aufgaben nie vor große Probleme stellen. 2.4 Zuletzt noch Es ist üblich, R-Skripte mit einem .R oder .r Suffix zu speichern. Befolge diese Konvention, außer du hast einen sehr außergewöhnlichen Grund, es nicht zu tun. Kommentare beginnen mit einem oder mehreren #-Symbolen. Verwende Kommentare.. RStudio hilft dir dabei ausgewählte Zeilen mit Ctrl+Shift+C (Windows und Linux) oder Command+Shif+C (Mac) zu kommentieren oder vorhandene Kommentare wieder zu entfernen. Dieser Workflow wird dir in Zukunft gute Dienste leisten: Erstelle ein RStudio Projekt für ein analytisches Projekt Speichere alle Input Dateien innerhalb des Projekts (wir werden bald über den Import sprechen) Bewahre deine Skripte dort auf; bearbeite sie und führen sie dort aus Speichere den Output innerhalb des Projekts (wie z.B. das PDF im letzten Beispiel) Du solltest es vermeiden die Maus für Teile deines Workflows zu verwenden, wie z.B. das Laden eines Datensatzes oder das Speichern einer Grafik. Das ist sehr wichtig für die Reproduzierbarkeit und um im Nachhinein feststellen zu können, wie eine numerische Tabelle oder eine PDF-Datei tatsächlich erzeugt wurde (eine Suche auf der lokalen Festplatte nach dem entsprechenden Dateinamen unter den .R-Dateien führt zum entsprechenden Skript). "],
["version-control.html", "Kapitel 3 Git, GitHub, and RStudio", " Kapitel 3 Git, GitHub, and RStudio Wir wissen nicht ob Versionskontrolle bereits ein Thema war mit dem du dich beschäftigt hast. Wenn nicht, solltest du mit ein paar Worten zu Git und GitHub von Jenny Byran (Autorin von STAT 545) starten. Ziel dieses Abschnitts wird es sein, dass du einen GitHub Account anlegst (falls nicht schon vorhanden) Git auf deinem Computer installierst dich bei Git vorstellst alles zusammenfügst und deine Verbindung zu GitHub testest abschließend noch RStudio ins Spiel bringst und RStudio mit Git und GitHub verbindest Bemerkung: Unter 5. wirst du ermutigt deine GitHub Zugangsdaten auf deinem Computer zu speichern. Wir können diesen Schritt nur empfehlen. Das Buch Happy Git and GitHub for the useR enthält noch viele weitere hilfreiche Git/GitHub Informationen. Auf manche kommen wir vielleicht im Laufe des Kurses noch zu sprechen. Andere sind vielleicht zu einem späteren Zeitpunkt interessant, wenn du an anspruchsvolleren Git Projekten arbeitest. "],
["r-markdown.html", "Kapitel 4 R Markdown", " Kapitel 4 R Markdown Ausgewählte Hausaufgaben wirst du als R Markdown Dokument abgeben. R Markdown ist eine sehr zugängliche Methode zur Erstellung von Dokumenten, die Prosa Text mit durch R-Code erzeugten Tabellen und Abbildungen kombinieren. Ein möglicher R Markdown Workflow, der eine Interaktion mit Git, GitHub, und RStudio beinhaltet, wird vorgestellt auf der Seite: Test drive R Markdown "],
["basic-data-care.html", "Kapitel 5 Letzte Vorbereitungen … 5.1 Data Frames sind fantastisch 5.2 Gapminder data 5.3 Die gapminder Daten sind ein “tibble” 5.4 Variablen in einem Data Frame 5.5 Recap", " Kapitel 5 Letzte Vorbereitungen … Jetzt ist es an der Zeit, sich zu vergewissern in welchem Verzeichnis auf deinem Computer du dich befindest. Falls du ein RStudio Projekt nutzt, sollte diese Frage leicht zu beantworten sein. Falls du trotzdem unsicher bist, gib getwd() in der Konsole ein, um das aktuelle Arbeitsverzeichnis zu sehen. Alle nachfolgenden Code Beispiele wollen wir abspeichern in einer .R Datei, die wir im aktuellen Arbeitsverzeichnis abspeichern wollen. Idealerweise geben wir dieser Datei noch einen Namen, wie etwa datenanalyse_teil_1.R, der uns schon viel über den möglichen Inhalt erzählt. Alternativ können wir alle Befehle natürlich auch in eine R Markdown Datei schreiben, siehe Test drive R Markdown. Prinzipiell geht es in den folgenden Abschnitten um Datenmanagement. Es werden aber auch immer wieder ein paar Grafiken zu sehen sein. Dies ist aber kein Problem, da wir ja bereits den Data Visualization Basics Primer besucht haben und so den nötigen Background haben. 5.1 Data Frames sind fantastisch Das Standardformat für Daten ist ein data frame. Die meisten Funktionen zur Inferenz, Modellierung und graphischen Darstellung erwarten, dass ihnen über ein data = Argument ein data frame übergeben wird. Dies gilt für die Basis R schon seit langem. Die als tidyverse bekannte Kollektion von Paketen geht noch einen Schritt weiter und priorisiert ausdrücklich die Verarbeitung von data frames. Tatsächlich priorisiert tidyverse eine besondere Art von data frames, die als “tibble” bezeichnet wird. Data frames - im Gegensatz zu allgemeinen Arrays oder speziell Matrizen in R - können Variablen unterschiedlicher Typen enthalten, wie z. B. Textdaten (Subjekt-ID oder Name), quantitative Daten (Anzahl der weißen Blutkörperchen) und kategoriale Informationen (behandelt vs. unbehandelt). Genauer gesagt können in data frames unterschiedliche Spalten aus unterschiedlichen Datentypen bestehen. Innerhalb einer Spalte müssen aber alle Einträge vom gleichen Typ sein. Daten aus einer Datenanalyse bestehen immer aus mehr als einem Datentyp. Aus diesem Grund können Matrizen oder Arrays nicht zur Datenanalyse verwendet werden, da man sonst mit verschiedenen, unverbundenen Objekten (Matrizen, Arrays) arbeiten müsste und diese nur schwer koordinieren kann. 5.2 Gapminder data Wir werden mit einigen der Daten aus dem [Gapminder-Projekt] (https://www.gapminder.org) arbeiten. Die Daten sind im gapminder Paket enthalten, welches wir über CRAN installieren können: install.packages(&quot;gapminder&quot;) Um die Daten zu verwenden, müssen wir das Paket natürlich auch noch laden library(gapminder) 5.3 Die gapminder Daten sind ein “tibble” Durch das Laden des gapminder Pakets haben wir nun Zugriff auf einen Datenobjekt mit demselben Namen. Schau dir nun mithilfe der Funktion str() die Struktur des Objekts an. str(gapminder) #&gt; tibble [1,704 × 6] (S3: tbl_df/tbl/data.frame) #&gt; $ country : Factor w/ 142 levels &quot;Afghanistan&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ continent: Factor w/ 5 levels &quot;Africa&quot;,&quot;Americas&quot;,..: 3 3 3 3 3 3 3 3 3 3 ... #&gt; $ year : int [1:1704] 1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 ... #&gt; $ lifeExp : num [1:1704] 28.8 30.3 32 34 36.1 ... #&gt; $ pop : int [1:1704] 8425333 9240934 10267083 11537966 13079460 14880372.. #&gt; $ gdpPercap: num [1:1704] 779 821 853 836 740 ... str() liefert eine vernünftige Beschreibung von fast allem, und im schlimmsten Fall kann tatsächlich auch nichts “Schlimmes” passieren. Aus dem Output erkennen wir, dass der Datensatz 1704 Beobachtungen enthält. Auf der anderen Seite hätten wir durch direkten Aufruf von gapminder den Inhalt auch direkt auf den Bildschirm schreiben können. Aber vielleicht hast du schon mal einen größeren Datensatz aufgerufen und zögerst nun etwas, da große Datensätze einfach die Konsole füllen und nur sehr wenig Einblick bieten. Dies ist der erste große Sieg für tibbles. Tidyverse bietet eine spezielle data frame Variante an: ein “tibble”. Dies wird auch verdeutlicht, wenn man sich z.B. die Klasse des gapminder Objekts anschaut class(gapminder) #&gt; [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; Schau, es ist immer noch ein reguläres data frame, aber eben auch ein tibble. Jetzt können wir gapminder einfach auf den Bildschirm anzeigen! Da es sich um ein tibble handelt, wird nur das Wichtigste angezeigt und deine Konsole läuft nicht voll. gapminder #&gt; # A tibble: 1,704 x 6 #&gt; country continent year lifeExp pop gdpPercap #&gt; &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 Afghanistan Asia 1952 28.8 8425333 779. #&gt; 2 Afghanistan Asia 1957 30.3 9240934 821. #&gt; 3 Afghanistan Asia 1962 32.0 10267083 853. #&gt; 4 Afghanistan Asia 1967 34.0 11537966 836. #&gt; 5 Afghanistan Asia 1972 36.1 13079460 740. #&gt; 6 Afghanistan Asia 1977 38.4 14880372 786. #&gt; 7 Afghanistan Asia 1982 39.9 12881816 978. #&gt; 8 Afghanistan Asia 1987 40.8 13867957 852. #&gt; 9 Afghanistan Asia 1992 41.7 16317921 649. #&gt; 10 Afghanistan Asia 1997 41.8 22227415 635. #&gt; # … with 1,694 more rows Wenn du mit einem reinen data frame arbeitest - und dieses Feature magst - kannst du es mit as_tibble() in ein tibble transformieren. library(tidyverse) as_tibble(iris) #&gt; # A tibble: 150 x 5 #&gt; Sepal.Length Sepal.Width Petal.Length Petal.Width Species #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; #&gt; 1 5.1 3.5 1.4 0.2 setosa #&gt; 2 4.9 3 1.4 0.2 setosa #&gt; 3 4.7 3.2 1.3 0.2 setosa #&gt; 4 4.6 3.1 1.5 0.2 setosa #&gt; 5 5 3.6 1.4 0.2 setosa #&gt; 6 5.4 3.9 1.7 0.4 setosa #&gt; 7 4.6 3.4 1.4 0.3 setosa #&gt; 8 5 3.4 1.5 0.2 setosa #&gt; 9 4.4 2.9 1.4 0.2 setosa #&gt; 10 4.9 3.1 1.5 0.1 setosa #&gt; # … with 140 more rows Weitere Möglichkeiten, grundlegende Informationen zu einem data frame abzufragen: names(gapminder) #&gt; [1] &quot;country&quot; &quot;continent&quot; &quot;year&quot; &quot;lifeExp&quot; &quot;pop&quot; &quot;gdpPercap&quot; ncol(gapminder) #&gt; [1] 6 length(gapminder) #&gt; [1] 6 dim(gapminder) #&gt; [1] 1704 6 nrow(gapminder) #&gt; [1] 1704 Ein bisschen deskriptive Statistik zum Inhalt eines data frames erhältst du mit summary(): summary(gapminder) #&gt; country continent year lifeExp #&gt; Afghanistan: 12 Africa :624 Min. :1952 Min. :23.6 #&gt; Albania : 12 Americas:300 1st Qu.:1966 1st Qu.:48.2 #&gt; Algeria : 12 Asia :396 Median :1980 Median :60.7 #&gt; Angola : 12 Europe :360 Mean :1980 Mean :59.5 #&gt; Argentina : 12 Oceania : 24 3rd Qu.:1993 3rd Qu.:70.8 #&gt; Australia : 12 Max. :2007 Max. :82.6 #&gt; (Other) :1632 #&gt; pop gdpPercap #&gt; Min. :6.00e+04 Min. : 241 #&gt; 1st Qu.:2.79e+06 1st Qu.: 1202 #&gt; Median :7.02e+06 Median : 3532 #&gt; Mean :2.96e+07 Mean : 7215 #&gt; 3rd Qu.:1.96e+07 3rd Qu.: 9325 #&gt; Max. :1.32e+09 Max. :113523 #&gt; Bemerkung: summary() ist eine generische Funktion. Für eine gegebene Klasse (des Inputs) bestimmt die generische Funktion die passende Methode. Die Funktion summary() besitzt die folgenden Methoden: methods(summary) #&gt; [1] summary,ANY-method summary,DBIObject-method #&gt; [3] summary.aov summary.aovlist* #&gt; [5] summary.aspell* summary.check_packages_in_dir* #&gt; [7] summary.connection summary.data.frame #&gt; [9] summary.Date summary.default #&gt; [11] summary.Duration* summary.ecdf* #&gt; [13] summary.factor summary.ggplot* #&gt; [15] summary.glm summary.haven_labelled* #&gt; [17] summary.hcl_palettes* summary.infl* #&gt; [19] summary.Interval* summary.lm #&gt; [21] summary.loess* summary.manova #&gt; [23] summary.matrix summary.mlm* #&gt; [25] summary.nls* summary.packageStatus* #&gt; [27] summary.Period* summary.POSIXct #&gt; [29] summary.POSIXlt summary.ppr* #&gt; [31] summary.prcomp* summary.princomp* #&gt; [33] summary.proc_time summary.rlang_error* #&gt; [35] summary.rlang_trace* summary.srcfile #&gt; [37] summary.srcref summary.stepfun #&gt; [39] summary.stl* summary.table #&gt; [41] summary.tukeysmooth* summary.vctrs_sclr* #&gt; [43] summary.vctrs_vctr* summary.warnings #&gt; see &#39;?methods&#39; for accessing help and source code Obwohl wir uns formell noch nicht eingehender mit der Visualisierung beschäftigt haben, ist es wichtig ein paar Grafiken zu erzeugen um einen ersten Eindruck über den Datensatz zu bekommen. Auf der anderen Seite werden die Grafiken aber auch nicht (viel) aufwendiger als im Data Visualisation Basics Primer ggplot(gapminder, mapping = aes(x = year, y = lifeExp)) + geom_point() ggplot(gapminder, mapping = aes(x = gdpPercap, y = lifeExp)) + geom_point() ggplot(gapminder, mapping = aes(x = log(gdpPercap), y = lifeExp)) + geom_point() Grafiken dieser Art werden wir zu einem späteren Zeitpunkt noch genauer behandeln. Dann sprechen wir auch über deren Inhalt. Wir schauen uns nochmal die Ausgabe von str() an, um darüber zu sprechen, was ein data frame genau ist. str(gapminder) #&gt; tibble [1,704 × 6] (S3: tbl_df/tbl/data.frame) #&gt; $ country : Factor w/ 142 levels &quot;Afghanistan&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ continent: Factor w/ 5 levels &quot;Africa&quot;,&quot;Americas&quot;,..: 3 3 3 3 3 3 3 3 3 3 ... #&gt; $ year : int [1:1704] 1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 ... #&gt; $ lifeExp : num [1:1704] 28.8 30.3 32 34 36.1 ... #&gt; $ pop : int [1:1704] 8425333 9240934 10267083 11537966 13079460 14880372.. #&gt; $ gdpPercap: num [1:1704] 779 821 853 836 740 ... Ein data frame ist ein Sonderfall einer Liste, die in R verwendet wird, um so gut wie alles aufzunehmen. Data frames sind ein Spezialfall, bei dem die Länge jedes Listenelements gleich ist. Nehmen wir mal an, dass wir eine Beschreibung der Variablen names(gapminder) #&gt; [1] &quot;country&quot; &quot;continent&quot; &quot;year&quot; &quot;lifeExp&quot; &quot;pop&quot; &quot;gdpPercap&quot; zusammen mit den Daten abspeichern wollen. Dazu könnten wir ein tibble (desc &lt;- tibble(variables = names(gapminder), desc = c(&quot;actor with 142 levels&quot;, &quot;factor with 5 levels&quot;, &quot;ranges from 1952 to 2007 in increments of 5 years&quot;, &quot;life expectancy at birth, in years&quot;, &quot;population&quot;,&quot;GDP per capita (US$, inflation-adjusted)&quot;))) #&gt; # A tibble: 6 x 2 #&gt; variables desc #&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 country actor with 142 levels #&gt; 2 continent factor with 5 levels #&gt; 3 year ranges from 1952 to 2007 in increments of 5 years #&gt; 4 lifeExp life expectancy at birth, in years #&gt; 5 pop population #&gt; 6 gdpPercap GDP per capita (US$, inflation-adjusted) erzeugen, das die Beschreibungen enthält. Dieses data frame hat nun die Dimension 6x2. Trotzdem können wir es mit gapminder kombinieren, wenn wir beide tibbles in einer Liste abspeichern gapminder_desc &lt;- list(gapminder, desc) str(gapminder_desc) #&gt; List of 2 #&gt; $ : tibble [1,704 × 6] (S3: tbl_df/tbl/data.frame) #&gt; ..$ country : Factor w/ 142 levels &quot;Afghanistan&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... #&gt; ..$ continent: Factor w/ 5 levels &quot;Africa&quot;,&quot;Americas&quot;,..: 3 3 3 3 3 3 3 3 3 .. #&gt; ..$ year : int [1:1704] 1952 1957 1962 1967 1972 1977 1982 1987 1992 199.. #&gt; ..$ lifeExp : num [1:1704] 28.8 30.3 32 34 36.1 ... #&gt; ..$ pop : int [1:1704] 8425333 9240934 10267083 11537966 13079460 14880.. #&gt; ..$ gdpPercap: num [1:1704] 779 821 853 836 740 ... #&gt; $ : tibble [6 × 2] (S3: tbl_df/tbl/data.frame) #&gt; ..$ variables: chr [1:6] &quot;country&quot; &quot;continent&quot; &quot;year&quot; &quot;lifeExp&quot; ... #&gt; ..$ desc : chr [1:6] &quot;actor with 142 levels&quot; &quot;factor with 5 levels&quot; &quot;ra&quot;.. 5.4 Variablen in einem Data Frame Um eine einzelne Variable aus einem data frame anzusprechen, kann man mit dem Dollarzeichen $ arbeiten. Wir schauen uns dazu die numerische Variable lifeExp an. head(gapminder$lifeExp) #&gt; [1] 28.8 30.3 32.0 34.0 36.1 38.4 summary(gapminder$lifeExp) #&gt; Min. 1st Qu. Median Mean 3rd Qu. Max. #&gt; 23.6 48.2 60.7 59.5 70.8 82.6 Zusätzlich wollen wir die noch die Verteilung von lifeExp visualisieren und plotten dazu ein Histogramm. Da wir dazu ggplot() verwenden, können wir lifeExp wieder direkt aufrufen. ggplot(gapminder, mapping = aes(x = lifeExp)) + geom_histogram() #&gt; `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Alternativ können wir die Einträge eines data frames auch über die eckigen Klammern [] indizieren. summary(gapminder[,&quot;lifeExp&quot;]) #&gt; lifeExp #&gt; Min. :23.6 #&gt; 1st Qu.:48.2 #&gt; Median :60.7 #&gt; Mean :59.5 #&gt; 3rd Qu.:70.8 #&gt; Max. :82.6 Dabei spezifiziert der Eintrag links vom Komma die Zeilen und der Wert rechts davon die Spalten. Dies ist hilfreich, wenn man auf einzelne Werte zugreifen will. Aber beim Aufruf einer kompletten Variable (Spalte) ist die $ Notation sicherlich vorteilhaft. Die Variable year ist eine ganzzahlige Variable, aber da es so wenige unterschiedliche Werte gibt, funktioniert sie auch ein wenig wie eine kategoriale Variable. summary(gapminder$year) #&gt; Min. 1st Qu. Median Mean 3rd Qu. Max. #&gt; 1952 1966 1980 1980 1993 2007 table(gapminder$year) #&gt; #&gt; 1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 2002 2007 #&gt; 142 142 142 142 142 142 142 142 142 142 142 142 Die Variablen country und continent enthalten rein kategorische Informationen, die in R (häufig) als factor gespeichert werden. class(gapminder$continent) #&gt; [1] &quot;factor&quot; summary(gapminder$continent) #&gt; Africa Americas Asia Europe Oceania #&gt; 624 300 396 360 24 levels(gapminder$continent) #&gt; [1] &quot;Africa&quot; &quot;Americas&quot; &quot;Asia&quot; &quot;Europe&quot; &quot;Oceania&quot; nlevels(gapminder$continent) #&gt; [1] 5 Die Levels von continent sind “Afrika”, “America” usw., und das ist es, was einem normalerweise in R angezeigt werden sollte, wenn man eine Faktorvariable aufruft. Im Allgemeinen sind die Levels von Menschen lesbare Zeichenfolgen, wie “male/female” und “control/treated”. Aber vergiss niemals, dass R diese Information in kodierter Form speichert. Schauen dir zum Beispiel das Ergebnis von str(gapminder$continent) an, falls du skeptisch sein solltest. str(gapminder$continent) #&gt; Factor w/ 5 levels &quot;Africa&quot;,&quot;Americas&quot;,..: 3 3 3 3 3 3 3 3 3 3 ... Faktorvariablen haben Vor- und Nachteil. Im weiteren Verlauf zeigen wir sowohl die Vor- wie auch die Nachteile. Generell ist aber durchaus so, dass die Vorteile überwiegen. Als Nächstes erstellen wir mit der Funktion table() eine Häufigkeitstabelle für die Variable count. Dieser Inhalt wird anschließend visualisiert über die Funktion geom_bar(). Die entsprechende Berechnung der Häufigkeitstabelle wird dabei aber sowohl von table() wie auch von geom_bar() (über die statistische Transformation stat_count()) durchgeführt, oder anders gesagt, wir können an geom_bar() den Datensatz (hier gapminder) anstatt von vorab berechneten Werten übergeben. table(gapminder$continent) #&gt; #&gt; Africa Americas Asia Europe Oceania #&gt; 624 300 396 360 24 ggplot(gapminder, aes(x = continent)) + geom_bar() In den folgenden Abbildungen sehen wir, wie Faktoren in Zahlen umgesetzt werden können. Der continent-Faktor lässt sich durch das ggplot2-Paket leicht in “Facetten” oder Farben und eine Legende abbilden. Die Erstellung von Grafiken mit ggplot2 werden wir noch genauer besprechen. Daher kannst du dich also ruhig zurücklehnen und die Plots genießen oder blind kopieren/einfügen. # wir initialisieren ein grafik (ohne inhalt) p &lt;- ggplot(filter(gapminder, continent != &quot;Oceania&quot;), aes(x = gdpPercap, y = lifeExp)) p &lt;- p + scale_x_log10() # auf der x-achse soll eine log skala verwendet werden p + geom_point() # ein scatterplot p + geom_point(aes(color = continent)) # für verschiedene kontinente werden verschiedene farben verwendet p + geom_point(alpha = (1/3), size = 3) + # punkte mit transparenz geom_smooth(lwd = 3, se = FALSE) # geglätter zusammenhang #&gt; `geom_smooth()` using method = &#39;gam&#39; and formula &#39;y ~ s(x, bs = &quot;cs&quot;)&#39; p + geom_point(alpha = (1/3), size = 3) + facet_wrap(~ continent) + # für jeden kontinent wird eine eigener # plot (innerhalb einer grafik) erzeugt geom_smooth(lwd = 1.5, se = FALSE) #&gt; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; 5.5 Recap Benutze data frames!!! Benutze tidyverse!!! Dadurch wird eine spezielle Art von data frames, ein “tibble”, bereitgestellt, die neben anderen Vorteilen ein nettes Standarddruckverhalten aufweist. Im Zweifelsfall kannst du dir immer Inhalte anzeigen lassen über str() oder im Fall eines tibbles, einfach das tibble selbst aufrufen. Sei dir immer über die Anzahl an Zeilen und Spalten deiner data frames bewusst. Sei dir im Klaren welche Art (numerisch, kategorial, …) von Variablen in deinen data frames enthalten sind. Benutze factors!!! Aber mach das bewusst und mit Vorsicht. Führe für jede Variable eine grundlegende statistische und visuelle Überprüfung durch. Ruf Variablen mit ihrem Namen auf, z.B. gapminder$lifeExp, nicht mit der Spaltennummer. Dein Code wird dadurch robuster und lesbarer sein. "],
["dplyr-intro.html", "Kapitel 6 Einführung in dplyr 6.1 Einstieg 6.2 filter(): Indizieren von Zeilen 6.3 Der Pipe-Operator 6.4 Mit select() Variablen auswählen 6.5 Jetzt nochmal ein Vergleich zu R Standardbefehlen 6.6 Pure, predictable, pipeable", " Kapitel 6 Einführung in dplyr 6.1 Einstieg dplyr ist ein Paket zur Datenmanipulation, entwickelt von Hadley Wickham und Romain Francois. In erster Linie will es schnell und ausdrucksstark sein. Es wird als Teil des “Metapakets” tidyverse installiert und gehört als Kernpaket zu den Paketen, die über library(tidyverse) geladen werden. Die Wurzeln von dplyr liegen in einem früheren Paket mit dem Namen plyr, das zum Ziel hat die [“split-apply-combine”-Strategie der Datenanalyse] (https://www.jstatsoft.org/article/view/v040i01) (Wickham 2011) umzusetzen. Wo plyr noch einen vielfältigen Satz von Ein- und Ausgaben abdeckt (z.B. Arrays, data frames, Listen), hat dplyr einen klaren Fokus auf data frames oder, im Tidyverse, tibbles. dplyr bietet schnelle Alternativen zu den R Standardfunktionen: subset(), apply(), [sl]apply(), tapply(), aggregate(), split(), do.call(), with(), within(), und mehr. Ferner kann man dplyr nutzen um über Zeilen oder Gruppen von Zeilen zu iterieren, was eine schnelle Alternative zur Nutzung von for Schleifen darstellt. 6.1.1 Wie immer, laden wir zu Beginn tidyverse Der Fokus liegt in diesem Abschnitt auf dplyr. Aber da wir immer wieder auch Funktionen aus anderen “tidyverse-Paketen” nutzen, laden wir stets tidyverse. library(tidyverse) #&gt; ── Attaching packages ────────────────────────────── tidyverse 1.3.0 ── #&gt; ✓ ggplot2 3.3.2 ✓ purrr 0.3.4 #&gt; ✓ tibble 3.0.3 ✓ dplyr 1.0.2 #&gt; ✓ tidyr 1.1.2 ✓ stringr 1.4.0 #&gt; ✓ readr 1.3.1 ✓ forcats 0.5.0 #&gt; ── Conflicts ───────────────────────────────── tidyverse_conflicts() ── #&gt; x dplyr::filter() masks stats::filter() #&gt; x dplyr::lag() masks stats::lag() Zusätzlich wollen wir auch noch gapminder laden. library(gapminder) 6.2 filter(): Indizieren von Zeilen filter() nimmt logische Ausdrücke und gibt die Zeilen zurück, für die der logische Ausdruck ein TRUE ergibt. filter(gapminder, lifeExp &lt; 29) #&gt; # A tibble: 2 x 6 #&gt; country continent year lifeExp pop gdpPercap #&gt; &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 Afghanistan Asia 1952 28.8 8425333 779. #&gt; 2 Rwanda Africa 1992 23.6 7290203 737. filter(gapminder, country == &quot;Rwanda&quot;, year &gt; 1979) #&gt; # A tibble: 6 x 6 #&gt; country continent year lifeExp pop gdpPercap #&gt; &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 Rwanda Africa 1982 46.2 5507565 882. #&gt; 2 Rwanda Africa 1987 44.0 6349365 848. #&gt; 3 Rwanda Africa 1992 23.6 7290203 737. #&gt; 4 Rwanda Africa 1997 36.1 7212583 590. #&gt; 5 Rwanda Africa 2002 43.4 7852401 786. #&gt; 6 Rwanda Africa 2007 46.2 8860588 863. filter(gapminder, country %in% c(&quot;Rwanda&quot;, &quot;Afghanistan&quot;)) #&gt; # A tibble: 24 x 6 #&gt; country continent year lifeExp pop gdpPercap #&gt; &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 Afghanistan Asia 1952 28.8 8425333 779. #&gt; 2 Afghanistan Asia 1957 30.3 9240934 821. #&gt; 3 Afghanistan Asia 1962 32.0 10267083 853. #&gt; 4 Afghanistan Asia 1967 34.0 11537966 836. #&gt; 5 Afghanistan Asia 1972 36.1 13079460 740. #&gt; 6 Afghanistan Asia 1977 38.4 14880372 786. #&gt; 7 Afghanistan Asia 1982 39.9 12881816 978. #&gt; 8 Afghanistan Asia 1987 40.8 13867957 852. #&gt; 9 Afghanistan Asia 1992 41.7 16317921 649. #&gt; 10 Afghanistan Asia 1997 41.8 22227415 635. #&gt; # … with 14 more rows Zum Vergleich kann man sich einen R Standardbefehl anschauen, der zum gleichen Ergebnis führt: gapminder[gapminder$lifeExp &lt; 29, ] subset(gapminder, country == &quot;Rwanda&quot;) ## subset funktioniert ähnlich wir filter Unter keinen Umständen solltest du allerdings deine Daten so unterteilen, wie hier: auswahl &lt;- gapminder[241:252, ] Warum ist das eine blöde Idee? Es ist nicht selbstdokumentierend. Was ist das Besondere an den Zeilen 241 bis 252? Es ist fehleranfällig. Diese Codezeile wird zu anderen Ergebnissen führen, wenn jemand die Zeilenreihenfolge von gapminder ändert, z.B. die Daten früher im Skript sortiert. filter(gapminder, country == &quot;Canada&quot;) Dieser Aufruf erklärt sich von selbst und ist ziemlich robust. 6.3 Der Pipe-Operator Bevor es weitergeht, wollen wir aber den Pipe-Operator, den das Tidyverse aus dem magrittr-Paket von Stefan Bache importiert, vorstellen. Mithilfe des Pipe-Operators ist man in der Lage Befehle für mehrere Operationen auszuführen, ohne sie ineinander zu verschachteln. Diese neue Syntax führt zu Code, der viel einfacher zu schreiben und zu lesen ist. Und so sieht er aus: %&gt;%. Das entsprechende RStudio Tastenkürzel lautet: Ctrl+Shift+M (Windows), Cmd+Shift+M (Mac). Erstmal ein Beispiel gapminder %&gt;% head() #&gt; # A tibble: 6 x 6 #&gt; country continent year lifeExp pop gdpPercap #&gt; &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 Afghanistan Asia 1952 28.8 8425333 779. #&gt; 2 Afghanistan Asia 1957 30.3 9240934 821. #&gt; 3 Afghanistan Asia 1962 32.0 10267083 853. #&gt; 4 Afghanistan Asia 1967 34.0 11537966 836. #&gt; 5 Afghanistan Asia 1972 36.1 13079460 740. #&gt; 6 Afghanistan Asia 1977 38.4 14880372 786. Du siehst, der Befehl ist äquivalent zu head(gapminder). Der Pipe-Operator nimmt das Objekt auf der linken Seite und leitet es in den Funktionsaufruf auf der rechten Seite weiter - er gibt es buchstäblich als erstes Argument ein. Keine Angst, du kannst immer noch weitere Argumente für die Funktion auf der rechten Seite angeben! Um die ersten 3 Reihen von gapminder zu sehen, könnte man sagen: head(gapminder, 3) oder: gapminder %&gt;% head(3) #&gt; # A tibble: 3 x 6 #&gt; country continent year lifeExp pop gdpPercap #&gt; &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 Afghanistan Asia 1952 28.8 8425333 779. #&gt; 2 Afghanistan Asia 1957 30.3 9240934 821. #&gt; 3 Afghanistan Asia 1962 32.0 10267083 853. Du bist wahrscheinlich noch nicht sehr beeindruckt, aber das sollte sich noch ändern. 6.4 Mit select() Variablen auswählen Nun zurück zu dplyr…. Verwende select(), um aus den Daten verschiedene Variablen (Spalten) auszuwählen. Hier kommt eine typische Verwendung von select(): select(gapminder, year, lifeExp) #&gt; # A tibble: 1,704 x 2 #&gt; year lifeExp #&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 1952 28.8 #&gt; 2 1957 30.3 #&gt; 3 1962 32.0 #&gt; 4 1967 34.0 #&gt; 5 1972 36.1 #&gt; 6 1977 38.4 #&gt; 7 1982 39.9 #&gt; 8 1987 40.8 #&gt; 9 1992 41.7 #&gt; 10 1997 41.8 #&gt; # … with 1,694 more rows Und nun noch kombiniert mit head() über den Pipe-Operator: gapminder %&gt;% select(year, lifeExp) %&gt;% head(4) #&gt; # A tibble: 4 x 2 #&gt; year lifeExp #&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 1952 28.8 #&gt; 2 1957 30.3 #&gt; 3 1962 32.0 #&gt; 4 1967 34.0 In Worten: “Nimm gapminder, wähle die Variablen year und lifeExp und zeige dann die ersten 4 Zeilen an.” 6.5 Jetzt nochmal ein Vergleich zu R Standardbefehlen Hier sind die Daten für Kambodscha, aber nur bestimmte Variablen: gapminder %&gt;% filter(country == &quot;Cambodia&quot;) %&gt;% select(year, lifeExp) #&gt; # A tibble: 12 x 2 #&gt; year lifeExp #&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 1952 39.4 #&gt; 2 1957 41.4 #&gt; 3 1962 43.4 #&gt; 4 1967 45.4 #&gt; 5 1972 40.3 #&gt; 6 1977 31.2 #&gt; 7 1982 51.0 #&gt; 8 1987 53.9 #&gt; 9 1992 55.8 #&gt; 10 1997 56.5 #&gt; 11 2002 56.8 #&gt; 12 2007 59.7 und so würde ein typischer R Standardbefehl aussehen: gapminder[gapminder$country == &quot;Cambodia&quot;, c(&quot;year&quot;, &quot;lifeExp&quot;)] #&gt; # A tibble: 12 x 2 #&gt; year lifeExp #&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 1952 39.4 #&gt; 2 1957 41.4 #&gt; 3 1962 43.4 #&gt; 4 1967 45.4 #&gt; 5 1972 40.3 #&gt; 6 1977 31.2 #&gt; 7 1982 51.0 #&gt; 8 1987 53.9 #&gt; 9 1992 55.8 #&gt; 10 1997 56.5 #&gt; 11 2002 56.8 #&gt; 12 2007 59.7 der zum gleichen Ergebnis führt. Wir würden sagen, dass der dplyr Befehl deutlich leichter zu lesen ist. 6.6 Pure, predictable, pipeable Bisher haben wir nur etwas an der Oberfläche von dplyr gekratzt, trotzdem möchten wir auf ein Schlüsselprinzipien hinweisen, die du vielleicht langsam zu schätzen lernen wirst. Die Verben (Hauptfunktionen) von dplyr, wie z.B. filter() und select(), sind pure functions. Dazu schreibt Hadley Wickham Functions chapter in seinem Advanced R Buch (2015): The functions that are the easiest to understand and reason about are pure functions: functions that always map the same input to the same output and have no other impact on the workspace. In other words, pure functions have no side effects: they don’t affect the state of the world in any way apart from the value they return. Tatsächlich sind diese Verben ein Spezialfall reiner Funktionen: sie nehmen als Input und Output denselben Objekttyp an, i.d.R. ein data frame. Die Daten sind für all diese Funktionen aus stets das erste Inputargument. Die dplyr Einführung geht weiter im Kapitel Mehr zu dplyr. "],
["dplyr-single.html", "Kapitel 7 Mehr zu dplyr 7.1 Wo stehen wir? 7.2 Falls noch nicht geschehen: lade dplyr und gapminder", " Kapitel 7 Mehr zu dplyr 7.1 Wo stehen wir? In Kapitel 6, Einführung in dplyr, haben wir bereits zwei sehr wichtige Verben sowie einen Operator vorgestellt und verwendet: filter() zum Auswählen spezieller Zeilen eines Datensatzes select() zum Auswählen spezieller Variablen eines Datensatzes den Pipe-Operator %&gt;%, der das Objekt auf der linken Seite überführt als erstes Funktionsargument der Funktion auf der rechten Seite Wir haben auch die Rolle von dplyr innerhalb des tidyverse besprochen: dplyr ist ein Kernpaket der tidyverse Kollektion von Paketen. Da wir die anderen oft beiläufig benutzen, werden wir stets dplyr und die anderen über library(tidyverse) laden. 7.2 Falls noch nicht geschehen: lade dplyr und gapminder Wir starten wieder mit dem Laden von dplyr (über tidyverse) library(tidyverse) #&gt; ── Attaching packages ────────────────────────────── tidyverse 1.3.0 ── #&gt; ✓ ggplot2 3.3.2 ✓ purrr 0.3.4 #&gt; ✓ tibble 3.0.3 ✓ dplyr 1.0.2 #&gt; ✓ tidyr 1.1.2 ✓ stringr 1.4.0 #&gt; ✓ readr 1.3.1 ✓ forcats 0.5.0 #&gt; ── Conflicts ───────────────────────────────── tidyverse_conflicts() ── #&gt; x dplyr::filter() masks stats::filter() #&gt; x dplyr::lag() masks stats::lag() und gapminder library(gapminder) to be continued … "],
["literatur.html", "Literatur", " Literatur "]
]
