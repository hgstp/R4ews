[{"path":"index.html","id":"r4ews","chapter":"R4ews","heading":"R4ews","text":"Willkommen zu R fÃ¼r EWS (EinfÃ¼hrung die Wahrscheinlichkeitstheorie und Statistik). Im Rahmen dieser Veranstaltung lernen wir erste Schritte, wie wirDaten aufbereiten, visualisieren und analysieren. ğŸš€das wollen wir reproduzierbar und auch wiedervendbar machen. Und vor allem, wollen wir alles mit R machen.Auf dieser Website geht es um verschiedene Aspekte der Datenanalyse.\nEine EinfÃ¼hrung die inferentielle Statistik erfolgt im Rahmen der Vorlesung EinfÃ¼hrung die Wahrscheinlichkeitstheorie und Statistik. Aber auch hier werden wir ein paar der dort vorgestellten Themen aufgreifen und mithilfe von R anwenden, illustrieren, â€¦Auf jeden Fall ist aber das Ziel von R4ews einen Fokus auf die angewandte statistische Ausbildung zu setzen. Datenanalysten verbringen viel Zeit mit der Projekt-Organisation, der Datenbereinigung und -aufbereitung sowie der Kommunikation. Diese TÃ¤tigkeiten kÃ¶nnen einen tiefgreifenden Einfluss auf die QualitÃ¤t und GlaubwÃ¼rdigkeit einer Analyse haben. Dennoch werden diese FÃ¤higkeiten selten vermittelt, obwohl sie wichtig und notwendig sind. R4ews versucht diese LÃ¼cke etwas zu verkleinern.Das Material wird kontinuierlich Ã¼ber das Semester hinweg ergÃ¤nzt/erweitert/verbessert.Letzte Ã„nderung:","code":"\ndate()\n## [1] \"Wed Oct 16 23:45:12 2024\""},{"path":"index.html","id":"beteiligte-personen","chapter":"R4ews","heading":"Beteiligte Personen","text":"","code":""},{"path":"index.html","id":"kolophon","chapter":"R4ews","heading":"Kolophon","text":"Dieses Buch wurde bookdown innerhalb von RStudio geschrieben.Teile des Buches basieren auf stat545.com. Alle Ã„nderungen wurden gemÃ¤ÃŸ der Creative Commons Attribution-ShareAlike 4.0 International License durchgefÃ¼hrt.Wir bedanken uns bei den Autor*innen von stat545 fÃ¼r das groÃŸartige Material.Die aktuelle Version dieses Buchs wurde miterstellt","code":"## Finding R package dependencies ... Done!\n##  setting  value\n##  version  R version 4.4.0 (2024-04-24)\n##  os       macOS 15.0.1\n##  system   aarch64, darwin20\n##  ui       X11\n##  language (EN)\n##  collate  en_US.UTF-8\n##  ctype    en_US.UTF-8\n##  tz       Europe/Berlin\n##  date     2024-10-16\n##  pandoc   3.2 @ /Applications/RStudio.app/Contents/Resources/app/quarto/bin/tools/aarch64/ (via rmarkdown)"},{"path":"index.html","id":"lizenz","chapter":"R4ews","heading":"Lizenz","text":"Diese Arbeit ist lizenziert unter Creative Commons Attribution-ShareAlike 4.0 International License.","code":""},{"path":"install.html","id":"install","chapter":"Kapitel 1 Installieren von R und RStudio","heading":"Kapitel 1 Installieren von R und RStudio","text":"","code":""},{"path":"install.html","id":"r-und-rstudio","chapter":"Kapitel 1 Installieren von R und RStudio","heading":"1.1 R und RStudio","text":"Zuerst benÃ¶tigen wir R, eine freie Softwareumgebung fÃ¼r statistische Berechnungen und Grafiken. Installiert daher R von CRAN, dem Comprehensive R Archive Network. Wir empfehlen euch dringend, eine vorkompilierte BinÃ¤rdistribution zu installieren - benutzt daher die Links oben auf der CRAN Seite!Zuerst benÃ¶tigen wir R, eine freie Softwareumgebung fÃ¼r statistische Berechnungen und Grafiken. Installiert daher R von CRAN, dem Comprehensive R Archive Network. Wir empfehlen euch dringend, eine vorkompilierte BinÃ¤rdistribution zu installieren - benutzt daher die Links oben auf der CRAN Seite!Danach kÃ¶nnt ihr die IDE (steht fÃ¼r integrated development environment) von RStudio installieren. Dabei handelt es sich um eine leistungsfÃ¤hige BenutzeroberflÃ¤che fÃ¼r R.\nRStudio wird mit einem Text Editor geliefert, dass es nicht unmittelbar erforderlich ist, einen separaten, eigenstÃ¤ndigen Editor zu installieren.\nRStudio bietet auch eine direkt Verbindung zu Git(Hub). Um die notwendige Git-Installationen mÃ¼sst ihr euch aber selbst kÃ¼mmern. Wir kommen aber auch spÃ¤ter auf diesen Punkt zurÃ¼ck.\nDanach kÃ¶nnt ihr die IDE (steht fÃ¼r integrated development environment) von RStudio installieren. Dabei handelt es sich um eine leistungsfÃ¤hige BenutzeroberflÃ¤che fÃ¼r R.RStudio wird mit einem Text Editor geliefert, dass es nicht unmittelbar erforderlich ist, einen separaten, eigenstÃ¤ndigen Editor zu installieren.RStudio bietet auch eine direkt Verbindung zu Git(Hub). Um die notwendige Git-Installationen mÃ¼sst ihr euch aber selbst kÃ¼mmern. Wir kommen aber auch spÃ¤ter auf diesen Punkt zurÃ¼ck.Wenn ihr bereits eine vorhandene R und/oder RStudio Installation habt, empfehlen wir euch dringend, beide neu zu installieren und aktuell wie mÃ¶glich zu halten.Wenn ihr R aktualisiert, mÃ¼ssen ihr alle Pakete, die ihr installiert habt, aktualisieren. Das kÃ¶nnt ihr leicht mit dem unten stehenden Befehl machen. MÃ¶glicherweise mÃ¼sst ihr aber auch noch weitere Argumente angeben, wenn ihr z.B. eine nicht standardmÃ¤ÃŸige Bibliothek fÃ¼r eure Pakete verwendet.Bemerkung: Mit diesem Befehl wird nur nach Updates auf CRAN gesucht. Wenn ihr aber ein Paket verwenden, das z.B. nur auf GitHub lebt, mÃ¼sst ihr manuell aktualisieren, z.B. Ã¼ber devtools::install_github().","code":"\nupdate.packages(ask = FALSE, checkBuilt = TRUE)"},{"path":"install.html","id":"funktioniert-alles-am-besten-ausprobieren","chapter":"Kapitel 1 Installieren von R und RStudio","heading":"1.2 Funktioniert alles? Am besten ausprobieren","text":"Startet RStudio auf eurem Computer. Dann solltet ihr ein Fenster Ã¤hnlich zu diesemerhalten. Vermutlich ist euer Fenster nicht dunkel. Aber wer es gerne dunkel mag, soll sich mal unter Tools -> Global -> Appearance die Editor Themes anschauen.Setzt den Cursor das Fenster mit der Bezeichnung Console. Ãœber die Konsole seid ihr der Lage mit R zu interagieren. Erstellt ein einfaches Objekt mit einem Code wie(gefolgt von Enter oder Return). Schaut euch dann das Objekt x genauer , indem ihr x der Konsole eingebt, gefolgt von Enter oder Return. Ihr sollten dann den Wert 8 auf dem Bildschirm sehen. Wenn ja, habet ihr R und RStudio erfolgreich installiert.","code":"\nx <- 2 * 4"},{"path":"install.html","id":"add-on-packages","chapter":"Kapitel 1 Installieren von R und RStudio","heading":"1.3 Add-on packages","text":"R ist ein erweiterbares System und viele Menschen teilen nÃ¼tzlichen Code, den sie als Paket entwickelt haben, Ã¼ber CRAN, GitHub, GitLab oder Ã¤hnlichen Plattformen. Um ein Paket von CRAN zu installieren, z.B. das Paket tidyverse (ist genauer gesagt eine Kollektion von Paketen), kann man folgenden Befehl verwendenMit der Option dependencies = TRUE achten wir darauf, dass alle fÃ¼r tidyverse notwendigen Pakete, ebenfalls installiert werden.","code":"\ninstall.packages(\"tidyverse\", dependencies = TRUE)"},{"path":"install.html","id":"rstudio-primers","chapter":"Kapitel 1 Installieren von R und RStudio","heading":"1.4 RStudio Primers","text":"Ein guter Startpunkt fÃ¼r verschiedene R Themen sind die RStudio primers, die aktuell nur als Paket zur lokallen Installation verfÃ¼gbar sind. DafÃ¼r kann man folgenden Befehl verwenden, um Pakete, die nicht auf CRAN verfÃ¼gbar sind, zu installieren.Um die Tutorials aufzurufen muss man auch das Paket â€œlearnrâ€ installieren.","code":"\ninstall.packages(\"remotes\")\nremotes::install_github(\"hgstp/idsst.rtutorials\")\ninstall.packages(\"lernr\")\nlibrary(\"learnr\")"},{"path":"install.html","id":"aufgabe","chapter":"Kapitel 1 Installieren von R und RStudio","heading":"1.5 Aufgabe","text":"Wir beginnen mit den Grundlagen. Hier wird unterschieden Programming und Visualization Basics.Programming Basics beinhaltet Grundlagen zu Objekttypen, Funktionen und deren Argumente, Listen (eigentlich sind alle Objekte Listen, nur unterschiedlich speziell) und Paketen.Visualization Basics erklÃ¤rt erste Schritte der Verwendung des ggplot2 Pakets, mit dem wir uns spÃ¤ter noch eingehend beschÃ¤ftigen werden.Bearbeitet eigenstÃ¤ndig den Basics Primer. DafÃ¼r verwenden wir den Befehl","code":"\nlearnr::run_tutorial(\"programming-basics\", package = \"idsst.rtutorials\")"},{"path":"r-basics.html","id":"r-basics","chapter":"Kapitel 2 R Basics und ArbeitsablÃ¤ufe","heading":"Kapitel 2 R Basics und ArbeitsablÃ¤ufe","text":"","code":""},{"path":"r-basics.html","id":"ein-paar-grundlagen-fÃ¼r-das-arbeiten-mit-r","chapter":"Kapitel 2 R Basics und ArbeitsablÃ¤ufe","heading":"2.1 Ein paar Grundlagen fÃ¼r das Arbeiten mit R","text":"Aktueller Stand: Ihr habt bereits den Basics Primer absolviert und nun wollt ihr anfangen mit eurer RStudio/R Installation zu arbeiten.Es geht los indem ihr RStudio startet. Beachtet dabei die Standardfensterbereiche:Console (links)Environment / History (oben rechts)Files / Plots / Packages / Help (unten rechtes)Bemerkung: Die Standardanordnung der Fenster kÃ¶nnt ihr neben vielen anderen Dingen nach deinen Vorstellungen Ã¤ndern/anpassen: Customizing RStudio.Geht nun die Konsole um mit R zu interagieren. Erstellt die nachfolgende Zuordnung und schau euch das erstellte Objekt genauer :Alle R Befehle, die ein Objekte erstellen (â€œZuweisungenâ€), haben die Form:Ihr werdet im weiteren Verlauf noch viele Zuweisungen vornehmen. TatsÃ¤chlich ist es etwas mÃ¼hsam den Operator <- zu tippen. Seid aber trotzdem nicht faul und benutzt stattdessen einfach = - auch wenn das theoretisch funktionieren wÃ¼rde. Aber spÃ¤ter kann die Verwendung von = fÃ¼r Zuweisungen zu Verwirrung fÃ¼hren. Verwendet stattdessen RStudio die Tastenkombination: Alt + - (Minuszeichen) bzw. option + -.Beachtet, dass RStudio automatisch <- mit Leerzeichen umgibt, eine nÃ¼tzliche Codeformatierung darstellt. Code ist selbst einem guten Tag eher schlecht zu lesen. GÃ¶nnt daher euren Augen eine Pause und verwende (ausreichend) Leerzeichen.RStudio bietet viele praktische TastaturkÃ¼rzel . Eine Ãœbersicht erhÃ¤lt man auch mit Alt+Shift+K bzw. option+Shift+K.Objektnamen dÃ¼rfen nicht mit einer Ziffer beginnen und bestimmte andere Zeichen wie ein Komma oder ein Leerzeichen nicht enthalten. Es ist daher ratsam, sich eine Konvention zur Abgrenzung von WÃ¶rtern Objektnamen zu Ã¼berlegen.Wir werden stets die erste Variante verwenden.FÃ¼hrt nun nachfolgenden Befehl ausIn eurem Workspace ist nun das Objekt this_is_a_really_long_name vorhanden. Probiert mithilfe dieses Objekts die VervollstÃ¤ndigungsfunktion von RStudio aus:Gib die ersten paar Zeichen ein, drÃ¼cke anschlieÃŸend die TAB Taste, fÃ¼gen weitere Zeichen hinzu, bis Eindeutigkeit hergestellt ist(wenn sonst wenig deinem Workspace ist, dann ist das schnell erreicht), und drÃ¼cke dann die Eingabetaste.FÃ¼hrt nun den Befehlaus, um anschlieÃŸend den Inhalt des Objekts anzuzeigen.Die Objekte zwei.hoch.drei und zwei_Hoch_drei sind natÃ¼rlich nicht vorhanden und somit fÃ¼hren beide Befehle zu einer Fehlermeldung. Man muss also absolut exakt sein mit seinen Befehlen.R verfÃ¼gt Ã¼ber eine Ã¼berwÃ¤ltigende Sammlung eingebauter Funktionen, die nach folgendem Schema aufgerufen werden:Als nÃ¤chstes wollen wir die Funktion seq() verwenden, die regulÃ¤re Zahlensequenzen erzeugt. Dabei wollen wir noch ein weiteres hilfreiches Feature von RStudio demonstrieren.Tippt se und drÃ¼cke dann die TAB Taste. einem Pop-Fenster werden dir mÃ¶gliche VervollstÃ¤ndigungen angezeigt. Der Befehl seq() kann dann durch weiteres Tippen oder Ã¼ber die AuswahlmÃ¶glichkeit (Pfeiltasten nach oben/unten) festgelegt werden. Zu jeder AuswahlmÃ¶glichkeit wird auch noch eine Kurzform der entsprechenden Hilfeseite angezeigt.FÃ¼gt man jetzt die Ã¶ffnende runde Klammer hinzu, wird die zugehÃ¶rige schlieÃŸende runde Klammer automatisch hinzugefÃ¼gt. Tippe anschlieÃŸend 1, 10 (das geschieht automatisch innerhalb der runden Klammern) und Return. RStudio beendet auch den Klammerausdruck fÃ¼r dich. RStudio ğŸš€Der letzte Befehl zeigt auch ganz gut, wie R Funktionsargumente auflÃ¶st. Sie kÃ¶nnen immer der Form Name = Wert angeben werden. Aber der Name muss nicht angegeben werden, wie man sieht. solchen FÃ¤llen versucht R, nach der Position aufzulÃ¶sen. wird oben angenommen, dass wir eine Sequenz bei 1 starten wollen, also = 1, und diese bis 10 laufen soll, daher = 10. Da wir keine Schrittweite angegeben haben, wird der Standardwert fÃ¼r verwendet, der diesem Fall gleich 1 ist.Bei Funktionen, die man oft aufruft, kann man gut diese AuflÃ¶sung nach Position fÃ¼r das erste und vielleicht auch das zweite Argument verwenden. Danach ist es aber ratsam immer mit Name = Wert zu arbeiten um falsche Zuweisungen (verschiedene Argumente kÃ¶nnen vom gleichen Typ sein, sodass eine falsche Zuweisung nicht automatisch zu einer Fehlermeldung fÃ¼hrt) zu vermeiden.Analog zur UnterstÃ¼tzung mit den runden Klammern, werden auch schlieÃŸende AnfÃ¼hrungszeichen automatisch ergÃ¤nzt, wie man folgendem Beispiel sieht.Nach einer Zuweisung wird der entsprechende Wert des Objekts nicht angezeigt. Daher ist man vielleicht dazu geneigt das Objekt gleich erneut aufzurufenDiese typische Aktion kann verkÃ¼rzt werden, indem die Zuweisung Klammern gesetzt wird, wodurch die Zuweisung und ein Befehl â€œDrucke auf den Bildschirmâ€ erfolgen.Nicht alle Funktionen haben (oder erfordern) Argumente:Schaut euch nun euren Workspace - unter Environment (vermutlich im Fenster rechts oben) seht ihr den Inhalt eures Workspace. Der Workspace ist der Ort, dem sich benutzerdefinierte Objekte ansammeln. Eine Liste dieser Objekte kÃ¶nnt ihr auch mit diesen Befehlen erhalten:Wenn ihr nun das Objekt mit dem Namen y entfernen mÃ¶chtet, kÃ¶nnt ihr das wie folgt machen:Alles lÃ¶schen kann man mit dem Befehloder man klickt auf den Besen im Environment Fenster von RStudio.","code":"\nx <- 3 * 4\nx\n## [1] 12\nobjectName <- valuei_use_snake_case\nother.people.use.periods\nevenOthersUseCamelCase\nthis_is_a_really_long_name <- 2.5\nzwei_hoch_drei <- 2 ^ 3\nzwei.hoch.drei\n## Error: object 'zwei.hoch.drei' not found\nzwei_Hoch_drei\n## Error: object 'zwei_Hoch_drei' not found\nfunctionName(arg1 = val1, arg2 = val2, ...)\nseq(1, 10)\n##  [1]  1  2  3  4  5  6  7  8  9 10\nyo <- \"hello world\"\ny <- seq(1, 10)\ny\n##  [1]  1  2  3  4  5  6  7  8  9 10\n(y <- seq(1, 10))\n##  [1]  1  2  3  4  5  6  7  8  9 10\ndate()\n## [1] \"Wed Oct 16 23:45:14 2024\"\nobjects()\n## [1] \"this_is_a_really_long_name\" \"x\"                         \n## [3] \"y\"                          \"yo\"                        \n## [5] \"zwei_hoch_drei\"\nls()\n## [1] \"this_is_a_really_long_name\" \"x\"                         \n## [3] \"y\"                          \"yo\"                        \n## [5] \"zwei_hoch_drei\"\nrm(y)\nrm(list = ls())"},{"path":"r-basics.html","id":"workspace-und-working-directory","chapter":"Kapitel 2 R Basics und ArbeitsablÃ¤ufe","heading":"2.2 Workspace und working directory","text":"Ziemlich schnell wird der Fall eintreten, dass ihr mit eurer R Arbeit (z.B. Bearbeitung eines Hausaufgaben Projekts) noch nicht fertig seid obwohl es Zeit die Arbeit fÃ¼r heute zu beenden. NatÃ¼rlich man aber zu einem spÃ¤teren Zeitpunkt mit der Analyse weitermachen, wo man gerade aufgehÃ¶rt hat.Etwas spÃ¤ter wird es ein, dass ihr zudem auch noch Daten R einlest und damit anschlieÃŸend numerische Ergebnisse erzeugt, die ihr dann auch wieder exportieren wollt.Und nochmal spÃ¤ter wird es (vielleicht) sein, dass ihr R gleichzeitig mehreren Analysen arbeitest, die ihr aber unbedingt getrennt halten wollt/sollt.Um diese Situationen zu bewÃ¤ltigen, mÃ¼sst ihr zwei Entscheidungen treffen:betrachtest du deiner Analyse als â€œErgebnisâ€, d.h. wirst du dauerhaft speichern?betrachtest du deiner Analyse als â€œErgebnisâ€, d.h. wirst du dauerhaft speichern?Wo â€œlebtâ€ deine Analyse?Wo â€œlebtâ€ deine Analyse?","code":""},{"path":"r-basics.html","id":"workspace-.rdata","chapter":"Kapitel 2 R Basics und ArbeitsablÃ¤ufe","heading":"2.2.1 Workspace, .RData","text":"Ihr startet gerade eure R Reise âœˆï¸. Daher wÃ¤re es okay, wenn ihr euren Workspace als das â€œErgebnisâ€ eurer Analyse betrachtet. Ziemlich bald, solltet ihr aber davon (vielleicht durch uns) Ã¼berzeugt sein, dass eure R Skripte das Ergebnis eurer Analyse sind (beiden FÃ¤llen hÃ¤ngt das Ergebnis vermutlich auch von Input Daten ab).Die Daten zusammen mit eurem R Code erlauben es euch jederzeit alle Ergebnisse zu reproduzieren und das ist die entscheidende Eigenschaft.Betrachtest man seinen Workspace als das Ergebnis der Analyse, dann muss man bei einem erneuten Analysedurchlauf (leicht verÃ¤nderte Aufgabenstellung, â€¦) entweder erneut eine Menge Tippen (natÃ¼rlich fehleranfÃ¤llig ist) oder die R History nach den nÃ¶tigen Befehlen durchwÃ¼hlen.\nStatt â€œbecoming expert managing R historyâ€ als Ziel zu haben, solltet ihr euren R Code sauber ein Skript speichern, sodass er fÃ¼r weitere Analysen zur VerfÃ¼gung steht.Der Workspace Ansatz wird allerdings â€œbegÃ¼nstigt/gefÃ¶rdertâ€ durch die Tatsache, dass RStudio beim Beenden der Session automatisch wissen ob der Workspace gespeichert werden soll. Das wollen wir mal ausprobieren.Beendet R/RStudio, entweder Ã¼ber das MenÃ¼ oder tippt q() die Konsole. Dann erhaltet ihr eine Eingabeaufforderung wie diese:Save workspace image ~/.Rdata?Merkt euch welchem Verzeichnis die Datei gespeichert wird und dann klickt auf Save.Geht das Verzeichnis mit dem gespeicherten Workspace Image und kontrolliert ob die Datei .RData vorhanden ist. Ihr werdet dort auch die Datei .Rhistory finden, die alle Befehle eurer letzten Sitzung enthÃ¤lt.Nun starte erneut RStudio. der Konsole seht ihr einen Befehl, der ungefÃ¤hr aussiehtund angibt, dass euer gespeicherter Workspace wiederhergestellt wurde. Unter Environment solltet ihr die gleichen Objekte wie zuvor sehen. Im Fenster History findet ihr die gespeicherten Befehle aus der letzten Sitzung.Aber diese Art, analytische Arbeit zu beginnen und zu beenden, wÃ¼rde nicht lange gut gehen. Daher fangen wir gleich mal damit die automatische Nachfrage nach dem Speichern des Workspaces abzuwÃ¤hlen. Ã–ffnet dazu die Global Options (unter Tools)und setzt Save workspace .RData exit auf Never. Nun werdet ihr nie mehr gefragt ob der Workspace gespeichert werden soll. Sehr wohl werdet ihr aber weiterhin gefragt ob ungesicherte Ã„nderungen euren R Skript gespeichert werden sollen, sobald ihr RStudio beenden wollt.","code":"[Workspace loaded from ~/.RData]"},{"path":"r-basics.html","id":"working-directory","chapter":"Kapitel 2 R Basics und ArbeitsablÃ¤ufe","heading":"2.2.2 Working directory","text":"Jeder Prozess, der auf einem Computer lÃ¤uft, hat einen Bezug zu seinem â€œArbeitsverzeichnisâ€. R ist dies der Ort, dem R standardmÃ¤ÃŸig nach Dateien suchen wÃ¼rde oder der Ort wo alle Dateien, die ihr auf die Festplatte schreiben wollt, abgelegt werden. MÃ¶glicherweise ist euer aktuelles Arbeitsverzeichnis das Verzeichnis, das ihr gerade untersucht habt um die .RData Datei zu finden.Das aktuelle Arbeitsverzeichnis kÃ¶nnt ihr euch anzeigen lassen mit dem BefehlAber es wird auch oben der RStudio Konsole direkt angezeigt.Es wÃ¤re schon, wenn das Arbeitsverzeichnis AbhÃ¤ngigkeit vom jeweils zu bearbeitenden Projekt leicht sinnvoll gesetzt werden kÃ¶nnte. Im nÃ¤chsten Abschnitt sehen wir, dass genau das mÃ¶glich ist.","code":"\ngetwd()"},{"path":"r-basics.html","id":"rprojs","chapter":"Kapitel 2 R Basics und ArbeitsablÃ¤ufe","heading":"2.3 RStudio Projects","text":"Alle zu einem Projekt gehÃ¶renden Dateien - Eingabedaten, R Skripte, Analyseergebnisse, Grafiken - einem Ort zu bÃ¼ndeln, ist eine sinnvolle Praxis, dass RStudio Ã¼ber seine Projects genau da ermÃ¶glicht.Lasst uns ein Projekt fÃ¼r den Kurs anlegen. Dazu wÃ¤hlen wir oben rechts im RStudio Fenster Project: (None) -> New ProjectDanach wÃ¤hlen wir New Directory -> New Project und geben abschlieÃŸend einen passenden Verzeichnisnamen ein (dabei beachten wir den Speicherort des neuen Verzeichnisses)Wir nehmen nun , dass ihr ein RStudio Projekt angelegt und auch geÃ¶ffnet habt. Als NÃ¤chstes benÃ¶tigen wir nun ein wenig R Code. Dazu tippen wir den unten stehenden Code (ausnahmsweise) die KonsoleJetzt nehmen wir mal , das wÃ¤re ein guter Start einer Analyse, die wir durchfÃ¼hren wollen. Daher wÃ¼rdest ihr das Ergebnis gerne abspeichern. Unter History kÃ¶nnt ihr alle obigen Befehle markieren und anschlieÃŸend Source klicken. Daraufhin wird sich ein neues Fenster mit einem R Skript - das natÃ¼rlich die Befehle enthÃ¤lt - Ã¶ffnen. Das Skript kÃ¶nnt ihn anschlieÃŸend abspeichern, und standardmÃ¤ÃŸig wird es den Projektordner gespeichert werden (aber natÃ¼rlich kÃ¶nntest man den Speicherort dieser Stelle auch Ã¤ndern/frei wÃ¤hlen).Nun beendet das Projekt (Close Project der rechten oberen Ecke). Wer , kann sich noch den Inhalt dess Projektordners anschauen, z.B. das PDF Ã¶ffnen.Danach Ã¶ffnet ihr das Projekt wieder. Euch sollte auffallen, dass alles dem Zustand ist, wie ihr das Projekt verlassen habt, z.B. Objekte im Arbeitsbereich, die Befehlshistorie, welche Dateien zur Bearbeitung geÃ¶ffnet sind, wo wir uns im Dateisystembrowser befinden, das Arbeitsverzeichnis fÃ¼r den R-Prozess usw. dies sind gute Dinge ğŸ˜.Nun Ã¤ndert ein paar Dinge eurem Code. Sinnvoll wÃ¤re z.B. Anfang die StichprobenlÃ¤nge n zu definieren und z.B. auf n <- 40 setzen. Dann\nsollten alle festen 40er Werte durch n ersetzt werden. AnschlieÃŸend kann man noch ein paar andere Dinge Ã¤ndern, z.B. die Steigung b, die Farbe der Linie â€¦ auch immer. Danach kÃ¶nnt ihr die verschiedenen MÃ¶glichkeiten ausprobieren, wie ihr den Code erneut ausfÃ¼hren kÃ¶nnt:Zeile fÃ¼r Zeile ausfÃ¼hren, indem ihr entweder das TastenkÃ¼rzel Command + Enter oder die Maus (auf â€œRunâ€ klicken der oberen rechten Ecke des Editor-Fensters) verwendet.Zeile fÃ¼r Zeile ausfÃ¼hren, indem ihr entweder das TastenkÃ¼rzel Command + Enter oder die Maus (auf â€œRunâ€ klicken der oberen rechten Ecke des Editor-Fensters) verwendet.Das gesamte Dokument durchlaufen lassen, entweder per TastenkÃ¼rzel Shift + Command +S oder Maus (klicken auf â€œSourceâ€ der oberen rechten Ecke des Editor-Fensters).Das gesamte Dokument durchlaufen lassen, entweder per TastenkÃ¼rzel Shift + Command +S oder Maus (klicken auf â€œSourceâ€ der oberen rechten Ecke des Editor-Fensters).AnschlieÃŸend kÃ¶nnt ihr euch das PDF anschauen und die Ã„nderungen bewundern.Irgendwann werdet ihr (vielleicht) vor der Aufgabe stehen, eine Grafik neu zu gestalten oder einfach nur verstehen zu wollen, woher sie stammt. Wenn ihr (relevante) Grafiken einer Datei speichert (Ã¼ber R Code und niemals Ã¼ber die Maus oder die Zwischenablage) und dabei sinnvolle Dateinamen/Speicherorte (innerhalb des zugehÃ¶rigen Projekts) benutzt, werden euch solche Aufgaben nie vor groÃŸe Probleme stellen âœ….","code":"\na <- 2\nb <- -3\nsig_sq <- 0.5\nx <- runif(40)\ny <- a + b * x + rnorm(40, sd = sqrt(sig_sq))\n(x_n <- mean(x))\n## [1] 0.449\nwrite(x_n, \"mittelwert_x.txt\")\nplot(x, y)\nabline(a, b, col = \"purple\")\ndev.print(pdf, \"scatterplot.pdf\")\n## quartz_off_screen \n##                 2"},{"path":"r-basics.html","id":"zu-guter-letzt","chapter":"Kapitel 2 R Basics und ArbeitsablÃ¤ufe","heading":"2.4 zu guter Letzt","text":"Es ist Ã¼blich, R-Skripte mit einem .R oder .r Suffix zu speichern. Befolgt diese Konvention, auÃŸer ihr habt einen sehr auÃŸergewÃ¶hnlichen Grund, es nicht zu tun.Kommentare beginnen mit einem oder mehreren #-Symbolen. Verwendet Kommentare. RStudio hilft dir dabei ausgewÃ¤hlte Zeilen mit Ctrl+Shift+C (Windows und Linux) oder command+Shif+C (Mac) zu kommentieren oder vorhandene Kommentare wieder zu entfernen.Dieser Workflow wird euch Zukunft gute Dienste leisten:erstelle ein RStudio Projekt fÃ¼r jedes neue R â€œVorhabenâ€speichere alle Input Dateien innerhalb des Projekts (wir werden bald Ã¼ber den Import sprechen)bewahre alle Skripte zu diesem Projekt dort auf; bearbeite sie und fÃ¼hren sie dort ausspeichere den Output innerhalb des Projekts (wie z.B. das PDF im letzten Beispiel)Ihr solltet vermeiden die Maus fÃ¼r Teile des Workflows zu verwenden, wie z.B. das Laden eines Datensatzes oder das Speichern einer Grafik. Das ist sehr wichtig fÃ¼r die Reproduzierbarkeit und um im Nachhinein feststellen zu kÃ¶nnen, wie eine numerische Tabelle oder eine PDF-Datei tatsÃ¤chlich erzeugt wurde.","code":""},{"path":"version-control.html","id":"version-control","chapter":"Kapitel 3 Git, GitHub, and RStudio","heading":"Kapitel 3 Git, GitHub, and RStudio","text":"Versionskontrolle sollte nach dem Besuch der EinfÃ¼hrung die Programmierung (nicht zutreffend diesem Jahr) bereits kein unbekanntes Thema mehr sein. Falls doch, solltet ihr mit ein paar Worten zu Git und GitHub von Jenny Byran (Autorin von STAT 545) starten.Ziel dieses Abschnitts wird es sein, dass ihreinen GitHub Account anlegt (falls nicht schon vorhanden)einen GitHub Account anlegt (falls nicht schon vorhanden)Git auf eurem Computer installiertGit auf eurem Computer installierteuch bei Git vorstellteuch bei Git vorstellteure Verbindung zu GitHub testeteure Verbindung zu GitHub testetabschlieÃŸend noch RStudio ins Spiel bringt und RStudio mit Git und GitHub verbindetabschlieÃŸend noch RStudio ins Spiel bringt und RStudio mit Git und GitHub verbindetBemerkung: Unter 5. werdet ihr ermutigt eure GitHub Zugangsdaten auf eurem Computer zu speichern. Dieser Schritt ist sehr empfehlenswert. Dazu findet ihr auch ein kurzes Video im Moodle Kurs zu EWS.âš ï¸\nDie Verwendung von GitHub ist eine generelle Empfehlung. Ein GitHub Account kann verschiedenen Situationen hilfreich sein, insbesondere auch nach dem Studium.\nWÃ¤hrend der Veranstaltung werdet ihr aber mit eurem LRZ GitLab Account arbeiten.Das Buch Happy Git GitHub useR enthÃ¤lt noch viele weitere hilfreiche Git/GitHub Informationen. Auf manche kommen wir vielleicht im Laufe des Kurses noch zu sprechen. Andere sind vielleicht zu einem spÃ¤teren Zeitpunkt interessant, wenn ihr anspruchsvolleren Git Projekten arbeitet.","code":""},{"path":"r-markdown.html","id":"r-markdown","chapter":"Kapitel 4 R Markdown","heading":"Kapitel 4 R Markdown","text":"AusgewÃ¤hlte Hausaufgaben werdet ihr als R Markdown Dokument abgeben. R Markdown ist eine sehr zugÃ¤ngliche Methode zur Erstellung von Dokumenten, die Prosa Text mit R-Code und den daraus erzeugten Berechnungen, Tabellen und Abbildungen kombinieren.Ein mÃ¶glicher R Markdown Workflow, der eine Interaktion mit Git, GitHub, und RStudio beinhaltet, wird auf der SeiteTest drive R Markdownvorgestellt.","code":""},{"path":"data-intro.html","id":"data-intro","chapter":"Kapitel 5 Letzte Vorbereitungen â€¦","heading":"Kapitel 5 Letzte Vorbereitungen â€¦","text":"Jetzt ist es der Zeit, sich zu vergewissern welchem Verzeichnis ihr auf eurem Computer ihr euch befindet. Falls ihr ein RStudio Projekt nutzt, sollte diese Frage leicht zu beantworten sein. Falls ihr trotzdem unsicher seid, gebt getwd() der Konsole ein, um das aktuelle Arbeitsverzeichnis zu sehen.Alle nachfolgenden Code Beispiele wollen wir einer .R Datei abspeichern, die dann im aktuellen Arbeitsverzeichnis gespeichert werden soll. Idealerweise geben wir dieser Datei noch einen Namen, wie etwa datenanalyse_teil_1.R, der uns schon viel Ã¼ber den mÃ¶glichen Inhalt erzÃ¤hlt.\nAlternativ kÃ¶nnen wir alle Befehle natÃ¼rlich auch eine R Markdown Datei schreiben, siehe Test drive R Markdown.Prinzipiell geht es den folgenden Abschnitten um Datenmanagement. Es werden aber auch immer wieder ein paar Grafiken zu sehen sein. Dies ist aber kein Problem, da ihr ja bereits den Data Visualization Basics Primerbesucht habt und somit den nÃ¶tigen Background besitzt.","code":""},{"path":"data-intro.html","id":"data-frames-sind-fantastisch","chapter":"Kapitel 5 Letzte Vorbereitungen â€¦","heading":"5.1 Data frames sind fantastisch","text":"Das Standardformat fÃ¼r Daten ist ein data frame. Die meisten Funktionen zur Inferenz, Modellierung und graphischen Darstellung erwarten, dass ihnen Ã¼ber ein data = Argument ein data frame Ã¼bergeben wird. Dies gilt fÃ¼r Funktion aus der R Basisdistribution schon seit langem.Die als tidyverse bekannte Kollektion von Paketen geht noch einen Schritt weiter und priorisiert ausdrÃ¼cklich die Verarbeitung von data frames. TatsÃ¤chlich priorisiert tidyverse eine besondere Art von data frames, die als â€œtibbleâ€ bezeichnet wird.Data frames - im Gegensatz zu allgemeinen Arrays oder speziell Matrizen - kÃ¶nnen Variablen unterschiedlicher Typen enthalten, wie z.B. Textdaten (Subjekt-ID oder Name), quantitative Daten (Anzahl der weiÃŸen BlutkÃ¶rperchen) und qualitative/kategoriale Informationen (behandelt vs.Â unbehandelt). Genauer gesagt kÃ¶nnen data frames unterschiedliche Spalten aus unterschiedlichen Datentypen bestehen. Innerhalb einer Spalte mÃ¼ssen aber alle EintrÃ¤ge vom gleichen Typ sein.Daten aus einer Datenanalyse bestehen immer aus mehr als einem Datentyp. Aus diesem Grund eigenen sich Matrizen oder Arrays nicht zur Datenanalyse, da man sonst mit verschiedenen, unverbundenen Objekten (Matrizen, Arrays) arbeiten mÃ¼sste und diese nur schwer koordinieren kann.","code":""},{"path":"data-intro.html","id":"gapminder-data","chapter":"Kapitel 5 Letzte Vorbereitungen â€¦","heading":"5.2 Gapminder data","text":"Wir werden mit einem Teil der Daten aus dem Gapminder-Projektarbeiten. Die Daten sind im gapminder Paket enthalten, welches wir Ã¼ber CRAN installieren kÃ¶nnen:Um die Daten zu verwenden, mÃ¼ssen wir das Paket natÃ¼rlich auch noch ladenGapminder wurde von Hans, Anna und Ola Rosling gegrÃ¼ndet. Auf der Webseite des Projekts findet man nicht nur viel Informatives, sondern auch sehr UnterhaltsamesLeider ist Hans Rosling bereits 2017 verstorben.","code":"\ninstall.packages(\"gapminder\")\nlibrary(gapminder)"},{"path":"data-intro.html","id":"die-gapminder-daten-sind-ein-tibble","chapter":"Kapitel 5 Letzte Vorbereitungen â€¦","heading":"5.3 Die gapminder Daten sind ein â€œtibbleâ€","text":"Durch das Laden des gapminder Pakets haben wir nun Zugriff auf einen Datenobjekt mit demselben Namen. Schauen wir uns mithilfe der Funktion str() mal die Struktur dieses Objekts .str() liefert eine vernÃ¼nftige Beschreibung von fast allem, und im schlimmsten Fall kann tatsÃ¤chlich auch nichts â€œSchlimmesâ€ passieren. Aus dem Output erkennen wir, dass der Datensatz 1704 Beobachtungen enthÃ¤lt.Auf der anderen Seite hÃ¤tten wir durch direkten Aufruf von gapminder den Inhalt auch direkt auf den Bildschirm schreiben kÃ¶nnen. Aber vielleicht habt ihr schon mal einen grÃ¶ÃŸeren Datensatz aufgerufen und zÃ¶gert nun etwas, da groÃŸe DatensÃ¤tze tendenziell einfach die Konsole fÃ¼llen und nur sehr wenig Einblick bieten.Tidyverse bietet eine spezielle data frame Variante : ein tibble. gapminder ist ein tibble. Das sieht man auch, wenn man sich die Klasse dieses Objekts anzeigen lÃ¤sstEs ist immer noch ein regulÃ¤res data frame, aber zusÃ¤tzlich eben auch ein tibble.Wenn wir nun gapminder einfach auf den Bildschirm ausgeben, sehen wir, dass die Konsole nicht voll lÃ¤uft.Dies ist der erste groÃŸe Vorteil eines tibbles gegenÃ¼ber einem data frame.Wenn ihr mit einem reinen data frame arbeitet - und dieses Feature gefÃ¤llt euch - kÃ¶nnt ihr es mit as_tibble() ein tibble transformieren.Weitere MÃ¶glichkeiten, grundlegende Informationen zu einem data frame abzufragen:Ein bisschen deskriptive Statistik zum Inhalt eines data frames erhÃ¤lt man mit der summary() Funktion:Bemerkung: summary() ist eine generische Funktion. FÃ¼r eine gegebene Klasse (des Inputs) bestimmt die generische Funktion die passende Methode. Die Funktion summary() besitzt z.B. die folgenden Methoden:Obwohl wir uns formell noch nicht eingehender mit der Visualisierung beschÃ¤ftigt haben, ist es wichtig ein paar Grafiken zu erzeugen um einen ersten Eindruck Ã¼ber den Datensatz zu bekommen. Auf der anderen Seite werden die Grafiken aber auch nicht (viel) aufwendiger als die Beispiele im Visualisation Basics Primer.Interessant ist z.B. der zeitliche Verlauf der Lebenserwartungoder der Zusammenhang zwischen dem GDP (gross domestic product) und der LebenserwartungGrafiken dieser Art werden wir zu einem spÃ¤teren Zeitpunkt noch genauer behandeln. Dann sprechen wir natÃ¼rlich auch intensiv Ã¼ber deren Inhalt.Wir schauen uns nochmal die Ausgabe von str() , um darÃ¼ber zu sprechen, ein data frame genau ist.Ein data frame ist ein Sonderfall einer Liste. R verwendet Listen um gut wie alles ein Objekt aufnehmen zu kÃ¶nnen. Data frames sind nun ein Spezialfall einer Liste, bei dem die LÃ¤nge jedes Listenelements gleich ist.Nehmen wir mal , dass wir eine Beschreibung der Variablenzusammen mit den Daten abspeichern wollen. Dazu kÃ¶nnten wir ein tibbleerzeugen, das die Beschreibungen enthÃ¤lt. Dieses data frame hat nun 6 Zeilen und 2 Spalten. Trotzdem kÃ¶nnen wir es mit gapminder kombinieren, wenn wir beide tibbles einer Liste abspeichern","code":"\nstr(gapminder)\n## tibble [1,704 Ã— 6] (S3: tbl_df/tbl/data.frame)\n##  $ country  : Factor w/ 142 levels \"Afghanistan\",..: 1 1 1 1 1 1 1 1 1 1 ...\n##  $ continent: Factor w/ 5 levels \"Africa\",\"Americas\",..: 3 3 3 3 3 3 3 3 3 3 ...\n##  $ year     : int [1:1704] 1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 ...\n##  $ lifeExp  : num [1:1704] 28.8 30.3 32 34 36.1 ...\n##  $ pop      : int [1:1704] 8425333 9240934 10267083 11537966 13079460 14880372..\n##  $ gdpPercap: num [1:1704] 779 821 853 836 740 ...\nclass(gapminder)\n## [1] \"tbl_df\"     \"tbl\"        \"data.frame\"\ngapminder\n## # A tibble: 1,704 Ã— 6\n##    country     continent  year lifeExp      pop gdpPercap\n##    <fct>       <fct>     <int>   <dbl>    <int>     <dbl>\n##  1 Afghanistan Asia       1952    28.8  8425333      779.\n##  2 Afghanistan Asia       1957    30.3  9240934      821.\n##  3 Afghanistan Asia       1962    32.0 10267083      853.\n##  4 Afghanistan Asia       1967    34.0 11537966      836.\n##  5 Afghanistan Asia       1972    36.1 13079460      740.\n##  6 Afghanistan Asia       1977    38.4 14880372      786.\n##  7 Afghanistan Asia       1982    39.9 12881816      978.\n##  8 Afghanistan Asia       1987    40.8 13867957      852.\n##  9 Afghanistan Asia       1992    41.7 16317921      649.\n## 10 Afghanistan Asia       1997    41.8 22227415      635.\n## # â„¹ 1,694 more rows\nlibrary(tidyverse)\nas_tibble(iris)\n## # A tibble: 150 Ã— 5\n##    Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n##           <dbl>       <dbl>        <dbl>       <dbl> <fct>  \n##  1          5.1         3.5          1.4         0.2 setosa \n##  2          4.9         3            1.4         0.2 setosa \n##  3          4.7         3.2          1.3         0.2 setosa \n##  4          4.6         3.1          1.5         0.2 setosa \n##  5          5           3.6          1.4         0.2 setosa \n##  6          5.4         3.9          1.7         0.4 setosa \n##  7          4.6         3.4          1.4         0.3 setosa \n##  8          5           3.4          1.5         0.2 setosa \n##  9          4.4         2.9          1.4         0.2 setosa \n## 10          4.9         3.1          1.5         0.1 setosa \n## # â„¹ 140 more rows\nnames(gapminder)\n## [1] \"country\"   \"continent\" \"year\"      \"lifeExp\"   \"pop\"       \"gdpPercap\"\nncol(gapminder)\n## [1] 6\nlength(gapminder)\n## [1] 6\ndim(gapminder)\n## [1] 1704    6\nnrow(gapminder)\n## [1] 1704\nsummary(gapminder)\n##         country        continent        year         lifeExp    \n##  Afghanistan:  12   Africa  :624   Min.   :1952   Min.   :23.6  \n##  Albania    :  12   Americas:300   1st Qu.:1966   1st Qu.:48.2  \n##  Algeria    :  12   Asia    :396   Median :1980   Median :60.7  \n##  Angola     :  12   Europe  :360   Mean   :1980   Mean   :59.5  \n##  Argentina  :  12   Oceania : 24   3rd Qu.:1993   3rd Qu.:70.8  \n##  Australia  :  12                  Max.   :2007   Max.   :82.6  \n##  (Other)    :1632                                               \n##       pop             gdpPercap     \n##  Min.   :6.00e+04   Min.   :   241  \n##  1st Qu.:2.79e+06   1st Qu.:  1202  \n##  Median :7.02e+06   Median :  3532  \n##  Mean   :2.96e+07   Mean   :  7215  \n##  3rd Qu.:1.96e+07   3rd Qu.:  9325  \n##  Max.   :1.32e+09   Max.   :113523  \n## \nmethods(summary)\n##  [1] summary.aov                         summary.aovlist*                   \n##  [3] summary.aspell*                     summary.check_packages_in_dir*     \n##  [5] summary.connection                  summary.data.frame                 \n##  [7] summary.Date                        summary.default                    \n##  [9] summary.Duration*                   summary.ecdf*                      \n## [11] summary.factor                      summary.ggplot*                    \n## [13] summary.glm                         summary.hcl_palettes*              \n## [15] summary.infl*                       summary.Interval*                  \n## [17] summary.lm                          summary.loess*                     \n## [19] summary.manova                      summary.matrix                     \n## [21] summary.mlm*                        summary.nls*                       \n## [23] summary.packageStatus*              summary.Period*                    \n## [25] summary.POSIXct                     summary.POSIXlt                    \n## [27] summary.ppr*                        summary.prcomp*                    \n## [29] summary.princomp*                   summary.proc_time                  \n## [31] summary.rlang_error*                summary.rlang_message*             \n## [33] summary.rlang_trace*                summary.rlang_warning*             \n## [35] summary.rlang:::list_of_conditions* summary.srcfile                    \n## [37] summary.srcref                      summary.stepfun                    \n## [39] summary.stl*                        summary.table                      \n## [41] summary.tukeysmooth*                summary.vctrs_sclr*                \n## [43] summary.vctrs_vctr*                 summary.warnings                   \n## see '?methods' for accessing help and source code\nggplot(gapminder, mapping = aes(x = year, y = lifeExp)) +\n         geom_point()\nggplot(gapminder, mapping = aes(x = gdpPercap, y = lifeExp)) +\n  geom_point()\nggplot(gapminder, mapping = aes(x = log(gdpPercap), y = lifeExp)) +\n  geom_point()\nstr(gapminder)\n## tibble [1,704 Ã— 6] (S3: tbl_df/tbl/data.frame)\n##  $ country  : Factor w/ 142 levels \"Afghanistan\",..: 1 1 1 1 1 1 1 1 1 1 ...\n##  $ continent: Factor w/ 5 levels \"Africa\",\"Americas\",..: 3 3 3 3 3 3 3 3 3 3 ...\n##  $ year     : int [1:1704] 1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 ...\n##  $ lifeExp  : num [1:1704] 28.8 30.3 32 34 36.1 ...\n##  $ pop      : int [1:1704] 8425333 9240934 10267083 11537966 13079460 14880372..\n##  $ gdpPercap: num [1:1704] 779 821 853 836 740 ...\nnames(gapminder)\n## [1] \"country\"   \"continent\" \"year\"      \"lifeExp\"   \"pop\"       \"gdpPercap\"\n(desc <- tibble(variables = names(gapminder),\n               desc = c(\"factor with 142 levels\", \"factor with 5 levels\",\n                        \"ranges from 1952 to 2007 in increments of 5 years\",\n                        \"life expectancy at birth, in years\",\n                        \"population\",\"GDP per capita (US$, inflation-adjusted)\")))\n## # A tibble: 6 Ã— 2\n##   variables desc                                             \n##   <chr>     <chr>                                            \n## 1 country   factor with 142 levels                           \n## 2 continent factor with 5 levels                             \n## 3 year      ranges from 1952 to 2007 in increments of 5 years\n## 4 lifeExp   life expectancy at birth, in years               \n## 5 pop       population                                       \n## 6 gdpPercap GDP per capita (US$, inflation-adjusted)\ngapminder_desc <- list(gapminder, desc)\nstr(gapminder_desc)\n## List of 2\n##  $ : tibble [1,704 Ã— 6] (S3: tbl_df/tbl/data.frame)\n##   ..$ country  : Factor w/ 142 levels \"Afghanistan\",..: 1 1 1 1 1 1 1 1 1 1 ...\n##   ..$ continent: Factor w/ 5 levels \"Africa\",\"Americas\",..: 3 3 3 3 3 3 3 3 3 ..\n##   ..$ year     : int [1:1704] 1952 1957 1962 1967 1972 1977 1982 1987 1992 199..\n##   ..$ lifeExp  : num [1:1704] 28.8 30.3 32 34 36.1 ...\n##   ..$ pop      : int [1:1704] 8425333 9240934 10267083 11537966 13079460 14880..\n##   ..$ gdpPercap: num [1:1704] 779 821 853 836 740 ...\n##  $ : tibble [6 Ã— 2] (S3: tbl_df/tbl/data.frame)\n##   ..$ variables: chr [1:6] \"country\" \"continent\" \"year\" \"lifeExp\" ...\n##   ..$ desc     : chr [1:6] \"factor with 142 levels\" \"factor with 5 levels\" \"r\".."},{"path":"data-intro.html","id":"variablen-in-einem-data-frame","chapter":"Kapitel 5 Letzte Vorbereitungen â€¦","heading":"5.4 Variablen in einem data frame","text":"Einzelne Variable einem data frame kann man mit dem Dollarzeichen $ ansprechen. Als Beispiel schauen wir uns die numerische Variable lifeExp genauer .Die summary() Funktion berechnet, neben dem empirischen Mittel, das Five-number summary, bestehend ausdem Minimumdem Minimumdem unteren Quartil (das empirische 0.25 Quantil)dem unteren Quartil (das empirische 0.25 Quantil)dem Mediandem Mediandem oberen Quartil (das empirische 0.75 Quantil)dem oberen Quartil (das empirische 0.75 Quantil)dem Maximumdem MaximumZusÃ¤tzlich wollen wir noch die Verteilung von lifeExp visualisieren und plotten dazu ein Histogramm. Dazu verwenden wir wieder ggplot().Beachtet, dass ihr innerhalb der ggplot2 Funktionen Variablen eines data frames direkt ansprechen kÃ¶nnt. Es ist hier also nicht nÃ¶tig mit dem $ Operator zu arbeiten.Alternativ kÃ¶nnen wir die EintrÃ¤ge eines data frames aber auch Ã¼ber die eckigen Klammern [] indizieren.Dabei spezifiziert der Eintrag links vom Komma die Zeilen und der Wert rechts davon die Spalten. Dies ist hilfreich, wenn man auf einzelne Werte zugreifen . Aber beim Aufruf nur einer Variable (Spalte), ist die $ Notation sicherlich vorteilhafter.Die Variable year ist eine ganzzahlige Variable, aber da es wenige unterschiedliche Werte gibt, funktioniert sie auch ein wenig wie eine kategoriale Variable und es macht Sinn die HÃ¤ufigkeit der einzelnen AusprÃ¤gungen zu zÃ¤hlen.Wir erkennen, dass jedem Jahr die gleiche Anzahl Beobachtungen vorhanden ist. Es handelt sich dabei stets um Beobachtungen aus den gleichen 142 LÃ¤ndern. Dies erkennt man aus dieser Ausgabe aber natÃ¼rlich noch nicht.Die Variablen country und continent enthalten rein kategorische Informationen, die R (hÃ¤ufig) als factor gespeichert werden.Die Levels von continent sind \"Afrika\", \"America\" usw., also Beschreibungen, die man gut lesen und verstehen kann. sollte es sein, wenn man R eine Faktorvariable aufruft. Im Allgemeinen sind die Levels von Menschen lesbare Zeichenfolgen, wie \"male/female\" oder \"control/treated\".Euch sollte aber auch klar sein, dass R diese Information kodierter Form speichert. Als Beispiel kÃ¶nnt ihr euch das Ergebnis von str(gapminder$continent) anschauenFaktorvariablen haben Vor- und Nachteil. Im weiteren Verlauf zeigen wir sowohl die Vor- wie auch die Nachteile. Generell ist aber durchaus , dass die Vorteile Ã¼berwiegen.Als NÃ¤chstes erstellen wir mit der Funktion table() eine HÃ¤ufigkeitstabelle fÃ¼r die Variable count. Die berechneten Werte wollen wir anschlieÃŸend noch mithilfe der Funktion geom_bar() visualisieren. Die zu plottenden HÃ¤ufigkeiten mÃ¼ssen dabei aber nicht die Funktion geom_bar() Ã¼bergeben werden. Die Funktion berechnet selbst (Ã¼ber die statistische Transformation stat_count()) die entsprechenden Werte.den folgenden Abbildungen sehen wir, wie die kodierten Zahlenwerte einer Faktor Variable genutzt werden kÃ¶nnen. Der continent-Faktor lÃ¤sst sich im ggplot2-Paket leicht â€œFacettenâ€ oder Farben abbilden.Die Erstellung von Grafiken mit ggplot2 werden wir noch genauer besprechen. Daher kÃ¶nnt ihr euch also ruhig zurÃ¼cklehnen und die Plots einfach genieÃŸen oder blind kopieren/einfÃ¼gen.ZunÃ¤chst initialisieren wir eine Grafik ohne Inhalt, da nicht gesagt wird, wie die Daten geplottet werden sollen.FÃ¼r die x-Achse wÃ¤hlen wir im nÃ¤chsten Schritt eine log Skala (zur Basis 10).Zum Grafikobjekt p werden nun weitere Komponenten hinzugefÃ¼gt und dann jeweils geplottet","code":"\nhead(gapminder$lifeExp)\n## [1] 28.8 30.3 32.0 34.0 36.1 38.4\nsummary(gapminder$lifeExp)\n##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n##    23.6    48.2    60.7    59.5    70.8    82.6\nggplot(gapminder, mapping = aes(x = lifeExp)) + \n  geom_histogram()\n## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\nsummary(gapminder[,\"lifeExp\"])\n##     lifeExp    \n##  Min.   :23.6  \n##  1st Qu.:48.2  \n##  Median :60.7  \n##  Mean   :59.5  \n##  3rd Qu.:70.8  \n##  Max.   :82.6\nsummary(gapminder$year)\n##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n##    1952    1966    1980    1980    1993    2007\ntable(gapminder$year)\n## \n## 1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 2002 2007 \n##  142  142  142  142  142  142  142  142  142  142  142  142\nclass(gapminder$continent)\n## [1] \"factor\"\nsummary(gapminder$continent)\n##   Africa Americas     Asia   Europe  Oceania \n##      624      300      396      360       24\nlevels(gapminder$continent)\n## [1] \"Africa\"   \"Americas\" \"Asia\"     \"Europe\"   \"Oceania\"\nnlevels(gapminder$continent)\n## [1] 5\nstr(gapminder$continent)\n##  Factor w/ 5 levels \"Africa\",\"Americas\",..: 3 3 3 3 3 3 3 3 3 3 ...\ntable(gapminder$continent)\n## \n##   Africa Americas     Asia   Europe  Oceania \n##      624      300      396      360       24\nggplot(gapminder, aes(x = continent)) + geom_bar()\np <- ggplot(filter(gapminder, \n                   continent != \"Oceania\"), # Daten aus Oceania werden \"herausgefiltert\"\n            aes(x = gdpPercap, y = lifeExp))  \np <- p + scale_x_log10() \n# einen scatterplot\np + geom_point() \n# mit verschiedenen farben fÃ¼r die verschiedenen kontinente\np + geom_point(aes(color = continent))  \n# punkte mit transparenz\np + geom_point(alpha = (1/3), size = 3) + \n  geom_smooth(lwd = 3, se = FALSE) # einen geglÃ¤tteten zusammenhang\n## `geom_smooth()` using method = 'gam' and formula = 'y ~ s(x, bs = \"cs\")'\n# fÃ¼r jeden kontinent einen eigenen plot (innerhalb einer grafik) erzeugen\np + geom_point(alpha = (1/3), size = 3) + \n  facet_wrap(~ continent) + \n  geom_smooth(lwd = 1.5, se = FALSE)\n## `geom_smooth()` using method = 'loess' and formula = 'y ~ x'"},{"path":"data-intro.html","id":"aufgabe-1","chapter":"Kapitel 5 Letzte Vorbereitungen â€¦","heading":"5.5 Aufgabe","text":"Im nÃ¤chsten Abschnitt starten wir mit dem dplyr Paket. Bearbeitet daher zur Vorbereitung die ersten beiden Abschnitte des Work Data Primers:Working Tibbbles zeigt die Verwendung von Tibbles sowie die Verwaltung von tidyverse-Paketen.Isolating Data dplyr zeigt wie ihr Variablen auswÃ¤hlt, Beobachtungen filtert und Werte neu anordnet. Zudem wird der Pipe-Operator von R, %>%, eingefÃ¼hrt.","code":""},{"path":"dplyr-intro.html","id":"dplyr-intro","chapter":"Kapitel 6 EinfÃ¼hrung in dplyr","heading":"Kapitel 6 EinfÃ¼hrung in dplyr","text":"","code":""},{"path":"dplyr-intro.html","id":"einstieg","chapter":"Kapitel 6 EinfÃ¼hrung in dplyr","heading":"6.1 Einstieg","text":"dplyr ist ein Paket zur Datenmanipulation, entwickelt von Hadley Wickham und Romain Francois. Das Paket ist Teil des tidyverse und gehÃ¶rt als Kernpaket zu den Paketen, die Ã¼ber library(tidyverse) geladen werden.Die Autoren des Pakets verstehen dplyr als eine Grammatik der Datenmanipulation. Daher werden die wichtigsten dplyr Funktionen auch oft als Verben bezeichnet. Diese Verben sollen euch helfen, die hÃ¤ufigsten Herausforderungen bei der Datenmanipulation zu lÃ¶sen:mutate(): fÃ¼gt neue Variablen zum Datensatz hinzu, die Funktionen von bestehenden Variablen sindmutate(): fÃ¼gt neue Variablen zum Datensatz hinzu, die Funktionen von bestehenden Variablen sindselect(): wÃ¤hlt Variablen (Spalten) basierend auf ihren Namen ausselect(): wÃ¤hlt Variablen (Spalten) basierend auf ihren Namen ausfilter(): wÃ¤hlt Zeilen basierend auf anzugebenden Bedingungen ausfilter(): wÃ¤hlt Zeilen basierend auf anzugebenden Bedingungen aussummarise(): reduziert mehrere Werte auf eine einzige Zusammenfassungsummarise(): reduziert mehrere Werte auf eine einzige Zusammenfassungarrange(): Ã¤ndert die Reihenfolge der Zeilenarrange(): Ã¤ndert die Reihenfolge der ZeilenDer Ursprung von dplyr liegt einem frÃ¼heren Paket mit dem Namen plyr, das zum Ziel hat die â€œsplit-apply-combineâ€-Strategie der Datenanalyse (Wickham 2011) umzusetzen. Wo plyr noch einen vielfÃ¤ltigen Satz von Ein- und Ausgabetypen abdeckt (z.B. Arrays, data frames, Listen), hat dplyr einen klaren Fokus auf data frames oder tibbles (wenn man sich im tidyverse befindet).dplyr bietet schnelle Alternativen zu den R Standardfunktionen:subset()subset()apply(), sapply(), lapply(), tapply()apply(), sapply(), lapply(), tapply()aggregate()aggregate()split()split().call().call()(), within()(), within()und mehr. Ferner bietet dplyr die MÃ¶glichkeit schnell Ã¼ber Zeilen oder Gruppen von Zeilen zu iterieren, eine schnelle Alternative zur Nutzung von Schleifen darstellt.Wie immer, laden wir zu Beginn\nDer Fokus liegt diesem Abschnitt auf dplyr. Aber da wir immer wieder auch Funktionen aus anderen â€œtidyverse-Paketenâ€ nutzen, laden wir stets tidyverse.ZusÃ¤tzlich laden wir auch noch wieder das gapminder Paket, da wir erneut mit dem gapminder Datensatz arbeiten wollen.","code":"\nlibrary(tidyverse)\n## â”€â”€ Attaching core tidyverse packages â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ tidyverse 2.0.0 â”€â”€\n## âœ” dplyr     1.1.4     âœ” readr     2.1.5\n## âœ” forcats   1.0.0     âœ” stringr   1.5.1\n## âœ” ggplot2   3.5.1     âœ” tibble    3.2.1\n## âœ” lubridate 1.9.3     âœ” tidyr     1.3.1\n## âœ” purrr     1.0.2     \n## â”€â”€ Conflicts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ tidyverse_conflicts() â”€â”€\n## âœ– dplyr::filter() masks stats::filter()\n## âœ– dplyr::lag()    masks stats::lag()\n## â„¹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\nlibrary(gapminder)"},{"path":"dplyr-intro.html","id":"filter-indizieren-von-zeilen","chapter":"Kapitel 6 EinfÃ¼hrung in dplyr","heading":"6.2 filter(): Indizieren von Zeilen","text":"Die Funktion filter() erwartet neben dem Datensatz logische AusdrÃ¼cke als Input und gibt die Zeilen des Datensatzes zurÃ¼ck, fÃ¼r die die Kombination der verwendeten logischen AusdrÃ¼cke ein TRUE ergibt.letzten Befehl erkennt man, dass die verschiedenen logischen AusdrÃ¼cke mit einem & verknÃ¼pft werden. man eine â€œoder Abfrageâ€ gestalten, muss diese einem logischen Ausdruck enthalten sein. kann man mit nachfolgendem Befehl beispielsweise nach allen Beobachtungen aus Ruanda oder Beobachachtungen nach 1979 fragen:man einen Vergleich mit mehr als einem Wert durchfÃ¼hren, kann man natÃ¼rlich alle Abfragen mit einem | verknÃ¼pfen, oder gleich den %% Operator verwenden.Wir erkennen sofort, dass wir mithilfe von dplyr sehr leicht den Datensatz aufteilen kÃ¶nnen, basierend auf der Tatsache ob Bedingungen erfÃ¼llt werden oder eben nicht.Daher solltet ihr unter keinen UmstÃ¤nden mit Befehlen wie diesemarbeiten.Warum ist das eine blÃ¶de Idee?Der Befehl dokumentiert sich nicht selbst. ist das Besondere den Zeilen 241 bis 252?Der Befehl dokumentiert sich nicht selbst. ist das Besondere den Zeilen 241 bis 252?Der Befehl ist fehleranfÃ¤llig. Diese Codezeile wird zu anderen Ergebnissen fÃ¼hren, wenn jemand die Zeilenreihenfolge von gapminder Ã¤ndert, z.B. die Daten vor diesem Befehl erst sortiert.Der Befehl ist fehleranfÃ¤llig. Diese Codezeile wird zu anderen Ergebnissen fÃ¼hren, wenn jemand die Zeilenreihenfolge von gapminder Ã¤ndert, z.B. die Daten vor diesem Befehl erst sortiert.Ganz anders verhÃ¤lt es sich mit diesem BefehlEr erklÃ¤rt sich von selbst und ist ziemlich robust.","code":"\n# beobachtungen mit einer lebenserwartung unter 29 jahren\nfilter(gapminder, lifeExp < 29)\n## # A tibble: 2 Ã— 6\n##   country     continent  year lifeExp     pop gdpPercap\n##   <fct>       <fct>     <int>   <dbl>   <int>     <dbl>\n## 1 Afghanistan Asia       1952    28.8 8425333      779.\n## 2 Rwanda      Africa     1992    23.6 7290203      737.\n# beobachtungen aus ruanda nach dem jahr 1979\nfilter(gapminder, country == \"Rwanda\", year > 1979)\n## # A tibble: 6 Ã— 6\n##   country continent  year lifeExp     pop gdpPercap\n##   <fct>   <fct>     <int>   <dbl>   <int>     <dbl>\n## 1 Rwanda  Africa     1982    46.2 5507565      882.\n## 2 Rwanda  Africa     1987    44.0 6349365      848.\n## 3 Rwanda  Africa     1992    23.6 7290203      737.\n## 4 Rwanda  Africa     1997    36.1 7212583      590.\n## 5 Rwanda  Africa     2002    43.4 7852401      786.\n## 6 Rwanda  Africa     2007    46.2 8860588      863.\nfilter(gapminder, country == \"Rwanda\" | year > 1979)\n## # A tibble: 858 Ã— 6\n##    country     continent  year lifeExp      pop gdpPercap\n##    <fct>       <fct>     <int>   <dbl>    <int>     <dbl>\n##  1 Afghanistan Asia       1982    39.9 12881816      978.\n##  2 Afghanistan Asia       1987    40.8 13867957      852.\n##  3 Afghanistan Asia       1992    41.7 16317921      649.\n##  4 Afghanistan Asia       1997    41.8 22227415      635.\n##  5 Afghanistan Asia       2002    42.1 25268405      727.\n##  6 Afghanistan Asia       2007    43.8 31889923      975.\n##  7 Albania     Europe     1982    70.4  2780097     3631.\n##  8 Albania     Europe     1987    72    3075321     3739.\n##  9 Albania     Europe     1992    71.6  3326498     2497.\n## 10 Albania     Europe     1997    73.0  3428038     3193.\n## # â„¹ 848 more rows\n# beobachtungen aus ruanda und afghanistan\nfilter(gapminder, country %in% c(\"Rwanda\", \"Afghanistan\"))\n## # A tibble: 24 Ã— 6\n##    country     continent  year lifeExp      pop gdpPercap\n##    <fct>       <fct>     <int>   <dbl>    <int>     <dbl>\n##  1 Afghanistan Asia       1952    28.8  8425333      779.\n##  2 Afghanistan Asia       1957    30.3  9240934      821.\n##  3 Afghanistan Asia       1962    32.0 10267083      853.\n##  4 Afghanistan Asia       1967    34.0 11537966      836.\n##  5 Afghanistan Asia       1972    36.1 13079460      740.\n##  6 Afghanistan Asia       1977    38.4 14880372      786.\n##  7 Afghanistan Asia       1982    39.9 12881816      978.\n##  8 Afghanistan Asia       1987    40.8 13867957      852.\n##  9 Afghanistan Asia       1992    41.7 16317921      649.\n## 10 Afghanistan Asia       1997    41.8 22227415      635.\n## # â„¹ 14 more rows\nauswahl <- gapminder[241:252, ]\nfilter(gapminder, country == \"Canada\")"},{"path":"dplyr-intro.html","id":"der-pipe-operator","chapter":"Kapitel 6 EinfÃ¼hrung in dplyr","heading":"6.3 Der Pipe-Operator","text":"Bevor es weitergeht, wollen wir aber den Pipe-Operator, den das Tidyverse aus dem magrittr-Paket von Stefan Bache importiert, vorstellen.\nFigure 6.1: Quelle https://en.wikipedia.org/wiki/The_Treachery_of_Images\nMithilfe des Pipe-Operators ist man der Lage aufeinanderfolgende Befehle von Daten-Operationen strukturiert anzugeben, ohne sie ineinander zu verschachteln. Diese neue Syntax fÃ¼hrt zu Code, der viel einfacher zu schreiben und zu lesen ist.Und sieht er aus: %>%.Das entsprechende RStudio TastenkÃ¼rzel lautet:\nCtrl+Shift+M (Windows), Cmd+Shift+M (Mac).Erstmal ein BeispielMan erkennt sofort, der Befehl ist Ã¤quivalent zu head(gapminder). Der Pipe-Operator nimmt das Objekt auf der linken Seite und leitet es den Funktionsaufruf auf der rechten Seite weiter - er gibt es buchstÃ¤blich als erstes Argument ein.Und natÃ¼rlich kann man der Funktion auf der rechten Seite auch noch weitere Argumente Ã¼bergeben. Um die ersten 3 Zeilen von gapminder auszugeben, kÃ¶nnte man head(gapminder, 3) nutzen oder:Der bisherige Einsatz des Pipe-Operators %>% war sicherlich noch nicht sehr beeindruckend, aber das sollte sich noch Ã¤ndern.","code":"\ngapminder %>% head()\n## # A tibble: 6 Ã— 6\n##   country     continent  year lifeExp      pop gdpPercap\n##   <fct>       <fct>     <int>   <dbl>    <int>     <dbl>\n## 1 Afghanistan Asia       1952    28.8  8425333      779.\n## 2 Afghanistan Asia       1957    30.3  9240934      821.\n## 3 Afghanistan Asia       1962    32.0 10267083      853.\n## 4 Afghanistan Asia       1967    34.0 11537966      836.\n## 5 Afghanistan Asia       1972    36.1 13079460      740.\n## 6 Afghanistan Asia       1977    38.4 14880372      786.\ngapminder %>% head(3)\n## # A tibble: 3 Ã— 6\n##   country     continent  year lifeExp      pop gdpPercap\n##   <fct>       <fct>     <int>   <dbl>    <int>     <dbl>\n## 1 Afghanistan Asia       1952    28.8  8425333      779.\n## 2 Afghanistan Asia       1957    30.3  9240934      821.\n## 3 Afghanistan Asia       1962    32.0 10267083      853."},{"path":"dplyr-intro.html","id":"mit-select-variablen-auswÃ¤hlen","chapter":"Kapitel 6 EinfÃ¼hrung in dplyr","heading":"6.4 Mit select() Variablen auswÃ¤hlen","text":"Verwendet select(), um aus den Daten verschiedene Variablen (Spalten) auszuwÃ¤hlen. Hier kommt eine typische Verwendung von select():und nun noch kombiniert mit head() Ã¼ber den Pipe-Operator:Der letzte Befehl nochmal Worten:â€œNimm gapminder, wÃ¤hle die Variablen year und lifeExp und zeige dann die ersten 4 Zeilen .â€NatÃ¼rlich kann man diese Operationen auch mit R Standardbefehlen ausfÃ¼hren. Die dplyr Befehle haben aber klare Vorteile bei der Lesbarkeit des Codes, wie man im nÃ¤chsten Beispiel sieht.Wir wÃ¤hlen aus dem gapminder Datensatz die Variablen year und lifeExp der Kambodscha BeobachtungenDas gleiche Ergebnis wÃ¼rde man mit diesem R Standardbefehl erhalten:Ich hoffe, ihr stimmt mir zu, dass der dplyr Befehl deutlich leichter zu lesen ist.","code":"\nselect(gapminder, year, lifeExp)\n## # A tibble: 1,704 Ã— 2\n##     year lifeExp\n##    <int>   <dbl>\n##  1  1952    28.8\n##  2  1957    30.3\n##  3  1962    32.0\n##  4  1967    34.0\n##  5  1972    36.1\n##  6  1977    38.4\n##  7  1982    39.9\n##  8  1987    40.8\n##  9  1992    41.7\n## 10  1997    41.8\n## # â„¹ 1,694 more rows\ngapminder %>%\n  select(year, lifeExp) %>%\n  head(4)\n## # A tibble: 4 Ã— 2\n##    year lifeExp\n##   <int>   <dbl>\n## 1  1952    28.8\n## 2  1957    30.3\n## 3  1962    32.0\n## 4  1967    34.0\ngapminder %>%\n  filter(country == \"Cambodia\") %>%\n  select(year, lifeExp)\n## # A tibble: 12 Ã— 2\n##     year lifeExp\n##    <int>   <dbl>\n##  1  1952    39.4\n##  2  1957    41.4\n##  3  1962    43.4\n##  4  1967    45.4\n##  5  1972    40.3\n##  6  1977    31.2\n##  7  1982    51.0\n##  8  1987    53.9\n##  9  1992    55.8\n## 10  1997    56.5\n## 11  2002    56.8\n## 12  2007    59.7\ngapminder[gapminder$country == \"Cambodia\", c(\"year\", \"lifeExp\")]\n## # A tibble: 12 Ã— 2\n##     year lifeExp\n##    <int>   <dbl>\n##  1  1952    39.4\n##  2  1957    41.4\n##  3  1962    43.4\n##  4  1967    45.4\n##  5  1972    40.3\n##  6  1977    31.2\n##  7  1982    51.0\n##  8  1987    53.9\n##  9  1992    55.8\n## 10  1997    56.5\n## 11  2002    56.8\n## 12  2007    59.7"},{"path":"dplyr-intro.html","id":"select-hilfsfunktionen","chapter":"Kapitel 6 EinfÃ¼hrung in dplyr","heading":"6.5 select() Hilfsfunktionen","text":"Der gapminder Datensatz ist klein und damit leicht Ã¼berschaubar. Daher ist eine strukturierte Auswahl von Variablen hier nicht notwendig. grÃ¶ÃŸeren DatensÃ¤tzen kann dies aber ganz anders sein. Dort bietet es sich mit Hilfsfunktionen wie: wÃ¤hlt einen Bereich von Spalten aus: wÃ¤hlt einen Bereich von Spalten aus- wÃ¤hlt alle Spalten auÃŸer â€¦- wÃ¤hlt alle Spalten auÃŸer â€¦starts_with() wÃ¤hlt alle Spalten, die mit â€¦ startenstarts_with() wÃ¤hlt alle Spalten, die mit â€¦ startenends_with() wÃ¤hlt alle Spalten, die mit â€¦ endenends_with() wÃ¤hlt alle Spalten, die mit â€¦ endencontains() wÃ¤hlt alle Spalten, die â€¦ enthaltencontains() wÃ¤hlt alle Spalten, die â€¦ enthaltenmatches() wÃ¤hlte alle Spalten, die den regulÃ¤ren Ausdruck â€¦ enthaltenmatches() wÃ¤hlte alle Spalten, die den regulÃ¤ren Ausdruck â€¦ enthaltenâ€¦â€¦zu arbeiten.","code":"\nselect(gapminder, \n       matches(        # von beginn ^\n         \"^.{4}$\"      # bis ende $\n         )             # enthÃ¤lt der namen irgendwelche . character\n       )\n## # A tibble: 1,704 Ã— 1\n##     year\n##    <int>\n##  1  1952\n##  2  1957\n##  3  1962\n##  4  1967\n##  5  1972\n##  6  1977\n##  7  1982\n##  8  1987\n##  9  1992\n## 10  1997\n## # â„¹ 1,694 more rows"},{"path":"dplyr-intro.html","id":"pure-predictable-pipeable","chapter":"Kapitel 6 EinfÃ¼hrung in dplyr","heading":"6.6 Pure, predictable, pipeable","text":"Bisher haben wir nur etwas der OberflÃ¤che von dplyr gekratzt, trotzdem mÃ¶chten wir auf ein SchlÃ¼sselprinzip hinweisen, das du mit der Zeit schÃ¤tzen lernen wirst.Die Verben (Hauptfunktionen) von dplyr, wie z.B. filter() und select(), sind pure functions. Dazu schreibt Hadley Wickham im Kapitel Functions seinem Advanced R Buch (2019):functions easiest understand reason pure functions: functions always map input output impact workspace. words, pure functions side effects: donâ€™t affect state world way apart value return.TatsÃ¤chlich sind diese Verben ein Spezialfall reiner Funktionen: sie nehmen als Input und Output denselben Objekttyp , .d.R. ein data frame.Die Daten sind fÃ¼r diese Funktionen auch stets das erste Inputargument.","code":""},{"path":"dplyr-intro.html","id":"aufgabe-2","chapter":"Kapitel 6 EinfÃ¼hrung in dplyr","heading":"6.7 Aufgabe","text":"Die dplyr EinfÃ¼hrung geht weiter im Kapitel Mehr zu dplyr. Bearbeitet aber vorher den letzten Abschnitte des Work Data Primers:Deriving Information dplyr zeigt euch wie ihr Ã¼ber bestehenden Variablen neue Variablen definiert und leicht zusammenfassende Statistiken innerhalb vorab definierter Gruppen berechnet.","code":""},{"path":"dplyr-single.html","id":"dplyr-single","chapter":"Kapitel 7 Mehr zu dplyr","heading":"Kapitel 7 Mehr zu dplyr","text":"","code":""},{"path":"dplyr-single.html","id":"wo-stehen-wir","chapter":"Kapitel 7 Mehr zu dplyr","heading":"7.1 Wo stehen wir?","text":"Kapitel 6 haben wir bereits zwei sehr wichtige Verben und den Pipe Operator kennengelernt und verwendet:filter() zur Auswahl spezieller Zeilen eines Datensatzesselect() zur Auswahl spezieller Variablen eines Datensatzesder Pipe-Operator %>% Ã¼berfÃ¼hrt das Objekt auf der linken Seite des Operators das erste Funktionsargument der Funktion auf der rechten Seite des AufrufsWir haben zudem auch noch die Rolle von dplyr innerhalb des tidyverse besprochen:dplyr ist ein Kernpaket der tidyverse Kollektion von Paketen. Da wir die anderen oft beilÃ¤ufig benutzen, werden wir stets dplyr und die anderen Ã¼ber library(tidyverse) laden.Wir starten wieder mit dem Laden von dplyr (Ã¼ber tidyverse)und gapminder","code":"\nlibrary(tidyverse)\n## â”€â”€ Attaching core tidyverse packages â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ tidyverse 2.0.0 â”€â”€\n## âœ” dplyr     1.1.4     âœ” readr     2.1.5\n## âœ” forcats   1.0.0     âœ” stringr   1.5.1\n## âœ” ggplot2   3.5.1     âœ” tibble    3.2.1\n## âœ” lubridate 1.9.3     âœ” tidyr     1.3.1\n## âœ” purrr     1.0.2     \n## â”€â”€ Conflicts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ tidyverse_conflicts() â”€â”€\n## âœ– dplyr::filter() masks stats::filter()\n## âœ– dplyr::lag()    masks stats::lag()\n## â„¹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\nlibrary(gapminder)"},{"path":"dplyr-single.html","id":"mit-mutate-neue-variablen-erstellen","chapter":"Kapitel 7 Mehr zu dplyr","heading":"7.2 Mit mutate() neue Variablen erstellen","text":"Wir starten mit dem Anlegen einer Kopie von gapminder, die wir dann nach unseren Vorstellungen verÃ¤ndern (es wÃ¤re aber auch nichts passiert, wenn wir alles mit gapminder durchfÃ¼hren wÃ¼rden; mit dem Befehl gapminder::gapminder kÃ¶nnen wir immer auf die Originalversion zurÃ¼ckgreifen).Unser Ziel ist es, dass GDP pro Land anzugeben. Das sollte machbar sein, da schlieÃŸlich das Pro-Kopf-GDP wie auch die BevÃ¶lkerungszahl im Datensatz enthalten sind. Multiplizieren beider Variablen liefert uns das gewÃ¼nschte Ergebnis.mutate() ist eine Funktion, die neue Variablen definiert und ein tibble einfÃ¼gt. Dabei kÃ¶nnen wir auf bestehende Variablen einfach Ã¼ber ihren Namen zugreifen.Hmmmm â€¦ diese GDP-Zahlen sind ziemlich groÃŸ und abstrakt. dem Zusammenhang, bedenke den Ratschlag von Randall Munroe:One thing bothers large numbers presented without contextâ€¦ â€œadded zero number, sentence containing mean something different ?â€ answer â€œâ€, maybe number business sentence first place.Vielleicht wÃ¤re es doch sinnvoller, wenn wir beim Pro-Kopf-GDP bleiben. Aber wÃ¤re, wenn wir das Pro-Kopf-GDP angeben wÃ¼rden Relation zu irgendeinem Vergleichsland. Wir kÃ¶nnten alles Bezug auf die entsprechenden Daten aus Deutschland angeben.Dazu mÃ¼ssen wir eine neue Variable erstellen, die aus den gdpPercap Werten , geteilt durch die deutschen gdpPercap Werte, besteht. Beim Erstellen der Variable mÃ¼ssen wir aber darauf achten, dass wir immer zwei Zahlen teilen, die sich auf dasselbe Jahr beziehen.Wie kÃ¶nnen wir das schaffen?Beobachtungen fÃ¼r Deutschland einem Objekt ger_gap speichernErstellen einer neue temporÃ¤ren Variable tmp my_gap, die definiert wird durch:\ndie gdpPercap-Variable aus ger_gap aufrufen\nmit rep() die gdpPercap Wert aus ger_gap einmal pro Land im my_gap reproduzieren, damit ein Vektor entsteht, der die gleiche Anzahl Beobachtungen wie my_gap hat\ndie gdpPercap-Variable aus ger_gap aufrufenmit rep() die gdpPercap Wert aus ger_gap einmal pro Land im my_gap reproduzieren, damit ein Vektor entsteht, der die gleiche Anzahl Beobachtungen wie my_gap hatDividieren der gdpPercap Werte durch die deutschen ZahlenLÃ¶schen der temporÃ¤ren Variable tmp my_gapBeachte, dass mutate() neue Variablen sequentiell erstellt, dass man auf frÃ¼here Variablen (wie tmp) verweisen kann um spÃ¤tere Variablen (wie gdpPercapRel) zu definieren. Nachdem eine Variable nicht mehr benÃ¶tigt wird, kann man sie einfach auf NULL setzen.Bleibt die Frage ob das alles richtig war. Um diese Frage zu beantworten, kÃ¶nnen wir uns aber einfach mal die Werte von gdpPercapRel fÃ¼r Deutschland anschauen. Die sollten besser alle 1 sein!Ich glaube, wir kÃ¶nnen annehmen, dass Deutschland ein Land mit einem â€œhohen GDPâ€ pro Kopf ist. Daher sollte die Verteilung von gdpPercapRel auf Werten unter 1 konzentriert sein, mÃ¶glicherweise sogar weit darunter. Aber besser mal nachschauen ob dem ist:Die Zahlen des relativen Pro-Kopf-GDP liegen deutlich unter 1. Wir sehen, dass die meisten LÃ¤nder, die diesem Datensatz erfasst werden, Ã¼ber den gesamten Zeitraum im Vergleich zu Deutschland ein wesentlich niedrigeres Pro-Kopf-GDP aufweisen.Tipp: Vertraut niemandem - einschlieÃŸlich (besonders?) euch selbst. Versucht immer, einen Weg zu finden, um zu Ã¼berprÃ¼fen, ob ihr das gemacht habt, ihr tun wolltet. Seid aber nicht schockiert, wenn ihr manchmal feststellen mÃ¼sst, dass dem nicht ist. ğŸ˜‰","code":"\nmy_gap <- gapminder\nmy_gap %>%\n  mutate(gdp = pop * gdpPercap)\n## # A tibble: 1,704 Ã— 7\n##    country     continent  year lifeExp      pop gdpPercap          gdp\n##    <fct>       <fct>     <int>   <dbl>    <int>     <dbl>        <dbl>\n##  1 Afghanistan Asia       1952    28.8  8425333      779.  6567086330.\n##  2 Afghanistan Asia       1957    30.3  9240934      821.  7585448670.\n##  3 Afghanistan Asia       1962    32.0 10267083      853.  8758855797.\n##  4 Afghanistan Asia       1967    34.0 11537966      836.  9648014150.\n##  5 Afghanistan Asia       1972    36.1 13079460      740.  9678553274.\n##  6 Afghanistan Asia       1977    38.4 14880372      786. 11697659231.\n##  7 Afghanistan Asia       1982    39.9 12881816      978. 12598563401.\n##  8 Afghanistan Asia       1987    40.8 13867957      852. 11820990309.\n##  9 Afghanistan Asia       1992    41.7 16317921      649. 10595901589.\n## 10 Afghanistan Asia       1997    41.8 22227415      635. 14121995875.\n## # â„¹ 1,694 more rows\nger_gap <- my_gap %>%\n  filter(country == \"Germany\")\n\nmy_gap <- my_gap %>%\n  mutate(tmp = rep(ger_gap$gdpPercap, nlevels(country)),\n         gdpPercapRel = gdpPercap / tmp,\n         tmp = NULL)\nmy_gap %>% \n  filter(country == \"Germany\") %>% \n  select(country, year, gdpPercapRel)\n## # A tibble: 12 Ã— 3\n##    country  year gdpPercapRel\n##    <fct>   <int>        <dbl>\n##  1 Germany  1952            1\n##  2 Germany  1957            1\n##  3 Germany  1962            1\n##  4 Germany  1967            1\n##  5 Germany  1972            1\n##  6 Germany  1977            1\n##  7 Germany  1982            1\n##  8 Germany  1987            1\n##  9 Germany  1992            1\n## 10 Germany  1997            1\n## 11 Germany  2002            1\n## 12 Germany  2007            1\nsummary(my_gap$gdpPercapRel)\n##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n##    0.01    0.07    0.19    0.37    0.51   15.17"},{"path":"dplyr-single.html","id":"mit-arrange-die-zeilenreihenfolge-Ã¤ndern","chapter":"Kapitel 7 Mehr zu dplyr","heading":"7.3 Mit arrange() die Zeilenreihenfolge Ã¤ndern","text":"arrange() ordnet die Zeilen einem data frame neu . Stellen wir uns mal vor, dass wir die Daten nach Jahr und Land und nicht nach Land und Jahr ordnen wollen.Oder vielleicht interessieren euch nur die Daten aus 2007, angeordnet entsprechend der Lebenserwartung.Das war nun aber nicht das Ergebnis, welches ihr sehen wolltet. Ihr wolltet eigentlich nach absteigender Lebenserwartung sortieren. Dazu mÃ¼sst ihr desc() verwenden.Tipp: Verlasst euch NIEMALS darauf, dass Zeilen oder Variablen einer bestimmten Reihenfolge stehen. Aber manchmal man Tabellen anderen prÃ¤sentieren und dabei macht es durchaus Sinn die Zeilenreihenfolge je nach Fragestellung anzupassen.","code":"\nmy_gap %>%\n  arrange(year, country)\n## # A tibble: 1,704 Ã— 7\n##    country     continent  year lifeExp      pop gdpPercap gdpPercapRel\n##    <fct>       <fct>     <int>   <dbl>    <int>     <dbl>        <dbl>\n##  1 Afghanistan Asia       1952    28.8  8425333      779.       0.109 \n##  2 Albania     Europe     1952    55.2  1282697     1601.       0.224 \n##  3 Algeria     Africa     1952    43.1  9279525     2449.       0.343 \n##  4 Angola      Africa     1952    30.0  4232095     3521.       0.493 \n##  5 Argentina   Americas   1952    62.5 17876956     5911.       0.827 \n##  6 Australia   Oceania    1952    69.1  8691212    10040.       1.41  \n##  7 Austria     Europe     1952    66.8  6927772     6137.       0.859 \n##  8 Bahrain     Asia       1952    50.9   120447     9867.       1.38  \n##  9 Bangladesh  Asia       1952    37.5 46886859      684.       0.0958\n## 10 Belgium     Europe     1952    68    8730405     8343.       1.17  \n## # â„¹ 1,694 more rows\nmy_gap %>%\n  filter(year == 2007) %>%\n  arrange(lifeExp)\n## # A tibble: 142 Ã— 7\n##    country                 continent  year lifeExp    pop gdpPercap gdpPercapRel\n##    <fct>                   <fct>     <int>   <dbl>  <int>     <dbl>        <dbl>\n##  1 Swaziland               Africa     2007    39.6 1.13e6     4513.       0.140 \n##  2 Mozambique              Africa     2007    42.1 2.00e7      824.       0.0256\n##  3 Zambia                  Africa     2007    42.4 1.17e7     1271.       0.0395\n##  4 Sierra Leone            Africa     2007    42.6 6.14e6      863.       0.0268\n##  5 Lesotho                 Africa     2007    42.6 2.01e6     1569.       0.0488\n##  6 Angola                  Africa     2007    42.7 1.24e7     4797.       0.149 \n##  7 Zimbabwe                Africa     2007    43.5 1.23e7      470.       0.0146\n##  8 Afghanistan             Asia       2007    43.8 3.19e7      975.       0.0303\n##  9 Central African Republâ€¦ Africa     2007    44.7 4.37e6      706.       0.0219\n## 10 Liberia                 Africa     2007    45.7 3.19e6      415.       0.0129\n## # â„¹ 132 more rows\nmy_gap %>%\n  filter(year == 2007) %>%\n  arrange(desc(lifeExp))\n## # A tibble: 142 Ã— 7\n##    country          continent  year lifeExp       pop gdpPercap gdpPercapRel\n##    <fct>            <fct>     <int>   <dbl>     <int>     <dbl>        <dbl>\n##  1 Japan            Asia       2007    82.6 127467972    31656.        0.984\n##  2 Hong Kong, China Asia       2007    82.2   6980412    39725.        1.23 \n##  3 Iceland          Europe     2007    81.8    301931    36181.        1.12 \n##  4 Switzerland      Europe     2007    81.7   7554661    37506.        1.17 \n##  5 Australia        Oceania    2007    81.2  20434176    34435.        1.07 \n##  6 Spain            Europe     2007    80.9  40448191    28821.        0.896\n##  7 Sweden           Europe     2007    80.9   9031088    33860.        1.05 \n##  8 Israel           Asia       2007    80.7   6426679    25523.        0.793\n##  9 France           Europe     2007    80.7  61083916    30470.        0.947\n## 10 Canada           Americas   2007    80.7  33390141    36319.        1.13 \n## # â„¹ 132 more rows"},{"path":"dplyr-single.html","id":"mit-rename-schÃ¶ne-namen-vergeben","chapter":"Kapitel 7 Mehr zu dplyr","heading":"7.4 Mit rename() â€œschÃ¶neâ€ Namen vergeben","text":"Ein paar der Namen gapminder sind nicht besonders hÃ¼bsch, wie z.B. lifeExp. life expectancy wÃ¤ren ja schlieÃŸlich zwei Worte und daher finde ich (persÃ¶nliche Meinung) es schÃ¶ner, dies auch im Variablennamen zu sehenDie Ã„nderungen haben wir jetzt aber nicht abgespeichert (auch wenn sie schÃ¶n waren), da wir den nachfolgenden Code auch weiterhin ausfÃ¼hren mÃ¶chten, ohne die Variablennamen entsprechend zu Ã¤ndern.Bemerkung: Mit select() kÃ¶nnten wir bei der Auswahl von Variablen auch deren Namen Ã¤nderneverything() wÃ¤hlt alle Ã¼brigen (auÃŸer gdpPercap) Variablen. Da gdpPercap erster Stelle gewÃ¤hlt wurde, wird die Variable auch zur ersten Spalte.","code":"\nmy_gap %>%\n  rename(life_exp = lifeExp,\n         gdp_percap = gdpPercap,\n         gdp_percap_rel = gdpPercapRel)\n## # A tibble: 1,704 Ã— 7\n##    country     continent  year life_exp      pop gdp_percap gdp_percap_rel\n##    <fct>       <fct>     <int>    <dbl>    <int>      <dbl>          <dbl>\n##  1 Afghanistan Asia       1952     28.8  8425333       779.         0.109 \n##  2 Afghanistan Asia       1957     30.3  9240934       821.         0.0806\n##  3 Afghanistan Asia       1962     32.0 10267083       853.         0.0661\n##  4 Afghanistan Asia       1967     34.0 11537966       836.         0.0567\n##  5 Afghanistan Asia       1972     36.1 13079460       740.         0.0411\n##  6 Afghanistan Asia       1977     38.4 14880372       786.         0.0383\n##  7 Afghanistan Asia       1982     39.9 12881816       978.         0.0444\n##  8 Afghanistan Asia       1987     40.8 13867957       852.         0.0346\n##  9 Afghanistan Asia       1992     41.7 16317921       649.         0.0245\n## 10 Afghanistan Asia       1997     41.8 22227415       635.         0.0229\n## # â„¹ 1,694 more rows\nmy_gap %>%\n  filter(country == \"Burundi\", year > 1996) %>% \n  select(yr = year, lifeExp, gdpPercap) %>% \n  select(gdpPercap, everything())\n## # A tibble: 3 Ã— 3\n##   gdpPercap    yr lifeExp\n##       <dbl> <int>   <dbl>\n## 1      463.  1997    45.3\n## 2      446.  2002    47.4\n## 3      430.  2007    49.6"},{"path":"dplyr-single.html","id":"summarise-in-kombination-mit-group_by","chapter":"Kapitel 7 Mehr zu dplyr","heading":"7.5 summarise() in Kombination mit group_by()","text":"Nehmen wir mal , dass uns die Antwort auf die Frageâ€œwelchem Land ist die Lebenserwartung innerhalb von 5 Jahren stÃ¤rksten gesunken?â€interessiert.dplyr bietet uns mÃ¤chtige Hilfsmittel zur Beantwortung der Frage:group_by() fÃ¼gt dem Datensatz eine zusÃ¤tzliche Struktur hinzu â€“ Gruppierungsinformationen â€“ die die Grundlage fÃ¼r Berechnungen innerhalb der Gruppen bilden.group_by() fÃ¼gt dem Datensatz eine zusÃ¤tzliche Struktur hinzu â€“ Gruppierungsinformationen â€“ die die Grundlage fÃ¼r Berechnungen innerhalb der Gruppen bilden.summarise() nimmt einen Datensatz mit \\(n\\)-Beobachtungen, berechnet die angeforderten Zusammenfassungen und gibt einen Datensatz mit einer Beobachtung (falls nur eine Zusammenfassung angefordert wurde) zurÃ¼ck.summarise() nimmt einen Datensatz mit \\(n\\)-Beobachtungen, berechnet die angeforderten Zusammenfassungen und gibt einen Datensatz mit einer Beobachtung (falls nur eine Zusammenfassung angefordert wurde) zurÃ¼ck.mutate() und summarise() berÃ¼cksichtigen Gruppen.mutate() und summarise() berÃ¼cksichtigen Gruppen.Kombiniert mit den Verben, die wir bereits kennen, kÃ¶nnt ihr mit diesen neuen Werkzeugen eine extrem vielfÃ¤ltige Reihe von Problemen relativ einfach lÃ¶sen.","code":""},{"path":"dplyr-single.html","id":"dinge-aufzÃ¤hlen","chapter":"Kapitel 7 Mehr zu dplyr","heading":"7.5.1 Dinge aufzÃ¤hlen","text":"Beginnen wir mit dem einfachen ZÃ¤hlen. Wie viele Beobachtungen haben wir pro Kontinent?Lasst uns hier kurz innehalten und Ã¼ber das tidyverse nachdenken. Ihr kÃ¶nntet die gleichen absoluten HÃ¤ufigkeiten natÃ¼rlich auch mit table() berechnen.Das Ergebnis ist ein Objekt der Klasse table. Dies macht nachfolgende Berechnungen leider etwas kniffliger, als es euch lieb ist. Zum Beispiel ist es schade, dass die Namen der Kontinente nur als Attribute und nicht als richtiger Faktor zusammen mit den berechneten Werten zurÃ¼ckgegeben werden.\nDies ist ein Beispiel dafÃ¼r, wie das tidyverse ÃœbergÃ¤nge glÃ¤ttet, bei denen die Ausgabe von Schritt die Eingabe von Schritt + 1 werden soll.Die tally() Funktion ist eine Komfortfunktion, die weiÃŸ, wie man Zeilen zÃ¤hlt und dabei Gruppen berÃ¼cksichtigt.Die Funktion count() bietet noch mehr Komfort. Sie kann sowohl gruppieren als auch zÃ¤hlen.wÃ¤re, wenn uns nicht nur die Anzahl Beobachtungen pro Kontinent interessiert, sondern auch die Anzahl unterschiedlichen LÃ¤ndern pro Kontinent. Dazu bestimmen wir einfach mehrere Zusammenfassungen innerhalb von summarise(). Dabei verwenden wir die Funktion n_distinct(), um die Anzahl der einzelnen LÃ¤nder innerhalb jedes Kontinents zu zÃ¤hlen.","code":"\nmy_gap %>%\n  group_by(continent) %>%\n  summarise(n = n())\n## # A tibble: 5 Ã— 2\n##   continent     n\n##   <fct>     <int>\n## 1 Africa      624\n## 2 Americas    300\n## 3 Asia        396\n## 4 Europe      360\n## 5 Oceania      24\ntable(gapminder$continent)\n## \n##   Africa Americas     Asia   Europe  Oceania \n##      624      300      396      360       24\nstr(table(gapminder$continent))\n##  'table' int [1:5(1d)] 624 300 396 360 24\n##  - attr(*, \"dimnames\")=List of 1\n##   ..$ : chr [1:5] \"Africa\" \"Americas\" \"Asia\" \"Europe\" ...\nmy_gap %>%\n  group_by(continent) %>%\n  tally()\n## # A tibble: 5 Ã— 2\n##   continent     n\n##   <fct>     <int>\n## 1 Africa      624\n## 2 Americas    300\n## 3 Asia        396\n## 4 Europe      360\n## 5 Oceania      24\nmy_gap %>% \n  count(continent)\n## # A tibble: 5 Ã— 2\n##   continent     n\n##   <fct>     <int>\n## 1 Africa      624\n## 2 Americas    300\n## 3 Asia        396\n## 4 Europe      360\n## 5 Oceania      24\nmy_gap %>%\n  group_by(continent) %>%\n  summarise(n = n(),\n            n_countries = n_distinct(country))\n## # A tibble: 5 Ã— 3\n##   continent     n n_countries\n##   <fct>     <int>       <int>\n## 1 Africa      624          52\n## 2 Americas    300          25\n## 3 Asia        396          33\n## 4 Europe      360          30\n## 5 Oceania      24           2"},{"path":"dplyr-single.html","id":"deskriptive-statistiken-mit-summarise","chapter":"Kapitel 7 Mehr zu dplyr","heading":"7.5.2 Deskriptive Statistiken mit summarise()","text":"Kombination mit summarise() kÃ¶nnen wir eine Vielzahl verschiedenen Funktionen verwenden. Einige davon berechnen klassische deskriptive Statistiken:allen betrachteten FÃ¤llen seien \\(x_1,\\dots,x_n\\) numerische Beobachtungen.mean() berechnet das arithmetische Mittel der Beobachtungen\n\\[\\overline x_n = \\frac{1}{n} \\sum_{=1}^n x_i\\,.\\]mean() berechnet das arithmetische Mittel der Beobachtungen\n\\[\\overline x_n = \\frac{1}{n} \\sum_{=1}^n x_i\\,.\\]median() berechnet den Median\n\\[x_{0.5} = \\begin{cases}\nx_{\\left(\\frac{n+1}{2}\\right)}, &  n\\ \\text{ungerade},\\\\\n\\frac{1}{2}\\left(x_{\\left(\\frac{n}{2}\\right)} + x_{\\left(\\frac{n}{2}+1\\right)}\\right), & n\\ \\text{gerade}\n\\end{cases}\\,.\\]median() berechnet den Median\n\\[x_{0.5} = \\begin{cases}\nx_{\\left(\\frac{n+1}{2}\\right)}, &  n\\ \\text{ungerade},\\\\\n\\frac{1}{2}\\left(x_{\\left(\\frac{n}{2}\\right)} + x_{\\left(\\frac{n}{2}+1\\right)}\\right), & n\\ \\text{gerade}\n\\end{cases}\\,.\\]var() berechnet die empirische Varianz\n\\[s_n^2 = \\frac{1}{n-1} \\sum_{=1}^n (x_i - \\overline x_n)^2\\,.\\]var() berechnet die empirische Varianz\n\\[s_n^2 = \\frac{1}{n-1} \\sum_{=1}^n (x_i - \\overline x_n)^2\\,.\\]sd() berechnet die empirische Standardabweichung\n\\[s_n = \\sqrt{s_n^2}\\,.\\]sd() berechnet die empirische Standardabweichung\n\\[s_n = \\sqrt{s_n^2}\\,.\\]IQR() berechnet den Interquartilsabstand\n\\[IQR = x_{0.75} - x_{0.25}\\,,\\]\nwobei \\(x_{0.25}\\) und \\(x_{0.75}\\) das empirische 0.25 bzw. 0.75 Quantil bezeichnen.IQR() berechnet den Interquartilsabstand\n\\[IQR = x_{0.75} - x_{0.25}\\,,\\]\nwobei \\(x_{0.25}\\) und \\(x_{0.75}\\) das empirische 0.25 bzw. 0.75 Quantil bezeichnen.min() berechnet das Minimum\n\\[x_{(1)} = \\min(x_1,\\dots,x_n)\\,.\\]min() berechnet das Minimum\n\\[x_{(1)} = \\min(x_1,\\dots,x_n)\\,.\\]und max() berechnet demnach das Maximum\n\\[x_{(n)} = \\max(x_1,\\dots,x_n)\\,.\\]und max() berechnet demnach das Maximum\n\\[x_{(n)} = \\max(x_1,\\dots,x_n)\\,.\\]Auch wenn dies statistisch gesehen unklug sein mag, lasst uns die durchschnittliche Lebenserwartung pro Kontinent berechnen.summarise_at() wendet die gleiche(n) Zusammenfassungs-Funktion(en) auf mehrere Variablen . Lasst uns die durchschnittliche Lebenserwartung sowie den Median und das Pro-Kopf-GDP nach Kontinenten pro Jahr berechnenâ€¦ aber nur fÃ¼r 1952 und 2007.Im nÃ¤chsten Schritt konzentrieren wir uns nur auf Asien. Wie hoch ist die minimale und maximale Lebenserwartung pro Jahr?NatÃ¼rlich wÃ¤re es viel interessanter zu sehen, welches Land bzw. welche LÃ¤nder diese extremen Beobachtungen beigetragen haben. Kommt das Minimum (Maximum) immer aus dem gleichen Land? Wir gehen dem KÃ¼rze mithilfe von Window Funktionen nach.","code":"\nmy_gap %>%\n  group_by(continent) %>%\n  summarise(avg_lifeExp = mean(lifeExp))\n## # A tibble: 5 Ã— 2\n##   continent avg_lifeExp\n##   <fct>           <dbl>\n## 1 Africa           48.9\n## 2 Americas         64.7\n## 3 Asia             60.1\n## 4 Europe           71.9\n## 5 Oceania          74.3\nmy_gap %>%\n  filter(year %in% c(1952, 2007)) %>%\n  group_by(continent, year) %>%\n  summarise_at(vars(lifeExp, gdpPercap), list(mean, median))\n## # A tibble: 10 Ã— 6\n## # Groups:   continent [5]\n##    continent  year lifeExp_fn1 gdpPercap_fn1 lifeExp_fn2 gdpPercap_fn2\n##    <fct>     <int>       <dbl>         <dbl>       <dbl>         <dbl>\n##  1 Africa     1952        39.1         1253.        38.8          987.\n##  2 Africa     2007        54.8         3089.        52.9         1452.\n##  3 Americas   1952        53.3         4079.        54.7         3048.\n##  4 Americas   2007        73.6        11003.        72.9         8948.\n##  5 Asia       1952        46.3         5195.        44.9         1207.\n##  6 Asia       2007        70.7        12473.        72.4         4471.\n##  7 Europe     1952        64.4         5661.        65.9         5142.\n##  8 Europe     2007        77.6        25054.        78.6        28054.\n##  9 Oceania    1952        69.3        10298.        69.3        10298.\n## 10 Oceania    2007        80.7        29810.        80.7        29810.\nmy_gap %>%\n  filter(continent == \"Asia\") %>%\n  group_by(year) %>%\n  summarise(min_lifeExp = min(lifeExp), max_lifeExp = max(lifeExp))\n## # A tibble: 12 Ã— 3\n##     year min_lifeExp max_lifeExp\n##    <int>       <dbl>       <dbl>\n##  1  1952        28.8        65.4\n##  2  1957        30.3        67.8\n##  3  1962        32.0        69.4\n##  4  1967        34.0        71.4\n##  5  1972        36.1        73.4\n##  6  1977        31.2        75.4\n##  7  1982        39.9        77.1\n##  8  1987        40.8        78.7\n##  9  1992        41.7        79.4\n## 10  1997        41.8        80.7\n## 11  2002        42.1        82  \n## 12  2007        43.8        82.6"},{"path":"dplyr-single.html","id":"gruppierte-verÃ¤nderungen","chapter":"Kapitel 7 Mehr zu dplyr","heading":"7.6 Gruppierte VerÃ¤nderungen","text":"Manchmal mÃ¶chte man die \\(n\\)-Zeilen fÃ¼r jede Gruppe nicht zu einer Zeile zusammenfassen. Stattdessen mÃ¶chte man die Gruppen behalten, aber innerhalb dieser Gruppen rechnen.","code":""},{"path":"dplyr-single.html","id":"berechnungen-innerhalb-der-gruppen","chapter":"Kapitel 7 Mehr zu dplyr","heading":"7.6.1 Berechnungen innerhalb der Gruppen","text":"Lasst uns eine neue Variable definieren, die die gewonnenen (verlorenen) Lebenserwartungsjahre im Vergleich zu 1952 fÃ¼r jedes einzelne Land angibt. Wir gruppieren nach LÃ¤ndern und verwenden mutate(), um eine neue Variable zu erstellen. Die Funktion first() extrahiert dabei den ersten Wert aus einem Vektor. Beachtet, dass first() mit dem Vektor der Lebenserwartungen jeder LÃ¤ndergruppe arbeitet.Innerhalb eines Landes nehmen wir die Differenz zwischen der Lebenserwartung im Jahr \\(\\) und der Lebenserwartung im Jahr 1952. Daher sehen wir fÃ¼r 1952 immer Nullen und fÃ¼r die meisten LÃ¤nder eine Folge von positiven und steigenden Zahlen.","code":"\nmy_gap %>% \n  group_by(country) %>% \n  select(country, year, lifeExp) %>% \n  mutate(lifeExp_gain = lifeExp - first(lifeExp)) %>% \n  filter(year < 1963)\n## # A tibble: 426 Ã— 4\n## # Groups:   country [142]\n##    country      year lifeExp lifeExp_gain\n##    <fct>       <int>   <dbl>        <dbl>\n##  1 Afghanistan  1952    28.8         0   \n##  2 Afghanistan  1957    30.3         1.53\n##  3 Afghanistan  1962    32.0         3.20\n##  4 Albania      1952    55.2         0   \n##  5 Albania      1957    59.3         4.05\n##  6 Albania      1962    64.8         9.59\n##  7 Algeria      1952    43.1         0   \n##  8 Algeria      1957    45.7         2.61\n##  9 Algeria      1962    48.3         5.23\n## 10 Angola       1952    30.0         0   \n## # â„¹ 416 more rows"},{"path":"dplyr-single.html","id":"window-functions","chapter":"Kapitel 7 Mehr zu dplyr","heading":"7.6.2 Window Funktionen","text":"Window Funktionen nehmen eine Eingabe der LÃ¤nge \\(n\\) und berechnen eine Ausgabe derselben LÃ¤nge. Diese Ausgabewerte hÃ¤ngen dabei von allen Eingabewerten ab. ist z.B. rank() eine Window Funktion, aber log() ist es nicht.Betrachten wir noch einmal die schlechtesten und besten Lebenserwartungen Asien im Laufe der Zeit, behalten aber Informationen darÃ¼ber bei, welches Land diese Extremwerte beisteuert.Wir sehen, dass (min = Afghanistan, max = Japan) das hÃ¤ufigste Ergebnis ist, aber Kambodscha und Israel tauchen auch jeweils mindestens einmal als min bzw. max auf.Aber wÃ¤re es nicht schÃ¶n eine Zeile pro Jahr zu haben?Zuerst sollten wir uns aber vielleicht nochmal fragen wie das eigentlich funktioniert hat? Dazu schauen wir uns die Beobachtungen aus Asien mal direkt .Jetzt wenden wir die Window Funktion min_rank() . Da asia nach Jahren gruppiert ist, operiert min_rank() innerhalb von Mini-DatensÃ¤tzen. Auf die Variable lifeExp angewandt, liefert min_rank() den Rang der beobachteten Lebenserwartung jedes Landes.Bemerkung: Der min-Teil im Funktionsnamen min_rank() gibt nur , wie im Fall von gleichen Beobachtungswerten die RÃ¤nge bestimmt werden.Neben dem Minimum gibt es aber auch noch eine Reihe weiterer Alternativen, wie z.B. den DurchschnittIm nÃ¤chsten Schritt schauen wir uns die RÃ¤nge der Lebenserwartung innerhalb eines Jahres mal explizit fÃ¼r ein paar LÃ¤nder (Afghanistan, Japan und Thailand) - sowohl der (Standard-) aufsteigenden als auch der absteigenden Reihenfolge.Afghanistan neigt dazu, 1 der le_rank-Variablen zu haben, Japan neigt dazu, 1 der le_desc_rank-Variablen zu haben und andere LÃ¤nder, wie Thailand, zeigen deutlich weniger extreme RÃ¤nge.Damit sollte der ursprÃ¼ngliche filter() Befehlauch klar sein.Diese beiden SÃ¤tze von RÃ¤ngen werden --fly, innerhalb der Jahresgruppe, gebildet, und filter() behÃ¤lt alle Zeilen, die einen Rangwert kleiner als 2 haben. Da wir dies fÃ¼r aufsteigende und absteigende RÃ¤nge machen, erhalten wir sowohl die Beobachtungen mit dem minimalen als auch dem maximalen Rang.Wenn wir nur das Minimum ODER das Maximum gewollt hÃ¤tten, hÃ¤tte auch ein alternativer Ansatz mit slice_min() bzw. slice_max() funktioniert.","code":"\nmy_gap %>%\n  filter(continent == \"Asia\") %>%\n  select(year, country, lifeExp) %>%\n  group_by(year) %>%\n  filter(min_rank(desc(lifeExp)) < 2 | min_rank(lifeExp) < 2) %>% \n  arrange(year) %>%\n  print(n = Inf)  # erzwingt eine Ausgabe aller Zeilen\n## # A tibble: 24 Ã— 3\n## # Groups:   year [12]\n##     year country     lifeExp\n##    <int> <fct>         <dbl>\n##  1  1952 Afghanistan    28.8\n##  2  1952 Israel         65.4\n##  3  1957 Afghanistan    30.3\n##  4  1957 Israel         67.8\n##  5  1962 Afghanistan    32.0\n##  6  1962 Israel         69.4\n##  7  1967 Afghanistan    34.0\n##  8  1967 Japan          71.4\n##  9  1972 Afghanistan    36.1\n## 10  1972 Japan          73.4\n## 11  1977 Cambodia       31.2\n## 12  1977 Japan          75.4\n## 13  1982 Afghanistan    39.9\n## 14  1982 Japan          77.1\n## 15  1987 Afghanistan    40.8\n## 16  1987 Japan          78.7\n## 17  1992 Afghanistan    41.7\n## 18  1992 Japan          79.4\n## 19  1997 Afghanistan    41.8\n## 20  1997 Japan          80.7\n## 21  2002 Afghanistan    42.1\n## 22  2002 Japan          82  \n## 23  2007 Afghanistan    43.8\n## 24  2007 Japan          82.6\n(asia <- my_gap %>%\n  filter(continent == \"Asia\") %>%\n  select(year, country, lifeExp) %>%\n  group_by(year))\n## # A tibble: 396 Ã— 3\n## # Groups:   year [12]\n##     year country     lifeExp\n##    <int> <fct>         <dbl>\n##  1  1952 Afghanistan    28.8\n##  2  1957 Afghanistan    30.3\n##  3  1962 Afghanistan    32.0\n##  4  1967 Afghanistan    34.0\n##  5  1972 Afghanistan    36.1\n##  6  1977 Afghanistan    38.4\n##  7  1982 Afghanistan    39.9\n##  8  1987 Afghanistan    40.8\n##  9  1992 Afghanistan    41.7\n## 10  1997 Afghanistan    41.8\n## # â„¹ 386 more rows\nrank(c(1,3,3,5), ties.method = \"min\")\n## [1] 1 2 2 4\nrank(c(1,3,3,5))\n## [1] 1.0 2.5 2.5 4.0\nasia %>%\n  mutate(le_rank = min_rank(lifeExp),\n         le_desc_rank = min_rank(desc(lifeExp))) %>% \n  filter(country %in% c(\"Afghanistan\", \"Japan\", \"Thailand\"), year > 1995)\n## # A tibble: 9 Ã— 5\n## # Groups:   year [3]\n##    year country     lifeExp le_rank le_desc_rank\n##   <int> <fct>         <dbl>   <int>        <int>\n## 1  1997 Afghanistan    41.8       1           33\n## 2  2002 Afghanistan    42.1       1           33\n## 3  2007 Afghanistan    43.8       1           33\n## 4  1997 Japan          80.7      33            1\n## 5  2002 Japan          82        33            1\n## 6  2007 Japan          82.6      33            1\n## 7  1997 Thailand       67.5      12           22\n## 8  2002 Thailand       68.6      12           22\n## 9  2007 Thailand       70.6      12           22\nfilter(min_rank(desc(lifeExp)) < 2 | min_rank(lifeExp) < 2)\nmy_gap %>%\n  filter(continent == \"Asia\") %>%\n  select(year, country, lifeExp) %>%\n  arrange(year) %>%\n  group_by(year) %>%\n# slice_min(lifeExp, n = 1)        ## fÃ¼r das Minimum\n  slice_max(lifeExp, n = 1) ## bzw. das Maximum\n## # A tibble: 12 Ã— 3\n## # Groups:   year [12]\n##     year country lifeExp\n##    <int> <fct>     <dbl>\n##  1  1952 Israel     65.4\n##  2  1957 Israel     67.8\n##  3  1962 Israel     69.4\n##  4  1967 Japan      71.4\n##  5  1972 Japan      73.4\n##  6  1977 Japan      75.4\n##  7  1982 Japan      77.1\n##  8  1987 Japan      78.7\n##  9  1992 Japan      79.4\n## 10  1997 Japan      80.7\n## 11  2002 Japan      82  \n## 12  2007 Japan      82.6"},{"path":"dplyr-single.html","id":"groÃŸes-finale","chapter":"Kapitel 7 Mehr zu dplyr","heading":"7.7 GroÃŸes Finale","text":"Beantworten wir also die Frage:â€œwelchem Land ist die Lebenserwartung innerhalb von 5 Jahren stÃ¤rksten gesunken?â€Die Beobachtungsfrequenz im Datensatz ist fÃ¼nf Jahre, d.h. wir haben Daten fÃ¼r 1952, 1957 usw. Dies bedeutet also, dass die VerÃ¤nderungen der Lebenserwartung zwischen benachbarten Zeitpunkten betrachtet werden mÃ¼ssen. Dazu verwenden wir die lag() Funktion. Diese veschiebt die EintrÃ¤ge des Inputvektors um ein Lag k.Wir kÃ¶nnen aber noch mehr erreichen. Lasst uns die Frage pro Kontinenten beantworten.Denkt ruhig eine Weile Ã¼ber das Ergebnis nach. Hier sieht man trockenen Statistiken Ã¼ber die durchschnittliche Lebenserwartung, wie VÃ¶lkermord aussieht.Um den Code besser zu verstehen, unterteilt ihn, beginnend von oben, StÃ¼cke und Ã¼berprÃ¼ft die einzelnen Zwischenergebnisse. wurde der Code auch geschrieben/entwickelt, mit Fehlern und Verfeinerungen auf dem Weg.","code":"\nmy_gap %>%\n  group_by(continent, country) %>%\n  # fÃ¼r jedes Land werden die Unterschiede berechnet\n  mutate(delta = lifeExp - lag(lifeExp, n = 1)) %>% \n  ## fÃ¼r jedes Land wird nur der kleinste Wert behalten\n  summarise(worst_delta = min(delta, na.rm = TRUE)) %>% \n  ## nun wird noch pro Kontinent, die Zeile mit dem kleinsten Wert ausgegeben\n  slice_min(worst_delta, n = 1) %>% \n  arrange(worst_delta)\n## `summarise()` has grouped output by 'continent'. You can override using the\n## `.groups` argument.\n## # A tibble: 5 Ã— 3\n## # Groups:   continent [5]\n##   continent country     worst_delta\n##   <fct>     <fct>             <dbl>\n## 1 Africa    Rwanda          -20.4  \n## 2 Asia      Cambodia         -9.10 \n## 3 Americas  El Salvador      -1.51 \n## 4 Europe    Montenegro       -1.46 \n## 5 Oceania   Australia         0.170"},{"path":"dplyr-single.html","id":"literatur","chapter":"Kapitel 7 Mehr zu dplyr","heading":"7.8 Literatur","text":"dieser Stelle sei noch auf die dplyr Webseite und das Kapitel\nData transformation R Data Science (Wickham Grolemund 2016) verwiesen.","code":""},{"path":"import-export.html","id":"import-export","chapter":"Kapitel 8 Daten I/O","heading":"Kapitel 8 Daten I/O","text":"","code":""},{"path":"import-export.html","id":"Ã¼berblick","chapter":"Kapitel 8 Daten I/O","heading":"8.1 Ãœberblick","text":"Im letzten Abschnitt haben wir die Gapminder-Daten als tibble aus dem gapminder Paket geladen. Dabei haben wir dann weder Daten, noch abgeleitete Ergebnisse, explizit eine Datei geschrieben. Im wirklichen Leben werdet ihr aber stÃ¤ndig Daten, die Tabellenform vorliegen, R ein- und auslesen. Manchmal muss das sogar fÃ¼r Daten geschehen, die nicht Tabellenform vorliegen.Wie macht man das? Worauf muss man aufpassen?","code":""},{"path":"import-export.html","id":"daten-import","chapter":"Kapitel 8 Daten I/O","heading":"8.1.1 Daten Import","text":"FÃ¼r das Importieren von Daten gibt es im Allgemeinen zwei Szenarien:â€œÃœberrasche mich!â€ Diese Haltung mÃ¼sst ihr einnehmen, wenn ihr einen Datensatz erhaltet und zum ersten Mal versucht diesen einzulesen. Man muss froh sein, wenn man die Daten ohne Fehlermeldung importieren kann. Im nÃ¤chsten Schritt schaut man sich das Ergebnis und entdeckt vermutlich Fehler den Daten und/oder beim Import. AnschlieÃŸend behebt man die Fehler und beginnt nochmal von vorne.â€œÃœberrasche mich!â€ Diese Haltung mÃ¼sst ihr einnehmen, wenn ihr einen Datensatz erhaltet und zum ersten Mal versucht diesen einzulesen. Man muss froh sein, wenn man die Daten ohne Fehlermeldung importieren kann. Im nÃ¤chsten Schritt schaut man sich das Ergebnis und entdeckt vermutlich Fehler den Daten und/oder beim Import. AnschlieÃŸend behebt man die Fehler und beginnt nochmal von vorne.â€œEin weiterer Tag im Paradies.â€ Das wird vermutlich euer GefÃ¼hl sein, wenn ihr versucht einen aufgerÃ¤umten Datensatz einzulesen (den jemand vorher einem oder mehreren â€œReinigungsskriptenâ€ aufgerÃ¤umt hat). Beim Einlesen solcher Daten sollte es keine Ãœberraschungen geben.â€œEin weiterer Tag im Paradies.â€ Das wird vermutlich euer GefÃ¼hl sein, wenn ihr versucht einen aufgerÃ¤umten Datensatz einzulesen (den jemand vorher einem oder mehreren â€œReinigungsskriptenâ€ aufgerÃ¤umt hat). Beim Einlesen solcher Daten sollte es keine Ãœberraschungen geben.Im zweiten Fall, und im weiteren Verlauf des ersten Falles, lernt ihr tatsÃ¤chlich eine Menge darÃ¼ber, wie die Daten strukturiert sind/sein sollten.Ein wichtiger Import-Ratschlag: Verwende die Argumente der Importfunktion, um weit wie mÃ¶glich und schnell wie mÃ¶glich zu kommen. Macht man dies nicht, sind oft nach dem Einlesen der Daten noch eine Reihe von weiteren Schritten nÃ¶tig, bevor man mit der eigentlichen Analyse beginnen kann. Daher lest die Hilfe zu den Importfunktionen und nutzt die Argumente maximal aus, um den Import zu steuern.","code":""},{"path":"import-export.html","id":"daten-export","chapter":"Kapitel 8 Daten I/O","heading":"8.1.2 Daten Export","text":"Es wird viele Gelegenheiten geben, bei denen ihr Daten aus R exportieren wollt. Zwei wichtige Beispiele:einen gesÃ¤uberten Datensatz, der bereit ist analysiert zu werdeneinen gesÃ¤uberten Datensatz, der bereit ist analysiert zu werdenein numerisches Ergebnis aus einer Datenaggregation oder Modellierung oder einer statistischen Schlussfolgerungein numerisches Ergebnis aus einer Datenaggregation oder Modellierung oder einer statistischen SchlussfolgerungErster Tipp: Der Output von heute ist der Input von morgen. Denkt die Schmerzen zurÃ¼ck, die ihr selbst beim Import von fremden Daten erlitten habt, und fÃ¼gt euch nicht selbst solche Schmerzen zu!Zweiter Tipp: Seid nicht zu clever. Eine einfache Textdatei, die von einem Menschen einem Texteditor lesbar ist, sollte euer Standard sein, bis es einen guten Grund dafÃ¼r gibt, dass dies nicht ausreichend ist. Das Lesen und Schreiben exotische Formate wird das Erste sein, mÃ¶glicherweise Zukunft oder auf einem anderen Computer nicht mehr funktioniert. Zudem schafft es Barrieren fÃ¼r jeden, der ein anderes Toolkit hat als ihr.Wie passt das zu unserer Betonung der dynamischen Berichterstattung Ã¼ber R Markdown? Es gibt fÃ¼r alles eine Zeit und einen Ort. Es gibt Projekte und Dokumente, bei denen ihr euch intensiv mit knitr und rmarkdown beschÃ¤ftigen kÃ¶nnt/wollt/mÃ¼sst. Aber es gibt viele gute GrÃ¼nde, warum (Teile) einer Analyse nicht (nur) einen dynamischen Bericht eingebettet werden sollten. Vielleicht wollt ihr Daten bereinigen, um einen Datensatz fÃ¼r eine nachfolgende Analyse zu erzeugen. Vielleicht leistet ihr einen kleinen, aber entscheidenden Beitrag zu einem gigantischen Multi-Autoren-Papier, usw. â€¦.Denkt zudem daran, dass es natÃ¼rlich auch noch andere Werkzeuge und ArbeitsablÃ¤ufe gibt, um etwas reproduzierbar zu machen: z.B. make.","code":""},{"path":"import-export.html","id":"readr","chapter":"Kapitel 8 Daten I/O","heading":"8.2 readr","text":"Zur Einlesen und Ausgeben von DatensÃ¤tzen verwenden wir das readr Paket, welches Alternativen zu den Standardfunktionen read.table() und write.table() bietet. readr ist Teil des tidyverse und daher fÃ¼hren wir standardmÃ¤ÃŸig einfach wiederaus.Einlesen der Gapminder DatenDie Gapminder Daten kÃ¶nnten wir natÃ¼rlich wie zuvor Ã¼ber das Laden des gapminder Pakets verfÃ¼gbar machen. Da es diesem Abschnitt aber um das Einlesen von Daten geht, versuchen wir die Daten als .tsv Datei (Tab getrennte Werte - sind die Daten im Paket gespeichert) einzulesen. Aber dies bedeutet natÃ¼rlich, dass wir die entsprechende .tsv Datei erst mal finden mÃ¼ssen. Dabei hilft uns glÃ¼cklicherweise das fs Paket.Nachdem wir jetzt den Speicherort der Datei kennen, kÃ¶nnen wir versuchen sie einzulesen.","code":"\nlibrary(tidyverse)\n## â”€â”€ Attaching core tidyverse packages â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ tidyverse 2.0.0 â”€â”€\n## âœ” dplyr     1.1.4     âœ” readr     2.1.5\n## âœ” forcats   1.0.0     âœ” stringr   1.5.1\n## âœ” ggplot2   3.5.1     âœ” tibble    3.2.1\n## âœ” lubridate 1.9.3     âœ” tidyr     1.3.1\n## âœ” purrr     1.0.2     \n## â”€â”€ Conflicts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ tidyverse_conflicts() â”€â”€\n## âœ– dplyr::filter() masks stats::filter()\n## âœ– dplyr::lag()    masks stats::lag()\n## â„¹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\nlibrary(fs)\n(gap_tsv <- path_package(\"gapminder\", \"extdata\", \"gapminder.tsv\"))\n## /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/library/gapminder/extdata/gapminder.tsv"},{"path":"import-export.html","id":"einlesen-von-daten-in-tabellenform","chapter":"Kapitel 8 Daten I/O","heading":"8.3 Einlesen von Daten in Tabellenform","text":"Die Haupt-Funktion zum Einlesen von Daten readr ist read_delim(). Hier verwenden wir eine Variante, read_tsv(), fÃ¼r Tab getrennte Daten:Wie wir sehen, wurde standardmÃ¤ÃŸig der komplette Datensatz eingelesen. Sind aber nur Teile eines Datensatzes relevant fÃ¼r die angestrebte Analyse, besteht auch keine Notwendigkeit den kompletten Datensatz zu laden. solchen FÃ¤llen kann man mit dem col_types Argument arbeitenZur Auswahl eines Teils der Variablen haben wir cols_only() verwendet. Diese Funktion erwartet bei der Auswahl der Variablen die Definition des Typs. diesem Beispiel haben wir continten (anders als im Standardfall) zu einer Faktorvariable transformiert. Dadurch enthÃ¤lt die Variable zusÃ¤tzlich die Information Ã¼ber die verschiedenen AusprÃ¤gungen der VariableÃœber den Tabulator Spalten einer Datentabelle zu trennen, ist natÃ¼rlich nur eine MÃ¶glichkeit von vielen. Weitere Alternativen sind:Komma: read_csv()Komma: read_csv()Strichpunkt: read_csv2()Strichpunkt: read_csv2()Leerzeichen: read_table()Leerzeichen: read_table()â€¦â€¦FÃ¼r volle FlexibilitÃ¤t bei der Angabe des Trennzeichens kann aber jederzeit direkt read_delim() verwendet werden.Der auffÃ¤lligste Unterschied zwischen den readr-Funktionen und der Standardfunktion read.table()ist, dass readr immer ein Tibble erzeugt statt eines Data Frames. Da wir Tibbles bevorzugen ist unserFazit: Benutzt readr::read_delim() und â€œFreundeâ€.Die Gapminder-Daten sind zu sauber und einfach, um die groÃŸartigen Funktionen von readr zur Geltung zu bringen. Ein Blick Introduction readr zeigt aber noch viele weitere AnpassungsmÃ¶glichkeiten der readr Funktionen.","code":"\ngapminder <- read_tsv(gap_tsv)\n## Rows: 1704 Columns: 6\n## â”€â”€ Column specification â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n## Delimiter: \"\\t\"\n## chr (2): country, continent\n## dbl (4): year, lifeExp, pop, gdpPercap\n## \n## â„¹ Use `spec()` to retrieve the full column specification for this data.\n## â„¹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\ngapminder\n## # A tibble: 1,704 Ã— 6\n##    country     continent  year lifeExp      pop gdpPercap\n##    <chr>       <chr>     <dbl>   <dbl>    <dbl>     <dbl>\n##  1 Afghanistan Asia       1952    28.8  8425333      779.\n##  2 Afghanistan Asia       1957    30.3  9240934      821.\n##  3 Afghanistan Asia       1962    32.0 10267083      853.\n##  4 Afghanistan Asia       1967    34.0 11537966      836.\n##  5 Afghanistan Asia       1972    36.1 13079460      740.\n##  6 Afghanistan Asia       1977    38.4 14880372      786.\n##  7 Afghanistan Asia       1982    39.9 12881816      978.\n##  8 Afghanistan Asia       1987    40.8 13867957      852.\n##  9 Afghanistan Asia       1992    41.7 16317921      649.\n## 10 Afghanistan Asia       1997    41.8 22227415      635.\n## # â„¹ 1,694 more rows\ngapminder_short <- read_tsv(gap_tsv, col_types = cols_only(\n  country = col_character(),\n  continent = col_factor(),\n  year = col_double(),\n  lifeExp = col_double()\n))\ngapminder_short\n## # A tibble: 1,704 Ã— 4\n##    country     continent  year lifeExp\n##    <chr>       <fct>     <dbl>   <dbl>\n##  1 Afghanistan Asia       1952    28.8\n##  2 Afghanistan Asia       1957    30.3\n##  3 Afghanistan Asia       1962    32.0\n##  4 Afghanistan Asia       1967    34.0\n##  5 Afghanistan Asia       1972    36.1\n##  6 Afghanistan Asia       1977    38.4\n##  7 Afghanistan Asia       1982    39.9\n##  8 Afghanistan Asia       1987    40.8\n##  9 Afghanistan Asia       1992    41.7\n## 10 Afghanistan Asia       1997    41.8\n## # â„¹ 1,694 more rows\nlevels(gapminder_short$continent)\n## [1] \"Asia\"     \"Europe\"   \"Africa\"   \"Americas\" \"Oceania\""},{"path":"import-export.html","id":"daten-exportieren","chapter":"Kapitel 8 Daten I/O","heading":"8.4 Daten exportieren","text":"Bevor wir etwas exportieren kÃ¶nnen, mÃ¼ssen wir natÃ¼rlich (sicher nicht richtig ist - niemand zwingt uns dazu ğŸ˜‰) etwas berechnen, das es wert ist, exportiert zu werden. Lasst uns daher eine Zusammenfassung der maximalen Lebenserwartung auf LÃ¤nderebene erstellen.Das Objekt gap_life_exp betrachten wir nun als Zwischenergebnis, das wir fÃ¼r die Zukunft und fÃ¼r nachgelagerte Analysen oder Visualisierungen speichern wollen.Die Haupt-Exportfunktion readr ist write_delim(). FÃ¼r verschiedene Dateiformate gibt es auch hier wieder verschiedene Komfortfunktionen. Mithilfe von write_csv() kÃ¶nnen wir den Inhalt von gap_life_exp einer kommagetrennten Datei abspeichern.Schauen wir uns die ersten paar Zeilen von gap_life_exp.csv . Dazu kÃ¶nnen wir entweder die Datei Ã¶ffnen oder z.B. im Terminal head verwendenDas sieht recht ordentlich aus, obwohl es keine sichtbare Ausrichtung oder Trennung Spalten gibt. HÃ¤tten wir die Basisfunktion read.csv() benutzt, wÃ¼rden wir Zeilennamen und viele AnfÃ¼hrungszeichen sehen, es sei denn, wir hÃ¤tten diese Features explizit abgeschaltet. Das schÃ¶nere Standardverhalten ist daher der Hauptgrund, warum wir readr::write_csv() gegenÃ¼ber write.csv() bevorzugen.Bemerkung: Es ist auch nicht wirklich fair, sich Ã¼ber den Mangel sichtbarer Ausrichtung zu beklagen. SchlieÃŸlich erzeugen wir Dateien, die der Computer lesen soll. Falls ihr aber wirklich der Datei â€œherumstÃ¶bernâ€ wollt, benutzt View() RStudio. Oder Ã¶ffnet die Datei mit einem Spreadsheet Programm (!). Aber erliegt NIE der Versuchung, dort Datenmanipulationen vorzunehmen â€¦ kehrt zurÃ¼ck zu R und schreibt dort die entsprechenden Befehle, die ihr die nÃ¤chsten 15 Mal (oder oft wie nÃ¶tig) ausfÃ¼hren kÃ¶nnt, wenn ihr diesen Datensatz (oder DatensÃ¤tze derselben Form) importieren/bereinigen/aggregieren/exportieren wollt.","code":"\ngap_life_exp <- gapminder %>%\n  group_by(country, continent) %>% \n  summarise(life_exp = max(lifeExp)) %>% \n  ungroup()\n## `summarise()` has grouped output by 'country'. You can override using the\n## `.groups` argument.\ngap_life_exp\n## # A tibble: 142 Ã— 3\n##    country     continent life_exp\n##    <chr>       <chr>        <dbl>\n##  1 Afghanistan Asia          43.8\n##  2 Albania     Europe        76.4\n##  3 Algeria     Africa        72.3\n##  4 Angola      Africa        42.7\n##  5 Argentina   Americas      75.3\n##  6 Australia   Oceania       81.2\n##  7 Austria     Europe        79.8\n##  8 Bahrain     Asia          75.6\n##  9 Bangladesh  Asia          64.1\n## 10 Belgium     Europe        79.4\n## # â„¹ 132 more rows\nwrite_csv(gap_life_exp, \"data/gap_life_exp.csv\")"},{"path":"import-export.html","id":"daten-Ã¼ber-eine-api","chapter":"Kapitel 8 Daten I/O","heading":"8.5 Daten Ã¼ber eine API","text":"APIs (Application Programming Interface) sind eine sehr nÃ¼tzliche Methode, um auf interessante Daten zuzugreifen, die online zur VerfÃ¼gung gestellt werden.Anstatt einen Datensatz herunterladen zu mÃ¼ssen, ermÃ¶glichen APIs Daten direkt von bestimmten Webseiten Ã¼ber eine Schnittstelle anzufordern. Viele groÃŸe Webseiten wie Twitter und Facebook ermÃ¶glichen Ã¼ber APIs den Zugriff auf Teile ihrer Daten.Wir werden die Grundlagen des Zugriffs auf eine API besprechen. Dazu benÃ¶tigt ihr aber kein Vorwissen bzgl. APIs.","code":""},{"path":"import-export.html","id":"einfÃ¼hrung","chapter":"Kapitel 8 Daten I/O","heading":"8.5.1 EinfÃ¼hrung","text":"API ist ein allgemeiner Begriff fÃ¼r den Ort, dem ein Computerprogramm mit einem anderen oder mit sich selbst interagiert. Wir sprechen Ã¼ber Web-APIs, bei denen zwei verschiedene Computer - ein Client und ein Server - miteinander interagieren, um Daten anzufordern bzw. bereitzustellen.APIs bieten eine ausgefeilte MÃ¶glichkeit Daten von einer Webseite anzufordern. Wenn eine Webseite wie Twitter eine API einrichtet, richten sie im Wesentlichen einen Computer ein, der auf Datenanfragen wartet.Sobald dieser Computer eine Datenabfrage empfÃ¤ngt, verarbeitet er die Daten selbst und sendet sie den Computer, der sie angefordert hat. Unsere Aufgabe wird es sein R Code zu schreiben, der die Anfrage erstellt und dem Computer, auf dem die API lÃ¤uft, mitteilt, wir benÃ¶tigen. Dieser Computer liest dann unseren Code, verarbeitet die Anfrage und gibt schÃ¶n formatierte Daten zurÃ¼ck, die mithilfe existierender R Pakete verarbeitet werden kÃ¶nnen.","code":""},{"path":"import-export.html","id":"erstellen-von-api-abfragen-in-r","chapter":"Kapitel 8 Daten I/O","heading":"8.5.2 Erstellen von API-Abfragen in R","text":"Um mit APIs R zu arbeiten, mÃ¼ssen wir ein paar neue Pakete laden (und vorher natÃ¼rlich installieren). Konkret werden wir mit den Paketen httr und jsonlite arbeiten. Sie spielen bei der Einbindung der APIs unterschiedliche Rollen, aber beide sind unverzichtbar.Vermutlich habt ihr die beiden Pakete bisher nicht installiert. Daher starten wir mit dem Installieren dieser beiden Paketeund laden sie anschlieÃŸend","code":"\ninstall.packages(c(\"httr\", \"jsonlite\"))\nlibrary(httr)\nlibrary(jsonlite)\n## Warning: package 'jsonlite' was built under R version 4.4.1\n## \n## Attaching package: 'jsonlite'\n## The following object is masked from 'package:purrr':\n## \n##     flatten"},{"path":"import-export.html","id":"unsere-erste-api-anfrage-stellen","chapter":"Kapitel 8 Daten I/O","heading":"8.5.3 Unsere erste API-Anfrage stellen","text":"Der erste Schritt, um Daten von einer API zu erhalten, ist die eigentliche Anfrage R. Diese Anfrage wird den Server geschickt, der Ã¼ber die API verfÃ¼gt, und wenn alles reibungslos verlÃ¤uft, wird er uns eine Antwort zurÃ¼cksenden.Es gibt verschiedene Arten von Anfragen, die man einen API-Server stellen kann. Diese verschiedenen Typen von Anfragen entsprechen verschiedenen Aktionen, die der Server ausfÃ¼hren soll.FÃ¼r unsere Zwecke fragen wir lediglich nach Daten, einer GET-Anfrage entspricht. Andere Arten von Anfragen sind z.B. POST (post file) und PUT (send put request), aber diese sind fÃ¼r uns nicht von Interesse und werden wir daher nicht weiter besprechen.Um eine GET-Anfrage zu erstellen, mÃ¼ssen wir die GET() Funktion aus dem httr Paket verwenden. Die GET() Funktion benÃ¶tigt als Input eine URL, die die Adresse des Servers angibt, den die Anforderung gesendet werden soll.Als Beispiel werden wir mit der Open Notify API arbeiten, die Daten zu verschiedenen NASA-Projekten enthÃ¤lt. Mithilfe der Open Notify API kÃ¶nnen wir uns Ã¼ber den Standort der Internationalen Raumstation informieren und erfahren, wie viele Personen sich derzeit im Weltraum aufhalten.Wir beginnen damit, dass wir unsere Anfrage mit der GET() Funktion stellen und die URL der API angeben:Die Ausgabe der Funktion GET() ist eine Liste, die alle Informationen enthÃ¤lt, die vom API-Server zurÃ¼ckgegeben werden.","code":"\njdata <- GET(\"http://api.open-notify.org/astros.json\")"},{"path":"import-export.html","id":"get-ausgabe","chapter":"Kapitel 8 Daten I/O","heading":"8.5.4 GET() Ausgabe","text":"Schauen wir uns , wie die Variable jdata der R-Konsole aussieht:Als erstes fÃ¤llt auf, dass die URL enthalten ist, die die GET-Anfrage gesendet wurde. AuÃŸerdem erkennen wir das Datum und die Uhrzeit, zu der die Anfrage gestellt wurde, sowie die GrÃ¶ÃŸe der Antwort.Die Information Content-Type gibt uns eine Vorstellung davon, welche Form die Daten haben. Diese spezielle Antwort besagt, dass die Daten ein JSON-Format annehmen, womit auch klar ist warum wir das Paket jsonlite geladen haben.Der Status verdient eine besondere Aufmerksamkeit. Status bezieht sich auf den Erfolg oder Misserfolg der API-Anfrage, und er wird Form einer Zahl angegeben. Die zurÃ¼ckgegebene Nummer gibt Auskunft darÃ¼ber, ob die Anfrage erfolgreich war oder nicht. Dort kÃ¶nnen auch GrÃ¼nde fÃ¼r einen mÃ¶glichen Misserfolg enthalten sein.Die Zahl 200 ist das, wir sehen wollen. Sie entspricht einem erfolgreichen Antrag, und das ist es, wir hier haben. Eine Ãœbersicht Ã¼ber weitere Status Codes findet man z.B. auf dieser Webseite.","code":"\njdata\n## Response [http://api.open-notify.org/astros.json]\n##   Date: 2024-10-16 21:45\n##   Status: 200\n##   Content-Type: application/json\n##   Size: 587 B"},{"path":"import-export.html","id":"handling-json-data","chapter":"Kapitel 8 Daten I/O","heading":"8.5.5 Handling JSON Data","text":"JSON steht fÃ¼r JavaScript Object Notation. WÃ¤hrend JavaScript eine weitere Programmiersprache ist, liegt unser Schwerpunkt bei JSON auf seiner Struktur. JSON ist nÃ¼tzlich, weil es von einem Computer leicht lesbar ist, und aus diesem Grund ist es zur primÃ¤ren Art und Weise geworden, wie Daten Ã¼ber APIs transportiert werden. Die meisten APIs senden ihre Antworten im JSON-Format.JSON ist als eine Reihe von SchlÃ¼ssel-Werte-Paaren formatiert, wobei ein bestimmtes Wort (â€œSchlÃ¼sselâ€) mit einem bestimmten Wert assoziiert ist. Ein Beispiel fÃ¼r diese SchlÃ¼ssel-Wert-Struktur ist unten dargestellt:ihrem aktuellen Zustand sind die Daten der Variablen jdata nicht verwendbar. Die Daten sind als Unicode-Rohdaten jdata enthalten, und mÃ¼ssen das JSON-Format konvertiert werden.Dazu mÃ¼ssen wir zunÃ¤chst den rohen Unicode character Daten konvertieren, die dem oben gezeigten JSON-Format Ã¤hneln. Die Funktion rawToChar() fÃ¼hrt genau diese Aufgabe aus:Die resultierende Zeichenfolge sieht zwar recht unordentlich aus, aber es liegt wirklich die JSON-Struktur vor.Ausgehend von diesem character Vektor kÃ¶nnen wir nun mit fromJSON(), aus dem jsonlite Paket, alles ein Listenformat transformieren.Die fromJSON() Funktion benÃ¶tigt einen character Vektor, der die JSON-Struktur enthÃ¤lt, die wir aus der Ausgabe von rawToChar() erhalten haben. Wenn wir also diese beiden Funktionen nacheinander anwenden, erhalten wir die gewÃ¼nschten Daten einem Format, das wir R leicht bearbeiten kÃ¶nnen.Die Liste data hat drei Elemente. Uns interessiert erster Linie das Data Frame people.Also, da haben wir unsere Antwort: Zum Zeitpunkt des letzten Updates Oct 16, 2024 von R4ews befanden sich 12 Personen im Weltraum. Aber wenn ihr den Code zu einem spÃ¤teren Zeitpunkt ausprobiert, kÃ¶nnten es auch schon wieder andere Namen und eine andere Anzahl sein. Das ist einer der Vorteile von APIs - im Gegensatz zu DatensÃ¤tzen, die man im Spreadsheet Format herunterladen kann, werden sie der Regel Echtzeit oder nahezu Echtzeit aktualisiert. APIs bieten somit die MÃ¶glichkeit leicht auf sehr aktuelle Daten zuzugreifen.diesem Beispiel haben wir einen sehr unkomplizierten API-Workflow durchlaufen. Die meisten APIs fordern, dass man demselben allgemeinen Muster folgt, aber dabei kÃ¶nnen die jeweilgen Aufrufe/Befehle durchaus deutlich komplexer sein.unserem Beispiel war es ausreichen nur die URL anzugeben. Aber einige APIs verlangen mehr Informationen vom Benutzer. Darauf gehen wir aber erstmal nicht weiter ein. Stattdessen fragen wir noch nach dem Ort der ISS im Moment der AbfrageDiese API gibt uns die Zeit Form von Unixzeit zurÃ¼ck. Unixzeit ist die Zeitspanne, die seit dem 1. Januar 1970 vergangen ist. Mithilfe der Funktion as_datetime() aus dem lubridate Paket kÃ¶nnen wir die Unixzeit aber leicht umrechnenDamit wollen wir den Abschnitt zu APIs beenden. Macht euch bewusst, dass wir hier wirklich nur die Basics Bezug auf APIs eingefÃ¼hrt haben. Aber hoffentlich hat euch diese EinfÃ¼hrung trotzdem ausreichend Vertrauen gegeben, sich mit einigen komplexeren und leistungsfÃ¤higeren APIs auseinanderzusetzen.","code":"{\n    â€œnameâ€: â€œJane Doeâ€,\n    â€œnumber_of_skillsâ€: 2\n}\nrawToChar(jdata$content)\n## [1] \"{\\\"people\\\": [{\\\"craft\\\": \\\"ISS\\\", \\\"name\\\": \\\"Oleg Kononenko\\\"}, {\\\"craft\\\": \\\"ISS\\\", \\\"name\\\": \\\"Nikolai Chub\\\"}, {\\\"craft\\\": \\\"ISS\\\", \\\"name\\\": \\\"Tracy Caldwell Dyson\\\"}, {\\\"craft\\\": \\\"ISS\\\", \\\"name\\\": \\\"Matthew Dominick\\\"}, {\\\"craft\\\": \\\"ISS\\\", \\\"name\\\": \\\"Michael Barratt\\\"}, {\\\"craft\\\": \\\"ISS\\\", \\\"name\\\": \\\"Jeanette Epps\\\"}, {\\\"craft\\\": \\\"ISS\\\", \\\"name\\\": \\\"Alexander Grebenkin\\\"}, {\\\"craft\\\": \\\"ISS\\\", \\\"name\\\": \\\"Butch Wilmore\\\"}, {\\\"craft\\\": \\\"ISS\\\", \\\"name\\\": \\\"Sunita Williams\\\"}, {\\\"craft\\\": \\\"Tiangong\\\", \\\"name\\\": \\\"Li Guangsu\\\"}, {\\\"craft\\\": \\\"Tiangong\\\", \\\"name\\\": \\\"Li Cong\\\"}, {\\\"craft\\\": \\\"Tiangong\\\", \\\"name\\\": \\\"Ye Guangfu\\\"}], \\\"number\\\": 12, \\\"message\\\": \\\"success\\\"}\"\ndata <-  fromJSON(rawToChar(jdata$content))\nglimpse(data)\n## List of 3\n##  $ people :'data.frame': 12 obs. of  2 variables:\n##   ..$ craft: chr [1:12] \"ISS\" \"ISS\" \"ISS\" \"ISS\" ...\n##   ..$ name : chr [1:12] \"Oleg Kononenko\" \"Nikolai Chub\" \"Tracy Caldwell Dyson\"..\n##  $ number : int 12\n##  $ message: chr \"success\"\ndata$people\n##       craft                 name\n## 1       ISS       Oleg Kononenko\n## 2       ISS         Nikolai Chub\n## 3       ISS Tracy Caldwell Dyson\n## 4       ISS     Matthew Dominick\n## 5       ISS      Michael Barratt\n## 6       ISS        Jeanette Epps\n## 7       ISS  Alexander Grebenkin\n## 8       ISS        Butch Wilmore\n## 9       ISS      Sunita Williams\n## 10 Tiangong           Li Guangsu\n## 11 Tiangong              Li Cong\n## 12 Tiangong           Ye Guangfu\njdata <-  GET(\"http://api.open-notify.org/iss-now.json\",)\ndata <- fromJSON(rawToChar(jdata$content))\ndata$iss_position\n## $latitude\n## [1] \"39.2660\"\n## \n## $longitude\n## [1] \"-140.0933\"\ndata$timestamp\n## [1] 1729115122\nlubridate::as_datetime(data$timestamp)\n## [1] \"2024-10-16 21:45:22 UTC\""},{"path":"import-export.html","id":"weiteres-material","chapter":"Kapitel 8 Daten I/O","heading":"8.6 Weiteres Material","text":"Wer noch mehr zum Thema Daten Import lesen , der soll einen Blick das Kapitel Data import im Buch R Data Science von Hadley Wickham und Garrett Grolemund (2016) werfen.","code":""},{"path":"tidy.html","id":"tidy","chapter":"Kapitel 9 tidy was?","heading":"Kapitel 9 tidy was?","text":"Idealerweise liegt ein Datensatz vor, dass er gut von einem Computer gelesen werden kann. der Regel sind die DatensÃ¤tze, mit denen wir uns beschÃ¤ftigen, ja umfangreich, d.h. der Mensch den Datensatz gar nicht (ein-)lesen. Trotzdem sind DatensÃ¤tze oft anders angelegt (der Mensch, und nicht der Computer ğŸ’», trifft die Entscheidung Ã¼ber das Layout).Der Computer kann einen Datensatz gut verarbeiten, wenn wir den Datensatz als tidy bezeichnen kÃ¶nnen. Hauptmerkmale von einem tidy Datensatz sind:jede Spalte ist eine Variablejede Zeile ist eine BeobachtungLiegen untidy Daten vor, verlÃ¤ngert sich (fast) immer die Zeit bis man mit den interessanten Schritten, z.B. Erstellen einer Grafik, starten kann. Daher lohnt es sich immer mal inne zu halten um zu Ã¼berlegen, ob die Daten tidy sind. Unordnung im Datensatz ist eine hÃ¤ufige, aber oft Ã¼bersehene, Ursache fÃ¼r unnÃ¶tige Qualen bei der Datenanalyse und -visualisierung.","code":""},{"path":"tidy.html","id":"lord-of-the-rings","chapter":"Kapitel 9 tidy was?","heading":"9.1 Lord of the Rings","text":"Von Jenny Byran (Autorin von STAT 545) haben wir folgenden Beispieldatensatz Ã¼bernommen: Data Lord Rings TrilogyWir haben eine Tabelle pro Film. jeder Tabelle haben wir die Gesamtzahl der gesprochenen WÃ¶rter, von Charakteren verschiedener Kategorien und Geschlechter.Stellt euch vor, diese drei Tabellen als separate ArbeitsblÃ¤tter einer Excel-Datei zu finden. Oder als Tabellen auf einer Webseite oder einem Word-Dokument.Das Format der Tabellen macht es fÃ¼r Menschen einfach, die Anzahl der â€œTwo Towersâ€ von weiblichen Elfen gesprochenen WÃ¶rter zu lesen. Aber dieses Format macht es fÃ¼r einen Computer ziemlich schwer, solche Zahlen zu extrahieren und, noch wichtiger ist, damit zu rechnen oder sie grafisch darzustellen.Die Aufgabe ist schwer, da die Daten untidy sind. enthalten z.B. die Spalten Female und Male nicht die Information Ã¼ber das Geschlecht, sondern jeweils die Anzahl der gesprochenen Worte. Auf der anderen Seite gibt es keine Variable Words, deren Inhalt diese Anzahl eigentlich sein sollte..","code":""},{"path":"tidy.html","id":"tidy-lord-of-the-rings-data","chapter":"Kapitel 9 tidy was?","heading":"9.2 Tidy Lord of the Rings data","text":"AufgerÃ¤umt sehen die Daten folgendermaÃŸen aus:Beachtet, dass tidy Daten im Allgemeinen hÃ¶her und schmaler sind. Bestimmte Elemente werden Ã¶fter wiederholt, hier z. B. Hobbit. Aus diesen GrÃ¼nden lehnen wir tidy Daten oft instinktiv als ineffizient oder hÃ¤sslich ab. Aber, solange ihr nicht das Endprodukt fÃ¼r eine textuelle PrÃ¤sentation von Daten erstellt, solltet ihr diesen Instinkt ignorieren.","code":""},{"path":"tidy.html","id":"vorteile-von-tidy-data","chapter":"Kapitel 9 tidy was?","heading":"9.3 Vorteile von tidy data","text":"Wenn die Daten aufgerÃ¤umter Form vorliegen, ist es naheliegend, einen Computer zu holen, um weitere Zusammenfassungen zu machen oder eine Abbildung zu erstellen.dieser Form kÃ¶nnen wir nun leicht folgende Fragen beantworten:Wie viele WÃ¶rter haben die mÃ¤nnlichen Hobbits insgesamt gesprochen?Wie viele WÃ¶rter haben die mÃ¤nnlichen Hobbits insgesamt gesprochen?Dominiert eine bestimmte Race einen Film? Unterscheidet sich die dominierende Race den Filmen?Dominiert eine bestimmte Race einen Film? Unterscheidet sich die dominierende Race den Filmen?1. Wie viele WÃ¶rter haben die mÃ¤nnlichen Hobbits insgesamt gesprochen?Nun braucht es nur noch ein kleines bisschen Code, um die Gesamtwortzahl fÃ¼r beide Geschlechter aller Kategorien Ã¼ber alle Filme hinweg zu berechnen. Wir nutzen dazu die Komfortfunktion count().Die Gesamtzahl der von mÃ¤nnlichen Hobbits gesprochenen WÃ¶rter ist 8780. Hier war es wichtig, dass alle WortzÃ¤hlungen einer Variable des Data Frames zusammengefasst sind und zugehÃ¶rige Variablen fÃ¼r Geschlecht und Kategorie existieren.2. Dominiert eine bestimmte Kategorie einen Film? Unterscheidet sich die dominierende Kategorie den Filmen?ZunÃ¤chst summieren wir Ã¼ber die Geschlechter hinweg, um die Wortzahlen fÃ¼r die verschiedenen Kategorien pro Film zu erhalten.Wir kÃ¶nnen jetzt entweder die Zahlen ein bisschen anstarren, um die Frage zu beantworten, oder besser, die gerade berechneten Wortzahlen einem Balkendiagramm darstellen.Hobbits sind â€œFellowhip Ringâ€ stark vertreten, wÃ¤hrend die Menschen â€œTwo Towersâ€ viel mehr Leinwandzeit hatten. Im letzten Film, â€œReturn Kingâ€, war die Anzahl von Menschen gesprochener WÃ¶rter nur noch leicht hÃ¶her als die Anzahl von Worten, die von Hobbits gesprochen wurden.Auch hier war es wichtig, alle Daten einem einzigen Data Frame zu haben, alle WortzÃ¤hlungen einer einzigen Variable und zugehÃ¶rige Variablen fÃ¼r Film und Kategorie.Im nÃ¤chsten Schritt schauen wir uns nun , wie man aus den obigen drei Tabellen eine sauberen Datensatz erzeugt.","code":"\nlibrary(tidyverse)\nlotr_tidy %>% \n  count(Gender, Race, wt = Words)## # A tibble: 6 Ã— 3\n##   Gender Race       n\n##   <chr>  <chr>  <dbl>\n## 1 Female Elf     1743\n## 2 Female Hobbit    16\n## 3 Female Man      669\n## 4 Male   Elf     1994\n## 5 Male   Hobbit  8780\n## 6 Male   Man     8043\n(by_race_film <- lotr_tidy %>% \n   group_by(Film, Race) %>% \n   summarize(Words = sum(Words)))## `summarise()` has grouped output by 'Film'. You can override using the\n## `.groups` argument.## # A tibble: 9 Ã— 3\n## # Groups:   Film [3]\n##   Film                       Race   Words\n##   <chr>                      <chr>  <dbl>\n## 1 The Fellowship Of The Ring Elf     2200\n## 2 The Fellowship Of The Ring Hobbit  3658\n## 3 The Fellowship Of The Ring Man     1995\n## 4 The Return Of The King     Elf      693\n## 5 The Return Of The King     Hobbit  2675\n## 6 The Return Of The King     Man     2727\n## 7 The Two Towers             Elf      844\n## 8 The Two Towers             Hobbit  2463\n## 9 The Two Towers             Man     3990\nggplot(by_race_film, aes(x = Film, y = Words, fill = Race)) + \n  geom_bar(stat = \"identity\", position = \"dodge\") +\n  coord_flip() + guides(fill = guide_legend(reverse = TRUE)) + \n  scale_fill_brewer(palette = \"Set1\")"},{"path":"tidy.html","id":"untidy-lord-of-the-rings-data","chapter":"Kapitel 9 tidy was?","heading":"9.4 Untidy Lord of the Rings data","text":"Wir importieren nun die Daten, die den drei Tabellen dargestellt wurden.FÃ¼r jede Tabelle existiert eine eigene csv Datei:The_Fellowship_Of_The_Ring.csvThe_Two_Towers.csvThe_Return_Of_The_King.csvWir haben jetzt ein Data Frame pro Film, jeweils mit den vier VariablenDer erste Schritt beim AufrÃ¤umen dieser Daten besteht darin, sie zu einem Data Frame zusammenzufÃ¼gen, indem wir die drei Data Frames zeilenweise stapeln. Dazu kÃ¶nnen wir die Funktion dplyr::bind_rows() verwenden.Das Zusammensetzen eines groÃŸen Datenobjekts aus vielen kleinen ist eine relativ Ã¼bliche Aufgabe bei der Datenaufbereitung. Wenn die Teile Ã¤hnlich sind wie hier, ist es schÃ¶n, sie gleich zu einem Objekt zusammenzusetzen. anderen Szenarien mÃ¼sst ihr mÃ¶glicherweise einige Nacharbeiten den einzelnen Objekten vornehmen, bevor sie gut zusammengefÃ¼gt werden kÃ¶nnen.Wenn mÃ¶glich, sollte man die einzelnen StÃ¼cke frÃ¼h wie mÃ¶glich\nzusammensetzen, denn es ist einfacher und effizienter, ein einzelnes Objekt aufzurÃ¤umen als 20 oder 1000 oder â€¦Nun kÃ¶nnen wir aufrÃ¤umenDas Objekt lotr_untidy verletzt immer noch eines der Grundprinzipien von tidy data.Die Anzahl gesprochenen WÃ¶rtern ist eine grundlegende Variable unserem Datensatz und sie ist derzeit auf zwei Variablen verteilt, Female und Male.Konzeptionell mÃ¼ssen wir die Wortanzahl einer einzigen Variable zusammenfassen und eine neue Variable Gender erstellen, um zu verfolgen, ob die jeweilige Anzahl Worten von Frauen oder MÃ¤nnern gesprochen wurde. Diese Aufgabe kÃ¶nnen wir mit der Funktion tidyr::pivot_longer() bearbeiten.Um unseren obigen Aufruf von pivot_longer() zu erklÃ¤ren, lesen wir ihn mal von links nach rechts:Nach der Auswahl des Datensatzes lotr_untidy haben wird die Spalten Female und Male genommen und ihre Werte eine neue Variable Words zusammengefasst. Dies erzwingt die Erstellung einer neuen Variable Gender, die angibt, ob ein bestimmter Wert von Words von Female oder Male stammt.Alle anderen Variablen, wie Film, bleiben unverÃ¤ndert und werden einfach nach Bedarf repliziert. Die Dokumentation fÃ¼r pivot_longer() gibt weitere Beispiele und dokumentiert zusÃ¤tzliche Argumente.Wenn man sich diese Arbeit gemacht hat, macht es Sinn sich auch das Ergebnis abzuspeichernTrotzdem solltet ihr natÃ¼rlich auch die Skripte zur Datenaufbereitung sowie die Originaldaten abspeichern.","code":"\nfship <- read_csv(file.path(\"data\", \"The_Fellowship_Of_The_Ring.csv\"))\nttow <- read_csv(file.path(\"data\", \"The_Two_Towers.csv\"))\nrking <- read_csv(file.path(\"data\", \"The_Return_Of_The_King.csv\")) \nrking## # A tibble: 3 Ã— 4\n##   Film                   Race   Female  Male\n##   <chr>                  <chr>   <dbl> <dbl>\n## 1 The Return Of The King Elf       183   510\n## 2 The Return Of The King Hobbit      2  2673\n## 3 The Return Of The King Man       268  2459\nnames(rking)## [1] \"Film\"   \"Race\"   \"Female\" \"Male\"\nlotr_untidy <- bind_rows(fship, ttow, rking)\nlotr_untidy## # A tibble: 9 Ã— 4\n##   Film                       Race   Female  Male\n##   <chr>                      <chr>   <dbl> <dbl>\n## 1 The Fellowship Of The Ring Elf      1229   971\n## 2 The Fellowship Of The Ring Hobbit     14  3644\n## 3 The Fellowship Of The Ring Man         0  1995\n## 4 The Two Towers             Elf       331   513\n## 5 The Two Towers             Hobbit      0  2463\n## 6 The Two Towers             Man       401  3589\n## 7 The Return Of The King     Elf       183   510\n## 8 The Return Of The King     Hobbit      2  2673\n## 9 The Return Of The King     Man       268  2459\nlotr_tidy <-\n  pivot_longer(lotr_untidy, cols = c(\"Female\", \"Male\"), \n               names_to = 'Gender', \n               values_to = 'Words')\nlotr_tidy## # A tibble: 18 Ã— 4\n##    Film                       Race   Gender Words\n##    <chr>                      <chr>  <chr>  <dbl>\n##  1 The Fellowship Of The Ring Elf    Female  1229\n##  2 The Fellowship Of The Ring Elf    Male     971\n##  3 The Fellowship Of The Ring Hobbit Female    14\n##  4 The Fellowship Of The Ring Hobbit Male    3644\n##  5 The Fellowship Of The Ring Man    Female     0\n##  6 The Fellowship Of The Ring Man    Male    1995\n##  7 The Two Towers             Elf    Female   331\n##  8 The Two Towers             Elf    Male     513\n##  9 The Two Towers             Hobbit Female     0\n## 10 The Two Towers             Hobbit Male    2463\n## 11 The Two Towers             Man    Female   401\n## 12 The Two Towers             Man    Male    3589\n## 13 The Return Of The King     Elf    Female   183\n## 14 The Return Of The King     Elf    Male     510\n## 15 The Return Of The King     Hobbit Female     2\n## 16 The Return Of The King     Hobbit Male    2673\n## 17 The Return Of The King     Man    Female   268\n## 18 The Return Of The King     Man    Male    2459\nwrite_csv(lotr_tidy, file = file.path(\"data\", \"lotr_tidy.csv\"))"},{"path":"tidy.html","id":"und-jetzt-noch-ein-bisschen-schmutzig-machen","chapter":"Kapitel 9 tidy was?","heading":"9.5 Und jetzt noch ein bisschen â€œschmutzigâ€ machen","text":"Manchmal (aber nicht hÃ¤ufig) ist es nÃ¶tig die Daten im Wide Format zu haben. Daher wollen wir zum Schluss die gerade gesÃ¤uberten LOTR Daten nochmal ein bisschen untidy machen.Dazu arbeiten wir mit den Funktion tidyr::pivot_wider(). Wir nehmen nun die AusprÃ¤gungen der Variable Race (anschlieÃŸend dann Gender) als Variablennamen der neu zu bildenden Variablen. Die Werte dieser neuen Variablen sind durch die Variable Words festgelegt.Das erste Beispiel hat immer noch 6 Beobachtungen, zwei pro Film. Nehmen wir mal , dass wir aber nur eine Beobachtung pro Film haben wollen. Dazu mÃ¼ssten wir die mÃ¶glichen Kombinationen aus Race und Gender einer neuen/weiteren Variablen zusammenfassen. Dies kÃ¶nnen wir Ã¼ber die Funktion tidyr::unite() erreichen.Kombination mit pivot_wider() ergibt sich soZum Schluss kÃ¶nnten wir auch noch alles zurÃ¼ck auf Anfang stellen und die\ndrei DatensÃ¤tze vom Anfang wiederherstellenWir erhalten eine Liste mit drei Elemente, deren Inhalt den drei Tabellen vom Anfang entspricht. Die Daten zu â€œReturn Kingâ€ sind beispielsweise im zweiten Element enthalten.","code":"\n## Race\nlotr_tidy %>% \n  pivot_wider(names_from = Race, values_from = Words)## # A tibble: 6 Ã— 5\n##   Film                       Gender   Elf Hobbit   Man\n##   <chr>                      <chr>  <dbl>  <dbl> <dbl>\n## 1 The Fellowship Of The Ring Female  1229     14     0\n## 2 The Fellowship Of The Ring Male     971   3644  1995\n## 3 The Two Towers             Female   331      0   401\n## 4 The Two Towers             Male     513   2463  3589\n## 5 The Return Of The King     Female   183      2   268\n## 6 The Return Of The King     Male     510   2673  2459\n## Gender\nlotr_tidy %>% \n  pivot_wider(names_from = Gender, values_from = Words)## # A tibble: 9 Ã— 4\n##   Film                       Race   Female  Male\n##   <chr>                      <chr>   <dbl> <dbl>\n## 1 The Fellowship Of The Ring Elf      1229   971\n## 2 The Fellowship Of The Ring Hobbit     14  3644\n## 3 The Fellowship Of The Ring Man         0  1995\n## 4 The Two Towers             Elf       331   513\n## 5 The Two Towers             Hobbit      0  2463\n## 6 The Two Towers             Man       401  3589\n## 7 The Return Of The King     Elf       183   510\n## 8 The Return Of The King     Hobbit      2  2673\n## 9 The Return Of The King     Man       268  2459\nlotr_tidy %>% \n  unite(Race_Gender, Race, Gender)## # A tibble: 18 Ã— 3\n##    Film                       Race_Gender   Words\n##    <chr>                      <chr>         <dbl>\n##  1 The Fellowship Of The Ring Elf_Female     1229\n##  2 The Fellowship Of The Ring Elf_Male        971\n##  3 The Fellowship Of The Ring Hobbit_Female    14\n##  4 The Fellowship Of The Ring Hobbit_Male    3644\n##  5 The Fellowship Of The Ring Man_Female        0\n##  6 The Fellowship Of The Ring Man_Male       1995\n##  7 The Two Towers             Elf_Female      331\n##  8 The Two Towers             Elf_Male        513\n##  9 The Two Towers             Hobbit_Female     0\n## 10 The Two Towers             Hobbit_Male    2463\n## 11 The Two Towers             Man_Female      401\n## 12 The Two Towers             Man_Male       3589\n## 13 The Return Of The King     Elf_Female      183\n## 14 The Return Of The King     Elf_Male        510\n## 15 The Return Of The King     Hobbit_Female     2\n## 16 The Return Of The King     Hobbit_Male    2673\n## 17 The Return Of The King     Man_Female      268\n## 18 The Return Of The King     Man_Male       2459\nlotr_tidy %>% \n  unite(Race_Gender, Race, Gender) %>% \n  pivot_wider(names_from = Race_Gender, values_from = Words)## # A tibble: 3 Ã— 7\n##   Film         Elf_Female Elf_Male Hobbit_Female Hobbit_Male Man_Female Man_Male\n##   <chr>             <dbl>    <dbl>         <dbl>       <dbl>      <dbl>    <dbl>\n## 1 The Fellowsâ€¦       1229      971            14        3644          0     1995\n## 2 The Two Towâ€¦        331      513             0        2463        401     3589\n## 3 The Return â€¦        183      510             2        2673        268     2459\n(sep_list <- lotr_tidy %>% \n  pivot_wider(names_from = Gender, values_from = Words) %>%\n   group_split(Film))## <list_of<\n##   tbl_df<\n##     Film  : character\n##     Race  : character\n##     Female: double\n##     Male  : double\n##   >\n## >[3]>\n## [[1]]\n## # A tibble: 3 Ã— 4\n##   Film                       Race   Female  Male\n##   <chr>                      <chr>   <dbl> <dbl>\n## 1 The Fellowship Of The Ring Elf      1229   971\n## 2 The Fellowship Of The Ring Hobbit     14  3644\n## 3 The Fellowship Of The Ring Man         0  1995\n## \n## [[2]]\n## # A tibble: 3 Ã— 4\n##   Film                   Race   Female  Male\n##   <chr>                  <chr>   <dbl> <dbl>\n## 1 The Return Of The King Elf       183   510\n## 2 The Return Of The King Hobbit      2  2673\n## 3 The Return Of The King Man       268  2459\n## \n## [[3]]\n## # A tibble: 3 Ã— 4\n##   Film           Race   Female  Male\n##   <chr>          <chr>   <dbl> <dbl>\n## 1 The Two Towers Elf       331   513\n## 2 The Two Towers Hobbit      0  2463\n## 3 The Two Towers Man       401  3589\nsep_list[[2]]## # A tibble: 3 Ã— 4\n##   Film                   Race   Female  Male\n##   <chr>                  <chr>   <dbl> <dbl>\n## 1 The Return Of The King Elf       183   510\n## 2 The Return Of The King Hobbit      2  2673\n## 3 The Return Of The King Man       268  2459"},{"path":"tidy.html","id":"literatur-1","chapter":"Kapitel 9 tidy was?","heading":"9.6 Literatur","text":"Tidy data Kapitel R Data Science, Garrett Grolemund Hadley Wickham\ntidyr Paket\ntidyr PaketBad Data Handbook Q. Ethan McCallum, published Oâ€™Reilly.\nChapter 3: Data Intended Human Consumption, Machine Consumption Paul Murrell.\nChapter 3: Data Intended Human Consumption, Machine Consumption Paul Murrell.Tidy data Hadley Wickham. Journal Statistical Software. Vol. 59, Issue 10, Sep 2014. http://www.jstatsoft.org/v59/i10","code":""},{"path":"einfuehrung-ggplot2.html","id":"einfuehrung-ggplot2","chapter":"Kapitel 10 EinfÃ¼hrung","heading":"Kapitel 10 EinfÃ¼hrung","text":"Das Paket ggplot2 verwendet eine speziell Systematik beim Erzeugen von Grafiken. Diese basiert aufWilkinson (2005): Grammar Graphics, Springer.Kurz gesagt, ist die zugrunde liegende Idee, dass eine statistische Grafik eine Abbildung von Daten auf Ã¤sthetische Attribute (Farbe, Form, GrÃ¶ÃŸe) von geometrischen Objekten (Punkte, Linien, Balken) ist.Ferner kann eine Grafik auch noch statistische Transformationen der Daten enthalten. Ãœber die Verwendung verschiedener Facetten ist es mÃ¶glich dieselbe Darstellung fÃ¼r verschiedene Untergruppen des Datensatzes zu erzeugen.Ende ist es eine Kombination dieser unabhÃ¤ngigen Komponenten, die eine Grafik ausmacht.Wie immer, laden wir zu Beginn\nMan weiÃŸ ja vorher nie genau man alles braucht.","code":"\nlibrary(tidyverse)\n## â”€â”€ Attaching core tidyverse packages â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ tidyverse 2.0.0 â”€â”€\n## âœ” dplyr     1.1.4     âœ” readr     2.1.5\n## âœ” forcats   1.0.0     âœ” stringr   1.5.1\n## âœ” ggplot2   3.5.1     âœ” tibble    3.2.1\n## âœ” lubridate 1.9.3     âœ” tidyr     1.3.1\n## âœ” purrr     1.0.2     \n## â”€â”€ Conflicts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ tidyverse_conflicts() â”€â”€\n## âœ– dplyr::filter() masks stats::filter()\n## âœ– dplyr::lag()    masks stats::lag()\n## â„¹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors"},{"path":"einfuehrung-ggplot2.html","id":"idee","chapter":"Kapitel 10 EinfÃ¼hrung","heading":"10.1 Idee","text":"Die grundlegende Idee des ggplot2 Ansatzes zum Erstellen von Grafiken, besteht darin die Bausteine (verschiedene Layer) eines Plots unabhÃ¤ngig voneinander zu definieren und diese dann zu einer Grafik zusammenzufÃ¼gen. Eine Grafik besteht immer aus:den Daten (als data.frame oder tibble), die ihr visualisieren mÃ¶chtetden Daten (als data.frame oder tibble), die ihr visualisieren mÃ¶chteteiner Reihe von Zuordnungen (einem mapping), die beschreiben, wie Variablen aus dem Datensatz auf Ã¤sthetische Attribute abgebildet werdeneiner Reihe von Zuordnungen (einem mapping), die beschreiben, wie Variablen aus dem Datensatz auf Ã¤sthetische Attribute abgebildet werdengeometrischen Objekten (geoms), die beschreiben man Ende wirklich sieht, also z.B. Punkte, Linien, â€¦geometrischen Objekten (geoms), die beschreiben man Ende wirklich sieht, also z.B. Punkte, Linien, â€¦einem Koordinatensystem, das beschreibt, wie die Koordinaten der Daten auf die Ebene der Grafik abgebildet werden. AuÃŸerdem stellt es Achsen und Gitternetzlinien zur VerfÃ¼gung, die das Lesen der Grafik ermÃ¶glichen. Normalerweise verwenden wir ein kartesisches Koordinatensystem, aber es gibt natÃ¼rlich auch noch eine Reihe anderer Optionen.einem Koordinatensystem, das beschreibt, wie die Koordinaten der Daten auf die Ebene der Grafik abgebildet werden. AuÃŸerdem stellt es Achsen und Gitternetzlinien zur VerfÃ¼gung, die das Lesen der Grafik ermÃ¶glichen. Normalerweise verwenden wir ein kartesisches Koordinatensystem, aber es gibt natÃ¼rlich auch noch eine Reihe anderer Optionen.Skalen (scales), die Werte der Daten abbilden auf Werte einem Ã¤sthetischen Raum, sei es Farbe, GrÃ¶ÃŸe oder Form.Skalen (scales), die Werte der Daten abbilden auf Werte einem Ã¤sthetischen Raum, sei es Farbe, GrÃ¶ÃŸe oder Form.ZusÃ¤tzlich kann die Grafik aber auch nochstatistische Transformationen (stat), die eine Zusammenfassung der Daten visualisieren,statistische Transformationen (stat), die eine Zusammenfassung der Daten visualisieren,Facetten, die es ermÃ¶glichen dieselbe Darstellung fÃ¼r verschiedene Untergruppen des Datensatzes zu erzeugen,Facetten, die es ermÃ¶glichen dieselbe Darstellung fÃ¼r verschiedene Untergruppen des Datensatzes zu erzeugen,â€¦â€¦enthalten.Die einzelnen Teile eines Plots werden mit dem + Operator zusammengefÃ¼gt. Initialisiert wird ein Plot mit ggplot(). Ohne weitere Bestandteile wird aber nur eine leere Grafik erzeugtIn den folgenden Abschnitten lernen wir daher wie weitere Bestandteile zum Plot hinzugefÃ¼gt werden.","code":"\nlibrary(gapminder)\nggplot(gapminder) "},{"path":"einfuehrung-ggplot2.html","id":"ein-einfacher-scatterplot","chapter":"Kapitel 10 EinfÃ¼hrung","heading":"10.2 Ein einfacher Scatterplot","text":"Wir schauen uns zum Start einfach mal fÃ¼r Deutschland den Verlauf des gdpPercap Ã¼ber die Zeit .dieser Grafik haben wir Ã¼ber geom_point() die Art des geometrischen Objekts gewÃ¤hlt. diesem Fall Punkte. Wenn uns die Form (shape) der Punkte nicht gefÃ¤llt, kÃ¶nnen wir diese natÃ¼rlich Ã¤ndern, z.B. DreieckeAber dazu mehr im Abschnitt Scales.Bemerkung: diesem einfachen Beispiel haben wir bereits gesehen, dass ggplot() Ã¼ber den Pipe-Operator verknÃ¼pft werden kann.","code":"\ngapminder %>%\n  filter(country == \"Germany\") %>% # auswÃ¤hlen der Daten \n  ggplot(aes(x = year, y = gdpPercap)) +  # Plot initialisieren\n  geom_point() # Punkte zum Darstellen der Daten verwenden\ngapminder %>%\n  filter(country == \"Germany\") %>% \n  ggplot(aes(x = year, y = gdpPercap)) +  \n  geom_point(shape = 2) # shape auf festen Wert 2 gesetzt"},{"path":"bausteine.html","id":"bausteine","chapter":"Kapitel 11 Bausteine","heading":"Kapitel 11 Bausteine","text":"den nÃ¤chsten Abschnitten schauen wir uns die verschiedene Bausteine einer ggplot2 Grafik genauer . Dabei sehen wir auch eine Reihe von Beispielen, die uns zeigen, wie man die verschiedenen Bausteine miteinander verknÃ¼pft.","code":""},{"path":"bausteine.html","id":"aes","chapter":"Kapitel 11 Bausteine","heading":"11.1 Aesthetics","text":"Mit der Funktion aes() lÃ¤sst sich das Aussehen der Grafik regeln (nicht der Inhalt). Wir kÃ¶nnen z.B.die Position: x und ydie Farbe: color und filldie Form: shapeden Linientyp: linetypedie GrÃ¶ÃŸe der Symbol: sizefestlegen. Die jeweiligen Werte dieser aesthetics kÃ¶nnen entweder fix oder AbhÃ¤ngigkeit von Variablen aus dem verwendeten Datensatz gewÃ¤hlt werden.\nWerden die Werte AbhÃ¤ngigkeit der Daten gewÃ¤hlt, definiert die Funktion aes() ein mapping zwischen den Daten und den aesthetics der Grafik.Nicht jedes aesthetic kann allerdings mit allen verfÃ¼gbaren geoms kombiniert werden. macht z.B. der linetype ja wenig Sinn geom_point(). Eine Ãœbersicht der mÃ¶glichen aesthetics findet man der Hilfe jeder geom-Funktion. der Hilfe von geom_point() findet man z.B.man Ã¼ber die Daten Werte fÃ¼r die verschiedenen aesthetics definieren, muss dies innerhalb der aes() Funktion geschehen. Werden Argumente auf fixe Werte gesetzt, sind sie auÃŸerhalb der aes() Funktion zu setzen.einem Plot der gdpPercap Daten fÃ¼r Deutschland und Frankreich wollen wir anhand von unterschiedlichen Farben die Daten der beiden LÃ¤nder unterscheiden. Dazu mÃ¼ssen wir nur colour innerhalb von aes() den Wert country zuweisen. ZusÃ¤tzlich wollen wir die GrÃ¶ÃŸe der zu zeichnenden Punkte etwas erhÃ¶hen. Aber die GrÃ¶ÃŸe soll fÃ¼r beide LÃ¤nder gleich sein. Daher definieren wir size auÃŸerhalb der aes() Funktion.","code":"geom_point {ggplot2}    R Documentation\nPoints\nDescription\nThe point geom is used to create scatterplots. The scatterplot is most useful for displaying the relationship between two continuous variables. It can be used to compare one continuous and one categorical variable, or two categorical variables, but a variation like geom_jitter(), geom_count(), or geom_bin2d() is usually more appropriate. A bubblechart is a scatterplot with a third variable mapped to the size of points.\n\nUsage\ngeom_point(\n  mapping = NULL,\n  data = NULL,\n  stat = \"identity\",\n  position = \"identity\",\n  ...,\n  na.rm = FALSE,\n  show.legend = NA,\n  inherit.aes = TRUE\n)\n\n...\n\nAesthetics\ngeom_point() understands the following aesthetics (required aesthetics \nare in bold):\n\nx\n\ny\n\nalpha\n\ncolour\n\nfill\n\ngroup\n\nshape\n\nsize\n\nstroke\n\nLearn more about setting these aesthetics in vignette(\"ggplot2-specs\").\n\ngapminder %>%\n  filter(country %in% c(\"Germany\",\"France\")) %>%  \n  ggplot(mapping = aes(x = year, y = gdpPercap, colour = country)) +  \n  geom_point(size = 3) "},{"path":"bausteine.html","id":"geoms","chapter":"Kapitel 11 Bausteine","heading":"11.2 Geoms","text":"Mithilfe der geom_xxx() Funktionen kÃ¶nnen wir die Daten als geometrische Formen (Punkte, Linien, â€¦) einer Grafik darstellen. Jede ggplot2 Grafik benÃ¶tigt daher mindestens ein geom. Beispiele sindgeom_point()geom_line()geom_histogram()Da wir nicht alle verfÃ¼gbaren geoms auflisten kÃ¶nnen/wollen, sei dieser Stelle auf die ggplot2 Seite verwiesen.Im nÃ¤chsten Beispiel stellen wir die gleichen Daten/Variablen Ã¼ber zwei verschiedene geoms dar.Obwohl die gleichen Daten visualisiert wurden, ist das Ergebnis doch recht unterschiedlich. Der Scatterplot zeigt alle (abgesehen von Overplotting) Daten, wohingegen mit geom_smooth() eine geglÃ¤tteter Zusammenhang dargestellt wird.Interessant sind hier natÃ¼rlich die wenigen groÃŸen gdpPercap Werte der linken GrafikKuwait hat Ã¼ber den gesamten Zeitraum sehr hohe GDP Werte. Aber zu Beginn der Aufzeichnungen waren die Werte Bezug auf die damals noch recht kleine PopulationsgrÃ¶ÃŸe sogar auÃŸergewÃ¶hnlich hoch.Einem ggplot Objekt kÃ¶nnen wir nicht nur ein geom zuordnen. Prinzipiell kÃ¶nnen wir beliebig viele weitere geoms hinzufÃ¼gen. Wir kÃ¶nnen also die gerade durchgefÃ¼hrte GlÃ¤ttung der Daten auch direkt zum Scatterplot hinzufÃ¼genWÃ¤hlen wir die Farbe eines geometrischen Objekts (oder mehrerer) anhand einer Faktorvariable, erhalten wir automatisch eine entsprechende LegendeBeachtet dabei, dass wir colour nur fÃ¼r geom_point() gewÃ¤hlt haben. Die GlÃ¤ttung erfolgt weiterhin Ã¼ber alle Daten und nicht separat fÃ¼r jeden Kontinent. diesem Fall haben wir geom_point() ein lokales mapping definiert.Aber natÃ¼rlich hÃ¤tten wir die GlÃ¤ttung auch pro Kontinent durchfÃ¼hren kÃ¶nnen. Dazu schreiben wir einfach colour das globale mapping und lÃ¶schen das lokale mapping geom_point() wieder.Nehmen wir mal , dass uns nun aber die Punkte etwas zu groÃŸ sind und die Linien sollten nicht durchgezogen sein. D.h. wir wÃ¼rden gerne andere (aber fixe, nicht von Variablen abhÃ¤ngende) aesthetic Werte setzen. Das lÃ¤sst sich schnell Ã¤ndern.","code":"\ngapminder %>%\n  ggplot(mapping = aes(x = year, y = gdpPercap)) +  \n  geom_point() \n\n\ngapminder %>%\n  ggplot(mapping = aes(x = year, y = gdpPercap)) +  \n  geom_smooth() \n## `geom_smooth()` using method = 'gam' and formula = 'y ~ s(x, bs = \"cs\")'\ngapminder %>%\n  filter(gdpPercap > 50000)\n## # A tibble: 6 Ã— 6\n##   country continent  year lifeExp     pop gdpPercap\n##   <fct>   <fct>     <int>   <dbl>   <int>     <dbl>\n## 1 Kuwait  Asia       1952    55.6  160000   108382.\n## 2 Kuwait  Asia       1957    58.0  212846   113523.\n## 3 Kuwait  Asia       1962    60.5  358266    95458.\n## 4 Kuwait  Asia       1967    64.6  575003    80895.\n## 5 Kuwait  Asia       1972    67.7  841934   109348.\n## 6 Kuwait  Asia       1977    69.3 1140357    59265.\ngapminder %>%\n  ggplot(mapping = aes(x = year, y = gdpPercap)) +  \n  geom_point() +\n  geom_smooth() \n## `geom_smooth()` using method = 'gam' and formula = 'y ~ s(x, bs = \"cs\")'\ngapminder %>%\n  ggplot(mapping = aes(x = year, y = gdpPercap)) +  \n  geom_point(mapping = aes(colour = continent)) +\n  geom_smooth() \n## `geom_smooth()` using method = 'gam' and formula = 'y ~ s(x, bs = \"cs\")'\ngapminder %>%\n  ggplot(mapping = aes(x = year, y = gdpPercap, colour = continent)) +  \n  geom_point() +\n  geom_smooth() \n## `geom_smooth()` using method = 'loess' and formula = 'y ~ x'\ngapminder %>%\n  ggplot(aes(x = year, y = gdpPercap, colour = continent)) +  \n  geom_point(size = 0.9) +\n  geom_smooth(linetype = 2) \n## `geom_smooth()` using method = 'loess' and formula = 'y ~ x'"},{"path":"bausteine.html","id":"stat-trans","chapter":"Kapitel 11 Bausteine","heading":"11.3 Statistische Transformationen","text":"Jede geom_xxx() Funktion besitzt eine â€œStandard-Statistikâ€, die beim Aufruf der Funktion berechnet wird.Bei einem Scatterplot ist die Statistik einfach nur die IdentitÃ¤t.Ein Balkendiagramm verwendet aber z.B.die Transformation count. Das macht durchaus Sinn, da ja gezÃ¤hlt werden muss/soll wie viele Beobachtungen die jeweilige Kategorie fallen.Die jeweiligen Statistiken kÃ¶nnten Ã¼ber die entsprechenden stat_xxx() Funktionen geplottet werden. Da aber jede geom_xxx() Funktion mit mindestens einer dieser stat_xxx() Funktionen verbunden ist, ist es oftmals einfacher direkt die entsprechende geom_xxx() Funktion zu verwenden. Aber generell kÃ¶nnte die jeweilige stat_xxx() Funktion auch direkt aufgerufen werden.Daher liefern die beiden nachfolgenden Befehle auch die exakt gleiche GrafikJedes geom hat zwar ein Standard-Transformation, aber natÃ¼rlich kÃ¶nnen oftmals noch weitere Transformationen berechnet/genutzt werden. Im Abschnitt Computed variables der Hilfe zu einem geom sieht man alle verfÃ¼gbaren Transformationen.FÃ¼r geom_bar() sind diesDie relativen HÃ¤ufigkeiten berechnet man also Ã¼ber prop. Dazu muss die y-Variable auf prop gesetzt werden. Da der Aufrufaber nach einer Variable prop suchen wÃ¼rde, muss eine alternative Notation diesem Fall verwendet werdenDer Befehl hat jetzt zwar eine Grafik erzeugt, aber die sieht noch nicht aus, wie wir das erwartet haben. Die\nrelativen HÃ¤ufigkeiten wurden innerhalb der fÃ¼nf Gruppen berechnet und nicht Ã¼ber alle Beobachtungen. D.h. wir mÃ¼ssen der Funktion noch sagen, dass die relativen HÃ¤ufigkeiten der fÃ¼nf verschiedenen AusprÃ¤gungen (Kontinente) eine Gruppe berechnet werden sollen. Dies geschieht Ã¼ber das group aesthetic.","code":"\nargs(geom_point)\n## function (mapping = NULL, data = NULL, stat = \"identity\", position = \"identity\", \n##     ..., na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) \n## NULL\nargs(geom_bar)\n## function (mapping = NULL, data = NULL, stat = \"count\", position = \"stack\", \n##     ..., just = 0.5, width = NULL, na.rm = FALSE, orientation = NA, \n##     show.legend = NA, inherit.aes = TRUE) \n## NULL\nggplot(gapminder, aes(x = continent)) + \n  geom_bar()\n\nggplot(gapminder, aes(x = continent)) + \n  stat_count()Computed variables\n\ncount\nnumber of points in bin\n\nprop\ngroupwise proportion\n\n\nggplot(gapminder, aes(x = continent, y = prop))\nggplot(gapminder, aes(x = continent, y = ..prop..)) + \n  geom_bar()\n## Warning: The dot-dot notation (`..prop..`) was deprecated\n## in ggplot2 3.4.0.\n## â„¹ Please use `after_stat(prop)` instead.\n## This warning is displayed once every 8 hours.\n## Call `lifecycle::last_lifecycle_warnings()` to\n## see where this warning was generated.\nggplot(gapminder, aes(x = continent, y = ..prop..)) + \n  geom_bar(aes(group = 1))"},{"path":"bausteine.html","id":"scales","chapter":"Kapitel 11 Bausteine","heading":"11.4 Scales","text":"Scales steuern die Zuordnung von Daten zu aesthetics. Sie nehmen die Daten und bestimmen damit GrÃ¶ÃŸe, Farbe, Position oder Form von Objekten. Sie erlauben euch auch die Achsen und die Legend nach euren Vorstellungen anzupassen.Man kann sicherlich mit ggplot2 Grafiken erstellen, ohne zu wissen, wie scales funktionieren. Aber wenn ihr versteht wie scales funktionieren und lernt, wie ihr sie einstellen kÃ¶nnt, werdet ihr viel mehr Kontrolle Ã¼ber eure Grafiken bekommen.Ãœber scale Funktionen der Form scale_\"aesthetic\"_\"type\" kÃ¶nnen wir aesthetics wiecolor und fillpositionsizeshapeline typemodifizieren. Argumente dieser Funktionen sind z.B. name, limits, breaks oder labels.Zuerst spielen wir etwas mit Farben. Dazu plotten wir erneut year gegen gdpPercap und wÃ¤hlen fÃ¼r jeden Kontinent eine eigene Farbe. Da wir die Farben Ã¼ber colour definieren, verwenden wir Funktionen aus der Klasse scale_colour_xxx(). HÃ¤tten wir beispielsweise FlÃ¤chen Ã¼ber das aesthetic fill mit Farbe gefÃ¼llt, wÃ¼rden wir Funktionen aus der Klasse scale_fill_xxx() verwenden um die Farben anzupassen.diesem Beispiel haben wir also die Farbe nachtrÃ¤glich Ã¼ber eine vorgegebene Palette, Grau-Stufen bzw. manuell gewÃ¤hlt. Im letzten Beispiel haben wir zusÃ¤tzlich noch den Titel der Legende geÃ¤ndert Ã¼ber das name Argument.Die Achsenbeschriftung der y-Achse ist nicht wirklich schÃ¶n, weil nicht unbedingt selbsterklÃ¤rend. Daher Ã¤ndern wir im nÃ¤chsten Schritt die Achsenbeschriftung.Da es sich bei gdpPercap um eine stetige Variable handelt, haben wir scale_y_continuous() verwendet (im Gegensatz zu scale_y_discrete()) um die Achsenbeschriftung zu Ã¤ndern. Ãœber die Hilfsfunktion labs() kÃ¶nnen wir die Beschriftung der Grafik aber auch einfacher/intuitiver Ã¤ndern.Die frÃ¼hen Kuwait-Beobachtungen ziehen die y-Achse stark auseinander. Daher kÃ¶nnte man vielleicht etwas den Plot hinein zoomen wollen. Dazu kann man das Koordinatensystem anpassen Ã¼ber coord_cartasian(). Alternativ kÃ¶nnte man auch mit der Funktion ylim() arbeiten (analog existiert natÃ¼rlich auch xlim()).Verwendet man aber xlim() bzw. ylim(), werden alle Datenpunkte, die nicht im zu plottenden Bereich liegen, aber nicht nur nicht gezeichnet, sondern auch aus dem Datensatz (fÃ¼r diesen einen Plot) entfernt. Dies hat dann Auswirkungen auf Teile des Plots, die auf statistische Transformationen basieren, welche mithilfe der vorhanden Daten berechnet werden.der rechten Grafik ist der Verlauf der Kurven unverÃ¤ndert. der linken Grafik hingegen liegt die Kurve fÃ¼r Asien nun bis Mitte der 80er Jahre deutlich unter der Kurve fÃ¼r Amerika.Weitere (mÃ¶gliche) PositionsÃ¤nderungen ergeben sich durch Skalierungen der Achsen wie scale_x_log10(), scale_y_sqrt() oderAm Ende von diesem Abschnitt wollen wir nochmal ein Blick auf die HÃ¤ufigkeitsverteilung bzgl. der verschiedenen Kontinente werfen. Diesmal wollen wir aber zusÃ¤tzlich noch die GDP pro Kopf Werte berÃ¼cksichtigen. Dazu teilen wir die GDP Werte niedrig (kleiner als das 0.25 Quantil aller Beobachtungen), mittel (zwischen dem 0.25 und 0.75 Quantil aller Beobachtungen) und hoch (Ã¼ber dem 0.75 Quantil aller Beobachtungen) ein. Diese Information nutzen wir dann zum EinfÃ¤rben der BalkenWir erkennen, dass die notwendige Klassifizierung der GDP Werte im Plot Befehl erfolgen kann. Das produzierte Ergebnis ist aber natÃ¼rlich nicht Ã¼berzeugend. Die Ãœberschrift, wie die Beschriftungen der Legende mÃ¼ssen angepasst werden. Dazu verwenden wir die Funktion scale_fill_discrete().dieser Darstellung bleibt es bei einem Balken pro Kontinent. WÃ¼rden wir aber gerne (bis zu) drei Balken pro Kontinent sehen, mÃ¼ssen die Positionierung Ã¤ndern.GefÃ¤llt einem das kartesische Koordinatensystem nicht, kÃ¶nnte man beispielsweise mit Polarkoordinaten arbeiten.FÃ¼r weitere Optionen sei hier auf die online Version der neuesten Auflage von ggplot2 (Wickham 2009) verwiesen.","code":"\n(p <- gapminder %>%\n  ggplot(aes(x = year, y = gdpPercap, colour = continent)) +  \n  geom_point(size = 0.9) +\n  geom_smooth(linetype = 2) )\n## `geom_smooth()` using method = 'loess' and\n## formula = 'y ~ x'\n\np + scale_colour_brewer(palette = \"Set1\") \n## `geom_smooth()` using method = 'loess' and\n## formula = 'y ~ x'\n# Farbpaletten von http://colorbrewer2.org/\n\np + scale_colour_grey(start = 0.1, end = 0.9) # keine so gute Wahl\n## `geom_smooth()` using method = 'loess' and\n## formula = 'y ~ x'\n\np + scale_colour_manual(\n  values = c(\"palevioletred3\", \"seagreen\", \"sienna1\", \"sienna4\", \"yellow\"),\n  name = \"Kontinent\")\n## `geom_smooth()` using method = 'loess' and\n## formula = 'y ~ x'\np <- p + \n  scale_colour_manual(\n  values = c(\"palevioletred3\", \"seagreen\", \"sienna1\", \"sienna4\", \"yellow\"))\n\np + scale_y_continuous(\"GDP pro Kopf\")\n## `geom_smooth()` using method = 'loess' and\n## formula = 'y ~ x'\n(p <- p + labs(x = \"Jahr\", y = \"GDP pro Kopf\",\n         title = \"Monoton steigendes GDP pro Kopf\",\n         subtitle = \"Gestrichelte Linie zeigt Durchschnittswerte Ã¼ber alle\n         LÃ¤nder pro Kontinent\"))\n## `geom_smooth()` using method = 'loess' and\n## formula = 'y ~ x'\np + ylim(0,55000)\n## `geom_smooth()` using method = 'loess' and\n## formula = 'y ~ x'\n## Warning: Removed 6 rows containing non-finite outside the\n## scale range (`stat_smooth()`).\n## Warning: Removed 6 rows containing missing values or\n## values outside the scale range (`geom_point()`).\n(p <- p + coord_cartesian(ylim = c(0, 55000)))\n## `geom_smooth()` using method = 'loess' and\n## formula = 'y ~ x'\np + scale_x_reverse()\n## `geom_smooth()` using method = 'loess' and\n## formula = 'y ~ x'\nggplot(gapminder, \n       aes(x = continent,\n           fill = cut(gdpPercap, \n                      breaks = c(0, quantile(gdpPercap,0.25),\n                                 quantile(gdpPercap, 0.75),\n                                 max(gdpPercap))\n                      )\n           )) + \n  geom_bar()\nq <- ggplot(gapminder, \n       aes(x = continent,\n           fill = cut(gdpPercap, \n                      breaks = c(0, quantile(gdpPercap,0.25),\n                                 quantile(gdpPercap, 0.75),\n                                 max(gdpPercap))\n                      )\n           )) \nq + \n  geom_bar() +\n  scale_fill_discrete(name = \"GDP\\nKlassifizierung\",\n                      labels = c(\"niedrig\", \"mittel\", \"hoch\"))\nq + \n  geom_bar(position = \"dodge\") +\n  scale_fill_discrete(name = \"GDP\\nKlassifizierung\",\n                      labels = c(\"niedrig\", \"mittel\", \"hoch\")) \nq + \n  geom_bar(position = \"dodge\") +\n  scale_fill_discrete(name = \"GDP\\nKlassifizierung\",\n                      labels = c(\"niedrig\", \"mittel\", \"hoch\")) +\n  coord_polar()"},{"path":"bausteine.html","id":"facets","chapter":"Kapitel 11 Bausteine","heading":"11.5 Facets","text":"DatensÃ¤tze lassen sich oftmals bzgl. vorhandener Variablen gruppieren. Die zu untersuchenden ZusammenhÃ¤nge zwischen weiteren Variablen sollten dann innerhalb dieser Gruppen dargestellt werden. Entsteht die Gruppierung basierend auf den AusprÃ¤gungen einer Variable, kann man z.B. mit facet_wrap() arbeitenIn der letzten Grafik verwenden alle fÃ¼nf Plots die gleiche Skala auf der y-Achse um die Vergleichbarkeit der Werte zu erhÃ¶hen. manchen FÃ¤llen mag dies aber stÃ¶rend sein. Mit dem Argument scales kÃ¶nnt ihr die Skala â€œbefreienâ€.Erfolgt die Gruppierung anhand von zwei Variablen, bietet facet_grid() eine passende Aufteilung des Grafikfensters Zeilen und Spalten. Neben dem Kontinent berÃ¼cksichtigen wir jetzt auch noch die PopulationsgrÃ¶ÃŸe des Landes. Konkret fragen wir ob die Population im entsprechenden Jahr grÃ¶ÃŸer als 5000000 ist, oder eben nicht.FÃ¼r Ozeanien erhalten wir z.B. eine Unterteilung Australien (TRUE) und Neuseeland (FALSE).Die Beschriftung der Spalten sieht natÃ¼rlich nicht besonders schÃ¶n aus. Ohne den Code ist die Beschriftung auch nicht zu verstehen, â€œist wahr??â€.Daher versuchen wir die Beschriftung Ã¼ber das Argument labeller der facet_grid() Funktion zu Ã¤ndern. ZulÃ¤ssige Werte fÃ¼r das Argument labeller kÃ¶nnen Ã¼ber die labeller() Funktion definiert werden. Hier hat man neben weiteren Optionen die MÃ¶glichkeit fÃ¼r jede AusprÃ¤gung der Variable, die eine Spalten- (oder Zeilen-) Aufteilung definiert, ein Label zu setzen. Dazu muss\ndie Variable Ã¼ber ihren Namen aufgerufen werden. Nun scheint es , dass ein Aufruf Ã¼ber â€œSondernamenâ€ wie pop > 5000000 nicht funktioniert. Um trotzdem die Verwendung von labeller zu illustrieren, definieren wir zuerst mit mutate eine neue Variable pop5 und setzen anschlieÃŸend die Labels Ã¼ber das Argument labeller.","code":"\ngapminder %>%\n  ggplot(aes(x = year, y = gdpPercap )) +  \n  geom_point(size = 0.9) +\n  geom_smooth(linetype = 2) +\n  facet_wrap(~ continent, ncol = 5)\n## `geom_smooth()` using method = 'loess' and\n## formula = 'y ~ x'\ngapminder %>%\n  ggplot(aes(x = year, y = gdpPercap )) +  \n  geom_point(size = 0.9) +\n  geom_smooth(linetype = 2) +\n  facet_wrap(~ continent, ncol = 2, scales = \"free\")\n## `geom_smooth()` using method = 'loess' and\n## formula = 'y ~ x'\ngapminder %>%\n  group_by(continent) %>%\n  ggplot(aes(x = year, y = gdpPercap )) +  \n  geom_point(size = 0.9) +\n  geom_smooth(linetype = 2) +\n  facet_grid(continent ~ pop > 5000000, scales = \"free\")\n## `geom_smooth()` using method = 'loess' and\n## formula = 'y ~ x'\ngapminder %>%\n  mutate(pop5 = pop > 5000000) %>%\n  group_by(continent) %>%\n  ggplot(aes(x = year, y = gdpPercap )) +  \n  geom_point(size = 0.9) +\n  geom_smooth(linetype = 2) +\n  facet_grid(continent ~ pop5, scales = \"free\",\n             labeller = labeller(\n               pop5 = c(`TRUE` = \"pop large than 5 MM\", \n                        `FALSE` = \"pop at most 5 MM\")))\n## `geom_smooth()` using method = 'loess' and\n## formula = 'y ~ x'"},{"path":"bausteine.html","id":"themes","chapter":"Kapitel 11 Bausteine","heading":"11.6 Themes","text":"AbschlieÃŸend wollen wir noch Ã¼ber verschiedene themes sprechen. Ãœber themes kann man das Aussehen der nicht datenbezogenen Elemente einer Grafik, wie z.B.die Beschriftungenden Hintergrunddie Legendeâ€¦.verÃ¤ndern. Eine Reihe von themes sind bereits vorhanden, wobei theme_gray() das Default theme ist. Siehe auch ?theme_gray().Wir mÃ¶chten nun gerne folgende Ã„nderungen der Grafik vornehmen:die GrÃ¶ÃŸe der Achsenbeschriftung Ã¤nderndie Gitterlinien ohne Beschriftung entfernendie Legende die Grafik verschiebendie Hintergrundfarbe der Grafik und der Legende Ã¤ndernDie meisten dieser Ã„nderungen kÃ¶nnen wir mit theme() durchfÃ¼hren.Ob das nun alles schÃ¶n aussieht, sei dahingestellt, aber es zeigt durchaus die vorhandenen MÃ¶glichkeiten.man gewisse Einstellung Ã¶fter verwenden, kann man diese auch einem theme Objekt speichern und wiederverwenden.","code":"\np\n## `geom_smooth()` using method = 'loess' and\n## formula = 'y ~ x'\np + theme_bw()\n## `geom_smooth()` using method = 'loess' and\n## formula = 'y ~ x'\np + theme_dark()\n## `geom_smooth()` using method = 'loess' and\n## formula = 'y ~ x'\np + theme_minimal()\n## `geom_smooth()` using method = 'loess' and\n## formula = 'y ~ x'\np <- p + scale_colour_brewer(palette = \"Set1\") \n## Scale for colour is already present.\n## Adding another scale for colour, which will\n## replace the existing scale.\np +\n  theme(\n    axis.text = element_text(size = 14),\n    legend.key = element_rect(fill = \"gold\"),\n    legend.background = element_rect(fill = \"#0065BD\"),\n    legend.position = \"bottom\",\n    legend.text = element_text(colour = \"white\"),\n    panel.grid.major = element_line(colour = \"grey40\"),\n    panel.grid.minor = element_blank(),\n    panel.background = element_rect(fill = \"gold\")\n  )\n## `geom_smooth()` using method = 'loess' and\n## formula = 'y ~ x'\nmein_theme <- theme(\n    axis.text = element_text(size = 14),\n    legend.key = element_rect(fill = \"hotpink3\"),\n    panel.grid.major = element_line(colour = \"grey40\"),\n    panel.grid.minor = element_blank(),\n    panel.background = element_rect(fill = \"navy\")\n  )\nclass(mein_theme)\n## [1] \"theme\" \"gg\"\np + mein_theme\n## `geom_smooth()` using method = 'loess' and\n## formula = 'y ~ x'"},{"path":"bausteine.html","id":"buch-zum-paket","chapter":"Kapitel 11 Bausteine","heading":"11.7 Buch zum Paket","text":"Dieser Abschnitt konnte nur einen kleinen Einblick die MÃ¶glichkeiten des ggplot2 Pakets geben. Eine ausfÃ¼hrliche Beschreibung findet man im Buch zum Paket.Findet man dort noch nicht die FunktionalitÃ¤t, die man sucht, sollte man einen Blick auf die ggplot2 extensions werfen. Oder vielleicht direkt dort starten.","code":""},{"path":"pakete.html","id":"pakete","chapter":"Kapitel 12 Pakete","heading":"Kapitel 12 Pakete","text":"Bei einem Paket ğŸ“¦ handelt es sich umeine strukturierte, standardisierte Einheit, welche aus R Code, Dokumentation, Daten und (mÃ¶glicherweise) externem Quellcode besteht.Wie man ein Paket installiert und lÃ¤dt, ist uns mittlerweile bekannt. Jetzt wollen wir eigene Pakete erstellen.Gute GrÃ¼nde fÃ¼r die Verwendung von Paketen:dynamisches Laden und Entladen des Pakets (Speicherplatz\nsparend)dynamisches Laden und Entladen des Pakets (Speicherplatz\nsparend)einfache Installation und Update von lokalen DatentrÃ¤gern Ã¼ber\ndas Web (innerhalb von R oder Ã¼ber die Kommandozeile des\nBetriebssystems)einfache Installation und Update von lokalen DatentrÃ¤gern Ã¼ber\ndas Web (innerhalb von R oder Ã¼ber die Kommandozeile des\nBetriebssystems)Validierung: R bietet Befehle zur groben ÃœberprÃ¼fung von Code,\nDokumentation und Installierbarkeit, sowie, falls man mÃ¶chte,\nÃœberprÃ¼fung von BerechnungsergebnissenValidierung: R bietet Befehle zur groben ÃœberprÃ¼fung von Code,\nDokumentation und Installierbarkeit, sowie, falls man mÃ¶chte,\nÃœberprÃ¼fung von Berechnungsergebnisseneinfache Verteilung der Software Dritteeinfache Verteilung der Software DritteBeispieldatensÃ¤tze kÃ¶nnen das Paket integriert werdenBeispieldatensÃ¤tze kÃ¶nnen das Paket integriert werden","code":""},{"path":"pakete.html","id":"struktur","chapter":"Kapitel 12 Pakete","heading":"12.1 Struktur","text":"Ein Paket besteht aus einigen Standardâ€“Dateien und Verzeichnissen:DESCRIPTION: Informationen Ã¼ber das Paket (Autor,\nLizenz, Titel, AbhÃ¤ngigkeiten, â€¦)R/: R Code .R Dateienman/: Dokumentationen (im *.Rd Format) der einzelnen FunktionenNAMESPACE: Information Ã¼ber die zu â€œexportierendenâ€ Funktionendata/: Datenbeispielesrc/: kompilierter C, C++ oder Fortran Codetests/: Testroutinen zur Validierung des PaketsBei der Erzeugung der Struktur (wie auch weiteren Schritten bei der Entwicklung) sollte man viel wie mÃ¶glich automatisieren. Wir verwenden dazu die von Hadley Wickham bereitgestellten Werkzeuge.Falls noch nicht geschehen, solltet ihr die Pakete devtools, roxygen2 und testthat installierenDiese Pakete erleichtern Kombination mit RStudio das Erstellen von Paketen.","code":"\ninstall.packages(c(\"devtools\", \"roxygen2\", \"testthat\"))"},{"path":"pakete.html","id":"c-compiler","chapter":"Kapitel 12 Pakete","heading":"12.2 C Compiler","text":"Um alle MÃ¶glichkeiten bei der Erstellung von R-Paketen ausnÃ¼tzen zu kÃ¶nnen, benÃ¶tigt man zusÃ¤tzlich noch einen C Compiler und ein paar andere Werkzeuge. Dies ist aber vermutlich erst dann wirklich nÃ¶tig, wenn ihr Pakete bauen wollt, die C- oder C++-Code enthalten (nicht Teil des Kurses). RStudio sollte dich auch warnen und dir UnterstÃ¼tzung anbieten, sobald du versuchen solltest, etwas zu tun, das die Einrichtung einer Entwicklungsumgebung erfordert.Mit has_devel() kÃ¶nnt ihr aber auch schon jetzt Ã¼berprÃ¼fen ob euer System vielleicht schon bereit dazu wÃ¤reDies scheint bei mir der Fall zu sein.","code":"\nlibrary(devtools)\nhas_devel()## Your system is ready to build packages!"},{"path":"pakete.html","id":"r-code","chapter":"Kapitel 12 Pakete","heading":"12.3 R Code","text":"Das Verzeichnis R/ ist der wichtigste Bestandteil eines Pakets, da dort der komplette R Code liegt.\nDieses Verzeichnis (wie auch andere Teile) erzeugt man mit der Funktion devtools::create(), z.B.Dieser Befehl erzeugt das Verzeichnis Pfad_zum_Paket/Paketname, welcheseine RStudio Projektdatei, Paketname.Rprojein R/ Verzeichniseine DESCRIPTION Dateieine NAMESPACE DateienthÃ¤lt. Allen R Code, der im Paket enthalten sein soll, kopiert man anschlieÃŸend das Verzeichnis Pfad_zum_Paket/Paketname/R.Innerhalb eines Pakets ist es nun einfach den kompletten R Code (nach Ã„nderungen) neu zu laden.devtools::load_all() lÃ¤dt allen R Code neu. RStudio auch Ã¼ber Strg + Shift + L mÃ¶glich.RStudio kann man mit Strg + Shift + B das Paket installieren, R neu starten und anschlieÃŸend das Paket Ã¼ber library() neu laden.Dadurch ergibt sich der folgende ArbeitsablaufR Dateien im Editor bearbeitenStrg + Shift + L (oder Strg + Shift + B) ausfÃ¼hrenCode der Konsole Ã¼berprÃ¼fenDas Ganze (falls nÃ¶tig) wiederholen","code":"\ncreate(\"Pfad_zum_Paket/Paketname\")"},{"path":"pakete.html","id":"verschiedene-typen","chapter":"Kapitel 12 Pakete","heading":"12.4 Verschiedene Typen","text":"Man unterscheidet fÃ¼nf verschiedene Typen: source, bundled, binary, installed und memory.source: Die source Version eines Pakets besteht aus dem Verzeichnis Paketnamesource: Die source Version eines Pakets besteht aus dem Verzeichnis Paketnamebundled: Komprimiert man das Verzeichnis eine .tar.gz Datei spricht man von einem â€œgebÃ¼ndeltenâ€ Paket. Dieser Typ stellt eher einen Zwischenschritt dar. Mit devtools::build() kann aber eine solche Version erzeugt werden. Weitere Unterschiede zu einer source Version sind fÃ¼r uns erst mal nicht von Interesse.bundled: Komprimiert man das Verzeichnis eine .tar.gz Datei spricht man von einem â€œgebÃ¼ndeltenâ€ Paket. Dieser Typ stellt eher einen Zwischenschritt dar. Mit devtools::build() kann aber eine solche Version erzeugt werden. Weitere Unterschiede zu einer source Version sind fÃ¼r uns erst mal nicht von Interesse.binary: Ein gebÃ¼ndeltes Paket kann von anderen R Nutzern nur installiert werden, wenn sie selbst Ã¼ber die entsprechenden â€œWerkzeugeâ€ (Rtools, â€¦) verfÃ¼gen. Binary Pakete bestehen auch nur aus einer Datei, kÃ¶nnen aber von anderen R Nutzern auch ohne weitere â€œWerkzeugeâ€ installiert werden. Allerdings sind binary Pakete plattformspezifisch. Ein Windows binary Paket kann also z.B. nicht auf einem Mac installiert werden. Erzeugt wird eine binary Version z.B. mit devtools::build(binary = TRUE).binary: Ein gebÃ¼ndeltes Paket kann von anderen R Nutzern nur installiert werden, wenn sie selbst Ã¼ber die entsprechenden â€œWerkzeugeâ€ (Rtools, â€¦) verfÃ¼gen. Binary Pakete bestehen auch nur aus einer Datei, kÃ¶nnen aber von anderen R Nutzern auch ohne weitere â€œWerkzeugeâ€ installiert werden. Allerdings sind binary Pakete plattformspezifisch. Ein Windows binary Paket kann also z.B. nicht auf einem Mac installiert werden. Erzeugt wird eine binary Version z.B. mit devtools::build(binary = TRUE).installed: Ein installiertes Paket ist ein eine R Library entpacktes binary Paket. Zu diesem Zustand kann man Ã¼ber mehrere Wege gelangen, z.B.\ninstall.packages(): CRAN binary -> installed\ninstall.packages(type = source): CRAN source -> bundled -> installed\ninstall(): source -> installed\ninstalled: Ein installiertes Paket ist ein eine R Library entpacktes binary Paket. Zu diesem Zustand kann man Ã¼ber mehrere Wege gelangen, z.B.install.packages(): CRAN binary -> installedinstall.packages(type = source): CRAN source -> bundled -> installedinstall(): source -> installedMit devtools::install_github() kÃ¶nnen source Pakete aus eine GitHub Projekt installiert werden, und mit devtools::_install_gitlab() aus einem GitLab Projekt.memory: man mit mehreren Funktionen eines Paket arbeiten, sollte es den Speicher geladen werden. Dies geschieht mit library() (installierte Pakete) oder load_all() (beim Entwickeln von Paketen).","code":""},{"path":"pakete.html","id":"description","chapter":"Kapitel 12 Pakete","heading":"12.5 DESCRIPTION","text":"Die DESCRIPTION Datei enthÃ¤lt Informationen Ã¼ber das Paket und ist ein essentieller Bestandteil jedes Pakets. Der Befehlerzeugt die DESCRIPTION Dateiim Ordner meinR4EWSpckg.Die wichtigsten Felder einer DESCRIPTION Datei sind dadurch vorhanden (und mÃ¼ssen gefÃ¼llt werden). Ãœber die Punkte Imports und Suggests (nicht automatisch vorhanden) kann festgelegt werden welche anderen R Pakete zwingend notwendig bzw. hilfreich sind fÃ¼r das eigene Paket.Pakete Imports werden beim Installieren des eigenen Pakets ebenfalls installiert, falls diese noch nicht vorhanden sind. Pakete Suggests werden nicht automatisch installiert.Ãœberkann z.B. das Paket dplyr dem Punkt Imports hinzugefÃ¼gt werden. usethis::use_package(type = \"Suggests\") fÃ¼gt Suggests weitere Pakete hinzu.","code":"\nusethis::create_package(\"meinR4EWSpckg\")Package: meinR4EWSpckg\nType: Package\nTitle: What the Package Does (Title Case)\nVersion: 0.1.0\nAuthor: Who wrote it\nMaintainer: The package maintainer <yourself@somewhere.net>\nDescription: More about what it does (maybe more than one line)\n    Use four spaces when indenting paragraphs within the Description.\nLicense: What license is it under?\nEncoding: UTF-8\nLazyData: true\nusethis::use_package(\"dplyr\")"},{"path":"pakete.html","id":"name-titel-beschreibung","chapter":"Kapitel 12 Pakete","heading":"12.5.1 Name, Titel, Beschreibung","text":"Der Name (Package) eines Pakets darf Buchstaben, Zahlen und . enthalten und sollte mit dem Verzeichnisname Ã¼bereinstimmen.Title und Description sollten beschreiben das Paket genau macht. Description ist dabei deutlich ausfÃ¼hrlicher und enthÃ¤lt daher .d.R. mehrere Zeilen. Nach einem Zeilenumbruch sollte 4 Leerzeichen eingerÃ¼ckt werden. Ein Beispiel wÃ¤re","code":"Title: An implementation of the Grammar of Graphics\nDescription: An implementation of the grammar of graphics in R. \n    It combines the advantages of both base and lattice graphics: \n    conditioning and shared axes are handled automatically, and \n    you can still build up a plot step by step from multiple data \n    sources. It also implements a sophisticated multidimensional \n    conditioning system and a consistent interface to map data \n    to aesthetic attributes. See the ggplot2 website for more \n    information, documentation and examples."},{"path":"pakete.html","id":"autoren","chapter":"Kapitel 12 Pakete","heading":"12.5.2 Autoren","text":"Ãœber das Feld Authors@R kÃ¶nnen die Autoren des Pakets angegeben werden. dieser Stelle kann\nder DESCRIPTION Datei R Code verwendet werden um die nÃ¶tigen Informationengiven, family: Vor- und Nachnameemail: E-Mailadresserole: Rolle der Person. Wichtige Beispiele sind\ncre: Ersteller oder Maintainer\naut: hat wichtige BeitrÃ¤ge zum Paket erbracht\nctb: hat kleinere BeitrÃ¤ge zum Paket erbracht\ncre: Ersteller oder Maintaineraut: hat wichtige BeitrÃ¤ge zum Paket erbrachtctb: hat kleinere BeitrÃ¤ge zum Paket erbrachtMit der Funktion person() kÃ¶nnen diese Informationen nun angegeben werdenDer Output von person() sieht dann folgendermaÃŸen aus","code":"Authors@R: person(given = \"Stephan\", family = \"Haug\", \n                  email = \"haug@tum.de\", \n                  role = c(\"cre\", \"aut\"))\nperson(given = \"Stephan\", family = \"Haug\", \n                  email = \"haug@tum.de\", \n                  role = c(\"cre\", \"aut\"))## [1] \"Stephan Haug <haug@tum.de> [cre, aut]\""},{"path":"pakete.html","id":"version","chapter":"Kapitel 12 Pakete","heading":"12.5.3 Version","text":"devtools::create() legt die Default-Version auf 0.1.0 fest. Generell sollte die Versionsnummer aus drei Teilen bestehen und die Form x.y.z haben, wobei x die Nummer fÃ¼r grÃ¶ÃŸere Updates, y die Nummer fÃ¼r kleinere Updates und z die Nummer fÃ¼r Korrekturen ist.Die aktuelle Version von ggplot2 ist z.B.FÃ¼r Pakete, die sich der Entwicklung befinden, bietet es sich noch einen vierten Teil anzufÃ¼gen und mit der Versionsnummer 0.0.0.9000 zu starten.Nach diesen Anpassung kÃ¶nnte die DESCRIPTION Datei also aussehenDer Punkt Lizenz ist fÃ¼r erstmal nachgeordnet. Wer aber mehr Ã¼ber die Wahl einer passenden Lizenz erfahren mÃ¶chte, den verweisen wir gerene auf das Kapitel Licensing R packages.","code":"\npackageVersion(\"ggplot2\")## [1] '3.5.1'Package: meinR4EWSpckg\nType: Package\nTitle: Paket zu R4ews, das ...\nVersion: 0.0.0.9000\nAuthors@R: person(given = \"Stephan\", family = \"Haug\", \n                  email = \"haug@tum.de\", \n                  role = c(\"cre\", \"aut\"))\nDescription: Paket, das im Rahmen des R Projekts R4ews entstanden ist.\n    Das Paket bietet ...\nLicense: What license is it under?\nEncoding: UTF-8\nLazyData: true\nImports: \n    dplyr"},{"path":"pakete.html","id":"pakete-dokumentation","chapter":"Kapitel 12 Pakete","heading":"12.6 Pakete: Dokumentation","text":"Ein wichtiger Teil eines Pakets ist die ausreichende Dokumentation (wichtiger) Funktionen. Dokumentationen werden als .Rd (LaTeX Ã¤hnliches Format) Dateien im Verzeichnis man/ abgelegt. Das Paket roxygen2 bietet eine komfortable MÃ¶glichkeit aus Funktionskommentaren (einem speziellen Format) eine .Rd Datei zu erzeugen.Ablauf:roxygen Kommentare die .R Datei einfÃ¼gendevtools::document() ausfÃ¼hren um Kommentare .Rd Datei zu konvertierenDokumentation mit ? betrachtengegebenenfalls alles wiederholenroxygen Kommentare beginnen mit #'.Wir fÃ¼gen eine Datei add_2.R mit Inhaltdem Verzeichnis meinR4EWSpckg/R hinzu.Der Befehl devtools::document() (ausgefÃ¼hrt im Verzeichnis meinR4EWSpckg - source Paket) erzeugt dann die Datei meinR4EWSpckg/man/add_2.RdAlle roxygen Kommentare beginnen mit #' und sind unterteilt verschiedene Tags der Form @name_tag beschreibung. Vor dem ersten Tag kommen allerdingsTitel: erste Zeile des KommentarsBeschreibung der Funktion: zweiter Abschnitt des Kommentars (lÃ¤nger als Titel)Details zur Funktion: dritter Abschnitt des Kommentars (lÃ¤nger als die Beschreibung) - optionalIn unserem Beispiel wurde der Titel auch gleich als Beschreibung (da nicht explizit angegeben) verwendet.Die drei wichtigsten Tags zum Kommentieren einer Funktion sind: @param, @examples und @return.\nWeitere Tags sind im Abschnitt Documenting functions des Buchs R packages beschrieben.Mit den Befehlen \\emph{}, \\strong{}, \\code{} und \\pkg{} (Paketname) kann der Text formatiert werden.Ebenso kÃ¶nnen Links zu anderen Dokumentationen\\code{\\link{function}}: Funktion function im eigenen Paket\\code{\\link[devtools]{load_all}}: Funktionen aus anderen Paketen, hier devtools::load_alloder dem Netz\\url{http://rstudio.com}\\href{http://rstudio.com}{RStudio}\\email{haug@@tum.de} (@@ ist nÃ¶tig, da @ fÃ¼r die Tags reserviert ist)Weitere MÃ¶glichkeiten der Formatierung findet man im Abschnitt Text formatting des Buch R packages.","code":"#' Addiere zwei Zahlen\n#' \n#' @param x Eine Zahl.\n#' @param y Eine Zahl.\n#' @return Die Summe von \\code{x} und \\code{y}.\n#' @examples\n#' add_2(1, 1)\n#' add_2(10, 1)\nadd_2 <- function(x, y) {\n  x + y\n}% Generated by roxygen2 (4.0.2): do not edit by hand\n\\name{add_2}\n\\alias{add_2}\n\\title{Addiere zwei Zahlen}\n\\usage{\nadd_2(x, y)\n}\n\\arguments{\n\\item{x}{Eine Zahl.}\n\n\\item{y}{Eine Zahl.}\n}\n\\value{\nDie Summe von \\code{x} und \\code{y}.\n}\n\\description{\nAddiere zwei Zahlen\n}\n\\examples{\nadd_2(1, 1)\nadd_2(10, 1)\n}\n"},{"path":"pakete.html","id":"namespace","chapter":"Kapitel 12 Pakete","heading":"12.7 NAMESPACE","text":"Es ist nicht nur fÃ¼r das Erstellen von Paketen hilfreich das Konzept eines NAMESPACE verstanden zu haben, sondern auch fÃ¼r das generelle Arbeiten mit R. Man unterscheidet dabei Import NAMESPACES und Export NAMESPACES.Import legt dabei fest wie die Funktion eines Pakets eine Funktion einem anderen Paket findet. Betrachten wir z.B.Diese Funktion ist definiert AbhÃ¤ngigkeit von dim() aus dem base Paket.Auch wenn wir die Funktiondefinieren, findet nrow() trotzdem die â€œrichtigeâ€ Funktionda sie den NAMESPACE des base Pakets verwendet.Export legt fest welche Funktionen eines Pakets auÃŸerhalb des Pakets zur VerfÃ¼gung stehen sollen. Dies mÃ¼ssen/sollten nicht alle Funktionen sein. Ein Paket kann also interne Funktionen haben, die nur intern verwendet werden kÃ¶nnen.Ãœber den Operator :: wird explizit auf den NAMESPACE eines Pakets zugegriffen. Auf diese Art und Weise vermeidet man auch Konflikte zwischen Funktionen aus verschiedenen Paketen, die aber den gleichem Namen haben. einem solchen Fall kommt es darauf welches Paket zuletzt geladen wurde. Dieses findet man dann zuerst im SuchpfadIn der NAMESPACE Datei beschreibenexport(): exportiert FunktionenexportPattern(): exportiert alle Funktionen, die zu einem bestimmten Schema passenS3method(): exportiert S3 Methodenden Export undimport(): importiert alle Funktionen aus einem PaketimportFrom(): importiert eine bestimmte Funktion aus einem PaketuseDynLib(): importiert eine Funktion aus Cden Import.Export-EintrÃ¤ge der NAMESPACE Datei kÃ¶nnen leicht Ã¼ber roxygen Kommentare erzeugt werden.\nÃœber einen @export Tag wird angegeben welche Funktion exportiert werden sollJe nach Objekttyp wird dann export(), exportPattern() oder S3method() im NAMESPACE verwendet. Generell sollte man sich die Regel halten lieber weniger als mehr Funktionen zu exportieren, wenn man das Paket Dritte weitergeben .Beim Importieren sollte man noch restriktiver sein. Man sollte Ã¼ber Imports der DESCRIPTION Datei sicherstellen, dass alle notwendigen Pakete installiert und geladen sind. Danach kann einfach Ã¼ber den :: Operator eigenen Funktionen auf Funktionen aus anderen geladenen Paketen zugegriffen werden, also z.B. pkg_name::funktion_aus_pkg_name().Dies erhÃ¶ht die spÃ¤tere Lesbarkeit der eigenen Programme und vermeidet potentielle Konflikte, die beim Importieren mehrerer Pakete - die dann wieder Funktionen mit gleichem Namen besitzen - auftreten kÃ¶nnen.Muss eine Funktion hÃ¤ufig verwendet werden - und man nicht dauernd :: verwenden - sollte man Ã¼ber importFrom() eher nur die Funktion und nicht das ganze Paket importieren.","code":"\nnrow## function (x) \n## dim(x)[1L]\n## <bytecode: 0x11bdba388>\n## <environment: namespace:base>\ndim <- function(x) c(1,1)\ndim(mtcars)## [1] 1 1\nnrow(mtcars)## [1] 32\nsearch()##  [1] \".GlobalEnv\"        \"package:devtools\"  \"package:usethis\"  \n##  [4] \"package:stats\"     \"package:graphics\"  \"package:grDevices\"\n##  [7] \"package:utils\"     \"package:datasets\"  \"package:methods\"  \n## [10] \"Autoloads\"         \"package:base\"#' @export\nexport_function <- function(...){\n  ... \n}"},{"path":"pakete.html","id":"daten-einbinden","chapter":"Kapitel 12 Pakete","heading":"12.8 Daten einbinden","text":"Daten, die das Paket enthalten sollte, legt man im Verzeichnis /data ab. Als Format sollte man .rda wÃ¤hlen (ist aber kein Muss). Der einfachste Weg dies zu berÃ¼cksichtigen ist die Funktion usethis::use_data() zu verwenden.Dieser Befehl speichert die Objekte x und mtcars den Dateien data/x.rda und data/mtcars.rda ab. Der Dateiname stimmt also mit dem Objektnamen Ã¼berein.DatensÃ¤tze sollten auf jeden Fall dokumentiert werden. Dazu fÃ¼gt man einfach eine der .R Dateien im Verzeichnis /R einen weiteren roxygen2 Absatz ein. FÃ¼r das Dokumentieren von DatensÃ¤tzen stehen zwei weitere Tags bereit. Ãœber @format beschreibt man das genaue Format der Daten, z.B. die einzelnen Spalten eines Data Frames, und mit @source gibt man (falls vorhanden) die Datenquelle .Die Beschreibung des Datensatzes x kÃ¶nnte also z.B. aussehen","code":"\nx <- sample(1:100, 50, replace = TRUE)\nusethis::use_data(x, mtcars)#' Mein Datensatz\n#' \n#' Ein Datensatz bestehend aus 50 Zahlen gezogen aus den \n#' Zahlen 1 bis 100 mit Zuruecklegen\n#' \n#' @format Ein Integer Vektor der Laenge 50\n\"x\""},{"path":"pakete.html","id":"c-special-topic","chapter":"Kapitel 12 Pakete","heading":"12.9 C++ (Special Topic)","text":"man seinem Paket R Funktionen verwenden, die mithilfe von Rcpp aus kompiliertem C++ Code entstanden sind, sollte man zur VorbereitungausfÃ¼hren. Danach ist das das Verzeichnis /src angelegt und Rcpp zu den Feldern LinkingTo und Imports der DESCRIPTION Datei hinzugefÃ¼gt. AuÃŸerdem wird man aufgefordert die roxygen Tagsin eine der .R Dateien einzufÃ¼gen.Ebenso wie die .R Dateien kann auch die .cpp Dateien die roxygen Dokumentation eingefÃ¼gt werden. Allerdings verwendet man //' statt #'.","code":"\nusethis::use_rcpp()#' @useDynLib meinR4EWSpckg\n#' @importFrom Rcpp sourceCpp#include <Rcpp.h>\nusing namespace Rcpp;\n\n//' Multipliziere eine Zahl mit 2\n//' \n//' @param x Ein Integer.\n//' @export\n// [[Rcpp::export]]\nint malZwei(int x) {\n   return x * 2;\n}"},{"path":"pakete.html","id":"git-und-githubgitlab","chapter":"Kapitel 12 Pakete","heading":"12.10 Git und GitHub/GitLab","text":"Jedes Pakete (mag es auch noch klein sein) sollte unter Verwendung von Git erstellt werden. Beim Anlegen des Projekts (zur Erstellung des Pakets) Ã¼ber RStudio, kann leicht ein lokales Git repository initialisiert werdenSoll zusÃ¤tzlich ein remote repository verwendet werden, kann man (im Standardfall) ein neues repository auf GitLab (oder GitHub) anlegen. Es sollte den gleichen Namen bekommen wie das Paket (lokales Git repository). Danach kann man im Terminal Befehle der FormausfÃ¼hren.Angenommen es existiert bereits ein remote repository und das Paket soll dort â€œverwaltetâ€ werden, kann einfach dieses repository geklont werdenDanach existiert im Verzeichnis, dem der Befehl ausgefÃ¼hrt wurde, das Unterverzeichnis paketName. R kann anschlieÃŸend den BefehlausgefÃ¼hrt werden (im Verzeichnis, welches das Git repository paketName enthÃ¤lt). Danach sichert man alle Ã„nderungen s Ã¼ber einen commit Befehlund pusht","code":"git remote add origin https://gitlab.lrz.de/vw99xyz/paketName.git\ngit push -u origin mastergit clone https://gitlab.lrz.de/vw99xyz/paketName.git\ndevtools::create(\"paketName\")git add .\ngit commit -m \"paket struktur angelegt\"git push"},{"path":"pakete.html","id":"literatur-2","chapter":"Kapitel 12 Pakete","heading":"12.11 Literatur","text":"Dieser Abschnitt hat einen kleinen Einblick das Erstellen eigener Pakete gegeben. Allerdings wurden viele weitere Aspekte nicht angesprochen. Weitere Informationen zu R Paketen findet man z.B. im Buch R packages von Hadley Wickham (2015b).","code":""},{"path":"funktionen.html","id":"funktionen","chapter":"Kapitel 13 Funktionen","heading":"Kapitel 13 Funktionen","text":"Wie jeder anderen Programmierumgebung, besteht auch R die MÃ¶glichkeit eigene Funktionen zu definieren.Eine der wichtigsten Erkenntnisse dabei ist die Tatsache, dass auch Funktionen Objekte sind. Generell ist R alles ein Objekt.Neue Funktionen werden mit der Funktion function() erzeugt.","code":""},{"path":"funktionen.html","id":"bestandteile-von-funktionen","chapter":"Kapitel 13 Funktionen","heading":"13.1 Bestandteile von Funktionen","text":"Alle R Funktionen bestehen aus den drei Teilen:formals(), Argumente, die den Funktionsaufruf â€œregelnâ€body(), der eigentliche Codeenvironment(), Verweis auf die Funktionseingabe","code":"\nf <- function(x) x + sin(x)\nformals(f)## $x\nbody(f)## x + sin(x)\nenvironment(f)## <environment: R_GlobalEnv>"},{"path":"funktionen.html","id":"body","chapter":"Kapitel 13 Funktionen","heading":"13.2 body()","text":"Wie alle Objekte R, besitzen auch Funktionen Attribute. Ein data frame besitzt z.B. die Attribute names, class und row.namesEine Funktion besitzt hingegen die AttributeDen Unterschied zu body() sehen wir im folgenden Beispiel.","code":"\nattributes(iris)## $names\n## [1] \"Sepal.Length\" \"Sepal.Width\"  \"Petal.Length\" \"Petal.Width\"  \"Species\"     \n## \n## $class\n## [1] \"data.frame\"\n## \n## $row.names\n##   [1]   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18\n##  [19]  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36\n##  [37]  37  38  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54\n##  [55]  55  56  57  58  59  60  61  62  63  64  65  66  67  68  69  70  71  72\n##  [73]  73  74  75  76  77  78  79  80  81  82  83  84  85  86  87  88  89  90\n##  [91]  91  92  93  94  95  96  97  98  99 100 101 102 103 104 105 106 107 108\n## [109] 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126\n## [127] 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144\n## [145] 145 146 147 148 149 150\nattributes(f)## NULL\nf <- function(x){\n  # Summe von x und sin(x)#\n  x + sin(x)\n}\nbody(f)## {\n##     x + sin(x)\n## }\nattr(f, \"srcref\")## NULL"},{"path":"funktionen.html","id":"einfache-funktionen","chapter":"Kapitel 13 Funktionen","heading":"13.3 â€œEinfacheâ€ Funktionen","text":"Es gibt eine Ausnahme von der obigen Regel, dass Funktionen aus drei Teilen bestehen. Die primitive functions wie sum(), sin() oder exp() rufen direkt Ã¼ber die Funktion .Primitive() C Code auf, enthalten somit keinen R Code und daher sind alle drei Teile gleich NULL.","code":"\nformals(sin)## NULL\nbody(sin)## NULL\nenvironment(sin)## NULL"},{"path":"funktionen.html","id":"jede-operation-ist-ein-funktionsaufruf","chapter":"Kapitel 13 Funktionen","heading":"13.4 Jede Operation ist ein Funktionsaufruf","text":"â€œunderstand computations R, two slogans helpful:\nEverything exists object.\nEverything happens function call.â€\nâ€” John ChambersAlle Operationen bestehen aus Funktionsaufrufen. Somit auch +, -, /,:, , , oder []und $. Dies sieht man z.B. diesem Beispieloder auch diesem BeispielenDie Verwendung von ` erlaubt den Zugriff auf reservierte AusdrÃ¼cke.Eine sinnvolle Anwendung dieser Zugriffsmethode liegt der Kombination mit den apply Funktionen (apply(), lapply(), sapply, mapply(), tapply()). Diese wenden eine zu Ã¼bergebende Funktion auf weitere InputgrÃ¶ÃŸen wie Listen oder Data Frames .sapply() ist eine Version von lapply(), die - wenn mÃ¶glich - eine â€œvereinfachteâ€ Ausgabe liefert.","code":"\nx <- 10 \ny <- 5\nx + y## [1] 15\n`+`(x, y)## [1] 15\nfor (i in 1:2) print(i)## [1] 1\n## [1] 2\n`for`(i, 1:2, print(i))## [1] 1\n## [1] 2\nx[3]## [1] NA\n`[`(x, 3)## [1] NA\nx <- list(1:3, 4:9, 10:12)\nsapply(x, `[`, 2)## [1]  2  5 11\nsapply(x, function(x) x[2])## [1]  2  5 11\nx <- list(1:3, 4:6, 7:9)\nlapply(x, `+`, 3)## [[1]]\n## [1] 4 5 6\n## \n## [[2]]\n## [1] 7 8 9\n## \n## [[3]]\n## [1] 10 11 12\nis.matrix(sapply(x, `+`, 3))## [1] TRUE"},{"path":"funktionen.html","id":"funktionsargumente","chapter":"Kapitel 13 Funktionen","heading":"13.5 Funktionsargumente","text":"Funktionen besitzen formelle Argumente, denen beim Funktionsaufruf (oder per Default) Werte zugewiesen werden. Beim Aufruf kÃ¶nnen die Argumente durch ihre Position, den vollen oder teilweisen Namen ausgewÃ¤hlt werden.Der folgende Aufruf kann aber nicht funktionieren.Generell sollte man die zwei, drei wichtigsten InputgrÃ¶ÃŸen den Beginn stellen. Alle anderen sollten eher nicht durch die Position ausgewÃ¤hlt werden. Dabei ist der vollstÃ¤ndige Namen sicherlich zu bevorzugen.Funktionsargumenten kÃ¶nnen Default-Werte zugeordnet werden. Dabei kÃ¶nnen Default-Werte auch AbhÃ¤ngigkeit anderer Argumente definiert werden.","code":"\nf <- function(abc, bcd, bdc) c(abc, bcd, bdc)\nf(3, 2, 1)## [1] 3 2 1\nf(2, 1, abc=3)## [1] 3 2 1\nf(2, 1, a=3)## [1] 3 2 1\nf(3, b=2, 1)## Error in f(3, b = 2, 1): argument 2 matches multiple formal arguments\nf <- function(a = 1, b = 2) {\n  c(a, b)\n}\nf()## [1] 1 2\ng <- function(a = 1, b = a * 2) {\n  c(a, b)\n}\ng(a=10)## [1] 10 20"},{"path":"funktionen.html","id":"funktionsargumente-lazy-evaluation","chapter":"Kapitel 13 Funktionen","heading":"13.6 Funktionsargumente: Lazy Evaluation","text":"R wertet Funktionsargumente nur aus, wenn diese tatsÃ¤chlich benÃ¼tzt werden. Dies entspricht der Idee der Lazy Evaluation.Mit force() kann man die Auswertung eines Arguments erzwingen.Benutzt man eine verschachtelte Funktion Kombination mit lapply() oder einer Schleife, kann die Lazy Evaluation entscheidend sein.x wird beim ersten Aufruf von addiere_zu_1bis10() ausgewertet. Bis dahin ist x aber bereits von 1 bis 10 â€œgelaufenâ€ und hat damit den Wert 10. Somit wird stets 10 zum Input addiert.Erzwingt man die Auswertung, erhÃ¤lt man das gewÃ¼nschte Ergebnis.Bisher schien die Lazy Evaluation eher nachteilig. Sie kann aber auch Vorteile haben. Die Befehleerzeugen keinen Fehler, obwohl NULL>0 keinen zulÃ¤ssigen Input fÃ¼r darstellt. Da !.null(x) bereits FALSE liefert, wird die zweite Abfrage nicht mehr ausgewertet.Hauptvorteil ist aber die Effizienz. Nur notwendige AusdrÃ¼cke werden ausgewertet.","code":"\nf <- function(x) {\n  10\n}\nf(stop(\"x ist nicht 10\"))## [1] 10\nf <- function(x) {\n  force(x)\n  10\n}\nf(stop(\"x ist nicht 10\"))## Error in force(x): x ist nicht 10\naddiere_x <- function(x){\n  function(y) x+y\n}\naddiere_zu_1bis10 <- lapply(1:10, addiere_x)\naddiere_zu_1bis10[[1]](10)## [1] 11\naddiere_zu_1bis10[[5]](10)## [1] 15\naddiere_x <- function(x){\n  force(x)\n  function(y) x+y\n}\naddiere_zu_1bis10 <- lapply(1:10, addiere_x)\naddiere_zu_1bis10[[1]](10)## [1] 11\naddiere_zu_1bis10[[5]](10)## [1] 15\nx <- NULL\nif (!is.null(x) && x > 0) {\n\n}"},{"path":"funktionen.html","id":"funktionsargumente-...","chapter":"Kapitel 13 Funktionen","heading":"13.7 Funktionsargumente: ...","text":"FÃ¼r eine Funktion kann das formale ... Drei-Punkte Argument verwendet werden. Alle nicht Ã¼ber Position und/oder Name zugeordneten Argumente werden durch ... aufgenommen. der Regel werden Ã¼ber ... Argumente Ã¼bergeben, die innerhalb der Funktion andere Funktionen weitergegeben werden.... erhÃ¶ht also offensichtlich die FlexibilitÃ¤t. Ein Nachteil ist, dass falsch geschriebene Argumente keinen Fehler erzeugen und alle Argumente nach ... voll ausgeschrieben werden mÃ¼ssen.","code":"\nsumme_plus2 <- function(x, ...){\n  x <- x+2\n  sum(x, ...)\n}\nsumme_plus2(c(1, 3, 5))## [1] 15\nsumme_plus2(c(1, 3, NA), na.rm = TRUE)## [1] 8\nsum(1, 2, NA, rm.na = TRUE)## [1] NA\nsum(1, 2, NA, na.rm = TRUE)## [1] 3"},{"path":"funktionen.html","id":"funktionsrÃ¼ckgabe","chapter":"Kapitel 13 Funktionen","heading":"13.8 FunktionsrÃ¼ckgabe","text":"Wir haben den Beispielen bereits gesehen wie die RÃ¼ckgabe funktioniert. Der letzte Ausdruck, der ausgewertet wird, bildet die RÃ¼ckgabe.Falls bereits zu einem frÃ¼heren Zeitpunkte eine RÃ¼ckgabe erfolgen soll (z.B. STOP Kriterium erfÃ¼llt) und diese speziell gekennzeichnet werden soll, kann die Funktion return() verwendet werden.Funktionen kÃ¶nnen nur ein Objekt zurÃ¼ckgeben. Soll die Ausgabe einer Funktion aus mehreren Objekten bestehen, schreibt man diese einfach eine Liste und gibt die Liste zurÃ¼ck.","code":"\nf <- function(x) {\n  if (x < 10) {\n    0\n  } else {\n    10\n  }\n}\nf(5)## [1] 0\nf(15)## [1] 10\nf <- function(x) {\n  if (x < 10) {\n    n_output <- 0\n    t_output <- \"eingabe war kleiner 10\"\n  } else {\n    n_output <- 10\n    t_output <- \"eingabe war grÃ¶ÃŸer oder gleich 10\"\n\n  }\n  \n  output <- list(n_output, t_output)\n  return(output) \n}\nf(5)## [[1]]\n## [1] 0\n## \n## [[2]]\n## [1] \"eingabe war kleiner 10\"\nf(15)## [[1]]\n## [1] 10\n## \n## [[2]]\n## [1] \"eingabe war grÃ¶ÃŸer oder gleich 10\""},{"path":"funktionen.html","id":"mehr-zu","chapter":"Kapitel 13 Funktionen","heading":"13.9 mehr zu â€¦","text":"Wenn ihr mehr zufunctionsenvironmentsfunctional programmingobject-oriented programmingâ€¦wissen wollt, dann findet ihr (fast) alle Antworten auf eure Fragen im Buch Advanced R von Hadley Wickham (2015a).","code":""},{"path":"envscop.html","id":"envscop","chapter":"Kapitel 14 Environments und Scoping","heading":"Kapitel 14 Environments und Scoping","text":"","code":""},{"path":"envscop.html","id":"zuordnungen","chapter":"Kapitel 14 Environments und Scoping","heading":"14.1 Zuordnungen","text":"Wie weiÃŸ R welchen Wert es welchem Symbol zuordnen soll?Warum wÃ¤hlt R nicht die Standardfunktion sqrt() aus dem base Paket?Wenn R einem Symbol einen Wert zuordnet, dann durchsucht R eine Reihe von environments (bereits im Abschnitt Funktionen gesehen) nach dem passenden Wert. Gesucht wird folgender ReihenfolgeDas Global Environment wird durchsucht.Die namespaces (dazu spÃ¤ter mehr) der Pakete auf der search Liste werden durchsucht.Das global environment (der Workspace) wird immer zuerst und base immer zuletzt durchsucht.Die search Liste wird also beeinflusst durch die von uns geladenen Pakete.Man beachte, dass R die Namen von Daten- und Funktionsobjekten unterscheiden kann.","code":"\nsqrt(2)## [1] 1.414214\nsqrt <- function(x) x^2\nsqrt(2)## [1] 4\nsearch()## [1] \".GlobalEnv\"        \"package:stats\"     \"package:graphics\" \n## [4] \"package:grDevices\" \"package:utils\"     \"package:datasets\" \n## [7] \"package:methods\"   \"Autoloads\"         \"package:base\"\nlibrary(ggplot2)\nsearch()##  [1] \".GlobalEnv\"        \"package:ggplot2\"   \"package:stats\"    \n##  [4] \"package:graphics\"  \"package:grDevices\" \"package:utils\"    \n##  [7] \"package:datasets\"  \"package:methods\"   \"Autoloads\"        \n## [10] \"package:base\"\n(sqrt <- 2)## [1] 2\nsqrt(2)## [1] 1.414214"},{"path":"envscop.html","id":"environments","chapter":"Kapitel 14 Environments und Scoping","heading":"14.2 Environments","text":"Ein Environment verbindet eine Menge von Namen mit einer entsprechenden Menge von Werten. Environments sind Ã¤hnlich zu einer Liste, aber es gibt entscheidende Unterschiededie Namen der Objekte einem Environment sind eindeutigdie Objekte eines Environments sind nicht geordnetjedes Environment besitzt ein parent Environment, auÃŸer emptyenv()Die EintrÃ¤ge von search() sind die Eltern des Global Environment. Mit new.env() kann auch ein neues Environment erzeugt werden.Bemerkung: Die meisten Environments erzeugt man durch die Verwendung von Funktionen.","code":"\nneues_env <- new.env()\nneues_env$eins <- c(1, 2)\nneues_env$zwei <- c(\"a\", \"b\")\nls(neues_env)## [1] \"eins\" \"zwei\"\nparent.env(neues_env)## <environment: R_GlobalEnv>"},{"path":"envscop.html","id":"scoping-rules","chapter":"Kapitel 14 Environments und Scoping","heading":"14.3 Scoping Rules","text":"Der Sichtbarkeitsbereich von Variablen (Scope) wird Ã¼ber Scoping Rules festgelegt. R verwendet static scoping oder auch lexical scoping genannt (eine Alternative ist das dynamic scoping).f hat die formellen Argumente x und y sowie die freie Variable z. Die Scoping Rule bestimmt wie Werte freien Variablen zugeordnet werden. R bedeutet diesDer Wert freier Variablen (einer Funktion) wird dem Environment gesucht, dem die Funktion definiert wurde.","code":"\nf <- function(x, y){\n  x + y/z\n}"},{"path":"envscop.html","id":"static-scoping","chapter":"Kapitel 14 Environments und Scoping","heading":"14.4 Static scoping","text":"Oftmals werden Funktionen im Globalen Environment definiert. Die Werte freier Variablen sollten dann im Workspace zu finden sein. Dieses â€œVerhaltenâ€ wird von den meisten â€œNutzernâ€ erwartet und als sinnvoll angesehen.Allerdings kÃ¶nnen Funktionen auch innerhalb von Funktionen definiert werden. diesem Fall ist das Environment der body einer anderen Funktion.bilde_potenz() liefert somit eine Funktion als Ausgabe.Sucht man nach einer Variable und/oder mÃ¶chte man ihren Wert ausgeben, kann man mit den Funktionen exists() und get() arbeiten. Beide verwenden static scoping.Schauen wir uns nun den closure (Funktion + zugehÃ¶riges Environment) von zweite_potenz() und dritte_potenz() genauer .","code":"\nbilde_potenz <- function(n){\n  potenz <- function(x)\n    x^n\n}\nzweite_potenz <- bilde_potenz(2)\ndritte_potenz <- bilde_potenz(3)\nget(\"eins\", envir = neues_env)## [1] 1 2\nx <- 1\nexists(\"x\", envir = neues_env)## [1] TRUE\nexists(\"x\", envir = neues_env, inherits = FALSE)## [1] FALSE\nls(environment(zweite_potenz))## [1] \"n\"      \"potenz\"\nget(\"n\", envir = environment(zweite_potenz))## [1] 2\nls(environment(dritte_potenz))## [1] \"n\"      \"potenz\"\nget(\"n\", envir = environment(dritte_potenz))## [1] 3"},{"path":"envscop.html","id":"anwendungsbeispiel","chapter":"Kapitel 14 Environments und Scoping","heading":"14.5 Anwendungsbeispiel","text":"Wir betrachten als Anwendungsbeispiel die Minimierung der Funktion\\[\n  l_x(\\mu,\\sigma^2) =-\\left(-\\frac{n}{2}\\log(2\\pi\\sigma^2)-\\frac1{2\\sigma^2}\\sum_{=1}^n(x_i-\\mu)^2\\right)\\,,\n  \\]\nwobei \\(x_i, =1,\\dots,n,\\) bekannte GrÃ¶ÃŸen sind. Die obigen Funktion ist der negative log-Likelihood einer Normalverteilung mit Parametern \\(\\mu\\) und \\(\\sigma^2\\), aber das spielt hier keine Rolle.Optimierungsroutinen wie optim(), nlm() oder optimize() erwarten als Eingabe eine\nFunktion, deren Argumente die zu optimierenden Parameterwerte sind. Oftmals (wie im obigen Beispiel) hÃ¤ngen Funktionen aber von weiteren Werten ab.Die Funktion ist geschrieben, dass einer der beiden Parameter fixiert werden kann.Fixieren wir nun \\(\\mu\\) gleich 1, erhÃ¤lt manBemerkung: Wir verwenden optimize() anstatt optim(), da letztere nicht fÃ¼r eindimensionale Optimierung geeignet ist.Durch Ãœbergabe aller weiteren GrÃ¶ÃŸen im Environmentkonnte die Funktion l_x() nur als Funktion der unbekannten Parameter im\n.GlobalEnv definiert werden.Es muss also keine Liste weiterer Argumente der Optimierungs- funktion Ã¼bergeben werden.","code":"\nnegLogLik <- function(data, fix = c(FALSE, FALSE)){\n  param <- fix\n  function(theta){\n    param[!fix] <- theta\n    mu <- param[1]\n    sigma_2 <- param[2]\n    l_x <- -( -length(data)/2 * log(2 * pi * sigma_2 )\n              - sum((data-mu)^2) / (2*sigma_2))\n    l_x\n  }\n}\nset.seed(1234)\nx <- rnorm(1000, mean = 1, sd = 2)\nl_x <- negLogLik(x)\nl_x## function (theta) \n## {\n##     param[!fix] <- theta\n##     mu <- param[1]\n##     sigma_2 <- param[2]\n##     l_x <- -(-length(data)/2 * log(2 * pi * sigma_2) - sum((data - \n##         mu)^2)/(2 * sigma_2))\n##     l_x\n## }\n## <bytecode: 0x10bc6ee48>\n## <environment: 0x12873af40>\nls(environment(l_x))## [1] \"data\"  \"fix\"   \"param\"\noptim(par = c(0, 1), fn = l_x)$par## [1] 0.9465684 3.9744817\nl_x <- negLogLik(x, fix = c(1, FALSE))\noptimize(f = l_x, interval = c(1e-6, 10))$minimum## [1] 3.97759\nls(environment(l_x))## [1] \"data\"  \"fix\"   \"param\"\nparent.env(environment(l_x))## <environment: R_GlobalEnv>"},{"path":"literatur-3.html","id":"literatur-3","chapter":"Literatur","heading":"Literatur","text":"","code":""}]
