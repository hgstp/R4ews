[{"path":"index.html","id":"r4ews","chapter":"R4ews","heading":"R4ews","text":"Willkommen zur R ErgÃ¤nzung zur EinfÃ¼hrung die Wahrscheinlichkeitstheorie und Statistik. Im Rahmen dieser ErgÃ¤nzung lernen wir erste Schritte, wie wirDaten aufbereiten, visualisieren und analysieren. ğŸš€das wollen wir reproduzierbar und auch wiedervendbar machen. Und vor allem, wollen wir alles mit R machen.Auf dieser Website geht es um alles, bei der Datenanalyse\nauftaucht auÃŸer um statistische Modellierung und Schlussfolgerungen. Dieser Teil der statistischen Analyse erfolgt der Vorlesung EinfÃ¼hrung die Wahrscheinlichkeitstheorie und Statistik.Das Design von R4ews wurde durch die Notwendigkeit motiviert, mehr Ausgewogenheit der angewandten statistischen Ausbildung zu schaffen. Datenanalysten verbringen viel Zeit mit der Projekt-Organisation, der Datenbereinigung und -aufbereitung sowie der Kommunikation. Diese TÃ¤tigkeiten kÃ¶nnen einen tiefgreifenden Einfluss auf die QualitÃ¤t und GlaubwÃ¼rdigkeit einer Analyse haben. Dennoch werden diese FÃ¤higkeiten selten vermittelt, obwohl sie wichtig und notwendig sind. R4ews versucht diese LÃ¼cke etwas zu verkleinern.Das Material wird kontinuierlich Ã¼ber das Semester hinweg ergÃ¤nzt/erweitert/verbessert.Letzte Ã„nderung:","code":"\ndate()\n## [1] \"Mon Nov 15 23:03:18 2021\""},{"path":"index.html","id":"beteiligte-personen","chapter":"R4ews","heading":"Beteiligte Personen","text":"","code":""},{"path":"index.html","id":"kolophon","chapter":"R4ews","heading":"Kolophon","text":"Dieses Buch wurde bookdown innerhalb von RStudio geschrieben.Teile des Buches basieren auf stat545.com. Alle Ã„nderungen wurden gemÃ¤ÃŸ der Creative Commons Attribution-ShareAlike 4.0 International License durchgefÃ¼hrt.Wir bedanken uns bei den Autor*innen von stat545 fÃ¼r das groÃŸartige Material.Die aktuelle Version dieses Buchs wurde miterstellt","code":"## Finding R package dependencies ... Done!\n##  setting  value                       \n##  version  R version 4.0.3 (2020-10-10)\n##  os       macOS Big Sur 10.16         \n##  system   x86_64, darwin17.0          \n##  ui       X11                         \n##  language (EN)                        \n##  collate  en_US.UTF-8                 \n##  ctype    en_US.UTF-8                 \n##  tz       Europe/Berlin               \n##  date     2021-11-15"},{"path":"index.html","id":"lizenz","chapter":"R4ews","heading":"Lizenz","text":"Diese Arbeit ist lizenziert unter Creative Commons Attribution-ShareAlike 4.0 International License.","code":""},{"path":"install.html","id":"install","chapter":"Kapitel 1 Installieren von R und RStudio","heading":"Kapitel 1 Installieren von R und RStudio","text":"","code":""},{"path":"install.html","id":"r-und-rstudio","chapter":"Kapitel 1 Installieren von R und RStudio","heading":"1.1 R und RStudio","text":"Zuerst benÃ¶tigen wir R, eine freie Softwareumgebung fÃ¼r statistische Berechnungen und Grafiken. Installiert daher R von CRAN, dem Comprehensive R Archive Network. Wir empfehlen euch dringend, eine vorkompilierte BinÃ¤rdistribution zu installieren - benutzt daher die Links oben auf der CRAN Seite!Zuerst benÃ¶tigen wir R, eine freie Softwareumgebung fÃ¼r statistische Berechnungen und Grafiken. Installiert daher R von CRAN, dem Comprehensive R Archive Network. Wir empfehlen euch dringend, eine vorkompilierte BinÃ¤rdistribution zu installieren - benutzt daher die Links oben auf der CRAN Seite!Danach kÃ¶nnt ihr die IDE (steht fÃ¼r integrated development environment) von RStudio installieren. Dabei handelt es sich um eine leistungsfÃ¤hige BenutzeroberflÃ¤che fÃ¼r R.\nRStudio wird mit einem Text Editor geliefert, dass es nicht unmittelbar erforderlich ist, einen separaten, eigenstÃ¤ndigen Editor zu installieren.\nRStudio bietet auch eine direkt Verbindung zu Git(Hub). Um die notwendige Git-Installationen mÃ¼sst ihr euch aber selbst kÃ¼mmern. Wir kommen aber auch spÃ¤ter auf diesen Punkt zurÃ¼ck.\nDanach kÃ¶nnt ihr die IDE (steht fÃ¼r integrated development environment) von RStudio installieren. Dabei handelt es sich um eine leistungsfÃ¤hige BenutzeroberflÃ¤che fÃ¼r R.RStudio wird mit einem Text Editor geliefert, dass es nicht unmittelbar erforderlich ist, einen separaten, eigenstÃ¤ndigen Editor zu installieren.RStudio bietet auch eine direkt Verbindung zu Git(Hub). Um die notwendige Git-Installationen mÃ¼sst ihr euch aber selbst kÃ¼mmern. Wir kommen aber auch spÃ¤ter auf diesen Punkt zurÃ¼ck.Wenn ihr bereits eine vorhandene R und/oder RStudio Installation habt, empfehlen wir euch dringend, beide neu zu installieren und aktuell wie mÃ¶glich zu halten.Wenn ihr R aktualisiert, mÃ¼ssen ihr alle Pakete, die ihr installiert habt, aktualisieren. Das kÃ¶nnt ihr leicht mit dem unten stehenden Befehl machen. MÃ¶glicherweise mÃ¼sst ihr aber auch noch weitere Argumente angeben, wenn ihr z.B. eine nicht standardmÃ¤ÃŸige Bibliothek fÃ¼r eure Pakete verwendet.Bemerkung: Mit diesem Befehl wird nur nach Updates auf CRAN gesucht. Wenn ihr aber ein Paket verwenden, das z.B. nur auf GitHub lebt, mÃ¼sst ihr manuell aktualisieren, z.B. Ã¼ber devtools::install_github().","code":"\nupdate.packages(ask = FALSE, checkBuilt = TRUE)"},{"path":"install.html","id":"funktioniert-alles-am-besten-ausprobieren","chapter":"Kapitel 1 Installieren von R und RStudio","heading":"1.2 Funktioniert alles? Am besten ausprobieren","text":"Startet RStudio auf eurem Computer. Dann solltet ihr ein Fenster Ã¤hnlich zu diesemerhalten. Vermutlich ist euer Fenster nicht dunkel. Aber wer es gerne dunkel mag, soll sich mal unter Tools -> Global -> Appearance die Editor Themes anschauen.Setzt den Cursor das Fenster mit der Bezeichnung Console. Ãœber die Konsole seid ihr der Lage mit R zu interagieren. Erstellt ein einfaches Objekt mit einem Code wie(gefolgt von Enter oder Return). Schaut euch dann das Objekt x genauer , indem ihr x der Konsole eingebt, gefolgt von Enter oder Return. Ihr sollten dann den Wert 8 auf dem Bildschirm sehen. Wenn ja, habet ihr R und RStudio erfolgreich installiert.","code":"\nx <- 2 * 4"},{"path":"install.html","id":"add-on-packages","chapter":"Kapitel 1 Installieren von R und RStudio","heading":"1.3 Add-on packages","text":"R ist ein erweiterbares System und viele Menschen teilen nÃ¼tzlichen Code, den sie als Paket entwickelt haben, Ã¼ber CRAN, GitHub, GitLab oder Ã¤hnlichen Plattformen. Um ein Paket von CRAN zu installieren, z.B. das Paket tidyverse (ist genauer gesagt eine Kollektion von Paketen), kann man folgenden Befehl verwendenMit der Option dependencies = TRUE achten wir darauf, dass alle fÃ¼r tidyverse notwendigen Pakete, ebenfalls installiert werden.","code":"\ninstall.packages(\"tidyverse\", dependencies = TRUE)"},{"path":"install.html","id":"rstudio-primers","chapter":"Kapitel 1 Installieren von R und RStudio","heading":"1.4 RStudio Primers","text":"Ein guter Startpunkt fÃ¼r verschiedene R Themen sind die RStudio primers.Im Laufe des Kurses werdet ihr die PrimersThe BasicsWork DataVisualize Datadurcharbeiten.","code":""},{"path":"install.html","id":"aufgabe","chapter":"Kapitel 1 Installieren von R und RStudio","heading":"1.5 Aufgabe","text":"Wir beginnen mit Basics. Hier wird unterschieden Programming und Visualization Basics.Programming Basics beinhaltet Grundlagen zu Objekttypen, Funktionen und deren Argumente, Listen (eigentlich sind alle Objekte Listen, nur unterschiedlich speziell) und Paketen.Visualization Basics erklÃ¤rt erste Schritte der Verwendung des ggplot2 Pakets, mit dem wir uns spÃ¤ter noch eingehend beschÃ¤ftigen werden.Bearbeitet eigenstÃ¤ndig den Basics Primer.","code":""},{"path":"r-basics.html","id":"r-basics","chapter":"Kapitel 2 R Basics und ArbeitsablÃ¤ufe","heading":"Kapitel 2 R Basics und ArbeitsablÃ¤ufe","text":"","code":""},{"path":"r-basics.html","id":"ein-paar-grundlagen-fÃ¼r-das-arbeiten-mit-r","chapter":"Kapitel 2 R Basics und ArbeitsablÃ¤ufe","heading":"2.1 Ein paar Grundlagen fÃ¼r das Arbeiten mit R","text":"Aktueller Stand: Ihr habt bereits den Basics Primer absolviert und nun wollt ihr anfangen mit eurer RStudio/R Installation zu arbeiten.Es geht los indem ihr RStudio startet. Beachtet dabei die Standardfensterbereiche:Console (links)Environment / History (oben rechts)Files / Plots / Packages / Help (unten rechtes)Bemerkung: Die Standardanordnung der Fenster kÃ¶nnt ihr neben vielen anderen Dingen nach deinen Vorstellungen Ã¤ndern/anpassen: Customizing RStudio.Geht nun die Konsole um mit R zu interagieren. Erstellt die nachfolgende Zuordnung und schau euch das erstellte Objekt genauer :Alle R Befehle, die ein Objekte erstellen (â€œZuweisungenâ€), haben die Form:Ihr werdet im weiteren Verlauf noch viele Zuweisungen vornehmen. TatsÃ¤chlich ist es etwas mÃ¼hsam den Operator <- zu tippen. Seid aber trotzdem nicht faul und benutzt stattdessen einfach = - auch wenn das theoretisch funktionieren wÃ¼rde. Aber spÃ¤ter kann die Verwendung von = fÃ¼r Zuweisungen zu Verwirrung fÃ¼hren. Verwendet stattdessen RStudio die Tastenkombination: Alt + - (Minuszeichen) bzw. option + -.Beachtet, dass RStudio automatisch <- mit Leerzeichen umgibt, eine nÃ¼tzliche Codeformatierung darstellt. Code ist selbst einem guten Tag eher schlecht zu lesen. GÃ¶nnt daher euren Augen eine Pause und verwende (ausreichend) Leerzeichen.RStudio bietet viele praktische TastaturkÃ¼rzel . Eine Ãœbersicht erhÃ¤lt man auch mit Alt+Shift+K bzw. option+Shift+K.Objektnamen dÃ¼rfen nicht mit einer Ziffer beginnen und bestimmte andere Zeichen wie ein Komma oder ein Leerzeichen nicht enthalten. Es ist daher ratsam, sich eine [Konvention zur Abgrenzung von WÃ¶rtern][wiki-snake-case] Objektnamen zu Ã¼berlegen.Wir werden stets die erste Variante verwenden.FÃ¼hrt nun nachfolgenden Befehl ausIn eurem Workspace ist nun das Objekt this_is_a_really_long_name vorhanden. Probiert mithilfe dieses Objekts die VervollstÃ¤ndigungsfunktion von RStudio aus:Gib die ersten paar Zeichen ein, drÃ¼cke anschlieÃŸend die TAB Taste, fÃ¼gen weitere Zeichen hinzu, bis Eindeutigkeit hergestellt ist(wenn sonst wenig deinem Workspace ist, dann ist das schnell erreicht), und drÃ¼cke dann die Eingabetaste.FÃ¼hrt nun den Befehlaus, um anschlieÃŸend den Inhalt des Objekts anzuzeigen.Die Objekte zwei.hoch.drei und zwei_Hoch_drei sind natÃ¼rlich nicht vorhanden und somit fÃ¼hren beide Befehle zu einer Fehlermeldung. Man muss also absolut exakt sein mit seinen Befehlen.R verfÃ¼gt Ã¼ber eine Ã¼berwÃ¤ltigende Sammlung eingebauter Funktionen, die nach folgendem Schema aufgerufen werden:Als nÃ¤chstes wollen wir die Funktion seq() verwenden, die regulÃ¤re Zahlensequenzen erzeugt. Dabei wollen wir noch ein weiteres hilfreiches Feature von RStudio demonstrieren.Tippt se und drÃ¼cke dann die TAB Taste. einem Pop-Fenster werden dir mÃ¶gliche VervollstÃ¤ndigungen angezeigt. Der Befehl seq() kann dann durch weiteres Tippen oder Ã¼ber die AuswahlmÃ¶glichkeit (Pfeiltasten nach oben/unten) festgelegt werden. Zu jeder AuswahlmÃ¶glichkeit wird auch noch eine Kurzform der entsprechenden Hilfeseite angezeigt.FÃ¼gt man jetzt die Ã¶ffnende runde Klammer hinzu, wird die zugehÃ¶rige schlieÃŸende runde Klammer automatisch hinzugefÃ¼gt. Tippe anschlieÃŸend 1, 10 (das geschieht automatisch innerhalb der runden Klammern) und Return. RStudio beendet auch den Klammerausdruck fÃ¼r dich. RStudio ğŸš€Der letzte Befehl zeigt auch ganz gut, wie R Funktionsargumente auflÃ¶st. Sie kÃ¶nnen immer der Form Name = Wert angeben werden. Aber der Name muss nicht angegeben werden, wie man sieht. solchen FÃ¤llen versucht R, nach der Position aufzulÃ¶sen. wird oben angenommen, dass wir eine Sequenz bei 1 starten wollen, also = 1, und diese bis 10 laufen soll, daher = 10. Da wir keine Schrittweite angegeben haben, wird der Standardwert fÃ¼r verwendet, der diesem Fall gleich 1 ist.Bei Funktionen, die man oft aufruft, kann man gut diese AuflÃ¶sung nach Position fÃ¼r das erste und vielleicht auch das zweite Argument verwenden. Danach ist es aber ratsam immer mit Name = Wert zu arbeiten um falsche Zuweisungen (verschiedene Argumente kÃ¶nnen vom gleichen Typ sein, sodass eine falsche Zuweisung nicht automatisch zu einer Fehlermeldung fÃ¼hrt) zu vermeiden.Analog zur UnterstÃ¼tzung mit den runden Klammern, werden auch schlieÃŸende AnfÃ¼hrungszeichen automatisch ergÃ¤nzt, wie man folgendem Beispiel sieht.Nach einer Zuweisung wird der entsprechende Wert des Objekts nicht angezeigt. Daher ist man vielleicht dazu geneigt das Objekt gleich erneut aufzurufenDiese typische Aktion kann verkÃ¼rzt werden, indem die Zuweisung Klammern gesetzt wird, wodurch die Zuweisung und ein Befehl â€œDrucke auf den Bildschirmâ€ erfolgen.Nicht alle Funktionen haben (oder erfordern) Argumente:Schaut euch nun euren Workspace - unter Environment (vermutlich im Fenster rechts oben) seht ihr den Inhalt eures Workspace. Der Workspace ist der Ort, dem sich benutzerdefinierte Objekte ansammeln. Eine Liste dieser Objekte kÃ¶nnt ihr auch mit diesen Befehlen erhalten:Wenn ihr nun das Objekt mit dem Namen y entfernen mÃ¶chtet, kÃ¶nnt ihr das wie folgt machen:Alles lÃ¶schen kann man mit dem Befehloder man klickt auf den Besen im Environment Fenster von RStudio.","code":"\nx <- 3 * 4\nx\n## [1] 12\nobjectName <- valuei_use_snake_case\nother.people.use.periods\nevenOthersUseCamelCase\nthis_is_a_really_long_name <- 2.5\nzwei_hoch_drei <- 2 ^ 3\nzwei.hoch.drei\n## Error in eval(expr, envir, enclos): object 'zwei.hoch.drei' not found\nzwei_Hoch_drei\n## Error in eval(expr, envir, enclos): object 'zwei_Hoch_drei' not found\nfunctionName(arg1 = val1, arg2 = val2, ...)\nseq(1, 10)\n##  [1]  1  2  3  4  5  6  7  8  9 10\nyo <- \"hello world\"\ny <- seq(1, 10)\ny\n##  [1]  1  2  3  4  5  6  7  8  9 10\n(y <- seq(1, 10))\n##  [1]  1  2  3  4  5  6  7  8  9 10\ndate()\n## [1] \"Mon Nov 15 23:03:22 2021\"\nobjects()\n## [1] \"this_is_a_really_long_name\" \"x\"                         \n## [3] \"y\"                          \"yo\"                        \n## [5] \"zwei_hoch_drei\"\nls()\n## [1] \"this_is_a_really_long_name\" \"x\"                         \n## [3] \"y\"                          \"yo\"                        \n## [5] \"zwei_hoch_drei\"\nrm(y)\nrm(list = ls())"},{"path":"r-basics.html","id":"workspace-und-working-directory","chapter":"Kapitel 2 R Basics und ArbeitsablÃ¤ufe","heading":"2.2 Workspace und working directory","text":"Ziemlich schnell wird der Fall eintreten, dass ihr mit eurer R Arbeit (z.B. Bearbeitung eines Hausaufgaben Projekts) noch nicht fertig seid obwohl es Zeit die Arbeit fÃ¼r heute zu beenden. NatÃ¼rlich man aber zu einem spÃ¤teren Zeitpunkt mit der Analyse weitermachen, wo man gerade aufgehÃ¶rt hat.Etwas spÃ¤ter wird es ein, dass ihr zudem auch noch Daten R einlest und damit anschlieÃŸend numerische Ergebnisse erzeugt, die ihr dann auch wieder exportieren wollt.Und nochmal spÃ¤ter wird es (vielleicht) sein, dass ihr R gleichzeitig mehreren Analysen arbeitest, die ihr aber unbedingt getrennt halten wollt/sollt.Um diese Situationen zu bewÃ¤ltigen, mÃ¼sst ihr zwei Entscheidungen treffen:betrachtest du deiner Analyse als â€œErgebnisâ€, d.h. wirst du dauerhaft speichern?betrachtest du deiner Analyse als â€œErgebnisâ€, d.h. wirst du dauerhaft speichern?Wo â€œlebtâ€ deine Analyse?Wo â€œlebtâ€ deine Analyse?","code":""},{"path":"r-basics.html","id":"workspace-.rdata","chapter":"Kapitel 2 R Basics und ArbeitsablÃ¤ufe","heading":"2.2.1 Workspace, .RData","text":"Ihr startet gerade eure R Reise âœˆï¸. Daher wÃ¤re es okay, wenn ihr euren Workspace als das â€œErgebnisâ€ eurer Analyse betrachtet. Ziemlich bald, solltet ihr aber davon (vielleicht durch uns) Ã¼berzeugt sein, dass eure R Skripte das Ergebnis eurer Analyse sind (beiden FÃ¤llen hÃ¤ngt das Ergebnis vermutlich auch von Input Daten ab).Die Daten zusammen mit eurem R Code erlauben es euch jederzeit alle Ergebnisse zu reproduzieren und das ist die entscheidende Eigenschaft.Betrachtest man seinen Workspace als das Ergebnis der Analyse, dann muss man bei einem erneuten Analysedurchlauf (leicht verÃ¤nderte Aufgabenstellung, â€¦) entweder erneut eine Menge Tippen (natÃ¼rlich fehleranfÃ¤llig ist) oder die R History nach den nÃ¶tigen Befehlen durchwÃ¼hlen.\nStatt â€œbecoming expert managing R historyâ€ als Ziel zu haben, solltet ihr euren R Code sauber ein Skript speichern, sodass er fÃ¼r weitere Analysen zur VerfÃ¼gung steht.Der Workspace Ansatz wird allerdings â€œbegÃ¼nstigt/gefÃ¶rdertâ€ durch die Tatsache, dass RStudio beim Beenden der Session automatisch wissen ob der Workspace gespeichert werden soll. Das wollen wir mal ausprobieren.Beendet R/RStudio, entweder Ã¼ber das MenÃ¼ oder tippt q() die Konsole. Dann erhaltet ihr eine Eingabeaufforderung wie diese:Save workspace image ~/.Rdata?Merkt euch welchem Verzeichnis die Datei gespeichert wird und dann klickt auf Save.Geht das Verzeichnis mit dem gespeicherten Workspace Image und kontrolliert ob die Datei .RData vorhanden ist. Ihr werdet dort auch die Datei .Rhistory finden, die alle Befehle eurer letzten Sitzung enthÃ¤lt.Nun starte erneut RStudio. der Konsole seht ihr einen Befehl, der ungefÃ¤hr aussiehtund angibt, dass euer gespeicherter Workspace wiederhergestellt wurde. Unter Environment solltet ihr die gleichen Objekte wie zuvor sehen. Im Fenster History findet ihr die gespeicherten Befehle aus der letzten Sitzung.Aber diese Art, analytische Arbeit zu beginnen und zu beenden, wÃ¼rde nicht lange gut gehen. Daher fangen wir gleich mal damit die automatische Nachfrage nach dem Speichern des Workspaces abzuwÃ¤hlen. Ã–ffnet dazu die Global Options (unter Tools)und setzt Save workspace .RData exit auf Never. Nun werdet ihr nie mehr gefragt ob der Workspace gespeichert werden soll. Sehr wohl werdet ihr aber weiterhin gefragt ob ungesicherte Ã„nderungen euren R Skript gespeichert werden sollen, sobald ihr RStudio beenden wollt.","code":"[Workspace loaded from ~/.RData]"},{"path":"r-basics.html","id":"working-directory","chapter":"Kapitel 2 R Basics und ArbeitsablÃ¤ufe","heading":"2.2.2 Working directory","text":"Jeder Prozess, der auf einem Computer lÃ¤uft, hat einen Bezug zu seinem â€œArbeitsverzeichnisâ€. R ist dies der Ort, dem R standardmÃ¤ÃŸig nach Dateien suchen wÃ¼rde oder der Ort wo alle Dateien, die ihr auf die Festplatte schreiben wollt, abgelegt werden. MÃ¶glicherweise ist euer aktuelles Arbeitsverzeichnis das Verzeichnis, das ihr gerade untersucht habt um die .RData Datei zu finden.Das aktuelle Arbeitsverzeichnis kÃ¶nnt ihr euch anzeigen lassen mit dem BefehlAber es wird auch oben der RStudio Konsole direkt angezeigt.Es wÃ¤re schon, wenn das Arbeitsverzeichnis AbhÃ¤ngigkeit vom jeweils zu bearbeitenden Projekt leicht sinnvoll gesetzt werden kÃ¶nnte. Im nÃ¤chsten Abschnitt sehen wir, dass genau das mÃ¶glich ist.","code":"\ngetwd()"},{"path":"r-basics.html","id":"rprojs","chapter":"Kapitel 2 R Basics und ArbeitsablÃ¤ufe","heading":"2.3 RStudio Projects","text":"Alle zu einem Projekt gehÃ¶renden Dateien - Eingabedaten, R Skripte, Analyseergebnisse, Grafiken - einem Ort zu bÃ¼ndeln, ist eine sinnvolle Praxis, dass RStudio Ã¼ber seine Projects genau da ermÃ¶glicht.Lasst uns ein Projekt fÃ¼r den Kurs anlegen. Dazu wÃ¤hlen wir oben rechts im RStudio Fenster Project: (None) -> New ProjectDanach wÃ¤hlen wir New Directory -> New Project und geben abschlieÃŸend einen passenden Verzeichnisnamen ein (dabei beachten wir den Speicherort des neuen Verzeichnisses)Wir nehmen nun , dass ihr ein RStudio Projekt angelegt und auch geÃ¶ffnet habt. Als NÃ¤chstes benÃ¶tigen wir nun ein wenig R Code. Dazu tippen wir den unten stehenden Code (ausnahmsweise) die KonsoleJetzt nehmen wir mal , das wÃ¤re ein guter Start einer Analyse, die wir durchfÃ¼hren wollen. Daher wÃ¼rdest ihr das Ergebnis gerne abspeichern. Unter History kÃ¶nnt ihr alle obigen Befehle markieren und anschlieÃŸend Source klicken. Daraufhin wird sich ein neues Fenster mit einem R Skript - das natÃ¼rlich die Befehle enthÃ¤lt - Ã¶ffnen. Das Skript kÃ¶nnt ihn anschlieÃŸend abspeichern, und standardmÃ¤ÃŸig wird es den Projektordner gespeichert werden (aber natÃ¼rlich kÃ¶nntest man den Speicherort dieser Stelle auch Ã¤ndern/frei wÃ¤hlen).Nun beendet das Projekt (Close Project der rechten oberen Ecke). Wer , kann sich noch den Inhalt dess Projektordners anschauen, z.B. das PDF Ã¶ffnen.Danach Ã¶ffnet ihr das Projekt wieder. Euch sollte auffallen, dass alles dem Zustand ist, wie ihr das Projekt verlassen habt, z.B. Objekte im Arbeitsbereich, die Befehlshistorie, welche Dateien zur Bearbeitung geÃ¶ffnet sind, wo wir uns im Dateisystembrowser befinden, das Arbeitsverzeichnis fÃ¼r den R-Prozess usw. dies sind gute Dinge ğŸ˜.Nun Ã¤ndert ein paar Dinge eurem Code. Sinnvoll wÃ¤re z.B. Anfang die StichprobenlÃ¤nge n zu definieren und z.B. auf n <- 40 setzen. Dann\nsollten alle festen 40er Werte durch n ersetzt werden. AnschlieÃŸend kann man noch ein paar andere Dinge Ã¤ndern, z.B. die Steigung b, die Farbe der Linie â€¦ auch immer. Danach kÃ¶nnt ihr die verschiedenen MÃ¶glichkeiten ausprobieren, wie ihr den Code erneut ausfÃ¼hren kÃ¶nnt:Zeile fÃ¼r Zeile ausfÃ¼hren, indem ihr entweder das TastenkÃ¼rzel Command + Enter oder die Maus (auf â€œRunâ€ klicken der oberen rechten Ecke des Editor-Fensters) verwendet.Zeile fÃ¼r Zeile ausfÃ¼hren, indem ihr entweder das TastenkÃ¼rzel Command + Enter oder die Maus (auf â€œRunâ€ klicken der oberen rechten Ecke des Editor-Fensters) verwendet.Das gesamte Dokument durchlaufen lassen, entweder per TastenkÃ¼rzel Shift + Command +S oder Maus (klicken auf â€œSourceâ€ der oberen rechten Ecke des Editor-Fensters).Das gesamte Dokument durchlaufen lassen, entweder per TastenkÃ¼rzel Shift + Command +S oder Maus (klicken auf â€œSourceâ€ der oberen rechten Ecke des Editor-Fensters).AnschlieÃŸend kÃ¶nnt ihr euch das PDF anschauen und die Ã„nderungen bewundern.Irgendwann werdet ihr (vielleicht) vor der Aufgabe stehen, eine Grafik neu zu gestalten oder einfach nur verstehen zu wollen, woher sie stammt. Wenn ihr (relevante) Grafiken einer Datei speichert (Ã¼ber R Code und niemals Ã¼ber die Maus oder die Zwischenablage) und dabei sinnvolle Dateinamen/Speicherorte (innerhalb des zugehÃ¶rigen Projekts) benutzt, werden euch solche Aufgaben nie vor groÃŸe Probleme stellen âœ….","code":"\na <- 2\nb <- -3\nsig_sq <- 0.5\nx <- runif(40)\ny <- a + b * x + rnorm(40, sd = sqrt(sig_sq))\n(x_n <- mean(x))\n## [1] 0.468\nwrite(x_n, \"mittelwert_x.txt\")\nplot(x, y)\nabline(a, b, col = \"purple\")\ndev.print(pdf, \"scatterplot.pdf\")\n## quartz_off_screen \n##                 2"},{"path":"r-basics.html","id":"zu-guter-letzt","chapter":"Kapitel 2 R Basics und ArbeitsablÃ¤ufe","heading":"2.4 zu guter Letzt","text":"Es ist Ã¼blich, R-Skripte mit einem .R oder .r Suffix zu speichern. Befolgt diese Konvention, auÃŸer ihr habt einen sehr auÃŸergewÃ¶hnlichen Grund, es nicht zu tun.Kommentare beginnen mit einem oder mehreren #-Symbolen. Verwendet Kommentare. RStudio hilft dir dabei ausgewÃ¤hlte Zeilen mit Ctrl+Shift+C (Windows und Linux) oder command+Shif+C (Mac) zu kommentieren oder vorhandene Kommentare wieder zu entfernen.Dieser Workflow wird euch Zukunft gute Dienste leisten:erstelle ein RStudio Projekt fÃ¼r jedes neue R â€œVorhabenâ€speichere alle Input Dateien innerhalb des Projekts (wir werden bald Ã¼ber den Import sprechen)bewahre alle Skripte zu diesem Projekt dort auf; bearbeite sie und fÃ¼hren sie dort ausspeichere den Output innerhalb des Projekts (wie z.B. das PDF im letzten Beispiel)Ihr solltet vermeiden die Maus fÃ¼r Teile des Workflows zu verwenden, wie z.B. das Laden eines Datensatzes oder das Speichern einer Grafik. Das ist sehr wichtig fÃ¼r die Reproduzierbarkeit und um im Nachhinein feststellen zu kÃ¶nnen, wie eine numerische Tabelle oder eine PDF-Datei tatsÃ¤chlich erzeugt wurde.","code":""},{"path":"version-control.html","id":"version-control","chapter":"Kapitel 3 Git, GitHub, and RStudio","heading":"Kapitel 3 Git, GitHub, and RStudio","text":"Versionskontrolle sollte nach dem Besuch der EinfÃ¼hrung die Programmierung bereits kein unbekanntes Thema mehr sein. Falls doch, solltet ihr mit ein paar Worten zu Git und GitHub von Jenny Byran (Autorin von STAT 545) starten.Ziel dieses Abschnitts wird es sein, dass ihreinen GitHub Account anlegt (falls nicht schon vorhanden)einen GitHub Account anlegt (falls nicht schon vorhanden)Git auf eurem Computer installiertGit auf eurem Computer installierteuch bei Git vorstellteuch bei Git vorstellteure Verbindung zu GitHub testeteure Verbindung zu GitHub testetabschlieÃŸend noch RStudio ins Spiel bringt und RStudio mit Git und GitHub verbindetabschlieÃŸend noch RStudio ins Spiel bringt und RStudio mit Git und GitHub verbindetBemerkung: Unter 5. werdet ihr ermutigt eure GitHub Zugangsdaten auf eurem Computer zu speichern. Dieser Schritt ist sehr empfehlenswert. Dazu findet ihr auch ein kurzes Video im Moodle Kurs zu EWS.âš ï¸\nDie Verwendung von GitHub ist eine generelle Empfehlung. Ein GitHub Account kann verschiedenen Situationen hilfreich sein, insbesondere auch nach dem Studium.\nWÃ¤hrend der Veranstaltung werdet ihr aber mit eurem LRZ GitLab Account arbeiten.Das Buch Happy Git GitHub useR enthÃ¤lt noch viele weitere hilfreiche Git/GitHub Informationen. Auf manche kommen wir vielleicht im Laufe des Kurses noch zu sprechen. Andere sind vielleicht zu einem spÃ¤teren Zeitpunkt interessant, wenn ihr anspruchsvolleren Git Projekten arbeitet.","code":""},{"path":"r-markdown.html","id":"r-markdown","chapter":"Kapitel 4 R Markdown","heading":"Kapitel 4 R Markdown","text":"AusgewÃ¤hlte Hausaufgaben werdet ihr als R Markdown Dokument abgeben. R Markdown ist eine sehr zugÃ¤ngliche Methode zur Erstellung von Dokumenten, die Prosa Text mit R-Code und den daraus erzeugten Berechnungen, Tabellen und Abbildungen kombinieren.Ein mÃ¶glicher R Markdown Workflow, der eine Interaktion mit Git, GitHub, und RStudio beinhaltet, wird auf der SeiteTest drive R Markdownvorgestellt.Wir werden versuchen diesen Workflow im Rahmen des R Projekts umzusetzen.","code":""},{"path":"basic-data-care.html","id":"basic-data-care","chapter":"Kapitel 5 Letzte Vorbereitungen â€¦","heading":"Kapitel 5 Letzte Vorbereitungen â€¦","text":"Jetzt ist es der Zeit, sich zu vergewissern welchem Verzeichnis ihr auf eurem Computer ihr euch befindet. Falls ihr ein RStudio Projekt nutzt, sollte diese Frage leicht zu beantworten sein. Falls ihr trotzdem unsicher seid, gebt getwd() der Konsole ein, um das aktuelle Arbeitsverzeichnis zu sehen.Alle nachfolgenden Code Beispiele wollen wir einer .R Datei abspeichern, die dann im aktuellen Arbeitsverzeichnis gespeichert werden soll. Idealerweise geben wir dieser Datei noch einen Namen, wie etwa datenanalyse_teil_1.R, der uns schon viel Ã¼ber den mÃ¶glichen Inhalt erzÃ¤hlt.\nAlternativ kÃ¶nnen wir alle Befehle natÃ¼rlich auch eine R Markdown Datei schreiben, siehe Test drive R Markdown.Prinzipiell geht es den folgenden Abschnitten um Datenmanagement. Es werden aber auch immer wieder ein paar Grafiken zu sehen sein. Dies ist aber kein Problem, da ihr ja bereits den Data Visualization Basics Primerbesucht habt und somit den nÃ¶tigen Background besitzt.","code":""},{"path":"basic-data-care.html","id":"data-frames-sind-fantastisch","chapter":"Kapitel 5 Letzte Vorbereitungen â€¦","heading":"5.1 Data frames sind fantastisch","text":"Das Standardformat fÃ¼r Daten ist ein data frame. Die meisten Funktionen zur Inferenz, Modellierung und graphischen Darstellung erwarten, dass ihnen Ã¼ber ein data = Argument ein data frame Ã¼bergeben wird. Dies gilt fÃ¼r Funktion aus der R Basisdistribution schon seit langem.Die als tidyverse bekannte Kollektion von Paketen geht noch einen Schritt weiter und priorisiert ausdrÃ¼cklich die Verarbeitung von data frames. TatsÃ¤chlich priorisiert tidyverse eine besondere Art von data frames, die als â€œtibbleâ€ bezeichnet wird.Data frames - im Gegensatz zu allgemeinen Arrays oder speziell Matrizen - kÃ¶nnen Variablen unterschiedlicher Typen enthalten, wie z.B. Textdaten (Subjekt-ID oder Name), quantitative Daten (Anzahl der weiÃŸen BlutkÃ¶rperchen) und qualitative/kategoriale Informationen (behandelt vs.Â unbehandelt). Genauer gesagt kÃ¶nnen data frames unterschiedliche Spalten aus unterschiedlichen Datentypen bestehen. Innerhalb einer Spalte mÃ¼ssen aber alle EintrÃ¤ge vom gleichen Typ sein.Daten aus einer Datenanalyse bestehen immer aus mehr als einem Datentyp. Aus diesem Grund eigenen sich Matrizen oder Arrays nicht zur Datenanalyse, da man sonst mit verschiedenen, unverbundenen Objekten (Matrizen, Arrays) arbeiten mÃ¼sste und diese nur schwer koordinieren kann.","code":""},{"path":"basic-data-care.html","id":"gapminder-data","chapter":"Kapitel 5 Letzte Vorbereitungen â€¦","heading":"5.2 Gapminder data","text":"Wir werden mit einem Teil der Daten aus dem Gapminder-Projektarbeiten. Die Daten sind im gapminder Paket enthalten, welches wir Ã¼ber CRAN installieren kÃ¶nnen:Um die Daten zu verwenden, mÃ¼ssen wir das Paket natÃ¼rlich auch noch ladenGapminder wurde von Hans, Anna und Ola Rosling gegrÃ¼ndet. Auf der Webseite des Projekts findet man nicht nur viel Informatives, sondern auch sehr UnterhaltsamesLeider ist Hans Rosling bereits 2017 verstorben.","code":"\ninstall.packages(\"gapminder\")\nlibrary(gapminder)"},{"path":"basic-data-care.html","id":"die-gapminder-daten-sind-ein-tibble","chapter":"Kapitel 5 Letzte Vorbereitungen â€¦","heading":"5.3 Die gapminder Daten sind ein â€œtibbleâ€","text":"Durch das Laden des gapminder Pakets haben wir nun Zugriff auf einen Datenobjekt mit demselben Namen. Schauen wir uns mithilfe der Funktion str() mal die Struktur dieses Objekts .str() liefert eine vernÃ¼nftige Beschreibung von fast allem, und im schlimmsten Fall kann tatsÃ¤chlich auch nichts â€œSchlimmesâ€ passieren. Aus dem Output erkennen wir, dass der Datensatz 1704 Beobachtungen enthÃ¤lt.Auf der anderen Seite hÃ¤tten wir durch direkten Aufruf von gapminder den Inhalt auch direkt auf den Bildschirm schreiben kÃ¶nnen. Aber vielleicht habt ihr schon mal einen grÃ¶ÃŸeren Datensatz aufgerufen und zÃ¶gert nun etwas, da groÃŸe DatensÃ¤tze tendenziell einfach die Konsole fÃ¼llen und nur sehr wenig Einblick bieten.Tidyverse bietet eine spezielle data frame Variante : ein tibble. gapminder ist ein ein tibble. Das sieht man auch, wenn man sich die Klasse dieses Objekts anzeigen lÃ¤sstEs ist immer noch ein regulÃ¤res data frame, aber zusÃ¤tzlich eben auch ein tibble.Wenn wir nun gapminder einfach auf den Bildschirm ausgeben, sehen wir, dass die Konsole nicht voll lÃ¤uft.Dies ist der erste groÃŸe Vorteil eines tibbles gegenÃ¼ber einem data frame.Wenn ihr mit einem reinen data frame arbeitet - und dieses Feature gefÃ¤llt euch - kÃ¶nnt ihr es mit as_tibble() ein tibble transformieren.Weitere MÃ¶glichkeiten, grundlegende Informationen zu einem data frame abzufragen:Ein bisschen deskriptive Statistik zum Inhalt eines data frames erhÃ¤lt man mit der summary() Funktion:Bemerkung: summary() ist eine generische Funktion. FÃ¼r eine gegebene Klasse (des Inputs) bestimmt die generische Funktion die passende Methode. Die Funktion summary() besitzt z.B. die folgenden Methoden:Obwohl wir uns formell noch nicht eingehender mit der Visualisierung beschÃ¤ftigt haben, ist es wichtig ein paar Grafiken zu erzeugen um einen ersten Eindruck Ã¼ber den Datensatz zu bekommen. Auf der anderen Seite werden die Grafiken aber auch nicht (viel) aufwendiger als die Beispiele im Visualisation Basics Primer.Interessant ist z.B. der zeitliche Verlauf der Lebenserwartungoder der Zusammenhang zwischen dem GDP (gross domestic product) und der LebenserwartungGrafiken dieser Art werden wir zu einem spÃ¤teren Zeitpunkt noch genauer behandeln. Dann sprechen wir natÃ¼rlich auch intensiv Ã¼ber deren Inhalt.Wir schauen uns nochmal die Ausgabe von str() , um darÃ¼ber zu sprechen, ein data frame genau ist.Ein data frame ist ein Sonderfall einer Liste. R verwendet Listen um gut wie alles ein Objekt aufnehmen zu kÃ¶nnen. Data frames sind nun ein Spezialfall einer Liste, bei dem die LÃ¤nge jedes Listenelements gleich ist.Nehmen wir mal , dass wir eine Beschreibung der Variablenzusammen mit den Daten abspeichern wollen. Dazu kÃ¶nnten wir ein tibbleerzeugen, das die Beschreibungen enthÃ¤lt. Dieses data frame hat nun 6 Zeilen und 2 Spalten. Trotzdem kÃ¶nnen wir es mit gapminder kombinieren, wenn wir beide tibbles einer Liste abspeichern","code":"\nstr(gapminder)\n## tibble [1,704 Ã— 6] (S3: tbl_df/tbl/data.frame)\n##  $ country  : Factor w/ 142 levels \"Afghanistan\",..: 1 1 1 1 1 1 1 1 1 1 ...\n##  $ continent: Factor w/ 5 levels \"Africa\",\"Americas\",..: 3 3 3 3 3 3 3 3 3 3 ...\n##  $ year     : int [1:1704] 1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 ...\n##  $ lifeExp  : num [1:1704] 28.8 30.3 32 34 36.1 ...\n##  $ pop      : int [1:1704] 8425333 9240934 10267083 11537966 13079460 14880372..\n##  $ gdpPercap: num [1:1704] 779 821 853 836 740 ...\nclass(gapminder)\n## [1] \"tbl_df\"     \"tbl\"        \"data.frame\"\ngapminder\n## # A tibble: 1,704 x 6\n##    country     continent  year lifeExp      pop gdpPercap\n##    <fct>       <fct>     <int>   <dbl>    <int>     <dbl>\n##  1 Afghanistan Asia       1952    28.8  8425333      779.\n##  2 Afghanistan Asia       1957    30.3  9240934      821.\n##  3 Afghanistan Asia       1962    32.0 10267083      853.\n##  4 Afghanistan Asia       1967    34.0 11537966      836.\n##  5 Afghanistan Asia       1972    36.1 13079460      740.\n##  6 Afghanistan Asia       1977    38.4 14880372      786.\n##  7 Afghanistan Asia       1982    39.9 12881816      978.\n##  8 Afghanistan Asia       1987    40.8 13867957      852.\n##  9 Afghanistan Asia       1992    41.7 16317921      649.\n## 10 Afghanistan Asia       1997    41.8 22227415      635.\n## # â€¦ with 1,694 more rows\nlibrary(tidyverse)\nas_tibble(iris)\n## # A tibble: 150 x 5\n##    Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n##           <dbl>       <dbl>        <dbl>       <dbl> <fct>  \n##  1          5.1         3.5          1.4         0.2 setosa \n##  2          4.9         3            1.4         0.2 setosa \n##  3          4.7         3.2          1.3         0.2 setosa \n##  4          4.6         3.1          1.5         0.2 setosa \n##  5          5           3.6          1.4         0.2 setosa \n##  6          5.4         3.9          1.7         0.4 setosa \n##  7          4.6         3.4          1.4         0.3 setosa \n##  8          5           3.4          1.5         0.2 setosa \n##  9          4.4         2.9          1.4         0.2 setosa \n## 10          4.9         3.1          1.5         0.1 setosa \n## # â€¦ with 140 more rows\nnames(gapminder)\n## [1] \"country\"   \"continent\" \"year\"      \"lifeExp\"   \"pop\"       \"gdpPercap\"\nncol(gapminder)\n## [1] 6\nlength(gapminder)\n## [1] 6\ndim(gapminder)\n## [1] 1704    6\nnrow(gapminder)\n## [1] 1704\nsummary(gapminder)\n##         country        continent        year         lifeExp    \n##  Afghanistan:  12   Africa  :624   Min.   :1952   Min.   :23.6  \n##  Albania    :  12   Americas:300   1st Qu.:1966   1st Qu.:48.2  \n##  Algeria    :  12   Asia    :396   Median :1980   Median :60.7  \n##  Angola     :  12   Europe  :360   Mean   :1980   Mean   :59.5  \n##  Argentina  :  12   Oceania : 24   3rd Qu.:1993   3rd Qu.:70.8  \n##  Australia  :  12                  Max.   :2007   Max.   :82.6  \n##  (Other)    :1632                                               \n##       pop             gdpPercap     \n##  Min.   :6.00e+04   Min.   :   241  \n##  1st Qu.:2.79e+06   1st Qu.:  1202  \n##  Median :7.02e+06   Median :  3532  \n##  Mean   :2.96e+07   Mean   :  7215  \n##  3rd Qu.:1.96e+07   3rd Qu.:  9325  \n##  Max.   :1.32e+09   Max.   :113523  \n## \nmethods(summary)\n##  [1] summary,ANY-method             summary,DBIObject-method      \n##  [3] summary.aov                    summary.aovlist*              \n##  [5] summary.aspell*                summary.check_packages_in_dir*\n##  [7] summary.connection             summary.data.frame            \n##  [9] summary.Date                   summary.default               \n## [11] summary.Duration*              summary.ecdf*                 \n## [13] summary.factor                 summary.ggplot*               \n## [15] summary.glm                    summary.haven_labelled*       \n## [17] summary.hcl_palettes*          summary.infl*                 \n## [19] summary.Interval*              summary.lm                    \n## [21] summary.loess*                 summary.manova                \n## [23] summary.matrix                 summary.mlm*                  \n## [25] summary.nls*                   summary.packageStatus*        \n## [27] summary.Period*                summary.POSIXct               \n## [29] summary.POSIXlt                summary.ppr*                  \n## [31] summary.prcomp*                summary.princomp*             \n## [33] summary.proc_time              summary.rlang_error*          \n## [35] summary.rlang_trace*           summary.srcfile               \n## [37] summary.srcref                 summary.stepfun               \n## [39] summary.stl*                   summary.table                 \n## [41] summary.tukeysmooth*           summary.vctrs_sclr*           \n## [43] summary.vctrs_vctr*            summary.warnings              \n## see '?methods' for accessing help and source code\nggplot(gapminder, mapping = aes(x = year, y = lifeExp)) +\n         geom_point()\nggplot(gapminder, mapping = aes(x = gdpPercap, y = lifeExp)) +\n  geom_point()\nggplot(gapminder, mapping = aes(x = log(gdpPercap), y = lifeExp)) +\n  geom_point()\nstr(gapminder)\n## tibble [1,704 Ã— 6] (S3: tbl_df/tbl/data.frame)\n##  $ country  : Factor w/ 142 levels \"Afghanistan\",..: 1 1 1 1 1 1 1 1 1 1 ...\n##  $ continent: Factor w/ 5 levels \"Africa\",\"Americas\",..: 3 3 3 3 3 3 3 3 3 3 ...\n##  $ year     : int [1:1704] 1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 ...\n##  $ lifeExp  : num [1:1704] 28.8 30.3 32 34 36.1 ...\n##  $ pop      : int [1:1704] 8425333 9240934 10267083 11537966 13079460 14880372..\n##  $ gdpPercap: num [1:1704] 779 821 853 836 740 ...\nnames(gapminder)\n## [1] \"country\"   \"continent\" \"year\"      \"lifeExp\"   \"pop\"       \"gdpPercap\"\n(desc <- tibble(variables = names(gapminder),\n               desc = c(\"factor with 142 levels\", \"factor with 5 levels\",\n                        \"ranges from 1952 to 2007 in increments of 5 years\",\n                        \"life expectancy at birth, in years\",\n                        \"population\",\"GDP per capita (US$, inflation-adjusted)\")))\n## # A tibble: 6 x 2\n##   variables desc                                             \n##   <chr>     <chr>                                            \n## 1 country   factor with 142 levels                           \n## 2 continent factor with 5 levels                             \n## 3 year      ranges from 1952 to 2007 in increments of 5 years\n## 4 lifeExp   life expectancy at birth, in years               \n## 5 pop       population                                       \n## 6 gdpPercap GDP per capita (US$, inflation-adjusted)\ngapminder_desc <- list(gapminder, desc)\nstr(gapminder_desc)\n## List of 2\n##  $ : tibble [1,704 Ã— 6] (S3: tbl_df/tbl/data.frame)\n##   ..$ country  : Factor w/ 142 levels \"Afghanistan\",..: 1 1 1 1 1 1 1 1 1 1 ...\n##   ..$ continent: Factor w/ 5 levels \"Africa\",\"Americas\",..: 3 3 3 3 3 3 3 3 3 ..\n##   ..$ year     : int [1:1704] 1952 1957 1962 1967 1972 1977 1982 1987 1992 199..\n##   ..$ lifeExp  : num [1:1704] 28.8 30.3 32 34 36.1 ...\n##   ..$ pop      : int [1:1704] 8425333 9240934 10267083 11537966 13079460 14880..\n##   ..$ gdpPercap: num [1:1704] 779 821 853 836 740 ...\n##  $ : tibble [6 Ã— 2] (S3: tbl_df/tbl/data.frame)\n##   ..$ variables: chr [1:6] \"country\" \"continent\" \"year\" \"lifeExp\" ...\n##   ..$ desc     : chr [1:6] \"factor with 142 levels\" \"factor with 5 levels\" \"r\".."},{"path":"basic-data-care.html","id":"variablen-in-einem-data-frame","chapter":"Kapitel 5 Letzte Vorbereitungen â€¦","heading":"5.4 Variablen in einem data frame","text":"Einzelne Variable einem data frame kann man mit dem Dollarzeichen $ ansprechen. Als Beispiel schauen wir uns die numerische Variable lifeExp genauer .Die summary() Funktion berechnet, neben dem empirischen Mittel, das Five-number summary, bestehend ausdem Minimumdem Minimumdem unteren Quartil (das empirische 0.25 Quantil)dem unteren Quartil (das empirische 0.25 Quantil)dem Mediandem Mediandem oberen Quartil (das empirische 0.75 Quantil)dem oberen Quartil (das empirische 0.75 Quantil)dem Maximumdem MaximumZusÃ¤tzlich wollen wir noch die Verteilung von lifeExp visualisieren und plotten dazu ein Histogramm. Dazu verwenden wir wieder ggplot().Beachtet, dass ihr inerhalb der ggplot2 Funktionen Variablen eines data frames direkt ansprechen kÃ¶nnt. Es ist hier also nicht nÃ¶tig mit dem $ Operator zu arbeiten.Alternativ kÃ¶nnen wir die EintrÃ¤ge eines data frames aber auch Ã¼ber die eckigen Klammern [] indizieren.Dabei spezifiziert der Eintrag links vom Komma die Zeilen und der Wert rechts davon die Spalten. Dies ist hilfreich, wenn man auf einzelne Werte zugreifen . Aber beim Aufruf nur einer Variable (Spalte), ist die $ Notation sicherlich vorteilhafter.Die Variable year ist eine ganzzahlige Variable, aber da es wenige unterschiedliche Werte gibt, funktioniert sie auch ein wenig wie eine kategoriale Variable und es macht Sinn die HÃ¤ufigkeit der einzelnen AusprÃ¤gungen zu zÃ¤hlen.Wir erkennen, dass jedem Jahr die gleiche Anzahl Beobachtungen vorhanden ist. Es handelt sich dabei stets um Beobachtungen aus den gleichen 142 LÃ¤ndern. Dies erkennt man aus dieser Ausgabe aber natÃ¼rlich noch nicht.Die Variablen country und continent enthalten rein kategorische Informationen, die R (hÃ¤ufig) als factor gespeichert werden.Die Levels von continent sind \"Afrika\", \"America\" usw., also Beschreibungen, die man gut lesen und verstehen kann. sollte es sein, wenn man R eine Faktorvariable aufruft. Im Allgemeinen sind die Levels von Menschen lesbare Zeichenfolgen, wie \"male/female\" oder \"control/treated\".Euch sollte aber auch klar sein, dass R diese Information kodierter Form speichert. Als Beispiel kÃ¶nnt ihr euch das Ergebnis von str(gapminder$continent) anschauenFaktorvariablen haben Vor- und Nachteil. Im weiteren Verlauf zeigen wir sowohl die Vor- wie auch die Nachteile. Generell ist aber durchaus , dass die Vorteile Ã¼berwiegen.Als NÃ¤chstes erstellen wir mit der Funktion table() eine HÃ¤ufigkeitstabelle fÃ¼r die Variable count. Die berechneten Werte wollen wir anschlieÃŸend noch mithilfe der Funktion geom_bar() visualisieren. Die zu plottenden HÃ¤ufigkeiten mÃ¼ssen dabei aber nicht die Funktion geom_bar() Ã¼bergeben werden. Die Funktion berechnet selbst (Ã¼ber die statistische Transformation stat_count()) die entsprechenden Werte.den folgenden Abbildungen sehen wir, wie die kodierten Zahlenwerte einer Faktor Variable genutzt werden kÃ¶nnen. Der continent-Faktor lÃ¤sst sich im ggplot2-Paket leicht â€œFacettenâ€ oder Farben abbilden.Die Erstellung von Grafiken mit ggplot2 werden wir noch genauer besprechen. Daher kÃ¶nnt ihr euch also ruhig zurÃ¼cklehnen und die Plots einfach genieÃŸen oder blind kopieren/einfÃ¼gen.ZunÃ¤chst initialisieren wir eine Grafik ohne Inhalt, da nicht gesagt wird, wie die Daten geplottete werden sollen.FÃ¼r die x-Achse wÃ¤hlen wir im nÃ¤chsten Schritt eine log Skala (zur Basis 10).Zum Grafikobjekt p werden nun weitere Komponenten hinzugefÃ¼gt und dann jeweils geplottet","code":"\nhead(gapminder$lifeExp)\n## [1] 28.8 30.3 32.0 34.0 36.1 38.4\nsummary(gapminder$lifeExp)\n##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n##    23.6    48.2    60.7    59.5    70.8    82.6\nggplot(gapminder, mapping = aes(x = lifeExp)) + \n  geom_histogram()\n## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\nsummary(gapminder[,\"lifeExp\"])\n##     lifeExp    \n##  Min.   :23.6  \n##  1st Qu.:48.2  \n##  Median :60.7  \n##  Mean   :59.5  \n##  3rd Qu.:70.8  \n##  Max.   :82.6\nsummary(gapminder$year)\n##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n##    1952    1966    1980    1980    1993    2007\ntable(gapminder$year)\n## \n## 1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 2002 2007 \n##  142  142  142  142  142  142  142  142  142  142  142  142\nclass(gapminder$continent)\n## [1] \"factor\"\nsummary(gapminder$continent)\n##   Africa Americas     Asia   Europe  Oceania \n##      624      300      396      360       24\nlevels(gapminder$continent)\n## [1] \"Africa\"   \"Americas\" \"Asia\"     \"Europe\"   \"Oceania\"\nnlevels(gapminder$continent)\n## [1] 5\nstr(gapminder$continent)\n##  Factor w/ 5 levels \"Africa\",\"Americas\",..: 3 3 3 3 3 3 3 3 3 3 ...\ntable(gapminder$continent)\n## \n##   Africa Americas     Asia   Europe  Oceania \n##      624      300      396      360       24\nggplot(gapminder, aes(x = continent)) + geom_bar()\np <- ggplot(filter(gapminder, \n                   continent != \"Oceania\"), # Daten aus Oceania werden \"herausgefiltert\"\n            aes(x = gdpPercap, y = lifeExp))  \np <- p + scale_x_log10() \n# einen scatterplot\np + geom_point() \n# mit verschiedenen farben fÃ¼r die verschiedenen kontinente\np + geom_point(aes(color = continent))  \n# punkte mit transparenz\np + geom_point(alpha = (1/3), size = 3) + \n  geom_smooth(lwd = 3, se = FALSE) # einen geglÃ¤tteten zusammenhang\n## `geom_smooth()` using method = 'gam' and formula 'y ~ s(x, bs = \"cs\")'\n# fÃ¼r jeden kontinent einen eigenen plot (innerhalb einer grafik) erzeugen\np + geom_point(alpha = (1/3), size = 3) + \n  facet_wrap(~ continent) + \n  geom_smooth(lwd = 1.5, se = FALSE)\n## `geom_smooth()` using method = 'loess' and formula 'y ~ x'"},{"path":"basic-data-care.html","id":"aufgabe-1","chapter":"Kapitel 5 Letzte Vorbereitungen â€¦","heading":"5.5 Aufgabe","text":"Im nÃ¤chsten Abschnitt starten wir mit dem dplyr Paket. Bearbeitet daher zur Vorbereitung die ersten beiden Abschnitte des Work Data Primers:Working Tibbbles zeigt die Verwendung von Tibbles sowie die Verwaltung von tidyverse-Paketen.Isolating Data dplyr zeigt wie ihr Variablen auswÃ¤hlt, Beobachtungen filtert und Werte neu anordnet. Zudem wird der Pipe-Operator von R, %>%, eingefÃ¼hrt.","code":""},{"path":"dplyr-intro.html","id":"dplyr-intro","chapter":"Kapitel 6 EinfÃ¼hrung in dplyr","heading":"Kapitel 6 EinfÃ¼hrung in dplyr","text":"","code":""},{"path":"dplyr-intro.html","id":"einstieg","chapter":"Kapitel 6 EinfÃ¼hrung in dplyr","heading":"6.1 Einstieg","text":"dplyr ist ein Paket zur Datenmanipulation, entwickelt von Hadley Wickham und Romain Francois. erster Linie es schnell und ausdrucksstark sein. Es wird als Teil des â€œMetapaketsâ€ tidyverse installiert und gehÃ¶rt als Kernpaket zu den Paketen, die Ã¼ber library(tidyverse) geladen werden.Die Wurzeln von dplyr liegen einem frÃ¼heren Paket mit dem Namen plyr, das zum Ziel hat die â€œsplit-apply-combineâ€-Strategie der Datenanalyse (Wickham 2011) umzusetzen. Wo plyr noch einen vielfÃ¤ltigen Satz von Ein- und Ausgaben abdeckt (z.B. Arrays, data frames, Listen), hat dplyr einen klaren Fokus auf data frames oder, im Tidyverse, tibbles.dplyr bietet schnelle Alternativen zu den R Standardfunktionen: subset(), apply(), [sl]apply(), tapply(), aggregate(), split(), .call(), (), within(), und mehr. Ferner kann man dplyr nutzen um Ã¼ber Zeilen oder Gruppen von Zeilen zu iterieren, eine schnelle Alternative zur Nutzung von Schleifen darstellt.","code":""},{"path":"dplyr-intro.html","id":"wie-immer-laden-wir-zu-beginn-tidyverse","chapter":"Kapitel 6 EinfÃ¼hrung in dplyr","heading":"6.1.1 Wie immer, laden wir zu Beginn tidyverse","text":"Der Fokus liegt diesem Abschnitt auf dplyr. Aber da wir immer wieder auch Funktionen aus anderen â€œtidyverse-Paketenâ€ nutzen, laden wir stets tidyverse.ZusÃ¤tzlich wollen wir auch noch gapminder laden.","code":"\nlibrary(tidyverse)\n## â”€â”€ Attaching packages â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ tidyverse 1.3.1 â”€â”€\n## âœ“ ggplot2 3.3.5     âœ“ purrr   0.3.4\n## âœ“ tibble  3.1.2     âœ“ dplyr   1.0.7\n## âœ“ tidyr   1.1.3     âœ“ stringr 1.4.0\n## âœ“ readr   2.0.1     âœ“ forcats 0.5.1\n## â”€â”€ Conflicts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ tidyverse_conflicts() â”€â”€\n## x dplyr::filter() masks stats::filter()\n## x dplyr::lag()    masks stats::lag()\nlibrary(gapminder)"},{"path":"dplyr-intro.html","id":"filter-indizieren-von-zeilen","chapter":"Kapitel 6 EinfÃ¼hrung in dplyr","heading":"6.2 filter(): Indizieren von Zeilen","text":"filter() nimmt logische AusdrÃ¼cke und gibt die Zeilen zurÃ¼ck, fÃ¼r die der logische Ausdruck ein TRUE ergibt.Zum Vergleich kann man sich einen R Standardbefehl anschauen, der zum gleichen Ergebnis fÃ¼hrt:Unter keinen UmstÃ¤nden solltest du allerdings deine Daten unterteilen, wie hier:Warum ist das eine blÃ¶de Idee?Es ist nicht selbstdokumentierend. ist das Besondere den Zeilen 241 bis 252?Es ist fehleranfÃ¤llig. Diese Codezeile wird zu anderen Ergebnissen fÃ¼hren, wenn jemand die Zeilenreihenfolge von gapminder Ã¤ndert, z.B. die Daten frÃ¼her im Skript sortiert.Dieser Aufruf erklÃ¤rt sich von selbst und ist ziemlich robust.","code":"\nfilter(gapminder, lifeExp < 29)\n## # A tibble: 2 x 6\n##   country     continent  year lifeExp     pop gdpPercap\n##   <fct>       <fct>     <int>   <dbl>   <int>     <dbl>\n## 1 Afghanistan Asia       1952    28.8 8425333      779.\n## 2 Rwanda      Africa     1992    23.6 7290203      737.\nfilter(gapminder, country == \"Rwanda\", year > 1979)\n## # A tibble: 6 x 6\n##   country continent  year lifeExp     pop gdpPercap\n##   <fct>   <fct>     <int>   <dbl>   <int>     <dbl>\n## 1 Rwanda  Africa     1982    46.2 5507565      882.\n## 2 Rwanda  Africa     1987    44.0 6349365      848.\n## 3 Rwanda  Africa     1992    23.6 7290203      737.\n## 4 Rwanda  Africa     1997    36.1 7212583      590.\n## 5 Rwanda  Africa     2002    43.4 7852401      786.\n## 6 Rwanda  Africa     2007    46.2 8860588      863.\nfilter(gapminder, country %in% c(\"Rwanda\", \"Afghanistan\"))\n## # A tibble: 24 x 6\n##    country     continent  year lifeExp      pop gdpPercap\n##    <fct>       <fct>     <int>   <dbl>    <int>     <dbl>\n##  1 Afghanistan Asia       1952    28.8  8425333      779.\n##  2 Afghanistan Asia       1957    30.3  9240934      821.\n##  3 Afghanistan Asia       1962    32.0 10267083      853.\n##  4 Afghanistan Asia       1967    34.0 11537966      836.\n##  5 Afghanistan Asia       1972    36.1 13079460      740.\n##  6 Afghanistan Asia       1977    38.4 14880372      786.\n##  7 Afghanistan Asia       1982    39.9 12881816      978.\n##  8 Afghanistan Asia       1987    40.8 13867957      852.\n##  9 Afghanistan Asia       1992    41.7 16317921      649.\n## 10 Afghanistan Asia       1997    41.8 22227415      635.\n## # â€¦ with 14 more rows\ngapminder[gapminder$lifeExp < 29, ] \nsubset(gapminder, country == \"Rwanda\" & year > 1979) ## subset funktioniert Ã¤hnlich wir filter\nauswahl <- gapminder[241:252, ]\nfilter(gapminder, country == \"Canada\")"},{"path":"dplyr-intro.html","id":"der-pipe-operator","chapter":"Kapitel 6 EinfÃ¼hrung in dplyr","heading":"6.3 Der Pipe-Operator","text":"Bevor es weitergeht, wollen wir aber den Pipe-Operator, den das Tidyverse aus dem magrittr-Paket von Stefan Bache importiert, vorstellen. Mithilfe des Pipe-Operators ist man der Lage Befehle fÃ¼r mehrere Operationen auszufÃ¼hren, ohne sie ineinander zu verschachteln. Diese neue Syntax fÃ¼hrt zu Code, der viel einfacher zu schreiben und zu lesen ist.Und sieht er aus: %>%. Das entsprechende RStudio TastenkÃ¼rzel lautet: Ctrl+Shift+M (Windows), Cmd+Shift+M (Mac).Erstmal ein BeispielDu siehst, der Befehl ist Ã¤quivalent zu head(gapminder). Der Pipe-Operator nimmt das Objekt auf der linken Seite und leitet es den Funktionsaufruf auf der rechten Seite weiter - er gibt es buchstÃ¤blich als erstes Argument ein.Keine Angst, du kannst immer noch weitere Argumente fÃ¼r die Funktion auf der rechten Seite angeben! Um die ersten 3 Reihen von gapminder zu sehen, kÃ¶nnte man sagen: head(gapminder, 3) oder:Du bist wahrscheinlich noch nicht sehr beeindruckt, aber das sollte sich noch Ã¤ndern.","code":"\ngapminder %>% head()\n## # A tibble: 6 x 6\n##   country     continent  year lifeExp      pop gdpPercap\n##   <fct>       <fct>     <int>   <dbl>    <int>     <dbl>\n## 1 Afghanistan Asia       1952    28.8  8425333      779.\n## 2 Afghanistan Asia       1957    30.3  9240934      821.\n## 3 Afghanistan Asia       1962    32.0 10267083      853.\n## 4 Afghanistan Asia       1967    34.0 11537966      836.\n## 5 Afghanistan Asia       1972    36.1 13079460      740.\n## 6 Afghanistan Asia       1977    38.4 14880372      786.\ngapminder %>% head(3)\n## # A tibble: 3 x 6\n##   country     continent  year lifeExp      pop gdpPercap\n##   <fct>       <fct>     <int>   <dbl>    <int>     <dbl>\n## 1 Afghanistan Asia       1952    28.8  8425333      779.\n## 2 Afghanistan Asia       1957    30.3  9240934      821.\n## 3 Afghanistan Asia       1962    32.0 10267083      853."},{"path":"dplyr-intro.html","id":"mit-select-variablen-auswÃ¤hlen","chapter":"Kapitel 6 EinfÃ¼hrung in dplyr","heading":"6.4 Mit select() Variablen auswÃ¤hlen","text":"Nun zurÃ¼ck zu dplyrâ€¦.Verwende select(), um aus den Daten verschiedene Variablen (Spalten) auszuwÃ¤hlen. Hier kommt eine typische Verwendung von select():Und nun noch kombiniert mit head() Ã¼ber den Pipe-Operator:Worten: â€œNimm gapminder, wÃ¤hle die Variablen year und lifeExp und zeige dann die ersten 4 Zeilen .â€","code":"\nselect(gapminder, year, lifeExp)\n## # A tibble: 1,704 x 2\n##     year lifeExp\n##    <int>   <dbl>\n##  1  1952    28.8\n##  2  1957    30.3\n##  3  1962    32.0\n##  4  1967    34.0\n##  5  1972    36.1\n##  6  1977    38.4\n##  7  1982    39.9\n##  8  1987    40.8\n##  9  1992    41.7\n## 10  1997    41.8\n## # â€¦ with 1,694 more rows\ngapminder %>%\n  select(year, lifeExp) %>%\n  head(4)\n## # A tibble: 4 x 2\n##    year lifeExp\n##   <int>   <dbl>\n## 1  1952    28.8\n## 2  1957    30.3\n## 3  1962    32.0\n## 4  1967    34.0"},{"path":"dplyr-intro.html","id":"jetzt-nochmal-ein-vergleich-zu-r-standardbefehlen","chapter":"Kapitel 6 EinfÃ¼hrung in dplyr","heading":"6.5 Jetzt nochmal ein Vergleich zu R Standardbefehlen","text":"Hier sind die Daten fÃ¼r Kambodscha, aber nur bestimmte Variablen:und wÃ¼rde ein typischer R Standardbefehl aussehen:der zum gleichen Ergebnis fÃ¼hrt. Wir wÃ¼rden sagen, dass der dplyr Befehl deutlich leichter zu lesen ist.","code":"\ngapminder %>%\n  filter(country == \"Cambodia\") %>%\n  select(year, lifeExp)\n## # A tibble: 12 x 2\n##     year lifeExp\n##    <int>   <dbl>\n##  1  1952    39.4\n##  2  1957    41.4\n##  3  1962    43.4\n##  4  1967    45.4\n##  5  1972    40.3\n##  6  1977    31.2\n##  7  1982    51.0\n##  8  1987    53.9\n##  9  1992    55.8\n## 10  1997    56.5\n## 11  2002    56.8\n## 12  2007    59.7\ngapminder[gapminder$country == \"Cambodia\", c(\"year\", \"lifeExp\")]\n## # A tibble: 12 x 2\n##     year lifeExp\n##    <int>   <dbl>\n##  1  1952    39.4\n##  2  1957    41.4\n##  3  1962    43.4\n##  4  1967    45.4\n##  5  1972    40.3\n##  6  1977    31.2\n##  7  1982    51.0\n##  8  1987    53.9\n##  9  1992    55.8\n## 10  1997    56.5\n## 11  2002    56.8\n## 12  2007    59.7"},{"path":"dplyr-intro.html","id":"pure-predictable-pipeable","chapter":"Kapitel 6 EinfÃ¼hrung in dplyr","heading":"6.6 Pure, predictable, pipeable","text":"Bisher haben wir nur etwas der OberflÃ¤che von dplyr gekratzt, trotzdem mÃ¶chten wir auf ein SchlÃ¼sselprinzipien hinweisen, die du vielleicht langsam zu schÃ¤tzen lernen wirst.Die Verben (Hauptfunktionen) von dplyr, wie z.B. filter() und select(), sind pure functions. Dazu schreibt Hadley Wickham Functions chapter seinem Advanced R Buch (2015a):functions easiest understand reason pure functions: functions always map input output impact workspace. words, pure functions side effects: donâ€™t affect state world way apart value return.TatsÃ¤chlich sind diese Verben ein Spezialfall reiner Funktionen: sie nehmen als Input und Output denselben Objekttyp , .d.R. ein data frame.Die Daten sind fÃ¼r diese Funktionen aus stets das erste Inputargument.","code":""},{"path":"dplyr-intro.html","id":"aufgabe-2","chapter":"Kapitel 6 EinfÃ¼hrung in dplyr","heading":"6.7 Aufgabe","text":"Die dplyr EinfÃ¼hrung geht weiter im Kapitel Mehr zu dplyr. Bearbeitet aber vorher den letzten Abschnitte des Work Data Primers:Deriving Information dplyr zeigt euch wie ihr Ã¼ber bestehenden Variablen neue Variablen definiert und leicht zusammenfassende Statistiken innerhalb vorab definiertert Gruppen berechnet.","code":""},{"path":"dplyr-single.html","id":"dplyr-single","chapter":"Kapitel 7 Mehr zu dplyr","heading":"Kapitel 7 Mehr zu dplyr","text":"","code":""},{"path":"dplyr-single.html","id":"wo-stehen-wir","chapter":"Kapitel 7 Mehr zu dplyr","heading":"7.1 Wo stehen wir?","text":"Kapitel 6, EinfÃ¼hrung dplyr, haben wir bereits zwei sehr wichtige Verben sowie einen Operator vorgestellt und verwendet:filter() zum AuswÃ¤hlen spezieller Zeilen eines Datensatzesselect() zum AuswÃ¤hlen spezieller Variablen eines Datensatzesden Pipe-Operator %>%, der das Objekt auf der linken Seite Ã¼berfÃ¼hrt als erstes Funktionsargument der Funktion auf der rechten SeiteWir haben auch die Rolle von dplyr innerhalb des tidyverse besprochen:dplyr ist ein Kernpaket der tidyverse Kollektion von Paketen. Da wir die anderen oft beilÃ¤ufig benutzen, werden wir stets dplyr und die anderen Ã¼ber library(tidyverse) laden.","code":""},{"path":"dplyr-single.html","id":"falls-noch-nicht-geschehen-lade-dplyr-und-gapminder","chapter":"Kapitel 7 Mehr zu dplyr","heading":"7.2 Falls noch nicht geschehen: lade dplyr und gapminder","text":"Wir starten wieder mit dem Laden von dplyr (Ã¼ber tidyverse)und gapminder","code":"\nlibrary(tidyverse)\n## â”€â”€ Attaching packages â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ tidyverse 1.3.1 â”€â”€\n## âœ“ ggplot2 3.3.5     âœ“ purrr   0.3.4\n## âœ“ tibble  3.1.2     âœ“ dplyr   1.0.7\n## âœ“ tidyr   1.1.3     âœ“ stringr 1.4.0\n## âœ“ readr   2.0.1     âœ“ forcats 0.5.1\n## â”€â”€ Conflicts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ tidyverse_conflicts() â”€â”€\n## x dplyr::filter() masks stats::filter()\n## x dplyr::lag()    masks stats::lag()\nlibrary(gapminder)"},{"path":"dplyr-single.html","id":"mitmutate-neue-variablen-erstellen","chapter":"Kapitel 7 Mehr zu dplyr","heading":"7.3 Mitmutate() neue Variablen erstellen","text":"Wir starten mit dem Anlegen einer Kopie von gapminder, die wir dann nach unseren Vorstellungen verÃ¤ndern (wÃ¤re aber auch nichts passiert, wenn wir alles mit gapminder durchfÃ¼hren wÃ¼rden).Unser Ziel ist es, dass GDP pro Land anzugeben. Das sollte machbar sein, da schlieÃŸlich das Pro-Kopf-GDP wie auch die BevÃ¶lkerungszahl im Datensatz enthalten sind. Multiplizieren beider Variablen liefert uns das gewÃ¼nschte Ergebnis.mutate() ist eine Funktion, die neue Variablen definiert und ein tibble einfÃ¼gt. Du kannst auf bestehende Variablen einfach Ã¼ber ihren Namen zugreifen.Hmmmm â€¦ diese GDP-Zahlen sind ziemlich groÃŸ und abstrakt. dem Zusammenhang, bedenke den Ratschlag von Randall Munroe:One thing bothers large numbers presented without contextâ€¦ â€œadded zero number, sentence containing mean something different ?â€ answer â€œâ€, maybe number business sentence first place.Vielleicht wÃ¤re es fÃ¼r die Betrachter unseres tibbles sinnvoller, beim Pro-Kopf-GDP zu bleiben. Aber wÃ¤re, wenn wir das Pro-Kopf-GDP angeben wÃ¼rde, Relation zu irgendeinem Vergleichsland. Wir kÃ¶nnten alles Bezug auf die entsprechenden Daten aus Deutschland angeben.Dazu mÃ¼ssen wir eine neue Variable erstellen, die gdpPercap geteilt durch die deutschen gdpPercap Werte ist, wobei wir darauf achten mÃ¼ssen, dass wir immer zwei Zahlen teilen, die sich auf dasselbe Jahr beziehen.Wie kÃ¶nnen wir das schaffen:Deutschland Beobachtungen einem Objekt ger_gap speichernErstellen Sie eine neue temporÃ¤re Variable tmp my_gap:\nDie gdpPercap-Variable aus tmp aufrufen.\nMit rep() die gdpPerap Wert aus tmp einmal pro Land im my_gap reproduzieren, damit ein Vektor, der die gleiche Anzahl Beobachtungen wie my_gap hat.\nDie gdpPercap-Variable aus tmp aufrufen.Mit rep() die gdpPerap Wert aus tmp einmal pro Land im my_gap reproduzieren, damit ein Vektor, der die gleiche Anzahl Beobachtungen wie my_gap hat.Dividieren der gdpPercap Werte durch die deutschen Zahlen.LÃ¶schen der temporÃ¤re Variable tmp my_gap.Beachte, dass mutate() neue Variablen sequentiell erstellt, dass du auf frÃ¼here Variablen (wie tmp) verweisen kannst um spÃ¤tere Variablen (wie gdpPercapRel) zu definieren. Nachdem eine Variable nicht mehr benÃ¶tigt wird, kannst du sie einfach auf NULL setzen.Hat das funktioniert? Einfach mal die Werte von gdpPercapRel fÃ¼r Deutschland anschauen. Sollten besser alle 1 sein!Ich nehme Deutschland ist ein Land mit einem â€œhohen GDPâ€ pro Kopf, daher gehe ich davon aus, dass die Verteilung von gdpPercapRel unter 1 liegt, mÃ¶glicherweise sogar weit darunter. Aber besser mal nachschauen ob dem ist:Die Zahlen des relativen Pro-Kopf-GDP liegen im deutlich unter 1. Wir sehen, dass die meisten LÃ¤nder, die diesem Datensatz erfasst werden, Ã¼ber den gesamten Zeitraum im Vergleich zu Deutschland ein wesentlich niedrigeres Pro-Kopf-GDP aufweisen.Tipp: Vertraue niemandem. EinschlieÃŸlich (besonders?) dir selbst. Versuche immer, einen Weg zu finden, um zu Ã¼berprÃ¼fen, ob du das gemacht hast, du tun wolltest. Sei nicht schockiert, wenn du manchmal feststellen musst, dass dem nicht ist.","code":"\nmy_gap <- gapminder\nmy_gap %>%\n  mutate(gdp = pop * gdpPercap)\n## # A tibble: 1,704 x 7\n##    country     continent  year lifeExp      pop gdpPercap          gdp\n##    <fct>       <fct>     <int>   <dbl>    <int>     <dbl>        <dbl>\n##  1 Afghanistan Asia       1952    28.8  8425333      779.  6567086330.\n##  2 Afghanistan Asia       1957    30.3  9240934      821.  7585448670.\n##  3 Afghanistan Asia       1962    32.0 10267083      853.  8758855797.\n##  4 Afghanistan Asia       1967    34.0 11537966      836.  9648014150.\n##  5 Afghanistan Asia       1972    36.1 13079460      740.  9678553274.\n##  6 Afghanistan Asia       1977    38.4 14880372      786. 11697659231.\n##  7 Afghanistan Asia       1982    39.9 12881816      978. 12598563401.\n##  8 Afghanistan Asia       1987    40.8 13867957      852. 11820990309.\n##  9 Afghanistan Asia       1992    41.7 16317921      649. 10595901589.\n## 10 Afghanistan Asia       1997    41.8 22227415      635. 14121995875.\n## # â€¦ with 1,694 more rows\nger_gap <- my_gap %>%\n  filter(country == \"Germany\")\n\nmy_gap <- my_gap %>%\n  mutate(tmp = rep(ger_gap$gdpPercap, nlevels(country)),\n         gdpPercapRel = gdpPercap / tmp,\n         tmp = NULL)\nmy_gap %>% \n  filter(country == \"Germany\") %>% \n  select(country, year, gdpPercapRel)\n## # A tibble: 12 x 3\n##    country  year gdpPercapRel\n##    <fct>   <int>        <dbl>\n##  1 Germany  1952            1\n##  2 Germany  1957            1\n##  3 Germany  1962            1\n##  4 Germany  1967            1\n##  5 Germany  1972            1\n##  6 Germany  1977            1\n##  7 Germany  1982            1\n##  8 Germany  1987            1\n##  9 Germany  1992            1\n## 10 Germany  1997            1\n## 11 Germany  2002            1\n## 12 Germany  2007            1\nsummary(my_gap$gdpPercapRel)\n##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n##    0.01    0.07    0.19    0.37    0.51   15.17"},{"path":"dplyr-single.html","id":"mit-arrange-die-zeilenreihenfolge-Ã¤ndern","chapter":"Kapitel 7 Mehr zu dplyr","heading":"7.4 Mit arrange() die Zeilenreihenfolge Ã¤ndern","text":"arrange() ordnet die Zeilen einem data frame neu . Stellen dir vor, du mÃ¶chtest die Daten nach Jahr und Land und nicht nach Land und Jahr geordnet haben.Oder vielleicht willst du nur die Daten aus 2007 sehen, angeordnet entsprechend der Lebenserwartung.Das war nicht du wolltest. Du wolltest nach absteigender Lebenserwartung sortieren. Dann verwende desc().Ein Tipp Ende: verlasse dich bei deinen Analysen NIEMALS darauf, dass Zeilen oder Variablen einer bestimmten Reihenfolge stehen. Aber manchmal man Tabellen anderen prÃ¤sentieren und dabei macht es durchaus Sinn die Zeilenreihenfolge je nach Fragestellung anzupassen.","code":"\nmy_gap %>%\n  arrange(year, country)\n## # A tibble: 1,704 x 7\n##    country     continent  year lifeExp      pop gdpPercap gdpPercapRel\n##    <fct>       <fct>     <int>   <dbl>    <int>     <dbl>        <dbl>\n##  1 Afghanistan Asia       1952    28.8  8425333      779.       0.109 \n##  2 Albania     Europe     1952    55.2  1282697     1601.       0.224 \n##  3 Algeria     Africa     1952    43.1  9279525     2449.       0.343 \n##  4 Angola      Africa     1952    30.0  4232095     3521.       0.493 \n##  5 Argentina   Americas   1952    62.5 17876956     5911.       0.827 \n##  6 Australia   Oceania    1952    69.1  8691212    10040.       1.41  \n##  7 Austria     Europe     1952    66.8  6927772     6137.       0.859 \n##  8 Bahrain     Asia       1952    50.9   120447     9867.       1.38  \n##  9 Bangladesh  Asia       1952    37.5 46886859      684.       0.0958\n## 10 Belgium     Europe     1952    68    8730405     8343.       1.17  \n## # â€¦ with 1,694 more rows\nmy_gap %>%\n  filter(year == 2007) %>%\n  arrange(lifeExp)\n## # A tibble: 142 x 7\n##    country                continent  year lifeExp     pop gdpPercap gdpPercapRel\n##    <fct>                  <fct>     <int>   <dbl>   <int>     <dbl>        <dbl>\n##  1 Swaziland              Africa     2007    39.6  1.13e6     4513.       0.140 \n##  2 Mozambique             Africa     2007    42.1  2.00e7      824.       0.0256\n##  3 Zambia                 Africa     2007    42.4  1.17e7     1271.       0.0395\n##  4 Sierra Leone           Africa     2007    42.6  6.14e6      863.       0.0268\n##  5 Lesotho                Africa     2007    42.6  2.01e6     1569.       0.0488\n##  6 Angola                 Africa     2007    42.7  1.24e7     4797.       0.149 \n##  7 Zimbabwe               Africa     2007    43.5  1.23e7      470.       0.0146\n##  8 Afghanistan            Asia       2007    43.8  3.19e7      975.       0.0303\n##  9 Central African Repubâ€¦ Africa     2007    44.7  4.37e6      706.       0.0219\n## 10 Liberia                Africa     2007    45.7  3.19e6      415.       0.0129\n## # â€¦ with 132 more rows\nmy_gap %>%\n  filter(year == 2007) %>%\n  arrange(desc(lifeExp))\n## # A tibble: 142 x 7\n##    country          continent  year lifeExp       pop gdpPercap gdpPercapRel\n##    <fct>            <fct>     <int>   <dbl>     <int>     <dbl>        <dbl>\n##  1 Japan            Asia       2007    82.6 127467972    31656.        0.984\n##  2 Hong Kong, China Asia       2007    82.2   6980412    39725.        1.23 \n##  3 Iceland          Europe     2007    81.8    301931    36181.        1.12 \n##  4 Switzerland      Europe     2007    81.7   7554661    37506.        1.17 \n##  5 Australia        Oceania    2007    81.2  20434176    34435.        1.07 \n##  6 Spain            Europe     2007    80.9  40448191    28821.        0.896\n##  7 Sweden           Europe     2007    80.9   9031088    33860.        1.05 \n##  8 Israel           Asia       2007    80.7   6426679    25523.        0.793\n##  9 France           Europe     2007    80.7  61083916    30470.        0.947\n## 10 Canada           Americas   2007    80.7  33390141    36319.        1.13 \n## # â€¦ with 132 more rows"},{"path":"dplyr-single.html","id":"mit-rename-schÃ¶ne-namen-vergeben","chapter":"Kapitel 7 Mehr zu dplyr","heading":"7.5 Mit rename() â€œschÃ¶neâ€ Namen vergeben","text":"Ein paar der Namen gapminder sind nicht besonders hÃ¼bsch, wie z.B. lifeExp. life expectancy wÃ¤ren ja schlieÃŸlich zwei Worte und daher finde ich (persÃ¶nliche Meinung) es schÃ¶ner dies auch im Variablennamen zu sehenDie Ã„nderungen haben wir jetzt aber nicht abgespeichert (auch wenn sie schÃ¶n waren), da wir den nachfolgenden Code auch weiterhin ausfÃ¼hren kÃ¶nnten ohne die Ã„nderung der Variablennamen durchgefÃ¼hrt zu haben.Bemerkung: Mit select() kÃ¶nnten wir bei der Auswahl von Variablen auch deren Namen Ã¤nderneverything() wÃ¤hlt alle Ã¼brigen (auÃŸer gdpPercap) Variablen. Da gdpPercap erster Stelle gewÃ¤hlt wurde, wird die Variable auch zur ersten Spalte.","code":"\nmy_gap %>%\n  rename(life_exp = lifeExp,\n         gdp_percap = gdpPercap,\n         gdp_percap_rel = gdpPercapRel)\n## # A tibble: 1,704 x 7\n##    country     continent  year life_exp      pop gdp_percap gdp_percap_rel\n##    <fct>       <fct>     <int>    <dbl>    <int>      <dbl>          <dbl>\n##  1 Afghanistan Asia       1952     28.8  8425333       779.         0.109 \n##  2 Afghanistan Asia       1957     30.3  9240934       821.         0.0806\n##  3 Afghanistan Asia       1962     32.0 10267083       853.         0.0661\n##  4 Afghanistan Asia       1967     34.0 11537966       836.         0.0567\n##  5 Afghanistan Asia       1972     36.1 13079460       740.         0.0411\n##  6 Afghanistan Asia       1977     38.4 14880372       786.         0.0383\n##  7 Afghanistan Asia       1982     39.9 12881816       978.         0.0444\n##  8 Afghanistan Asia       1987     40.8 13867957       852.         0.0346\n##  9 Afghanistan Asia       1992     41.7 16317921       649.         0.0245\n## 10 Afghanistan Asia       1997     41.8 22227415       635.         0.0229\n## # â€¦ with 1,694 more rows\nmy_gap %>%\n  filter(country == \"Burundi\", year > 1996) %>% \n  select(yr = year, lifeExp, gdpPercap) %>% \n  select(gdpPercap, everything())\n## # A tibble: 3 x 3\n##   gdpPercap    yr lifeExp\n##       <dbl> <int>   <dbl>\n## 1      463.  1997    45.3\n## 2      446.  2002    47.4\n## 3      430.  2007    49.6"},{"path":"dplyr-single.html","id":"group_by-macht-das-r-leben-einfacher","chapter":"Kapitel 7 Mehr zu dplyr","heading":"7.6 group_by() macht das R Leben einfacher","text":"Nehmen wir mal , dass uns die Antwort auf die Frage â€œwelchem Land ist die Lebenserwartung innerhalb von 5 Jahren stÃ¤rksten gesunken?â€ interessiert.dplyr bietet uns mÃ¤chtige Hilfsmittel um diese Frage zu beantworten:group_by() fÃ¼gt dem Datensatz eine zusÃ¤tzliche Struktur hinzu â€“ Gruppierungsinformationen â€“ die die Grundlage fÃ¼r Berechnungen innerhalb der Gruppen bilden.group_by() fÃ¼gt dem Datensatz eine zusÃ¤tzliche Struktur hinzu â€“ Gruppierungsinformationen â€“ die die Grundlage fÃ¼r Berechnungen innerhalb der Gruppen bilden.summarise() nimmt einen Datensatz mit \\(n\\)-Beobachtungen, berechnet die angeforderten Zusammenfassungen und gibt einen Datensatz mit einer Beobachtung (falls nur eine Zusammenfassung angefordert wurde) zurÃ¼ck.summarise() nimmt einen Datensatz mit \\(n\\)-Beobachtungen, berechnet die angeforderten Zusammenfassungen und gibt einen Datensatz mit einer Beobachtung (falls nur eine Zusammenfassung angefordert wurde) zurÃ¼ck.Window Funktionen nehmen einen Datensatz mit \\(n\\)-Beobachtungen und geben einen Datensatz mit \\(n\\)-Beobachtungen zurÃ¼ck.Window Funktionen nehmen einen Datensatz mit \\(n\\)-Beobachtungen und geben einen Datensatz mit \\(n\\)-Beobachtungen zurÃ¼ck.mutate() und summarise() berÃ¼cksichtigen Gruppen.mutate() und summarise() berÃ¼cksichtigen Gruppen.Kombiniert mit den Verben, die du bereits kennst, kannst du mit diesen neuen Werkzeugen eine extrem vielfÃ¤ltige Reihe von Problemen relativ einfach lÃ¶sen.","code":""},{"path":"dplyr-single.html","id":"die-dinge-aufzÃ¤hlen","chapter":"Kapitel 7 Mehr zu dplyr","heading":"7.6.1 Die Dinge aufzÃ¤hlen","text":"Beginnen wir mit dem einfachen ZÃ¤hlen. Wie viele Beobachtungen haben wir pro Kontinent?Lassen uns hier kurz innehalten und Ã¼ber das tidyverse nachdenken. Du kÃ¶nntest dir mit table() die gleichen absoluten HÃ¤ufigkeiten berechnen.Aber das Objekt der Klasse table, das zurÃ¼ckgegeben wird, macht die nachfolgenden Berechnungen einfach etwas kniffliger, als es dir lieb ist. Zum Beispiel ist es zu schade, dass die Namen der Kontinente nur als Namen und nicht als richtige Faktor zusammen mit den berechneten Werten zurÃ¼ckgegeben werden. Dies ist ein Beispiel dafÃ¼r, wie das tidyverse ÃœbergÃ¤nge glÃ¤ttet, bei denen die Ausgabe von Schritt die Eingabe von Schritt + 1 werden soll.Die tally() Funktion ist eine Komfortfunktion, die weiÃŸ, wie man Zeilen zÃ¤hlt und dabei Gruppen berÃ¼cksichtigt.Die Funktion count() bietet noch mehr Komfort. Sie kann sowohl gruppieren als auch zÃ¤hlen.wÃ¤re, wenn uns nicht nur die Anzahl Beobachtungen pro Kontinent interessiert, sondern auch die Anzahl unterschiedlichen LÃ¤ndern pro Kontinent. Da wir mehrere Zusammenfassungen innerhalb von summarise() berechnen. Verwenden Sie die Funktion n_distinct(), um die Anzahl der einzelnen LÃ¤nder innerhalb jedes Kontinents zu zÃ¤hlen.","code":"\nmy_gap %>%\n  group_by(continent) %>%\n  summarise(n = n())\n## # A tibble: 5 x 2\n##   continent     n\n##   <fct>     <int>\n## 1 Africa      624\n## 2 Americas    300\n## 3 Asia        396\n## 4 Europe      360\n## 5 Oceania      24\ntable(gapminder$continent)\n## \n##   Africa Americas     Asia   Europe  Oceania \n##      624      300      396      360       24\nstr(table(gapminder$continent))\n##  'table' int [1:5(1d)] 624 300 396 360 24\n##  - attr(*, \"dimnames\")=List of 1\n##   ..$ : chr [1:5] \"Africa\" \"Americas\" \"Asia\" \"Europe\" ...\nmy_gap %>%\n  group_by(continent) %>%\n  tally()\n## # A tibble: 5 x 2\n##   continent     n\n##   <fct>     <int>\n## 1 Africa      624\n## 2 Americas    300\n## 3 Asia        396\n## 4 Europe      360\n## 5 Oceania      24\nmy_gap %>% \n  count(continent)\n## # A tibble: 5 x 2\n##   continent     n\n##   <fct>     <int>\n## 1 Africa      624\n## 2 Americas    300\n## 3 Asia        396\n## 4 Europe      360\n## 5 Oceania      24\nmy_gap %>%\n  group_by(continent) %>%\n  summarise(n = n(),\n            n_countries = n_distinct(country))\n## # A tibble: 5 x 3\n##   continent     n n_countries\n##   <fct>     <int>       <int>\n## 1 Africa      624          52\n## 2 Americas    300          25\n## 3 Asia        396          33\n## 4 Europe      360          30\n## 5 Oceania      24           2"},{"path":"dplyr-single.html","id":"deskriptive-statistiken-mit-summarise","chapter":"Kapitel 7 Mehr zu dplyr","heading":"7.6.2 Deskriptive Statistiken mit summarise()","text":"Kombination mit summarise() kÃ¶nnen wir eine Vielzahl verschiedenen Funktionen verwenden. Einige davon berechnen klassische deskriptive Statistiken:allen betrachteten FÃ¤llen seien \\(x_1,\\dots,x_n\\) numerische Beobachtungen.mean() berechnet das arithmetische Mittel der Beo\\[\\overline x_n = \\frac{1}{n} \\sum_{=1}^n x_i\\,.\\]mean() berechnet das arithmetische Mittel der Beo\\[\\overline x_n = \\frac{1}{n} \\sum_{=1}^n x_i\\,.\\]median() berechnet den Median\n\\[x_{0.5} = \\begin{cases}\nx_{\\left(\\frac{n+1}{2}\\right)}, &  n\\ \\text{ungerade},\\\\\n\\frac{1}{2}\\left(x_{\\left(\\frac{n}{2}\\right)} + x_{\\left(\\frac{n}{2}+1\\right)}\\right), & n\\ \\text{gerade}\n\\end{cases}\\,.\\]median() berechnet den Median\n\\[x_{0.5} = \\begin{cases}\nx_{\\left(\\frac{n+1}{2}\\right)}, &  n\\ \\text{ungerade},\\\\\n\\frac{1}{2}\\left(x_{\\left(\\frac{n}{2}\\right)} + x_{\\left(\\frac{n}{2}+1\\right)}\\right), & n\\ \\text{gerade}\n\\end{cases}\\,.\\]var() berechnet die empirische Varianz\n\\[s_n^2 = \\frac{1}{n-1} \\sum_{=1}^n (x_i - \\overline x_n)^2\\,.\\]var() berechnet die empirische Varianz\n\\[s_n^2 = \\frac{1}{n-1} \\sum_{=1}^n (x_i - \\overline x_n)^2\\,.\\]sd() berechnet die empirische Standardabweichung\n\\[s_n = \\sqrt{s_n^2}\\,.\\]sd() berechnet die empirische Standardabweichung\n\\[s_n = \\sqrt{s_n^2}\\,.\\]IQR() berechnet den Interquartilsabstand\n\\[IQR = x_{0.75} - x_{0.25}\\,,\\]\nwobei \\(x_{0.25}\\) und \\(x_{0.75}\\) das empirische 0.25 bzw. 0.75 Quantil bezeichnen.IQR() berechnet den Interquartilsabstand\n\\[IQR = x_{0.75} - x_{0.25}\\,,\\]\nwobei \\(x_{0.25}\\) und \\(x_{0.75}\\) das empirische 0.25 bzw. 0.75 Quantil bezeichnen.min() berechnet das Minimum\n\\[x_{(1)} = \\min(x_1,\\dots,x_n)\\,.\\]min() berechnet das Minimum\n\\[x_{(1)} = \\min(x_1,\\dots,x_n)\\,.\\]und max() berechnet demnach das Maximum\n\\[x_{(n)} = \\max(x_1,\\dots,x_n)\\,.\\]und max() berechnet demnach das Maximum\n\\[x_{(n)} = \\max(x_1,\\dots,x_n)\\,.\\]Auch wenn dies statistisch gesehen unklug sein mag, lass uns die durchschnittliche Lebenserwartung pro Kontinenten berechnen.summarise_at() wendet die gleiche(n) Zusammenfassungs-Funktion(en) auf mehrere Variablen . Lass uns die durchschnittliche Lebenserwartung sowie den Median und das Pro-Kopf-GDP nach Kontinenten pro Jahr berechnenâ€¦ aber nur fÃ¼r 1952 und 2007.Konzentrieren wir uns nur auf Asien. Wie hoch ist die minimale und maximale Lebenserwartung pro Jahr?NatÃ¼rlich wÃ¤re es viel interessanter zu sehen, welches Land diese extremen Beobachtungen beigetragen hat. Kommt das Minimum (Maximum) immer aus dem gleichen Land? Wir gehen dem KÃ¼rze mit Window Funktionen nach.","code":"\nmy_gap %>%\n  group_by(continent) %>%\n  summarise(avg_lifeExp = mean(lifeExp))\n## # A tibble: 5 x 2\n##   continent avg_lifeExp\n##   <fct>           <dbl>\n## 1 Africa           48.9\n## 2 Americas         64.7\n## 3 Asia             60.1\n## 4 Europe           71.9\n## 5 Oceania          74.3\nmy_gap %>%\n  filter(year %in% c(1952, 2007)) %>%\n  group_by(continent, year) %>%\n  summarise_at(vars(lifeExp, gdpPercap), list(mean, median))\n## # A tibble: 10 x 6\n## # Groups:   continent [5]\n##    continent  year lifeExp_fn1 gdpPercap_fn1 lifeExp_fn2 gdpPercap_fn2\n##    <fct>     <int>       <dbl>         <dbl>       <dbl>         <dbl>\n##  1 Africa     1952        39.1         1253.        38.8          987.\n##  2 Africa     2007        54.8         3089.        52.9         1452.\n##  3 Americas   1952        53.3         4079.        54.7         3048.\n##  4 Americas   2007        73.6        11003.        72.9         8948.\n##  5 Asia       1952        46.3         5195.        44.9         1207.\n##  6 Asia       2007        70.7        12473.        72.4         4471.\n##  7 Europe     1952        64.4         5661.        65.9         5142.\n##  8 Europe     2007        77.6        25054.        78.6        28054.\n##  9 Oceania    1952        69.3        10298.        69.3        10298.\n## 10 Oceania    2007        80.7        29810.        80.7        29810.\nmy_gap %>%\n  filter(continent == \"Asia\") %>%\n  group_by(year) %>%\n  summarise(min_lifeExp = min(lifeExp), max_lifeExp = max(lifeExp))\n## # A tibble: 12 x 3\n##     year min_lifeExp max_lifeExp\n##    <int>       <dbl>       <dbl>\n##  1  1952        28.8        65.4\n##  2  1957        30.3        67.8\n##  3  1962        32.0        69.4\n##  4  1967        34.0        71.4\n##  5  1972        36.1        73.4\n##  6  1977        31.2        75.4\n##  7  1982        39.9        77.1\n##  8  1987        40.8        78.7\n##  9  1992        41.7        79.4\n## 10  1997        41.8        80.7\n## 11  2002        42.1        82  \n## 12  2007        43.8        82.6"},{"path":"dplyr-single.html","id":"gruppierte-verÃ¤nderungen","chapter":"Kapitel 7 Mehr zu dplyr","heading":"7.7 Gruppierte VerÃ¤nderungen","text":"Manchmal mÃ¶chte man die \\(n\\)-Zeilen fÃ¼r jede Gruppe nicht zu einer Zeile zusammenfassen. Stattdessen mÃ¶chte man die Gruppen behalten, aber innerhalb dieser Gruppen rechnen.","code":""},{"path":"dplyr-single.html","id":"berechnungen-innerhalb-der-gruppen","chapter":"Kapitel 7 Mehr zu dplyr","heading":"7.7.1 Berechnungen innerhalb der Gruppen","text":"Machen wir eine neue Variable, die die gewonnenen (verlorenen) Lebenserwartungsjahre im Vergleich zu 1952 fÃ¼r jedes einzelne Land angibt. Wir gruppieren nach LÃ¤ndern und verwenden mutate(), um eine neue Variable zu erstellen. Die Funktion first() extrahiert dabei den ersten Wert aus einem Vektor. Beachte, dass first() mit dem Vektor der Lebenserwartungen jeder LÃ¤ndergruppe arbeitet.Innerhalb eines Landes nehmen wir die Differenz zwischen der Lebenserwartung im Jahr \\(\\) und der Lebenserwartung im Jahr 1952. Daher sehen wir fÃ¼r 1952 immer Nullen und fÃ¼r die meisten LÃ¤nder eine Folge von positiven und steigenden Zahlen.","code":"\nmy_gap %>% \n  group_by(country) %>% \n  select(country, year, lifeExp) %>% \n  mutate(lifeExp_gain = lifeExp - first(lifeExp)) %>% \n  filter(year < 1963)\n## # A tibble: 426 x 4\n## # Groups:   country [142]\n##    country      year lifeExp lifeExp_gain\n##    <fct>       <int>   <dbl>        <dbl>\n##  1 Afghanistan  1952    28.8         0   \n##  2 Afghanistan  1957    30.3         1.53\n##  3 Afghanistan  1962    32.0         3.20\n##  4 Albania      1952    55.2         0   \n##  5 Albania      1957    59.3         4.05\n##  6 Albania      1962    64.8         9.59\n##  7 Algeria      1952    43.1         0   \n##  8 Algeria      1957    45.7         2.61\n##  9 Algeria      1962    48.3         5.23\n## 10 Angola       1952    30.0         0   \n## # â€¦ with 416 more rows"},{"path":"dplyr-single.html","id":"window-functions","chapter":"Kapitel 7 Mehr zu dplyr","heading":"7.7.2 Window Funktionen","text":"Window Funktionen nehmen \\(n\\)-Eingaben entgegen und geben \\(n\\)-Ausgaben zurÃ¼ck. AuÃŸerdem hÃ¤ngt die Ausgabe von allen Werten ab. ist rank() eine Window Funktion, aber log() ist es nicht.Betrachten wir noch einmal die schlechtesten und besten Lebenserwartungen Asien im Laufe der Zeit, behalten aber Informationen darÃ¼ber bei, welches Land diese Extremwerte beisteuert.Wir sehen, dass (min = Afghanistan, max = Japan) das hÃ¤ufigste Ergebnis ist, aber Kambodscha und Israel tauchen jeweils mindestens einmal als min bzw. max auf.\nAber wÃ¤re es nicht schÃ¶n, eine Zeile pro Jahr zu haben?Wie hat das eigentlich funktioniert? Dazu schauen wir uns die Beobachtungen aus Asien mal direkt .Jetzt wenden wir eine Window Funktion â€“ min_rank(). Da asia nach Jahren gruppiert ist, operiert min_rank() innerhalb von Mini-DatensÃ¤tzen, jeder fÃ¼r ein bestimmtes Jahr. Auf die Variable LifeExp angewandt, liefert min_rank() den Rang der beobachteten Lebenserwartung jedes Landes.Bemerkung: Der min-Teil gibt nur , wie die Verbindungen unterbrochen werden.Neben dem Minimum gibt es aber auch noch eine Reihe weiterer Alternative, wie z.B. den DurchschnittDann schauen wir uns die RÃ¤nge der Lebenserwartung innerhalb eines Jahres mal explizit fÃ¼r ein paar LÃ¤nder, sowohl der (Standard-) aufsteigenden als auch der absteigenden Reihenfolge.Da wir im zweiten Schritt nach einigen LÃ¤ndern filtern, erzeugen wir im ersten Schritt mit mutate() die gewÃ¼nschten Werte und weisen sie neuen Variablen zu.Afghanistan neigt dazu, 1 der le_rank-Variablen zu haben, Japan neigt dazu, 1 der le_desc_rank-Variablen zu haben und andere LÃ¤nder, wie Thailand, zeigen deutlich weniger extreme RÃ¤nge.Damit sollte der ursprÃ¼ngliche filter() Befehlauch klar sein.Diese beiden SÃ¤tze von RÃ¤ngen werden --fly, innerhalb der Jahresgruppe, gebildet, und filter() behÃ¤lt Zeilen mit Rang weniger als 2. Da wir dies fÃ¼r aufsteigende und absteigende RÃ¤nge tun, erhalten wir sowohl den minimalen als auch den maximalen Rang.Wenn wir nur das Minimum ODER das Maximum gewollt hÃ¤tten, hÃ¤tte auch ein alternativer Ansatz mit top_n() funktioniert.","code":"\nmy_gap %>%\n  filter(continent == \"Asia\") %>%\n  select(year, country, lifeExp) %>%\n  group_by(year) %>%\n  filter(min_rank(desc(lifeExp)) < 2 | min_rank(lifeExp) < 2) %>% \n  arrange(year) %>%\n  print(n = Inf)  # erzwingt eine Ausgabe aller Zeilen\n## # A tibble: 24 x 3\n## # Groups:   year [12]\n##     year country     lifeExp\n##    <int> <fct>         <dbl>\n##  1  1952 Afghanistan    28.8\n##  2  1952 Israel         65.4\n##  3  1957 Afghanistan    30.3\n##  4  1957 Israel         67.8\n##  5  1962 Afghanistan    32.0\n##  6  1962 Israel         69.4\n##  7  1967 Afghanistan    34.0\n##  8  1967 Japan          71.4\n##  9  1972 Afghanistan    36.1\n## 10  1972 Japan          73.4\n## 11  1977 Cambodia       31.2\n## 12  1977 Japan          75.4\n## 13  1982 Afghanistan    39.9\n## 14  1982 Japan          77.1\n## 15  1987 Afghanistan    40.8\n## 16  1987 Japan          78.7\n## 17  1992 Afghanistan    41.7\n## 18  1992 Japan          79.4\n## 19  1997 Afghanistan    41.8\n## 20  1997 Japan          80.7\n## 21  2002 Afghanistan    42.1\n## 22  2002 Japan          82  \n## 23  2007 Afghanistan    43.8\n## 24  2007 Japan          82.6\n(asia <- my_gap %>%\n  filter(continent == \"Asia\") %>%\n  select(year, country, lifeExp) %>%\n  group_by(year))\n## # A tibble: 396 x 3\n## # Groups:   year [12]\n##     year country     lifeExp\n##    <int> <fct>         <dbl>\n##  1  1952 Afghanistan    28.8\n##  2  1957 Afghanistan    30.3\n##  3  1962 Afghanistan    32.0\n##  4  1967 Afghanistan    34.0\n##  5  1972 Afghanistan    36.1\n##  6  1977 Afghanistan    38.4\n##  7  1982 Afghanistan    39.9\n##  8  1987 Afghanistan    40.8\n##  9  1992 Afghanistan    41.7\n## 10  1997 Afghanistan    41.8\n## # â€¦ with 386 more rows\nrank(c(1,3,3,5), ties.method = \"min\")\n## [1] 1 2 2 4\nrank(c(1,3,3,5))\n## [1] 1.0 2.5 2.5 4.0\nasia %>%\n  mutate(le_rank = min_rank(lifeExp),\n         le_desc_rank = min_rank(desc(lifeExp))) %>% \n  filter(country %in% c(\"Afghanistan\", \"Japan\", \"Thailand\"), year > 1995)\n## # A tibble: 9 x 5\n## # Groups:   year [3]\n##    year country     lifeExp le_rank le_desc_rank\n##   <int> <fct>         <dbl>   <int>        <int>\n## 1  1997 Afghanistan    41.8       1           33\n## 2  2002 Afghanistan    42.1       1           33\n## 3  2007 Afghanistan    43.8       1           33\n## 4  1997 Japan          80.7      33            1\n## 5  2002 Japan          82        33            1\n## 6  2007 Japan          82.6      33            1\n## 7  1997 Thailand       67.5      12           22\n## 8  2002 Thailand       68.6      12           22\n## 9  2007 Thailand       70.6      12           22\nfilter(min_rank(desc(lifeExp)) < 2 | min_rank(lifeExp) < 2)\nmy_gap %>%\n  filter(continent == \"Asia\") %>%\n  select(year, country, lifeExp) %>%\n  arrange(year) %>%\n  group_by(year) %>%\n  #top_n(1, wt = lifeExp)        ## fÃ¼r das Minimum\n  top_n(1, wt = desc(lifeExp)) ## bzw. das Maximum\n## # A tibble: 12 x 3\n## # Groups:   year [12]\n##     year country     lifeExp\n##    <int> <fct>         <dbl>\n##  1  1952 Afghanistan    28.8\n##  2  1957 Afghanistan    30.3\n##  3  1962 Afghanistan    32.0\n##  4  1967 Afghanistan    34.0\n##  5  1972 Afghanistan    36.1\n##  6  1977 Cambodia       31.2\n##  7  1982 Afghanistan    39.9\n##  8  1987 Afghanistan    40.8\n##  9  1992 Afghanistan    41.7\n## 10  1997 Afghanistan    41.8\n## 11  2002 Afghanistan    42.1\n## 12  2007 Afghanistan    43.8"},{"path":"dplyr-single.html","id":"groÃŸes-finale","chapter":"Kapitel 7 Mehr zu dplyr","heading":"7.8 GroÃŸes Finale","text":"Beantworten wir also die Frage: Welches Land hat den stÃ¤rksten RÃ¼ckgang der Lebenserwartung um 5 Jahre erlebt?Die Beobachtungsfrequenz im Datensatz ist fÃ¼nf Jahre, d.h. wir haben Daten fÃ¼r 1952, 1957 usw. Dies bedeutet also, dass die VerÃ¤nderungen der Lebenserwartung zwischen benachbarten Zeitpunkten betrachtet werden mÃ¼ssen.Zum jetzigen Zeitpunkt ist das einfach zu einfach, also lasst es uns, wenn wir schon dabei sind, nach Kontinenten machen.Denk ruhig eine Weile Ã¼ber das Ergebnis nach. Meistens sieht man hier trockenen Statistiken Ã¼ber die durchschnittliche Lebenserwartung, wie VÃ¶lkermord aussieht.Unterteile den Code, beginnend von oben, StÃ¼cke und Ã¼berprÃ¼fe die einzelnen Zwischenergebnisse. wurde der Code auch geschrieben/entwickelt, mit vielen Fehlern und Verfeinerungen auf dem Weg.","code":"\nmy_gap %>%\n  select(country, year, continent, lifeExp) %>%\n  group_by(continent, country) %>%\n  # fÃ¼r jedes Land werden die Unterschiede berechnet\n  mutate(le_delta = lifeExp - lag(lifeExp)) %>% \n  ## fÃ¼r jedes Land wird nur der kleinste Wert behalten\n  summarise(worst_le_delta = min(le_delta, na.rm = TRUE)) %>% \n  ## nun wird noch pro Kontinent, die Zeile mit dem kleinsten Wert ausgegeben\n  top_n(-1, wt = worst_le_delta) %>% \n  arrange(worst_le_delta)\n## `summarise()` has grouped output by 'continent'. You can override using the `.groups` argument.\n## # A tibble: 5 x 3\n## # Groups:   continent [5]\n##   continent country     worst_le_delta\n##   <fct>     <fct>                <dbl>\n## 1 Africa    Rwanda             -20.4  \n## 2 Asia      Cambodia            -9.10 \n## 3 Americas  El Salvador         -1.51 \n## 4 Europe    Montenegro          -1.46 \n## 5 Oceania   Australia            0.170"},{"path":"dplyr-single.html","id":"literatur","chapter":"Kapitel 7 Mehr zu dplyr","heading":"7.9 Literatur","text":"dieser Stelle sei noch auf die dplyr Webseite und das Kapitel\nData transformation R Data Science (Wickham Grolemund 2016) verwiesen.","code":""},{"path":"import-export.html","id":"import-export","chapter":"Kapitel 8 Daten I/O","heading":"Kapitel 8 Daten I/O","text":"","code":""},{"path":"import-export.html","id":"Ã¼berblick","chapter":"Kapitel 8 Daten I/O","heading":"8.1 Ãœberblick","text":"Wir haben die Gapminder-Daten als tibble aus dem gapminder Paket geladen. Wir haben im letzten Abschnitt weder Daten noch abgeleitete Ergebnisse explizit eine Datei geschrieben. Im wirklichen Leben wirst du aber stÃ¤ndig Daten, die Tabellenform vorliegen, R ein- und auslesen. Manchmal muss das sogar fÃ¼r Daten geschehen, die nicht Tabellenform vorliegen.Wie macht man das? Worauf muss man aufpassen?","code":""},{"path":"import-export.html","id":"daten-import","chapter":"Kapitel 8 Daten I/O","heading":"8.1.1 Daten Import","text":"FÃ¼r den Daten Import gibt es im Allgemeinen zwei MÃ¶glichkeiten:â€œÃœberrasche mich!â€ Diese Haltung musst du einnehmen, wenn du zum ersten Mal einen Datensatz erhÃ¤ltst. Du musst einfach froh, wenn du die Daten ohne Fehler importieren konntest. Dann schaust du dir das Ergebnis , entdeckst Fehler den Daten und/oder beim Import. Du behebst sie und beginnst nochmal von vorne.â€œEin weiterer Tag im Paradies.â€ Das ist die Einstellung, wenn du einen aufgerÃ¤umten Datensatz einliest, den du vorher einem oder mehreren Reinigungsskripten wahnsinnig aufgerÃ¤umt haben. Es sollte keine Ãœberraschungen geben.Im zweiten Fall, und im weiteren Verlauf des ersten Falles, lernst du tatsÃ¤chlich eine Menge darÃ¼ber, wie die Daten sind/sein sollten. Ein wichtiger Import-Ratschlag: Verwende die Argumente der Importfunktion, um weit wie mÃ¶glich und schnell wie mÃ¶glich zu kommen. AnfÃ¤ngercode hat oft eine Menge unnÃ¶tigen nachtrÃ¤glichen Aufwand. Lese die Hilfe zu den Importfunktionen und nutzen die Argumente maximal aus, um den Import zu steuern.","code":""},{"path":"import-export.html","id":"daten-export","chapter":"Kapitel 8 Daten I/O","heading":"8.1.2 Daten Export","text":"Es wird viele Gelegenheiten geben, bei denen du Daten aus R exportieren willst. Zwei wichtige Beispiele:einen gesÃ¤uberten Datensatz der bereit ist analysiert zu werden, den du heldenhaft aus recht unordentlichen Daten erstellt hastein numerisches Ergebnis aus einer Datenaggregation oder Modellierung oder einer statistischen SchlussfolgerungErster Tipp: Der Output von heute ist der Input von morgen. Denke die Schmerzen zurÃ¼ck, die du selbst beim Import von fremden Daten erlitten hast, und fÃ¼gen dir nicht selbst solche Schmerzen zu!Zweiter Tipp: Sei nicht zu clever. Eine einfache Textdatei, die von einem Menschen einem Texteditor lesbar ist, sollte dein Standard sein, bis du einen guten Grund dafÃ¼r hast, dass dies nicht funktionieren wird. Das Lesen und Schreiben exotische Formate wird das erste sein, Zukunft oder auf einem anderen Computer kaputtgehen wird. Es schafft auch Barrieren fÃ¼r jeden, der ein anderes Toolkit hat als du. Strebe nach Zukunfts- und Idiotensicherheit.Wie passt das zu unserer Betonung der dynamischen Berichterstattung Ã¼ber R Markdown? Es gibt fÃ¼r alles eine Zeit und einen Ort. Es gibt Projekte und Dokumente, bei denen du dich intensiv mit knitr und rmarkdown beschÃ¤ftigen kannst/willst/musst. Aber es gibt viele gute GrÃ¼nde, warum (Teile von) einer Analyse nicht (nur) einen dynamischen Bericht eingebettet werden sollten. Vielleicht bist du gerade dabei Daten zu bereinigen, um einen Datensatz fÃ¼r eine nachfolgende Analyse zu erzeugen. Vielleicht leistet du einen kleinen, aber entscheidenden Beitrag zu einem gigantischen Multi-Autoren-Papier. Etc. Denke auch daran, dass es natÃ¼rlich auch noch andere Werkzeuge und ArbeitsablÃ¤ufe gibt, um etwas reproduzierbar zu machen: z.B. make.","code":""},{"path":"import-export.html","id":"load-the-tidyverse","chapter":"Kapitel 8 Daten I/O","heading":"8.2 Load the tidyverse","text":"Das Hauptpaket, das wir verwenden werden, ist readr, welches Alternativen zu den Standardfunktionen read.table() und write.table() bietet. Trotzdem laden wir standardmÃ¤ÃŸig einfach wieder tidyverse.","code":"\nlibrary(tidyverse)\n## â”€â”€ Attaching packages â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ tidyverse 1.3.1 â”€â”€\n## âœ“ ggplot2 3.3.5     âœ“ purrr   0.3.4\n## âœ“ tibble  3.1.2     âœ“ dplyr   1.0.7\n## âœ“ tidyr   1.1.3     âœ“ stringr 1.4.0\n## âœ“ readr   2.0.1     âœ“ forcats 0.5.1\n## â”€â”€ Conflicts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ tidyverse_conflicts() â”€â”€\n## x dplyr::filter() masks stats::filter()\n## x dplyr::lag()    masks stats::lag()"},{"path":"import-export.html","id":"einlesen-der-gapminder-daten","chapter":"Kapitel 8 Daten I/O","heading":"8.3 Einlesen der Gapminder Daten","text":"Die Gapminder Daten kÃ¶nnten wir natÃ¼rlich wie zuvor Ã¼ber das Laden des gapminder Pakets verfÃ¼gbar machen. Da es diesem Abschnitt aber um das Einlesen von Daten geht, versuchen wir die Daten als .tsv Datei (tab-separated values - sind sie im Paket gespeichert) einzulesen. Aber dies bedeutet natÃ¼rlich, dass wir die entsprechende .tsv Datei erst mal finden mÃ¼ssen. Dabei hilft uns glÃ¼cklicherweise das fs Paket.Nachdem wir jetzt den Speicherort der Datei kennen, kÃ¶nnen wir versuchen sie einzulesen.","code":"\nlibrary(fs)\n(gap_tsv <- path_package(\"gapminder\", \"extdata\", \"gapminder.tsv\"))\n## /Library/Frameworks/R.framework/Versions/4.0/Resources/library/gapminder/extdata/gapminder.tsv"},{"path":"import-export.html","id":"einlesen-von-daten-in-tabellenform","chapter":"Kapitel 8 Daten I/O","heading":"8.4 Einlesen von Daten in Tabellenform","text":"Die Haupt-Funktion zum Einlesen von Daten readr ist read_delim(). Hier verwenden wir eine Variante, read_tsv(), fÃ¼r tabulatorgetrennte Daten:Ãœber den Tabulator Spalten einer Datentabelle zu trennen, ist natÃ¼rlich nur eine Variante neben weiteren Alternativen wie Komma, Strichpunkt, Leerzeichen, â€¦FÃ¼r Komma getrennte Daten wÃ¼rde man beispielsweise read_csv() verwenden. FÃ¼r volle FlexibilitÃ¤t bei der Angabe des Trennzeichens kannst du aber jederzeit direkt read_delim() verwenden.Der auffÃ¤lligste Unterschied zwischen den readr-Funktionen und der Standardfunktion read.table()ist, dass readr standardmÃ¤ÃŸig Characters NICHT Faktoren umwandelt. Im GroÃŸen und Ganzen ist dies ein besseres Standardverhalten, obwohl es natÃ¼rlich immer wieder vorkommen wird, dass du einzelne Variablen nach dem Einlesen einen Faktoren umwandeln wirst. Aber lass dich davon nicht tÃ¤uschen - im Allgemeinen wirst du durch die Verwendung von readr nach dem Einlesen weniger Anpassungen machen mÃ¼ssen im Vergleich zum Standardvorgehen.Fazit: Benutze readr::read_delim() und â€œFreundeâ€.Die Gapminder-Daten sind zu sauber und einfach, um die groÃŸartigen Funktionen von readr zur Geltung zu bringen. Ein Blick Introduction readr zeigt aber noch viele weitere AnpassungsmÃ¶glichkeiten der readr Funktionen.","code":"\ngapminder <- read_tsv(gap_tsv)\n## Rows: 1704 Columns: 6\n## â”€â”€ Column specification â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n## Delimiter: \"\\t\"\n## chr (2): country, continent\n## dbl (4): year, lifeExp, pop, gdpPercap\n## \n## â„¹ Use `spec()` to retrieve the full column specification for this data.\n## â„¹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\nglimpse(gapminder)\n## Rows: 1,704\n## Columns: 6\n## $ country   <chr> \"Afghanistan\", \"Afghanistan\", \"Afghanistan\", \"Afghanistan\", â€¦\n## $ continent <chr> \"Asia\", \"Asia\", \"Asia\", \"Asia\", \"Asia\", \"Asia\", \"Asia\", \"Asiâ€¦\n## $ year      <dbl> 1952, 1957, 1962, 1967, 1972, 1977, 1982, 1987, 1992, 1997, â€¦\n## $ lifeExp   <dbl> 28.8, 30.3, 32.0, 34.0, 36.1, 38.4, 39.9, 40.8, 41.7, 41.8, â€¦\n## $ pop       <dbl> 8425333, 9240934, 10267083, 11537966, 13079460, 14880372, 12â€¦\n## $ gdpPercap <dbl> 779, 821, 853, 836, 740, 786, 978, 852, 649, 635, 727, 975, â€¦"},{"path":"import-export.html","id":"daten-exportieren","chapter":"Kapitel 8 Daten I/O","heading":"8.5 Daten exportieren","text":"Bevor wir etwas exportieren kÃ¶nnen, mÃ¼ssen (das ist natÃ¼rlich nicht richtig - niemand zwingt uns dazu) etwas berechnen, das es wert ist, exportiert zu werden. Lass uns eine Zusammenfassung der maximalen Lebenserwartung auf LÃ¤nderebene erstellen.Das gap_life_exp data frame ist ein Beispiel fÃ¼r ein Zwischenergebnis, das wir fÃ¼r die Zukunft und fÃ¼r nachgelagerte Analysen oder Visualisierungen speichern wollen.Die Haupt-Exportfunktion readr ist write_delim(). FÃ¼r verschiedene Dateiformate gibt es auch hier wieder verschiedene Komfortfunktionen. Lass uns write_csv() benutzen, um eine kommagetrennte Datei zu erhalten.Schauen wir uns die ersten paar Zeilen von gap_life_exp.csv . Dazu kannst du entweder die Datei Ã¶ffnen oder, im Terminal, head darauf anwenden.Das sieht recht ordentlich aus, obwohl es keine sichtbare Ausrichtung oder Trennung Spalten gibt. HÃ¤tten wir die Basisfunktion read.csv() benutzt, wÃ¼rden wir Zeilennamen und viele AnfÃ¼hrungszeichen sehen, es sei denn, wir hÃ¤tten diese Features explizit abgeschaltet. Das schÃ¶nere Standardverhalten ist daher der Hauptgrund, warum wir readr::write_csv() gegenÃ¼ber write.csv() bevorzugen.Es ist nicht wirklich fair, sich Ã¼ber den Mangel sichtbarer Ausrichtung zu beklagen, schlieÃŸlich erzeugen wir Dateien, die der Computer lesen soll. Falls du wirklich der Datei â€œherumstÃ¶bernâ€ willst, benutze View() RStudio oder Ã¶ffnen die Datei mit einem Spreadsheet Programm (!). Aber erliege NIE der Versuchung, dort Datenmanipulationen vorzunehmen â€¦ gehe zurÃ¼ck zu R und schreibe dort die Befehle, die du die nÃ¤chsten 15 Mal ausfÃ¼hren kannst, wenn du diesen Datensatz (oder DatensÃ¤tze derselben Form) importieren/bereinigen/aggregieren/exportieren willst.","code":"\ngap_life_exp <- gapminder %>%\n  group_by(country, continent) %>% \n  summarise(life_exp = max(lifeExp)) %>% \n  ungroup()\n## `summarise()` has grouped output by 'country'. You can override using the `.groups` argument.\ngap_life_exp\n## # A tibble: 142 x 3\n##    country     continent life_exp\n##    <chr>       <chr>        <dbl>\n##  1 Afghanistan Asia          43.8\n##  2 Albania     Europe        76.4\n##  3 Algeria     Africa        72.3\n##  4 Angola      Africa        42.7\n##  5 Argentina   Americas      75.3\n##  6 Australia   Oceania       81.2\n##  7 Austria     Europe        79.8\n##  8 Bahrain     Asia          75.6\n##  9 Bangladesh  Asia          64.1\n## 10 Belgium     Europe        79.4\n## # â€¦ with 132 more rows\nwrite_csv(gap_life_exp, \"data/gap_life_exp.csv\")country,continent,life_exp\nAfghanistan,Asia,43.828\nAlbania,Europe,76.423\nAlgeria,Africa,72.301\nAngola,Africa,42.731\nArgentina,Americas,75.32"},{"path":"import-export.html","id":"daten-Ã¼ber-eine-api","chapter":"Kapitel 8 Daten I/O","heading":"8.6 Daten Ã¼ber eine API","text":"Interessante DatensÃ¤tze sind der Treibstoff fÃ¼r ein gutes Data Science Projekt. APIs (Application Programming Interface) sind eine weitere sehr nÃ¼tzliche Methode, um auf interessante Daten zuzugreifen.Anstatt einen Datensatz herunterladen zu mÃ¼ssen, ermÃ¶glichen APIs Daten direkt von bestimmten Websites Ã¼ber eine Schnittstelle anzufordern. Viele groÃŸe Webseiten wie Twitter und Facebook ermÃ¶glichen Ã¼ber APIs den Zugriff auf Teile ihrer Daten.Wir werden die Grundlagen des Zugriffs auf eine API besprechen. Dazu benÃ¶tigst du aber keine Vorwissen bzgl. APIs.","code":""},{"path":"import-export.html","id":"einfÃ¼hrung","chapter":"Kapitel 8 Daten I/O","heading":"8.6.1 EinfÃ¼hrung","text":"API ist ein allgemeiner Begriff fÃ¼r den Ort, dem ein Computerprogramm mit einem anderen oder mit sich selbst interagiert. Wir sprechen Ã¼ber Web-APIs, bei denen zwei verschiedene Computer - ein Client und ein Server - miteinander interagieren, um Daten anzufordern bzw. bereitzustellen.APIs bieten eine ausgefeilte MÃ¶glichkeit Daten von einer Website anzufordern. Wenn eine Website wie Twitter eine API einrichtet, richten sie im Wesentlichen einen Computer ein, der auf Datenanfragen wartet.Sobald dieser Computer eine Datenanforderung empfÃ¤ngt, verarbeitet er die Daten selbst und sendet sie den Computer, der sie angefordert hat. Unsere Aufgabe als Anforderer der Daten wird es sein R Code zu schreiben, der die Anforderung erstellt und dem Computer, auf dem die API lÃ¤uft, mitteilt, wir benÃ¶tigen. Dieser Computer liest dann unseren Code, verarbeitet die Anfrage und gibt schÃ¶n formatierte Daten zurÃ¼ck, die mithilfe existierender R Pakete verarbeitet werden kÃ¶nnen..","code":""},{"path":"import-export.html","id":"erstellen-von-api-anforderungen-in-r","chapter":"Kapitel 8 Daten I/O","heading":"8.6.2 Erstellen von API-Anforderungen in R","text":"Um mit APIs R zu arbeiten, mÃ¼ssen wir ein paar neue Pakete laden (und vorher natÃ¼rlich installieren). Konkret werden wir mit den Paketen httr und jsonlite arbeiten. Sie spielen bei der Einbindung der APIs unterschiedliche Rollen, aber beide sind unverzichtbar.Vermutlich hast du die beiden Pakete bisher nicht installiert. Daher ist der erste Schritt die beiden Pakete zu installierenund anschlieÃŸend zu laden","code":"\ninstall.packages(c(\"httr\", \"jsonlite\"))\nlibrary(httr)\nlibrary(jsonlite)\n## \n## Attaching package: 'jsonlite'\n## The following object is masked from 'package:purrr':\n## \n##     flatten"},{"path":"import-export.html","id":"unsere-erste-api-anfrage-stellen","chapter":"Kapitel 8 Daten I/O","heading":"8.6.3 Unsere erste API-Anfrage stellen","text":"Der erste Schritt, um Daten von einer API zu erhalten, ist die eigentliche Anfrage R. Diese Anfrage wird den Computer-Server geschickt, der Ã¼ber die API verfÃ¼gt, und wenn alles reibungslos verlÃ¤uft, wird er eine Antwort zurÃ¼cksenden.Es gibt verschiedene Arten von Anfragen, die man einen API-Server stellen kann. Diese Arten von Anfragen entsprechen verschiedenen Aktionen, die der Server ausfÃ¼hren soll.FÃ¼r unsere Zwecke fragen wir lediglich nach Daten, einer GET-Anfrage entspricht. Andere Arten von Anfragen sind z.B. POST und PUT, aber diese sind fÃ¼r uns nicht von Interesse und daher brauchen wir uns darum nicht zu kÃ¼mmern.Um eine GET-Anfrage zu erstellen, mÃ¼ssen wir die GET() Funktion aus dem httr Paket verwenden. Die GET() Funktion benÃ¶tigt als Input eine URL, die die Adresse des Servers angibt, den die Anforderung gesendet werden soll.Als Beispiel werden wir mit der Open Notify API arbeiten, die Daten zu verschiedenen NASA-Projekten enthÃ¤lt. Mithilfe der Open Notify API kÃ¶nnen wir uns Ã¼ber den Standort der Internationalen Raumstation informieren und erfahren, wie viele Personen sich derzeit im Weltraum aufhalten.Wir beginnen damit, dass wir unsere Anfrage mit der GET() Funktion stellen und die URL der API angeben:Die Ausgabe der Funktion GET() ist eine Liste, die alle Informationen enthÃ¤lt, die vom API-Server zurÃ¼ckgegeben werden.","code":"\njdata <- GET(\"http://api.open-notify.org/astros.json\")"},{"path":"import-export.html","id":"get-ausgabe","chapter":"Kapitel 8 Daten I/O","heading":"8.6.4 GET() Ausgabe","text":"Schauen wir uns einmal , wie die Variable jdata der R-Konsole aussieht:Als erstes fÃ¤llt auf, dass die URL enthalten ist, die die GET-Anfrage gesendet wurde. AuÃŸerdem sehen wir das Datum und die Uhrzeit, zu der die Anfrage gestellt wurde, sowie die GrÃ¶ÃŸe der Antwort.Die Information Content-Type gibt uns eine Vorstellung davon, welche Form die Daten haben. Diese spezielle Antwort besagt, dass die Daten ein JSON-Format annehmen, womit auch klar ist warum wir das Paket jsonlite ebenfalls geladen haben.Der Status verdient eine besondere Aufmerksamkeit. Status bezieht sich auf den Erfolg oder Misserfolg der API-Anfrage, und er wird Form einer Zahl angegeben. Die zurÃ¼ckgegebene Nummer gibt Auskunft darÃ¼ber, ob die Anfrage erfolgreich war oder nicht, und kann auch einige GrÃ¼nde fÃ¼r einen mÃ¶glichen Misserfolg nennen.Die Zahl 200 ist das, wir sehen wollen. Sie entspricht einem erfolgreichen Antrag, und das ist es, wir hier haben. Eine Ãœbersicht Ã¼ber weitere Status Codes findet man z.B. auf dieser [Webseite](https://www.restapitutorial.com/httpstatuscodes.html.","code":"\njdata\n## Response [http://api.open-notify.org/astros.json]\n##   Date: 2021-11-15 22:03\n##   Status: 200\n##   Content-Type: application/json\n##   Size: 497 B"},{"path":"import-export.html","id":"handling-json-data","chapter":"Kapitel 8 Daten I/O","heading":"8.6.5 Handling JSON Data","text":"JSON steht fÃ¼r JavaScript Object Notation. WÃ¤hrend JavaScript eine weitere Programmiersprache ist, liegt unser Schwerpunkt bei JSON auf seiner Struktur. JSON ist nÃ¼tzlich, weil es von einem Computer leicht lesbar ist, und aus diesem Grund ist es zur primÃ¤ren Art und Weise geworden, wie Daten Ã¼ber APIs transportiert werden. Die meisten APIs senden ihre Antworten im JSON-Format.JSON ist als eine Reihe von SchlÃ¼ssel-Werte-Paaren formatiert, wobei ein bestimmtes Wort (â€œSchlÃ¼sselâ€) mit einem bestimmten Wert assoziiert ist. Ein Beispiel fÃ¼r diese SchlÃ¼ssel-Wert-Struktur ist unten dargestellt:ihrem aktuellen Zustand sind die Daten der Variablen jdata nicht verwendbar. Die Daten sind als Unicode-Rohdaten jdata enthalten, und mÃ¼ssen das JSON-Format konvertiert werden.Dazu mÃ¼ssen wir zunÃ¤chst den rohen Unicode Character Daten konvertieren, die dem oben gezeigten JSON-Format Ã¤hneln. Die Funktion rawToChar() fÃ¼hrt genau diese Aufgabe aus:Die resultierende Zeichenfolge sieht zwar recht unordentlich aus, aber es liegt wirklich die JSON-Struktur vor.Ausgehend von diesem Character Vektor kÃ¶nnen wir nun mit fromJSON() aus dem jsonlite alles ein Listenformat transformieren.Die fromJSON() Funktion benÃ¶tigt einen Character Vektor, der die JSON-Struktur enthÃ¤lt, die wir aus der Ausgabe von rawToChar() erhalten haben. Wenn wir also diese beiden Funktionen aneinanderreihen, erhalten wir die gewÃ¼nschten Daten einem Format, das wir R leichter bearbeiten kÃ¶nnen.Die Liste data hat drei Elemente. Uns interessiert erster Linie das Data Frame people.Also, da haben wir unsere Antwort: Zum Zeitpunkt des letzten Updates Mon Nov 15 23:03:41 2021 von R4ews befanden sich 10 Personen im Weltraum. Aber wenn du alles selbst ausprobierst, kÃ¶nnten es auch schon wieder andere Namen und eine andere Anzahl sein. Das ist einer der Vorteile von APIs - im Gegensatz zu herunterladbaren DatensÃ¤tzen werden sie im Allgemeinen Echtzeit oder nahezu Echtzeit aktualisiert, dass sie eine groÃŸartige MÃ¶glichkeit darstellen, Zugang zu sehr aktuellen Daten zu erhalten.diesem Beispiel haben wir einen sehr unkomplizierten API-Workflow durchlaufen. Die meisten APIs erfordern, dass Sie demselben allgemeinen Muster folgen, aber dabei kÃ¶nnen sie durchaus komplexer sein.unserem Beispiel war es ausreichen nur die URL anzugeben. Aber einige APIs verlangen durchaus mehr Informationen vom Benutzer. Im letzten Teil dieser EinfÃ¼hrung gehen wir darauf ein, wie du der API mit deiner Anfrage zusÃ¤tzliche Informationen zur VerfÃ¼gung stellen kannst.","code":"{\n    â€œnameâ€: â€œJane Doeâ€,\n    â€œnumber_of_skillsâ€: 2\n}\nrawToChar(jdata$content)\n## [1] \"{\\\"message\\\": \\\"success\\\", \\\"people\\\": [{\\\"name\\\": \\\"Mark Vande Hei\\\", \\\"craft\\\": \\\"ISS\\\"}, {\\\"name\\\": \\\"Pyotr Dubrov\\\", \\\"craft\\\": \\\"ISS\\\"}, {\\\"name\\\": \\\"Anton Shkaplerov\\\", \\\"craft\\\": \\\"ISS\\\"}, {\\\"name\\\": \\\"Zhai Zhigang\\\", \\\"craft\\\": \\\"Shenzhou 13\\\"}, {\\\"name\\\": \\\"Wang Yaping\\\", \\\"craft\\\": \\\"Shenzhou 13\\\"}, {\\\"name\\\": \\\"Ye Guangfu\\\", \\\"craft\\\": \\\"Shenzhou 13\\\"}, {\\\"name\\\": \\\"Raja Chari\\\", \\\"craft\\\": \\\"ISS\\\"}, {\\\"name\\\": \\\"Tom Marshburn\\\", \\\"craft\\\": \\\"ISS\\\"}, {\\\"name\\\": \\\"Kayla Barron\\\", \\\"craft\\\": \\\"ISS\\\"}, {\\\"name\\\": \\\"Matthias Maurer\\\", \\\"craft\\\": \\\"ISS\\\"}], \\\"number\\\": 10}\"\ndata <-  fromJSON(rawToChar(jdata$content))\nglimpse(data)\n## List of 3\n##  $ message: chr \"success\"\n##  $ people :'data.frame': 10 obs. of  2 variables:\n##   ..$ name : chr [1:10] \"Mark Vande Hei\" \"Pyotr Dubrov\" \"Anton Shkaplerov\" \"Z\"..\n##   ..$ craft: chr [1:10] \"ISS\" \"ISS\" \"ISS\" \"Shenzhou 13\" ...\n##  $ number : int 10\ndata$people\n##                name       craft\n## 1    Mark Vande Hei         ISS\n## 2      Pyotr Dubrov         ISS\n## 3  Anton Shkaplerov         ISS\n## 4      Zhai Zhigang Shenzhou 13\n## 5       Wang Yaping Shenzhou 13\n## 6        Ye Guangfu Shenzhou 13\n## 7        Raja Chari         ISS\n## 8     Tom Marshburn         ISS\n## 9      Kayla Barron         ISS\n## 10  Matthias Maurer         ISS"},{"path":"import-export.html","id":"apis-und-abfrageparameter","chapter":"Kapitel 8 Daten I/O","heading":"8.6.6 APIs und Abfrageparameter","text":"wÃ¤re, wenn wir wissen wollten, wann die ISS einen bestimmten Ort auf der Erde Ã¼berfliegen wÃ¼rde? Die ISS Pass Times API von Open Notify verlangt von uns, dass wir zusÃ¤tzliche Parameter angeben, bevor sie die gewÃ¼nschten Daten zurÃ¼ckgeben kann.Wir mÃ¼ssen den LÃ¤ngen- und Breitengrad des Ortes angeben, nach dem wir im Rahmen unserer GET() Anfrage fragen. Sobald ein LÃ¤ngen- und Breitengrad angegeben ist, werden sie als Abfrageparameter mit der ursprÃ¼nglichen URL kombiniert.Lass uns die API verwenden, um herauszufinden, wann die ISS Garching (auf 48.24896 Breiten- und 11.65101 LÃ¤ngengrad) passieren wird:Man muss der Dokumentation fÃ¼r die API, mit man arbeiten , nachsehen, ob es erforderliche Abfrageparameter gibt. FÃ¼r die Ã¼berwiegende Mehrheit der APIs, auf die du mÃ¶glicherweise zugreifen mÃ¶chtest, gibt es eine Dokumentation, die du lesen kannst (und lesen solltest), um ein klares VerstÃ¤ndnis dafÃ¼r zu erhalten, welche Parameter deine Anfrage erfordert.Wie auch immer, jetzt, da wir unsere Anfrage einschlieÃŸlich der Standortparameter gestellt haben, kÃ¶nnen wir die Antwort mit den gleichen Funktionen Ã¼berprÃ¼fen, die wir zuvor verwendet haben. Lass uns die Daten aus der Antwort extrahieren:Diese API gibt uns Zeiten Form von Unixzeit zurÃ¼ck. Unixzeit ist die Zeitspanne, die seit dem 1. Januar 1970 vergangen ist. Mithilfe der Funktion as_datetime() aus dem lubridate Paket kÃ¶nnen wir die Unixzeit aber leicht umrechnenWir haben hier wirklich nur die Basics Bezug auf APIs eingefÃ¼hrt. Aber hoffentlich hat dir diese EinfÃ¼hrung trotzdem das Vertrauen gegeben, sich mit einigen komplexeren und leistungsfÃ¤higeren APIs auseinanderzusetzen, und trÃ¤gt dadurch dazu bei, eine ganz neue Welt von Daten zu erschlieÃŸen, die du erforschen kannst!","code":"\njdata <-  GET(\"http://api.open-notify.org/iss-pass.json\",\n    query = list(lat = 48.24896, lon = 11.65101))\ndata <- fromJSON(rawToChar(jdata$content))\ndata$response\n##   duration   risetime\n## 1      652 1637014341\n## 2      658 1637020165\n## 3      620 1637025981\n## 4      321 1637031883\n## 5      575 1637086349\nlubridate::as_datetime(data$response$risetime)\n## [1] \"2021-11-15 22:12:21 UTC\" \"2021-11-15 23:49:25 UTC\"\n## [3] \"2021-11-16 01:26:21 UTC\" \"2021-11-16 03:04:43 UTC\"\n## [5] \"2021-11-16 18:12:29 UTC\""},{"path":"import-export.html","id":"weiteres-material","chapter":"Kapitel 8 Daten I/O","heading":"8.7 Weiteres Material","text":"Hier sein noch auf das Kapitel Data import im Buch R Data Science von Hadley Wickham und Garrett Grolemund (2016) verwiesen fÃ¼r weitere Information zum Daten Import.","code":""},{"path":"tidy.html","id":"tidy","chapter":"Kapitel 9 tidy ?","heading":"Kapitel 9 tidy ?","text":"Idealerweise liegt ein Datensatz vor, dass er gut von einem Computer gelesen werden kann. der Regel sind die DatensÃ¤tze, mit denen wir uns beschÃ¤ftigen, ja umfangreich, d.h. der Mensch den Datensatz ja gar nicht (ein-)lesen. Trotzdem sind DatensÃ¤tze oft anders angelegt (der Mensch trifft die Entscheidung Ã¼ber das Layout).Der Computer kann einen Datensatz gut verarbeiten, wenn wir den Datensatz als tidy bezeichnen kÃ¶nnen. Hauptmerkmal von einem tidy Datensatz:Jede Spalte ist eine VariableJede Zeile ist eine BeobachtungUntidy data mag z.B. der Grund dafÃ¼r sein, dass Du mit einer Abbildung kÃ¤mpfst. Daher lohnt es sich immer mal inne zu halten um zu Ã¼berlegen, ob die Daten tidy sind. Unordnung ist eine hÃ¤ufige, oft Ã¼bersehene Ursache fÃ¼r Qualen bei der Datenanalyse und -visualisierung.","code":""},{"path":"tidy.html","id":"lord-of-the-rings","chapter":"Kapitel 9 tidy ?","heading":"9.1 Lord of the Rings","text":"Von Jenny Byran (Autorin von STAT 545) habe ich folgenden Beispieldatensatz Ã¼bernommen: Data Lord Rings TrilogyWir haben eine Tabelle pro Film. jeder Tabelle haben wir die Gesamtzahl der gesprochenen WÃ¶rter, von Charakteren verschiedener Kategorien und Geschlechter.Stell dir vor, diese drei Tabellen als separate ArbeitsblÃ¤tter einer Excel-Arbeitsmappe zu finden. Oder einigen Zellen Rande eines Arbeitsblatts, das die zugrunde liegenden Rohdaten enthÃ¤lt. Oder als Tabellen auf einer Webseite oder einem Word-Dokument.Das Format der Tabellen macht es fÃ¼r einen Menschen einfach, die Anzahl der von weiblichen Elfen â€œTwo Towersâ€ gesprochenen WÃ¶rter nachzuschlagen. Aber dieses Format macht es fÃ¼r einen Computer ziemlich schwer, solche ZÃ¤hlungen herauszuziehen und, noch wichtiger ist, damit zu rechnen oder sie grafisch darzustellen.Diese Aufgabe ist dann wieder nicht einfach, da die Daten untidy sind: Die Inhalte der Spalte Female und Male enthalten nicht die Information Ã¼ber das Geschlecht. Auf der anderen Seite sind Wert der Variable (noch nicht vorhanden) Words auf zwei Spalten verteilt.","code":""},{"path":"tidy.html","id":"tidy-lord-of-the-rings-data","chapter":"Kapitel 9 tidy ?","heading":"9.2 Tidy Lord of the Rings data","text":"sauberer Form sehen die Daten folgendermaÃŸen aus:Beachte, dass tidy data im Allgemeinen hÃ¶her und schmaler sind. Bestimmte Elemente werden oft wiederholt, z. B. Hobbit. Aus diesen GrÃ¼nden lehnen wir tidy Daten oft instinktiv als ineffizient oder hÃ¤sslich ab. Aber, solange du nicht das Endprodukt fÃ¼r eine textuelle PrÃ¤sentation von Daten erstellst, solltest du diesen Instinkt ignorieren.","code":""},{"path":"tidy.html","id":"vorteile-von-tidy-data","chapter":"Kapitel 9 tidy ?","heading":"9.3 Vorteile von tidy data","text":"Wenn die Daten ordentlicher Form vorliegen, ist es naheliegend, einen Computer zu holen, um weitere Zusammenfassungen zu machen oder eine Abbildung zu erstellen.dieser Form kÃ¶nnen wir nun leicht folgende Fragen beantworten:Wie viele WÃ¶rter haben die mÃ¤nnlichen Hobbits insgesamt gesprochen?Wie viele WÃ¶rter haben die mÃ¤nnlichen Hobbits insgesamt gesprochen?Dominiert eine bestimmte Race einen Film? Unterscheidet sich die dominierende Race den Filmen?Dominiert eine bestimmte Race einen Film? Unterscheidet sich die dominierende Race den Filmen?","code":""},{"path":"tidy.html","id":"wie-viele-wÃ¶rter-haben-die-mÃ¤nnlichen-hobbits-insgesamt-gesprochen","chapter":"Kapitel 9 tidy ?","heading":"9.3.0.1 Wie viele WÃ¶rter haben die mÃ¤nnlichen Hobbits insgesamt gesprochen?","text":"Nun braucht es nur noch ein kleines bisschen Code, um die Gesamtwortzahl fÃ¼r beide Geschlechter aller Kategorien Ã¼ber alle Filme hinweg zu berechnen. Die Gesamtzahl der von mÃ¤nnlichen Hobbits gesprochenen WÃ¶rter ist 8780. Hier war es wichtig, alle WortzÃ¤hlungen einer einzigen Variable zu haben, innerhalb eines Data Frames, der auch eine Variable fÃ¼r Geschlecht und Kategorie enthielt.","code":"\nlibrary(tidyverse)\nlotr_tidy %>% \n  count(Gender, Race, wt = Words)## # A tibble: 6 x 3\n##   Gender Race       n\n##   <chr>  <chr>  <dbl>\n## 1 Female Elf     1743\n## 2 Female Hobbit    16\n## 3 Female Man      669\n## 4 Male   Elf     1994\n## 5 Male   Hobbit  8780\n## 6 Male   Man     8043"},{"path":"tidy.html","id":"dominiert-eine-bestimmte-kategorie-einen-film-unterscheidet-sich-die-dominierende-kategorie-in-den-filmen","chapter":"Kapitel 9 tidy ?","heading":"9.3.0.2 Dominiert eine bestimmte Kategorie einen Film? Unterscheidet sich die dominierende Kategorie in den Filmen?","text":"ZunÃ¤chst summieren wir Ã¼ber die Geschlechter hinweg, um die Wortzahlen fÃ¼r die verschiedenen Kategorien nach Film zu erhalten.Wir kÃ¶nnen ganz genau auf diese Zahlen starren, um die Frage zu beantworten. Aber noch schÃ¶ner ist es, die gerade berechneten Wortzahlen einem Balkendiagramm darzustellen.Hobbits sind â€œFellowhip Ringâ€ stark vertreten, wÃ¤hrend die Menschen â€œTwo Towersâ€ viel mehr Leinwandzeit hatten. Ebenso prominent waren sie im letzten Film, â€œReturn Kingâ€.Auch hier war es wichtig, alle Daten einem einzigen Data Frame zu haben, alle WortzÃ¤hlungen einer einzigen Variable und zugehÃ¶rige Variablen fÃ¼r Film und Kategorie.Im nÃ¤chsten Schritt schauen wir uns nun , wie man aus den obigen drei Tabellen eine sauberen Datensatz erzeugt.","code":"\n(by_race_film <- lotr_tidy %>% \n   group_by(Film, Race) %>% \n   summarize(Words = sum(Words)))## `summarise()` has grouped output by 'Film'. You can override using the `.groups` argument.## # A tibble: 9 x 3\n## # Groups:   Film [3]\n##   Film                       Race   Words\n##   <chr>                      <chr>  <dbl>\n## 1 The Fellowship Of The Ring Elf     2200\n## 2 The Fellowship Of The Ring Hobbit  3658\n## 3 The Fellowship Of The Ring Man     1995\n## 4 The Return Of The King     Elf      693\n## 5 The Return Of The King     Hobbit  2675\n## 6 The Return Of The King     Man     2727\n## 7 The Two Towers             Elf      844\n## 8 The Two Towers             Hobbit  2463\n## 9 The Two Towers             Man     3990\nggplot(by_race_film, aes(x = Film, y = Words, fill = Race)) + \n  geom_bar(stat = \"identity\", position = \"dodge\") +\n  coord_flip() + guides(fill = guide_legend(reverse = TRUE)) + \n  scale_fill_brewer(palette = \"Set1\")"},{"path":"tidy.html","id":"untidy-lord-of-the-rings-data","chapter":"Kapitel 9 tidy ?","heading":"9.4 Untidy Lord of the Rings data","text":"Wir importieren nun die Daten, die den drei filmspezifischen WortzÃ¤hlungstabellen dargestellt wurden.FÃ¼r jede Tabelle existiert eine eigene csv Datei:The_Fellowship_Of_The_Ring.csvThe_Two_Towers.csvThe_Return_Of_The_King.csv","code":"\nfship <- read_csv(file.path(\"data\", \"The_Fellowship_Of_The_Ring.csv\"))## Rows: 3 Columns: 4## â”€â”€ Column specification â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n## Delimiter: \",\"\n## chr (2): Film, Race\n## dbl (2): Female, Male## \n## â„¹ Use `spec()` to retrieve the full column specification for this data.\n## â„¹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\nttow <- read_csv(file.path(\"data\", \"The_Two_Towers.csv\"))## Rows: 3 Columns: 4## â”€â”€ Column specification â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n## Delimiter: \",\"\n## chr (2): Film, Race\n## dbl (2): Female, Male## \n## â„¹ Use `spec()` to retrieve the full column specification for this data.\n## â„¹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\nrking <- read_csv(file.path(\"data\", \"The_Return_Of_The_King.csv\")) ## Rows: 3 Columns: 4## â”€â”€ Column specification â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n## Delimiter: \",\"\n## chr (2): Film, Race\n## dbl (2): Female, Male## \n## â„¹ Use `spec()` to retrieve the full column specification for this data.\n## â„¹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\nrking## # A tibble: 3 x 4\n##   Film                   Race   Female  Male\n##   <chr>                  <chr>   <dbl> <dbl>\n## 1 The Return Of The King Elf       183   510\n## 2 The Return Of The King Hobbit      2  2673\n## 3 The Return Of The King Man       268  2459"},{"path":"tidy.html","id":"und-nun-alles-zusammen","chapter":"Kapitel 9 tidy ?","heading":"9.5 Und nun alles zusammen","text":"Wir haben jetzt ein Data Frame pro Film, jeweils mit den vier VariablenDer erste Schritt beim AufrÃ¤umen dieser Daten besteht darin, sie zu einem Data Frame zusammenzufÃ¼gen, indem wir die drei Data Frames zeilenweise stapeln. Dazu kÃ¶nnen wir die Funktion dplyr::bind_rows() verwenden.Das Zusammensetzen eines groÃŸen Datenobjekts aus vielen kleinen ist eine relativ Ã¼bliche Aufgabe bei der Datenaufbereitung. Wenn die Teile Ã¤hnlich sind wie hier, ist es schÃ¶n, sie gleich zu einem Objekt zusammenzusetzen. anderen Szenarien mÃ¼sst du mÃ¶glicherweise einige Nacharbeiten den einzelnen Objekten vornehmen, bevor sie gut zusammengefÃ¼gt werden kÃ¶nnen.Wenn mÃ¶glich, sollte man die einzelnen StÃ¼cke frÃ¼h wie mÃ¶glich\nzusammensetzen, denn es ist einfacher und effizienter, ein einzelnes Objekt aufzurÃ¤umen als 20 oder 1000.","code":"\nnames(rking)## [1] \"Film\"   \"Race\"   \"Female\" \"Male\"\nlotr_untidy <- bind_rows(fship, ttow, rking)\nlotr_untidy## # A tibble: 9 x 4\n##   Film                       Race   Female  Male\n##   <chr>                      <chr>   <dbl> <dbl>\n## 1 The Fellowship Of The Ring Elf      1229   971\n## 2 The Fellowship Of The Ring Hobbit     14  3644\n## 3 The Fellowship Of The Ring Man         0  1995\n## 4 The Two Towers             Elf       331   513\n## 5 The Two Towers             Hobbit      0  2463\n## 6 The Two Towers             Man       401  3589\n## 7 The Return Of The King     Elf       183   510\n## 8 The Return Of The King     Hobbit      2  2673\n## 9 The Return Of The King     Man       268  2459"},{"path":"tidy.html","id":"nun-kÃ¶nnen-wir-aufrÃ¤umen","chapter":"Kapitel 9 tidy ?","heading":"9.6 Nun kÃ¶nnen wir aufrÃ¤umen","text":"Wir verletzen immer noch eines der Grundprinzipien von tidy data. Die Anzahl gesprochenen WÃ¶rtern ist eine grundlegende Variable unserem Datensatz und sie ist derzeit auf zwei Variablen verteilt, Female und Male. Konzeptionell mÃ¼ssen wir die Wortanzahl einer einzigen Variable zusammenfassen und eine neue Variable Gender erstellen, um zu verfolgen, ob die jeweilige Anzahl Worten von Frauen oder MÃ¤nnern gesprochen wurde. Dies Aufgabe kÃ¶nnen wir mit der Funktion tidyr::pivot_longer() bearbeiten.Um unseren obigen Aufruf von pivot_longer() zu erklÃ¤ren, lesen wir ihn links nach rechts: Nach der Auswahl des Datensatzes lotr_untidy haben wird die Spalten Female und Male genommen und ihre Werte eine einzige neue Variable Words zusammengefasst. Dies erzwang die Erstellung einer neuen Variable Gender, die angibt, ob ein bestimmter Wert von Words von Female oder Male stammt. Alle anderen Variablen, wie Film, bleiben unverÃ¤ndert und werden einfach nach Bedarf repliziert. Die Dokumentation fÃ¼r pivot_longer() gibt weitere Beispiele und dokumentiert zusÃ¤tzliche Argumente.Wenn man sich diese Arbeit gemacht hat, dann macht es schon Sinn sich auch das Ergebnis abzuspeichernTrotzdem solltet ihr auch bei/nach der Datenaufbereitung auch die Skripte zur Datenaufbereitung wie auch die Originaldaten abspeichern.","code":"\nlotr_tidy <-\n  pivot_longer(lotr_untidy, cols = c(\"Female\", \"Male\"), names_to = 'Gender', \n               values_to = 'Words')\nlotr_tidy## # A tibble: 18 x 4\n##    Film                       Race   Gender Words\n##    <chr>                      <chr>  <chr>  <dbl>\n##  1 The Fellowship Of The Ring Elf    Female  1229\n##  2 The Fellowship Of The Ring Elf    Male     971\n##  3 The Fellowship Of The Ring Hobbit Female    14\n##  4 The Fellowship Of The Ring Hobbit Male    3644\n##  5 The Fellowship Of The Ring Man    Female     0\n##  6 The Fellowship Of The Ring Man    Male    1995\n##  7 The Two Towers             Elf    Female   331\n##  8 The Two Towers             Elf    Male     513\n##  9 The Two Towers             Hobbit Female     0\n## 10 The Two Towers             Hobbit Male    2463\n## 11 The Two Towers             Man    Female   401\n## 12 The Two Towers             Man    Male    3589\n## 13 The Return Of The King     Elf    Female   183\n## 14 The Return Of The King     Elf    Male     510\n## 15 The Return Of The King     Hobbit Female     2\n## 16 The Return Of The King     Hobbit Male    2673\n## 17 The Return Of The King     Man    Female   268\n## 18 The Return Of The King     Man    Male    2459\nwrite_csv(lotr_tidy, path = file.path(\"data\", \"lotr_tidy.csv\"))## Warning: The `path` argument of `write_csv()` is deprecated as of readr 1.4.0.\n## Please use the `file` argument instead."},{"path":"tidy.html","id":"und-jetzt-noch-ein-bisschen-schmutzig-machen","chapter":"Kapitel 9 tidy ?","heading":"9.7 Und jetzt noch ein bisschen â€œschmutzigâ€ machen","text":"Manchmal (aber nicht hÃ¤ufig) ist es doch nÃ¶tig die Daten im Wide Format zu haben. Daher wollen wir zum Schluss die gerade gesÃ¤uberten LOTR Daten nochmal ein bisschen untidy machen.Dazu arbeiten wir mit den Funktion tidyr::pivot_wider(). Wir nehmen nun die AusprÃ¤gungen der Variable Race (anschlieÃŸend dann Gender) als Variablennamen der neu zu bildenden Variablen. Die Werte dieser neuen Variablen sind durch die Variable Words festgelegt.Das erste Beispiel hat immer noch 6 Beobachtungen, zwei pro Film. Nehmen wir mal , dass wir aber nur eine Beobachtung pro Film haben wollen. Dazu mÃ¼ssten wir die mÃ¶glichen Kombinationen aus Race und Gender neuen/weiteren Variablen zusammenfassen. Dies kÃ¶nnen wir Ã¼ber die Funktion tidyr::unite() erreichen.Kombination mit pivot_wider() ergibt sich soZum Schluss kÃ¶nnten wir jetzt auch noch alles zurÃ¼ck auf Anfang stellen und die\ndrei DatensÃ¤tze vom Anfang wiederherstellenWir erhalten eine Liste mit drei Elemente, die deren Inhalt den drei Tabellen vom Anfang entspricht. Die Daten zu â€œReturn Kingâ€ sind beispielsweise im zweiten Element enthalten.","code":"\n## Race\nlotr_tidy %>% \n  pivot_wider(names_from = Race, values_from = Words)## # A tibble: 6 x 5\n##   Film                       Gender   Elf Hobbit   Man\n##   <chr>                      <chr>  <dbl>  <dbl> <dbl>\n## 1 The Fellowship Of The Ring Female  1229     14     0\n## 2 The Fellowship Of The Ring Male     971   3644  1995\n## 3 The Two Towers             Female   331      0   401\n## 4 The Two Towers             Male     513   2463  3589\n## 5 The Return Of The King     Female   183      2   268\n## 6 The Return Of The King     Male     510   2673  2459\n## Gender\nlotr_tidy %>% \n  pivot_wider(names_from = Gender, values_from = Words)## # A tibble: 9 x 4\n##   Film                       Race   Female  Male\n##   <chr>                      <chr>   <dbl> <dbl>\n## 1 The Fellowship Of The Ring Elf      1229   971\n## 2 The Fellowship Of The Ring Hobbit     14  3644\n## 3 The Fellowship Of The Ring Man         0  1995\n## 4 The Two Towers             Elf       331   513\n## 5 The Two Towers             Hobbit      0  2463\n## 6 The Two Towers             Man       401  3589\n## 7 The Return Of The King     Elf       183   510\n## 8 The Return Of The King     Hobbit      2  2673\n## 9 The Return Of The King     Man       268  2459\nlotr_tidy %>% \n  unite(Race_Gender, Race, Gender)## # A tibble: 18 x 3\n##    Film                       Race_Gender   Words\n##    <chr>                      <chr>         <dbl>\n##  1 The Fellowship Of The Ring Elf_Female     1229\n##  2 The Fellowship Of The Ring Elf_Male        971\n##  3 The Fellowship Of The Ring Hobbit_Female    14\n##  4 The Fellowship Of The Ring Hobbit_Male    3644\n##  5 The Fellowship Of The Ring Man_Female        0\n##  6 The Fellowship Of The Ring Man_Male       1995\n##  7 The Two Towers             Elf_Female      331\n##  8 The Two Towers             Elf_Male        513\n##  9 The Two Towers             Hobbit_Female     0\n## 10 The Two Towers             Hobbit_Male    2463\n## 11 The Two Towers             Man_Female      401\n## 12 The Two Towers             Man_Male       3589\n## 13 The Return Of The King     Elf_Female      183\n## 14 The Return Of The King     Elf_Male        510\n## 15 The Return Of The King     Hobbit_Female     2\n## 16 The Return Of The King     Hobbit_Male    2673\n## 17 The Return Of The King     Man_Female      268\n## 18 The Return Of The King     Man_Male       2459\nlotr_tidy %>% \n  unite(Race_Gender, Race, Gender) %>% \n  pivot_wider(names_from = Race_Gender, values_from = Words)## # A tibble: 3 x 7\n##   Film         Elf_Female Elf_Male Hobbit_Female Hobbit_Male Man_Female Man_Male\n##   <chr>             <dbl>    <dbl>         <dbl>       <dbl>      <dbl>    <dbl>\n## 1 The Fellowsâ€¦       1229      971            14        3644          0     1995\n## 2 The Two Towâ€¦        331      513             0        2463        401     3589\n## 3 The Return â€¦        183      510             2        2673        268     2459\n(sep_list <- lotr_tidy %>% \n  pivot_wider(names_from = Gender, values_from = Words) %>%\n   group_split(Film))## <list_of<\n##   tbl_df<\n##     Film  : character\n##     Race  : character\n##     Female: double\n##     Male  : double\n##   >\n## >[3]>\n## [[1]]\n## # A tibble: 3 x 4\n##   Film                       Race   Female  Male\n##   <chr>                      <chr>   <dbl> <dbl>\n## 1 The Fellowship Of The Ring Elf      1229   971\n## 2 The Fellowship Of The Ring Hobbit     14  3644\n## 3 The Fellowship Of The Ring Man         0  1995\n## \n## [[2]]\n## # A tibble: 3 x 4\n##   Film                   Race   Female  Male\n##   <chr>                  <chr>   <dbl> <dbl>\n## 1 The Return Of The King Elf       183   510\n## 2 The Return Of The King Hobbit      2  2673\n## 3 The Return Of The King Man       268  2459\n## \n## [[3]]\n## # A tibble: 3 x 4\n##   Film           Race   Female  Male\n##   <chr>          <chr>   <dbl> <dbl>\n## 1 The Two Towers Elf       331   513\n## 2 The Two Towers Hobbit      0  2463\n## 3 The Two Towers Man       401  3589\nsep_list[[2]]## # A tibble: 3 x 4\n##   Film                   Race   Female  Male\n##   <chr>                  <chr>   <dbl> <dbl>\n## 1 The Return Of The King Elf       183   510\n## 2 The Return Of The King Hobbit      2  2673\n## 3 The Return Of The King Man       268  2459"},{"path":"tidy.html","id":"literatur-1","chapter":"Kapitel 9 tidy ?","heading":"9.8 Literatur","text":"Tidy data Kapitel R Data Science, Garrett Grolemund Hadley Wickham\ntidyr Paket\ntidyr PaketBad Data Handbook Q. Ethan McCallum, published Oâ€™Reilly.\nChapter 3: Data Intended Human Consumption, Machine Consumption Paul Murrell.\nChapter 3: Data Intended Human Consumption, Machine Consumption Paul Murrell.Tidy data Hadley Wickham. Journal Statistical Software. Vol. 59, Issue 10, Sep 2014. http://www.jstatsoft.org/v59/i10","code":""},{"path":"graphics-overview.html","id":"graphics-overview","chapter":"Kapitel 10 EinfÃ¼hrung","heading":"Kapitel 10 EinfÃ¼hrung","text":"Das Paket ggplot2 verwendet eine Grammatik beim Erzeugen von Grafiken. Diese basiert aufWilkinson (2005): Grammar Graphics, Springer.Dadurchist eine starke Abstraktion bei der Definition einer Grafik mÃ¶glichsteht ein sehr flexibles Grafiksystem zur VerfÃ¼gung.","code":""},{"path":"graphics-overview.html","id":"ggplot2-laden","chapter":"Kapitel 10 EinfÃ¼hrung","heading":"10.1 ggplot2 laden","text":"Wie zuvor auch, laden wir stets das komplette tidyverse. Man weiÃŸ ja vorher nie genau man alles braucht.","code":"\nlibrary(tidyverse)\n## â”€â”€ Attaching packages â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ tidyverse 1.3.1 â”€â”€\n## âœ“ ggplot2 3.3.5     âœ“ purrr   0.3.4\n## âœ“ tibble  3.1.2     âœ“ dplyr   1.0.7\n## âœ“ tidyr   1.1.3     âœ“ stringr 1.4.0\n## âœ“ readr   2.0.1     âœ“ forcats 0.5.1\n## â”€â”€ Conflicts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ tidyverse_conflicts() â”€â”€\n## x dplyr::filter() masks stats::filter()\n## x dplyr::lag()    masks stats::lag()"},{"path":"graphics-overview.html","id":"idee","chapter":"Kapitel 10 EinfÃ¼hrung","heading":"10.2 Idee","text":"Die grundlegende Idee des ggplot2 Ansatzes zum Erstellen von Grafiken, besteht darin die Bausteine eines Plots unabhÃ¤ngig voneinander zu definieren. Ein Plot besteht immer aus:Daten (als data.frame oder tibble)KoordinatensystemSkalageometrisches Objekt zur Darstellung (geom)ZusÃ¤tzlich kann er aber auch nochstatistische Transformationen (stat)verschiedene Facettenâ€¦enthalten.Die einzelnen Teile eines Plots werden dann mit dem + Operator zusammengefÃ¼gt.Initialisiert wird ein Plot mit ggplot(). Ohne weitere Bestandteile wird aber nur eine leere Grafik erzeugtIn den folgenden Abschnitten lernen wir daher wie weitere Bestandteile zum Plot hinzugefÃ¼gt werden.","code":"\nlibrary(gapminder)\nggplot(gapminder) "},{"path":"graphics-overview.html","id":"ein-einfacher-scatterplot","chapter":"Kapitel 10 EinfÃ¼hrung","heading":"10.3 Ein einfacher Scatterplot","text":"Wir schauen uns zum Start einfach mal fÃ¼r Deutschland den Verlauf des gdpPercap Ã¼ber die Zeit .diesem einfachen Beispiel haben wir bereits gesehen, dass ggplot() Ã¼ber den Pipe-Operator verknÃ¼pft werden kann.","code":"\ngapminder %>%\n  filter(country == \"Germany\") %>% # auswÃ¤hlen der Daten \n  ggplot(aes(x = year, y = gdpPercap)) +  # plot initialisieren\n  geom_point() # punkte zum Darstellen der Daten verwenden"},{"path":"bausteine.html","id":"bausteine","chapter":"Kapitel 11 Bausteine","heading":"Kapitel 11 Bausteine","text":"","code":""},{"path":"bausteine.html","id":"aes","chapter":"Kapitel 11 Bausteine","heading":"11.1 Aesthetics","text":"Mit der Funktion aes() lÃ¤sst sich das Aussehen der Grafik regeln (nicht der Inhalt). Wir kÃ¶nnen z.B.die Position: x und ydie Farbe: color und filldie Form: shapeden Linientyp: linetypedie GrÃ¶ÃŸe der Symbol: sizefestlegen. Nicht jedes aesthetic kann allerdings mit allen verfÃ¼gbaren geoms kombiniert werden. macht z.B. der linetype ja wenig Sinn geom_point(). Ein Ãœbersicht der mÃ¶glichen aesthetics findet man der Hilfe jeder geom-FunktionIn der aes() Funktion sollten die Daten den Wert der Argumente bestimmen. Werden Argumente auf fixe Werte gesetzt, sind sie auÃŸerhalb der aes() Funktion zu setzen.einem Plot der gdpPercap Daten fÃ¼r Deutschland und Frankreich wollen wir anhand von unterschiedlichen Farben die Daten der beiden LÃ¤nder unterscheiden. Dazu mÃ¼ssen wir nur colour innerhalb von aes() den Wert country zuweisen.","code":"geom_point {ggplot2}    R Documentation\nPoints\nDescription\nThe point geom is used to create scatterplots. The scatterplot is most useful for displaying the relationship between two continuous variables. It can be used to compare one continuous and one categorical variable, or two categorical variables, but a variation like geom_jitter(), geom_count(), or geom_bin2d() is usually more appropriate. A bubblechart is a scatterplot with a third variable mapped to the size of points.\n\nUsage\ngeom_point(\n  mapping = NULL,\n  data = NULL,\n  stat = \"identity\",\n  position = \"identity\",\n  ...,\n  na.rm = FALSE,\n  show.legend = NA,\n  inherit.aes = TRUE\n)\n\n...\n\nAesthetics\ngeom_point() understands the following aesthetics (required aesthetics are in bold):\n\nx\n\ny\n\nalpha\n\ncolour\n\nfill\n\ngroup\n\nshape\n\nsize\n\nstroke\n\nLearn more about setting these aesthetics in vignette(\"ggplot2-specs\").\n\ngapminder %>%\n  filter(country %in% c(\"Germany\",\"France\")) %>% # auswÃ¤hlen der Daten \n  ggplot(aes(x = year, y = gdpPercap, colour = country)) +  \n  geom_point(size = 3) # size wird auf einen fixen Wert gesetzt (auÃŸerhalb von aes())"},{"path":"bausteine.html","id":"geoms","chapter":"Kapitel 11 Bausteine","heading":"11.2 Geoms","text":"Mit den geom_xx() Funktionen stellen wir die Daten als geometrische Formen einer Grafik dar. Jede ggplot2 Grafik benÃ¶tigt daher mindestens ein geom. Beispiele sindgeom_point()geom_line()geom_histogram()Da wir nicht alle verfÃ¼gbaren geoms auflisten kÃ¶nnen, sei dieser Stelle auf die ggplot2 Seite verwiesen.Wir haben hier die gleichen Daten visualisiert. Allerdings ist das Ergebnis doch recht unterschiedlich. Der Scatterplot zeigt alle (abgesehen von Ã¼berzeichnen) Daten, wohingegen mit geom_smooth() eine geglÃ¤tteter Zusammenhang dargestellt wird.Interessant sind hier natÃ¼rlich die wenigen groÃŸen gdpPercap WerteKuwait hat Ã¼ber den gesamten Zeitraum hohe GDP Werte. Aber zu Beginn der Aufzeichnungen waren die Werte Bezug auf die damals noch recht kleine PopulationsgrÃ¶ÃŸe auÃŸergewÃ¶hnlich hoch.Einem ggplot Objekt kÃ¶nnen wir nicht nur ein geom zuordnen. Prinzipiell kÃ¶nnen wir beliebig viele weitere geoms hinzufÃ¼gen. Wir kÃ¶nnen also die gerade durchgefÃ¼hrte GlÃ¤ttung der Daten auch\ndirekt zum Scatterplot hinzufÃ¼genWÃ¤hlen wir die Farbe der geometrischen Objekte anhand einer Faktorvariable, erhalten wir automatisch eine entsprechende Legende\nBeachte auch, dass wir colour nur fÃ¼r geom_point() gewÃ¤hlt haben. Die GlÃ¤ttung erfolgt weiterhin Ã¼ber alle Daten und nicht separat fÃ¼r jeden Kontinent. Aber das wÃ¤re natÃ¼rlich auch mÃ¶glich. Dazu kÃ¶nnen wir colour wieder global ggplot() definieren.Die Punkte sind mir etwas zu groÃŸ und der Linientyp gefÃ¤llt mir auch nicht diesem Plot. Aber das lÃ¤sst sich schnell Ã¤ndern.","code":"\ngapminder %>%\n  ggplot(aes(x = year, y = gdpPercap)) +  \n  geom_point() \n\n\ngapminder %>%\n  ggplot(aes(x = year, y = gdpPercap)) +  \n  geom_smooth() \n## `geom_smooth()` using method = 'gam' and formula 'y ~ s(x, bs = \"cs\")'\ngapminder %>%\n  filter(gdpPercap > 50000)\n## # A tibble: 6 x 6\n##   country continent  year lifeExp     pop gdpPercap\n##   <fct>   <fct>     <int>   <dbl>   <int>     <dbl>\n## 1 Kuwait  Asia       1952    55.6  160000   108382.\n## 2 Kuwait  Asia       1957    58.0  212846   113523.\n## 3 Kuwait  Asia       1962    60.5  358266    95458.\n## 4 Kuwait  Asia       1967    64.6  575003    80895.\n## 5 Kuwait  Asia       1972    67.7  841934   109348.\n## 6 Kuwait  Asia       1977    69.3 1140357    59265.\ngapminder %>%\n  ggplot(aes(x = year, y = gdpPercap)) +  \n  geom_point() +\n  geom_smooth() \n## `geom_smooth()` using method = 'gam' and formula 'y ~ s(x, bs = \"cs\")'\ngapminder %>%\n  ggplot(aes(x = year, y = gdpPercap)) +  \n  geom_point(aes(colour = continent)) +\n  geom_smooth() \n## `geom_smooth()` using method = 'gam' and formula 'y ~ s(x, bs = \"cs\")'\ngapminder %>%\n  ggplot(aes(x = year, y = gdpPercap, colour = continent)) +  \n  geom_point() +\n  geom_smooth() \n## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\ngapminder %>%\n  ggplot(aes(x = year, y = gdpPercap, colour = continent)) +  \n  geom_point(size = 0.9) +\n  geom_smooth(linetype = 2) \n## `geom_smooth()` using method = 'loess' and formula 'y ~ x'"},{"path":"bausteine.html","id":"stat-trans","chapter":"Kapitel 11 Bausteine","heading":"11.3 Statistische Transformationen","text":"Jede geom_xx() Funktion besitzt eine Default Statistik, die berechnet wird.Bei einem Scatterplot ist dies nur die IdentitÃ¤t.Ein Balkendiagramm verwendet anderseitsdie Transformation count, Sinn macht, da ja gezÃ¤hlt werden muss/soll wie viele Beobachtungen die jeweilige Kategorie fallen.Der Aufruf der stat_xx() Funktion ist oftmals einfacher Ã¼ber die entsprechende geom_xx() Funktion, aber natÃ¼rlich kann die stat_xx() Funktion auch direkt aufgerufen werden.Jedes geom hat zwar ein Default-Transformation, aber natÃ¼rlich kÃ¶nnen oftmals noch weitere Transformationen berechnet/genutzt werden. Im Abschnitt Computed variables der Hilfe zu einem geom sieht man alle verfÃ¼gbaren TransformationenFÃ¼r geom_bar() sind diesDie relativen HÃ¤ufigkeiten berechnet man also Ã¼ber prop. Dazu muss die y-Variable auf prop gesetzt werden. Da der Aufrufaber nach einer Variable prop suchen wÃ¼rde, muss eine alternative Notation diesem Fall verwendet werdenDas sieht jetzt noch nicht wie wir das erwartet haben. Die\nrelativen HÃ¤ufigkeiten wurden innerhalb der fÃ¼nf Gruppen berechnet und nicht Ã¼ber alle Beobachtungen. D.h. wir mÃ¼ssen der Funktion noch sagen, dass es nur eine Gruppe geben soll.","code":"\nargs(geom_point)\n## function (mapping = NULL, data = NULL, stat = \"identity\", position = \"identity\", \n##     ..., na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) \n## NULL\nargs(geom_bar)\n## function (mapping = NULL, data = NULL, stat = \"count\", position = \"stack\", \n##     ..., width = NULL, na.rm = FALSE, orientation = NA, show.legend = NA, \n##     inherit.aes = TRUE) \n## NULL\nggplot(gapminder, aes(x = continent)) + \n  geom_bar()\n\nggplot(gapminder, aes(x = continent)) + \n  stat_count()Computed variables\n\ncount\nnumber of points in bin\n\nprop\ngroupwise proportion\n\n\nggplot(gapminder, aes(x = continent, y = prop))\nggplot(gapminder, aes(x = continent, y = ..prop..)) + \n  geom_bar()\nggplot(gapminder, aes(x = continent, y = ..prop..)) + \n  geom_bar(aes(group = 1))"},{"path":"bausteine.html","id":"scales","chapter":"Kapitel 11 Bausteine","heading":"11.4 scales","text":"Scales steuern die Zuordnung von Daten zu aesthetics. Sie nehmen deine Daten und bestimmen damit GrÃ¶ÃŸe, Farbe, Position oder Form von Objekten. Sie erlauben dir auch die Achsen und die Legend nach deinen Vorstellungen anzupassen. Du kannst sicher mit ggplot2 Grafiken erstellen, ohne zu wissen, wie scales funktionieren, aber wenn du scales verstehst und lernst, wie du sie einstellen kannst, wirst du viel mehr Kontrolle Ã¼ber deine Grafiken bekommen.Neben weiteren MÃ¶glichkeiten kÃ¶nnen wir Ã¼ber scales alsocolor und fillpositionsizeshapeline typedurch Verwendung der scale_\"aesthetic\"_\"type\" Funktionen modifizieren. Argumente dieser Funktionen sind z.B. name, limits, breaks oder labels.Zuerst spielen wir etwas mit Farben. Dazu plotten wir erneut year gegen gdpPercap und wÃ¤hlen fÃ¼r jeden Kontinent eine eigene Farbe. Da wir die Farben Ã¼ber colour definieren, verwenden wir danach die Funktionen scale_colour_xxx() (im Vergleich zu z.B. scale_fill_brewer()).diesem Beispiel haben wir also die Farbe Ã¼ber eine vorgegebene Palette, Grau-Stufen bzw. manuell gewÃ¤hlt. Im letzten Beispiel haben wir zusÃ¤tzlich noch den Titel der Legende geÃ¤ndert Ã¼ber das name Argument.Die Achsenbeschriftung der y-Achse ist nicht wirklich schÃ¶n, weil nicht unbedingt selbsterklÃ¤rend. Daher Ã¤ndern wir im nÃ¤chsten Schritt die Achsenbeschriftung.Da es sich bei gdpPercap um eine stetige Variable handelt, haben wir scale_y_continuous() verwendet (im Gegensatz zu scale_y_discrete()) um die Achsenbeschriftung zu Ã¤ndern. Ãœber die Hilfsfunktion labs() kÃ¶nnen wir die Beschriftung der Grafik aber auch einfacher/intuitiver Ã¤ndern.Die frÃ¼hen Kuwait-Beobachtungen ziehen die y-Achse stark auseinander. Daher kÃ¶nnte man etwas den Plot hinein zoomen wollen. Dazu kann man das Koordinatensystem anpassen Ã¼bercoord_cartasian(). Alternativ kÃ¶nnte man auch mit der Funktion ylim() arbeiten (analog existiert natÃ¼rlich auch xlmin()). Verwendet man xlim() bzw. ylim(), werden alle Datenpunkte, die nicht im zu plottenden Bereich liegen, aber nicht nur nicht gezeichnet, sondern auch aus dem Datensatz (fÃ¼r diesen einen Plot) entfernt. Dies hat Auswirkungen auf Teile des Plots, die auf statistische Transformationen basieren, die mithilfe der vorhanden Daten berechnet wurden.der rechten Grafik ist der Verlauf der Kurven unverÃ¤ndert. der linken Grafik hingegen liegt die Kurve fÃ¼r Asien nun deutlich unter der Kurve fÃ¼r Amerika bis Mitte der 80er Jahre.Andere mÃ¶gliche PositionsÃ¤nderungen ergeben sich durch Skalierungen der Achsen wie scale_x_log10(), scale_y_sqrt() oderFÃ¼r weitere Optionen sei hier auf die online Version der neuesten Auflage von ggplot2 (Wickham 2009) verwiesen.","code":"\n(p <- gapminder %>%\n  ggplot(aes(x = year, y = gdpPercap, colour = continent)) +  \n  geom_point(size = 0.9) +\n  geom_smooth(linetype = 2) )\n## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\n\np + scale_colour_brewer(palette = \"Set1\") # Farbpaletten von http://colorbrewer2.org/\n## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\n\np + scale_colour_grey(start = 0.1, end = 0.9) # keine so gute Wahl\n## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\n\np + scale_colour_manual(values = c(\"blue\", \"gold\", \"sienna1\", \"sienna4\", \"hotpink1\", \"hotpink4\"), name = \"Kontinent\")\n## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\np <- p + scale_colour_manual(values = c(\"blue\", \"gold\", \"sienna1\", \"sienna4\", \"hotpink1\", \"hotpink4\"))\n\np + scale_y_continuous(\"GDP pro Kopf\")\n## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\n(p <- p + labs(x = \"Jahr\", y = \"GDP pro Kopf\",\n         title = \"Monoton steigendes GDP pro Kopf\",\n         subtitle = \"Gestrichelte Linie zeigt Durchschnittswerte Ã¼ber alle LÃ¤nder pro Kontinent\"))\n## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\np + ylim(0,55000)\n## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\n## Warning: Removed 6 rows containing non-finite values\n## (stat_smooth).\n## Warning: Removed 6 rows containing missing values\n## (geom_point).\n(p <- p + coord_cartesian(ylim = c(0, 55000)))\n## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\np + scale_x_reverse()\n## `geom_smooth()` using method = 'loess' and formula 'y ~ x'"},{"path":"bausteine.html","id":"facets","chapter":"Kapitel 11 Bausteine","heading":"11.5 facets","text":"DatensÃ¤tze lassen sich oftmals bzgl. vorhandener Variablen gruppieren. Dann man ZusammenhÃ¤nge weiterer Variablen innerhalb dieser Gruppen darstellen. Entsteht die Gruppierung aufgrund einer Variable, kannst du mit facet_wrap() arbeitenIn der letzten Grafik verwenden alle fÃ¼nf Plots die gleiche Skala auf der y-Achse um die Vergleichbarkeit der Werte zu erhÃ¶hen. manchen FÃ¤llen mag dies aber stÃ¶rend sein. Mit dem Argument scale kannst du die Skala â€œbefreienâ€.Erfolgt die Gruppierung anhand von zwei Variablen, bietet facet_grid() eine passende Aufteilung des Grafikfensters. Neben dem Kontinent betrachten wir nun auch noch ob die PopulationsgrÃ¶ÃŸe des Landes im entsprechenden Jahr grÃ¶ÃŸer als 5000000 ist, oder eben nicht.FÃ¼r Ozeanien erhalten wir z.B. eine Unterteilung Australien (TRUE) und Neuseeland (FALSE).","code":"\ngapminder %>%\n  ggplot(aes(x = year, y = gdpPercap )) +  \n  geom_point(size = 0.9) +\n  geom_smooth(linetype = 2) +\n  facet_wrap(~ continent, ncol = 2)\n## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\ngapminder %>%\n  ggplot(aes(x = year, y = gdpPercap )) +  \n  geom_point(size = 0.9) +\n  geom_smooth(linetype = 2) +\n  facet_wrap(~ continent, ncol = 2, scales = \"free\")\n## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\ngapminder %>%\n  group_by(continent) %>%\n  ggplot(aes(x = year, y = gdpPercap )) +  \n  geom_point(size = 0.9) +\n  geom_smooth(linetype = 2) +\n  facet_grid(continent ~ pop > 5000000, scales = \"free\")\n## `geom_smooth()` using method = 'loess' and formula 'y ~ x'"},{"path":"bausteine.html","id":"themes","chapter":"Kapitel 11 Bausteine","heading":"11.6 themes","text":"AbschlieÃŸend wollen wir noch Ã¼ber verschiedene themes sprechen. Ãœber themes kann man das Aussehen der nicht datenbezogenen Elemente einer Grafik verÃ¤ndern, wie z.B.die Beschriftungenden Hintergrunddie Legendeâ€¦.Eine Reihe von themes sind bereits vorhanden, wobei theme_gray() das Default theme ist. Siehe auch ?theme_gray().Wir mÃ¶chten nun gerne folgende Ã„nderungen der Grafik vornehmen:die GrÃ¶ÃŸe der Achsenbeschriftung Ã¤nderndie Gitterlinien ohne Beschriftung entferneneine Ãœberschrift hinzufÃ¼gendie Legende die Grafik verschiebendie Hintergrundfarbe der Grafik und der Legende Ã¤ndernDie meisten dieser Ã„nderungen kÃ¶nnen wir mit theme() durchfÃ¼hren.Ob das nun alles schÃ¶n aussieht, sei dahingestellt, aber es zeigt durchaus die vorhandenen MÃ¶glichkeiten.man gewisse Einstellung Ã¶fter verwenden, kann man diese auch einem theme Objekt speichern und wiederverwenden.","code":"\np\n## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\np + theme_bw()\n## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\np + theme_dark()\n## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\np + theme_minimal()\n## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\np +\n  theme(\n    axis.text = element_text(size = 14),\n    legend.key = element_rect(fill = \"navy\"),\n    legend.background = element_rect(fill = \"green\"),\n    legend.position = \"bottom\",\n    panel.grid.major = element_line(colour = \"grey40\"),\n    panel.grid.minor = element_blank(),\n    panel.background = element_rect(fill = \"navy\")\n  )\n## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\nmein_theme <- theme(\n    axis.text = element_text(size = 14),\n    legend.key = element_rect(fill = \"hotpink3\"),\n    panel.grid.major = element_line(colour = \"grey40\"),\n    panel.grid.minor = element_blank(),\n    panel.background = element_rect(fill = \"navy\")\n  )\nclass(mein_theme)\n## [1] \"theme\" \"gg\"\np + mein_theme\n## `geom_smooth()` using method = 'loess' and formula 'y ~ x'"},{"path":"bausteine.html","id":"buch-zum-paket","chapter":"Kapitel 11 Bausteine","heading":"11.7 Buch zum Paket","text":"Dieser Abschnitt konnte nur einen kleinen Einblick die MÃ¶glichkeiten des ggplot2 Pakets geben. Eine ausfÃ¼hrliche Beschreibung findet man im Buch zum Paket.","code":""},{"path":"packages.html","id":"packages","chapter":"Kapitel 12 Pakete","heading":"Kapitel 12 Pakete","text":"Bei einem Paket handelt es sich umeine strukturierte, standardisierte Einheit, welche aus R Code, Dokumentation, Daten und (mÃ¶glicherweise) externem Quellcode besteht.Wie man ein Paket installiert und lÃ¤dt, ist uns mittlerweile bekannt. Jetzt wollen wir eigene Pakete erstellen.Gute GrÃ¼nde fÃ¼r die Verwendung von Paketen:dynamisches Laden und Entladen des Pakets (Speicherplatz\nsparend)dynamisches Laden und Entladen des Pakets (Speicherplatz\nsparend)einfache Installation und Update von lokalen DatentrÃ¤gern oder Ã¼ber\ndas Web, innerhalb von R oder Ã¼ber die Kommandozeile des\nBetriebssystemseinfache Installation und Update von lokalen DatentrÃ¤gern oder Ã¼ber\ndas Web, innerhalb von R oder Ã¼ber die Kommandozeile des\nBetriebssystemsValidierung: R bietet Befehle zur groben ÃœberprÃ¼fung von Code,\nDokumentation und Installierbarkeit, sowie, falls man mÃ¶chte,\nÃœberprÃ¼fung von Berechnungsergebnissen.Validierung: R bietet Befehle zur groben ÃœberprÃ¼fung von Code,\nDokumentation und Installierbarkeit, sowie, falls man mÃ¶chte,\nÃœberprÃ¼fung von Berechnungsergebnissen.einfache Verteilung der Software Dritte; BeispieldatensÃ¤tze kÃ¶nnen auch ins Paket!einfache Verteilung der Software Dritte; BeispieldatensÃ¤tze kÃ¶nnen auch ins Paket!","code":""},{"path":"packages.html","id":"struktur","chapter":"Kapitel 12 Pakete","heading":"12.1 Struktur","text":"Ein Paket besteht aus einigen Standardâ€“Dateien und Verzeichnissen:DESCRIPTION: Informationen Ã¼ber das Paket (Autor,\nLizenz, Titel, AbhÃ¤ngigkeiten, â€¦)R/: R Code .R Dateienman/: Dokumentationen (im *.Rd Format) der einzelnen FunktionenNAMESPACE: Information Ã¼ber die zu â€œexportierendenâ€ Funktionendata/: Datenbeispielesrc/: kompilierter C, C++ oder Fortran Codetests/: Testroutinen zur Validierung des PaketsBei der Erzeugung der Struktur (wie auch weiteren Schritten bei der Entwicklung) sollte man viel wie mÃ¶glich automatisieren. Wir verwenden dazu die von Hadley Wickham bereitgestellten Werkzeuge.Falls noch nicht geschehen, sollte manausfÃ¼hren. Diese Pakete erleichtern Kombination mit RStudio das Erstellen von Paketen.","code":"\ninstall.packages(c(\"devtools\", \"roxygen2\", \"testthat\"))"},{"path":"packages.html","id":"c-compiler","chapter":"Kapitel 12 Pakete","heading":"12.2 C Compiler","text":"Um alle MÃ¶glichkeiten bei der Erstellung von R-Paketen ausnÃ¼tzen zu kÃ¶nnen, brauchst du auÃŸerdem einen Compiler und noch ein paar andere Werkzeuge. Dies ist aber vermutlich erst dann wirklich nÃ¶tig, wenn du Pakete bauen willst, die C- oder C++-Code enthalten (nicht Teil des Kurses). RStudio sollte dich auch warnen und dir UnterstÃ¼tzung anbieten, sobald du versuchen solltest, etwas zu tun, das die Einrichtung einer Entwicklungsumgebung erfordert.Mit has_devel() kannst du aber bereits auch jetzt mal Ã¼berprÃ¼fen ob dein System vielleicht schon bereit istDies scheint bei mir der Fall zu sein.","code":"\nlibrary(devtools)\nhas_devel()\n## Your system is ready to build packages!"},{"path":"packages.html","id":"r-code","chapter":"Kapitel 12 Pakete","heading":"12.3 R Code","text":"Das Verzeichnis R/ ist der wichtigste Bestandteil eines Pakets, da dort der komplette R Code liegt.\nDieses Verzeichnis (wie auch andere Teile) erzeugt man mit der Funktion devtools::create(), z.B.Dieser Befehl erzeugt das Verzeichnis Pfad_zum_Paket/Paketname, welcheseine RStudio Projektdatei, Paketname.Rprojein R/ Verzeichniseine DESCRIPTION Dateieine NAMESPACE DateienthÃ¤lt. Allen R Code, der im Paket enthalten sein soll, kopiert man anschlieÃŸend das Verzeichnis Pfad_zum_Paket/Paketname/R.Innerhalb eines Pakets ist es nun einfach den kompletten R Code (nach Ã„nderungen) neu zu laden.devtools::load_all() lÃ¤dt allen R Code neu. RStudio auch Ã¼ber Strg + Shift + L mÃ¶glich.RStudio kann man mit Strg + Shift + B das Paket installieren, R neu starten und anschlieÃŸend das Paket Ã¼ber library() neu laden.Dadurch ergibt sich der folgende ArbeitsablaufR Dateien im Editor bearbeitenStrg + Shift + L (oder Strg + Shift + B) ausfÃ¼hrenCode der Konsole Ã¼berprÃ¼fenDas Ganze (falls nÃ¶tig) wiederholen","code":"\ncreate(\"Pfad_zum_Paket/Paketname\")"},{"path":"packages.html","id":"verschiedene-typen","chapter":"Kapitel 12 Pakete","heading":"12.4 Verschiedene Typen","text":"Man unterscheidet fÃ¼nf verschiedene Typen: source, bundled, binary, installed und memory.source: Die source Version eines Pakets besteht aus dem Verzeichnis Paketnamesource: Die source Version eines Pakets besteht aus dem Verzeichnis Paketnamebundled: Komprimiert man das Verzeichnis eine .tar.gz Datei spricht man von einem â€œgebÃ¼ndeltenâ€ Paket. Dieser Typ stellt eher einen Zwischenschritt dar. Mit devtools::build() kann aber eine solche Version erzeugt werden. Weitere Unterschiede zu einer source Version sind fÃ¼r uns erst mal nicht von Interesse.bundled: Komprimiert man das Verzeichnis eine .tar.gz Datei spricht man von einem â€œgebÃ¼ndeltenâ€ Paket. Dieser Typ stellt eher einen Zwischenschritt dar. Mit devtools::build() kann aber eine solche Version erzeugt werden. Weitere Unterschiede zu einer source Version sind fÃ¼r uns erst mal nicht von Interesse.binary: Ein gebÃ¼ndeltes Paket kann von anderen R Nutzern nur installiert werden, wenn sie selbst Ã¼ber die entsprechenden â€œWerkzeugeâ€ (Rtools, â€¦) verfÃ¼gen. Binary Pakete bestehen auch nur aus einer Datei, kÃ¶nnen aber von anderen R Nutzern auch ohne weitere â€œWerkzeugeâ€ installiert werden. Allerdings sind binary Pakete plattformspezifisch. Ein Windows binary Paket kann also z.B. nicht auf einem Mac installiert werden. Erzeugt wird eine binary Version z.B. mit devtools::build(binary = TRUE).binary: Ein gebÃ¼ndeltes Paket kann von anderen R Nutzern nur installiert werden, wenn sie selbst Ã¼ber die entsprechenden â€œWerkzeugeâ€ (Rtools, â€¦) verfÃ¼gen. Binary Pakete bestehen auch nur aus einer Datei, kÃ¶nnen aber von anderen R Nutzern auch ohne weitere â€œWerkzeugeâ€ installiert werden. Allerdings sind binary Pakete plattformspezifisch. Ein Windows binary Paket kann also z.B. nicht auf einem Mac installiert werden. Erzeugt wird eine binary Version z.B. mit devtools::build(binary = TRUE).installed: Ein installiertes Paket ist ein eine R Library entpacktes binary Paket. Zu diesem Zustand kann man Ã¼ber mehrere Wege gelangen, z.B.\ninstall.packages(): CRAN binary -> installed\ninstall.packages(type = source): CRAN source -> bundled -> installed\ninstall(): source -> installed\ninstalled: Ein installiertes Paket ist ein eine R Library entpacktes binary Paket. Zu diesem Zustand kann man Ã¼ber mehrere Wege gelangen, z.B.install.packages(): CRAN binary -> installedinstall.packages(type = source): CRAN source -> bundled -> installedinstall(): source -> installedMit devtools::install_github() kÃ¶nnen source Pakete aus eine GitHub Projekt installiert werden.memory: Um mit einem Paket zu arbeiten muss es den Speicher geladen werden. Dies geschieht mit library() (installierte Pakete) oder load_all() (beim Entwickeln von Paketen).","code":""},{"path":"packages.html","id":"description","chapter":"Kapitel 12 Pakete","heading":"12.5 DESCRIPTION","text":"Die DESCRIPTION Datei enthÃ¤lt Informationen Ã¼ber das Paket und ist ein essentieller Bestandteil jedes Pakets. Der Befehlerzeugt die DESCRIPTION Dateiim Ordner meinR4EWSpckg.Die wichtigsten Felder einer DESCRIPTION Datei sind dadurch vorhanden (und mÃ¼ssen gefÃ¼llt werden). Ãœber die Punkte Imports und Suggests (nicht automatisch vorhanden) kann festgelegt werden welche anderen R Pakete zwingend notwendig bzw. hilfreich sind fÃ¼r das eigene Paket.Pakete Imports werden beim Installieren des eigenen Pakets ebenfalls installiert, falls diese noch nicht vorhanden sind. Pakete Suggests werden nicht automatisch installiert.Ãœberkann z.B. das Paket dplyr dem Punkt Imports hinzugefÃ¼gt werden. usethis::use_package(type = \"Suggests\") fÃ¼gt Suggests weitere Pakete hinzu.","code":"\nusethis::create_package(\"meinR4EWSpckg\")Package: meinR4EWSpckg\nType: Package\nTitle: What the Package Does (Title Case)\nVersion: 0.1.0\nAuthor: Who wrote it\nMaintainer: The package maintainer <yourself@somewhere.net>\nDescription: More about what it does (maybe more than one line)\n    Use four spaces when indenting paragraphs within the Description.\nLicense: What license is it under?\nEncoding: UTF-8\nLazyData: true\nusethis::use_package(\"dplyr\")"},{"path":"packages.html","id":"name-titel-beschreibung","chapter":"Kapitel 12 Pakete","heading":"12.5.1 Name, Titel, Beschreibung","text":"Der Name (Package) eines Pakets darf Buchstaben, Zahlen und . enthalten und sollte mit dem Verzeichnisname Ã¼bereinstimmen.Title und Description sollten beschreiben das Paket genau macht. Description ist dabei deutlich ausfÃ¼hrlicher und enthÃ¤lt daher .d.R. mehrere Zeilen. Nach einem Zeilenumbruch sollte 4 Leerzeichen eingerÃ¼ckt werden. Ein Beispiel wÃ¤re","code":"Title: An implementation of the Grammar of Graphics\nDescription: An implementation of the grammar of graphics in R. \n    It combines the advantages of both base and lattice graphics: \n    conditioning and shared axes are handled automatically, and \n    you can still build up a plot step by step from multiple data \n    sources. It also implements a sophisticated multidimensional \n    conditioning system and a consistent interface to map data \n    to aesthetic attributes. See the ggplot2 website for more \n    information, documentation and examples."},{"path":"packages.html","id":"autoren","chapter":"Kapitel 12 Pakete","heading":"12.5.2 Autoren","text":"Ãœber das Feld Authors@R kÃ¶nnen die Autoren des Pakets angegeben werden. dieser Stelle kann\nder DESCRIPTION Datei R Code verwendet werden um die nÃ¶tigen Informationengiven, family: Vor- und Nachnameemail: E-Mailadresserole: Rolle der Person. Wichtige Beispiele sind\ncre: Ersteller oder Maintainer\naut: hat wichtige BeitrÃ¤ge zum Paket erbracht\nctb: hat kleinere BeitrÃ¤ge zum Paket erbracht\ncre: Ersteller oder Maintaineraut: hat wichtige BeitrÃ¤ge zum Paket erbrachtctb: hat kleinere BeitrÃ¤ge zum Paket erbrachtMit der Funktion person() kÃ¶nnen diese Informationen nun angegeben werdenDer Output von person() sieht dann folgendermaÃŸen aus","code":"Authors@R: person(given = \"Stephan\", family = \"Haug\", \n                  email = \"haug@tum.de\", \n                  role = c(\"cre\", \"aut\"))\nperson(given = \"Stephan\", family = \"Haug\", \n                  email = \"haug@tum.de\", \n                  role = c(\"cre\", \"aut\"))\n## [1] \"Stephan Haug <haug@tum.de> [cre, aut]\""},{"path":"packages.html","id":"version","chapter":"Kapitel 12 Pakete","heading":"12.5.3 Version","text":"devtools::create() legt die Default-Version auf 0.1.0 fest. Generell sollte die Versionsnummer aber aus drei Teilen bestehen und die Form x.y.z haben, wobei x die Nummer fÃ¼r grÃ¶ÃŸere Updates, y die Nummer fÃ¼r kleinere Updates und z die Nummer fÃ¼r Korrekturen ist.Die aktuelle Version von ggplot2 ist z.B.FÃ¼r Pakete, die sich der Entwicklung befinden, bietet es sich noch einen vierten Teil anzufÃ¼gen und mit der Versionsnummer 0.0.0.9000 zu starten.Nach diesen Anpassung kÃ¶nnte die DESCRIPTION Datei also aussehenDer Punkt Lizenz ist fÃ¼r erstmal nachgeordnet. Wer aber mehr Ã¼ber die Wahl einer passenden Lizenz erfahren mÃ¶chte, den verweisen wir gerene auf das Kapitel Licensing R packages.","code":"\npackageVersion(\"ggplot2\")\n## [1] '3.3.5'Package: meinR4EWSpckg\nType: Package\nTitle: Paket zu R4ews, das ...\nVersion: 0.0.0.9000\nAuthors@R: person(given = \"Stephan\", family = \"Haug\", \n                  email = \"haug@tum.de\", \n                  role = c(\"cre\", \"aut\"))\nDescription: Paket, das im Rahmen des R Projekts R4ews entstanden ist.\n    Das Paket bietet ...\nLicense: What license is it under?\nEncoding: UTF-8\nLazyData: true\nImports: \n    dplyr"},{"path":"packages.html","id":"pakete-dokumentation","chapter":"Kapitel 12 Pakete","heading":"12.6 Pakete: Dokumentation","text":"Ein wichtiger Teil eines Pakets ist die ausreichende Dokumentation (wichtiger) Funktionen. Dokumentationen werden als .Rd (LaTeX Ã¤hnliches Format) Dateien im Verzeichnis man/ abgelegt. Das Paket roxygen2 bietet eine komfortable MÃ¶glichkeit aus Funktionskommentaren (einem speziellen Format) eine .Rd Datei zu erzeugen.Ablauf:roxygen Kommentare die .R Datei einfÃ¼gendevtools::document() ausfÃ¼hren um Kommentare .Rd Datei zu konvertierenDokumentation mit ? betrachtengegebenenfalls alles wiederholenroxygen Kommentare beginnen mit #'.Wir fÃ¼gen eine Datei add_2.R mit Inhaltdem Verzeichnis meinR4EWSpckg/R hinzu.Der Befehl devtools::document() (ausgefÃ¼hrt im Verzeichnis meinR4EWSpckg - source Paket) erzeugt dann die Datei meinR4EWSpckg/man/add_2.RdAlle roxygen Kommentare beginnen mit #' und sind unterteilt verschiedene Tags der Form @name_tag beschreibung. Vor dem ersten Tag kommen allerdingsTitel: erste Zeile des KommentarsBeschreibung der Funktion: zweiter Abschnitt des Kommentars (lÃ¤nger als Titel)Details zur Funktion: dritter Abschnitt des Kommentars (lÃ¤nger als die Beschreibung) - optionalIn unserem Beispiel wurde der Titel auch gleich als Beschreibung (da nicht explizit angegeben) verwendet.Die drei wichtigsten Tags zum Kommentieren einer Funktion sind: @param, @examples und @return.\nWeitere Tags sind im Abschnitt Documenting functions des Buchs R packages beschrieben.Mit den Befehlen \\emph{}, \\strong{}, \\code{} und \\pkg{} (Paketname) kann der Text formatiert werden.Ebenso kÃ¶nnen Links zu anderen Dokumentationen\\code{\\link{function}}: Funktion function im eigenen Paket\\code{\\link[devtools]{load_all}}: Funktionen aus anderen Paketen, hier devtools::load_alloder dem Netz\\url{http://rstudio.com}\\href{http://rstudio.com}{RStudio}\\email{haug@@tum.de} (@@ ist nÃ¶tig, da @ fÃ¼r die Tags reserviert ist)Weitere MÃ¶glichkeiten der Formatierung findest du im Abschnitt Text formatting des Buch R packages.","code":"#' Addiere zwei Zahlen\n#' \n#' @param x Eine Zahl.\n#' @param y Eine Zahl.\n#' @return Die Summe von \\code{x} und \\code{y}.\n#' @examples\n#' add_2(1, 1)\n#' add_2(10, 1)\nadd_2 <- function(x, y) {\n  x + y\n}% Generated by roxygen2 (4.0.2): do not edit by hand\n\\name{add_2}\n\\alias{add_2}\n\\title{Addiere zwei Zahlen}\n\\usage{\nadd_2(x, y)\n}\n\\arguments{\n\\item{x}{Eine Zahl.}\n\n\\item{y}{Eine Zahl.}\n}\n\\value{\nDie Summe von \\code{x} und \\code{y}.\n}\n\\description{\nAddiere zwei Zahlen\n}\n\\examples{\nadd_2(1, 1)\nadd_2(10, 1)\n}\n"},{"path":"packages.html","id":"namespace","chapter":"Kapitel 12 Pakete","heading":"12.7 NAMESPACE","text":"Es ist nicht nur fÃ¼r das Erstellen von Paketen hilfreich das Konzept eines NAMESPACE verstanden zu haben, sondern auch fÃ¼r das generelle Arbeiten mit R. Man unterscheidet dabei Import NAMESPACES und Export NAMESPACES.Import legt dabei fest wie die Funktion eines Pakets eine Funktion einem anderen Paket findet. Betrachten wir z.B.Diese Funktion ist definiert AbhÃ¤ngigkeit von dim() aus dem base Paket.Auch wenn wir die Funktiondefinieren, findet nrow() trotzdem die â€œrichtigeâ€ Funktionda sie den NAMESPACE des base Pakets verwendet.Export legt fest welche Funktionen eines Pakets auÃŸerhalb des Pakets zur VerfÃ¼gung stehen sollen. Dies mÃ¼ssen/sollten nicht alle Funktionen sein. Ein Paket kann also interne Funktionen haben, die nur intern verwendet werden kÃ¶nnen.Ãœber den Operator :: wird explizit auf den NAMESPACE eines Pakets zugegriffen. Auf diese Art und Weise vermeidet man auch Konflikte zwischen Funktionen aus verschiedenen Paketen, die aber den gleichem Namen haben. einem solchen Fall kommt es darauf welches Paket zuletzt geladen wurde. Dieses findet man dann zuerst im SuchpfadIn der NAMESPACE Datei beschreibenexport(): exportiert FunktionenexportPattern(): exportiert alle Funktionen, die zu einem bestimmten Schema passenS3method(): exportiert S3 Methodenden Export undimport(): importiert alle Funktionen aus einem PaketimportFrom(): importiert eine bestimmte Funktion aus einem PaketuseDynLib(): importiert eine Funktion aus Cden Import.Export-EintrÃ¤ge der NAMESPACE Datei kÃ¶nnen leicht Ã¼ber roxygen Kommentare erzeugt werden.\nÃœber einen @export Tag wird angegeben welche Funktion exportiert werden sollJe nach Objekttyp wird dann export(), exportPattern() oder S3method() im NAMESPACE verwendet. Generell sollte man sich die Regel halten lieber weniger als mehr Funktionen zu exportieren, wenn man das Paket Dritte weitergeben .Beim Importieren sollte man noch restriktiver sein. Man sollte Ã¼ber Imports der DESCRIPTION Datei sicherstellen, dass alle notwendigen Pakete installiert und geladen sind. Danach kann einfach Ã¼ber den :: Operator eigenen Funktionen auf Funktionen aus anderen geladenen Paketen zugegriffen werden, also z.B. pkg_name::funktion_aus_pkg_name().Dies erhÃ¶ht die spÃ¤tere Lesbarkeit der eigenen Programme und vermeidet potentielle Konflikte, die beim Importieren mehrerer Pakete - die dann wieder Funktionen mit gleichem Namen besitzen - auftreten kÃ¶nnen.Muss eine Funktion hÃ¤ufig verwendet werden - und man nicht dauernd :: verwenden - sollte man Ã¼ber importFrom() eher nur die Funktion und nicht das ganze Paket importieren.","code":"\nnrow\n## function (x) \n## dim(x)[1L]\n## <bytecode: 0x7f8b2efcdf10>\n## <environment: namespace:base>\ndim <- function(x) c(1,1)\ndim(mtcars)\n## [1] 1 1\nnrow(mtcars)\n## [1] 32\nsearch()\n##  [1] \".GlobalEnv\"        \"package:devtools\"  \"package:usethis\"  \n##  [4] \"package:stats\"     \"package:graphics\"  \"package:grDevices\"\n##  [7] \"package:utils\"     \"package:datasets\"  \"package:methods\"  \n## [10] \"Autoloads\"         \"package:base\"#' @export\nexport_function <- function(...){\n  ... \n}"},{"path":"packages.html","id":"daten-einbinden","chapter":"Kapitel 12 Pakete","heading":"12.8 Daten einbinden","text":"Daten, die das Paket enthalten sollte, legt man im Verzeichnis /data ab. Als Format sollte man .rda wÃ¤hlen (ist aber kein Muss). Der einfachste Weg dies zu berÃ¼cksichtigen ist die Funktion usethis::use_data() zu verwenden.Dieser Befehl speichert die Objekte x und mtcars den Dateien data/x.rda und data/mtcars.rda ab. Der Dateiname stimmt also mit dem Objektnamen Ã¼berein.DatensÃ¤tze sollten auf jeden Fall dokumentiert werden. Dazu fÃ¼gt man einfach eine der .R Dateien im Verzeichnis /R einen weiteren roxygen2 Absatz ein. FÃ¼r das Dokumentieren von DatensÃ¤tzen stehen zwei weitere Tags bereit. Ãœber @format beschreibt man das genaue Format der Daten, z.B. die einzelnen Spalten eines Data Frames, und mit @source gibt man (falls vorhanden) die Datenquelle .Die Beschreibung des Datensatzes x kÃ¶nnte also z.B. aussehen","code":"\nx <- sample(1:100, 50, replace = TRUE)\nusethis::use_data(x, mtcars)#' Mein Datensatz\n#' \n#' Ein Datensatz bestehend aus 50 Zahlen gezogen aus den \n#' Zahlen 1 bis 100 mit Zuruecklegen\n#' \n#' @format Ein Integer Vektor der Laenge 50\n\"x\""},{"path":"packages.html","id":"c-special-topic","chapter":"Kapitel 12 Pakete","heading":"12.9 C++ (Special Topic)","text":"man seinem Paket R Funktionen verwenden, die mithilfe von Rcpp aus kompiliertem C++ Code entstanden sind, sollte man zur VorbereitungausfÃ¼hren. Danach ist das das Verzeichnis /src angelegt und Rcpp zu den Feldern LinkingTo und Imports der DESCRIPTION Datei hinzugefÃ¼gt. AuÃŸerdem wird man aufgefordert die roxygen Tagsin eine der .R Dateien einzufÃ¼gen.Ebenso wie die .R Dateien kann auch die .cpp Dateien die roxygen Dokumentation eingefÃ¼gt werden. Allerdings verwendet man //' statt #'.","code":"\nusethis::use_rcpp()#' @useDynLib meinR4EWSpckg\n#' @importFrom Rcpp sourceCpp#include <Rcpp.h>\nusing namespace Rcpp;\n\n//' Multipliziere eine Zahl mit 2\n//' \n//' @param x Ein Integer.\n//' @export\n// [[Rcpp::export]]\nint malZwei(int x) {\n   return x * 2;\n}"},{"path":"packages.html","id":"git-und-githubgitlab","chapter":"Kapitel 12 Pakete","heading":"12.10 Git und GitHub/GitLab","text":"Benutze fÃ¼r jedes deiner Pakete (mag es auch noch klein sein) Git. Beim Anlegen des Projekts (zur Erstellung des Pakets) Ã¼ber RStudio, kann leicht ein lokales Git repository initialisiert werdenSoll zusÃ¤tzlich ein remote repository verwendet werden, kann man (im Standardfall) ein neues repository auf GitLab (oder GitHub) anlegen. Es sollte den gleichen Namen bekommen wie das Paket (lokales Git repository). Danach kannst du im Terminal Befehle der FormausfÃ¼hren.Angenommen es existiert bereits ein remote repository und das Paket soll dort â€œverwaltetâ€ werden. Dann kannst du einfach dieses repository klonenDanach existiert im Verzeichnis, dem der Befehl ausgefÃ¼hrt wurde, das Unterverzeichnis paketName. R kannst du anschlieÃŸend den BefehlausfÃ¼hren (im Verzeichnis, welches das Git repository paketName enthÃ¤lt). Danach kannst du die Ã„nderungen speichern Ã¼ber einen commit Befehlund pushen","code":"git remote add origin https://gitlab.lrz.de/vw99xyz/paketName.git\ngit push -u origin mastergit clone https://gitlab.lrz.de/vw99xyz/paketName.git\ndevtools::create(\"paketName\")git add -A\ngit commit -m \"paket struktur angelegt\"git push"},{"path":"packages.html","id":"literatur-2","chapter":"Kapitel 12 Pakete","heading":"12.11 Literatur","text":"Diese Folien haben einen kleinen Einblick das Erstellen eigener Pakete gegeben. Allerdings wurden viele weitere Aspekte nicht angesprochen. Weitere Informationen zu R Paketen findet man z.B. im Buch R packages von Hadley Wickham (2015b).","code":""},{"path":"funktionen.html","id":"funktionen","chapter":"Kapitel 13 Funktionen","heading":"Kapitel 13 Funktionen","text":"Wie jeder anderen Programmierumgebung, besteht auch R die MÃ¶glichkeit eigene Funktionen zu definieren.Eine der wichtigsten Erkenntnisse dabei ist die Tatsache, dass auch Funktionen Objekte sind. Generell ist R alles ein Objekt.Neue Funktionen werden mit der Funktion function() erzeugt.","code":""},{"path":"funktionen.html","id":"bestandteile-von-funktionen","chapter":"Kapitel 13 Funktionen","heading":"13.1 Bestandteile von Funktionen","text":"Alle R Funktionen bestehen aus den drei Teilen:formals(), Argumente, die den Funktionsaufruf â€œregelnâ€body(), der eigentliche Codeenvironment(), Verweis auf die Funktionseingabe","code":"\nf <- function(x) x + sin(x)\nformals(f)## $x\nbody(f)## x + sin(x)\nenvironment(f)## <environment: R_GlobalEnv>"},{"path":"funktionen.html","id":"body","chapter":"Kapitel 13 Funktionen","heading":"13.2 body()","text":"Wie alle Objekte R, besitzen auch Funktionen Attribute. Ein data frame besitzt z.B. die Attribute names, class und row.namesEine Funktion besitzt hingegen die AttributeDen Unterschied zu body() sehen wir im folgenden Beispiel.","code":"\nattributes(iris)## $names\n## [1] \"Sepal.Length\" \"Sepal.Width\"  \"Petal.Length\" \"Petal.Width\"  \"Species\"     \n## \n## $class\n## [1] \"data.frame\"\n## \n## $row.names\n##   [1]   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18\n##  [19]  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36\n##  [37]  37  38  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54\n##  [55]  55  56  57  58  59  60  61  62  63  64  65  66  67  68  69  70  71  72\n##  [73]  73  74  75  76  77  78  79  80  81  82  83  84  85  86  87  88  89  90\n##  [91]  91  92  93  94  95  96  97  98  99 100 101 102 103 104 105 106 107 108\n## [109] 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126\n## [127] 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144\n## [145] 145 146 147 148 149 150\nattributes(f)## $srcref\n## function(x) x + sin(x)\nf <- function(x){\n  # Summe von x und sin(x)#\n  x + sin(x)\n}\nbody(f)## {\n##     x + sin(x)\n## }\nattr(f, \"srcref\")## function(x){\n##   # Summe von x und sin(x)#\n##   x + sin(x)\n## }"},{"path":"funktionen.html","id":"einfache-funktionen","chapter":"Kapitel 13 Funktionen","heading":"13.3 â€œEinfacheâ€ Funktionen","text":"Es gibt eine Ausnahme von der obigen Regel, dass Funktionen aus drei Teilen bestehen. Die primitive functions wie sum(), sin() oder exp() rufen direkt Ã¼ber die Funktion .Primitive() C Code auf, enthalten somit keinen R Code und daher sind alle drei Teile gleich NULL.","code":"\nformals(sin)## NULL\nbody(sin)## NULL\nenvironment(sin)## NULL"},{"path":"funktionen.html","id":"jede-operation-ist-ein-funktionsaufruf","chapter":"Kapitel 13 Funktionen","heading":"13.4 Jede Operation ist ein Funktionsaufruf","text":"â€œunderstand computations R, two slogans helpful:\nEverything exists object.\nEverything happens function call.â€\nâ€” John ChambersAlle Operationen bestehen aus Funktionsaufrufen. Somit auch +, -, /,:, , , oder []und $. Dies sieht man z.B. diesem Beispieloder auch diesem BeispielenDie Verwendung von ` erlaubt den Zugriff auf reservierte AusdrÃ¼cke.Eine sinnvolle Anwendung dieser Zugriffsmethode liegt der Kombination mit den apply Funktionen (apply(), lapply(), sapply, mapply(), tapply()). Diese wenden eine zu Ã¼bergebende Funktion auf weitere InputgrÃ¶ÃŸen wie Listen oder Data Frames .","code":"\nx <- 10 \ny <- 5\nx + y## [1] 15\n`+`(x, y)## [1] 15\nfor (i in 1:2) print(i)## [1] 1\n## [1] 2\n`for`(i, 1:2, print(i))## [1] 1\n## [1] 2\nx[3]## [1] NA\n`[`(x, 3)## [1] NA\nx <- list(1:3, 4:9, 10:12)\nsapply(x, `[`, 2)## [1]  2  5 11\nsapply(x, function(x) x[2])## [1]  2  5 11"},{"path":"funktionen.html","id":"lapply-sapply","chapter":"Kapitel 13 Funktionen","heading":"13.5 lapply, sapply","text":"sapply() ist eine Version von lapply(), die - wenn mÃ¶glich - eine â€œvereinfachteâ€ Ausgabe liefert.","code":"\nx <- list(1:3, 4:6, 7:9)\nlapply(x, `+`, 3)## [[1]]\n## [1] 4 5 6\n## \n## [[2]]\n## [1] 7 8 9\n## \n## [[3]]\n## [1] 10 11 12\nis.matrix(sapply(x, `+`, 3))## [1] TRUE"},{"path":"funktionen.html","id":"funktionsargumente","chapter":"Kapitel 13 Funktionen","heading":"13.6 Funktionsargumente","text":"Funktionen besitzen formelle Argumente, denen beim Funktionsaufruf (oder per Default) Werte zugewiesen werden. Beim Aufruf kÃ¶nnen die Argumente durch ihre Position, den vollen oder teilweisen Namen ausgewÃ¤hlt werden.Der folgende Aufruf kann aber nicht funktionieren.Generell sollte man die zwei, drei wichtigsten InputgrÃ¶ÃŸen den Beginn stellen. Alle anderen sollten eher nicht durch die Position ausgewÃ¤hlt werden. Dabei ist der vollstÃ¤ndige Namen sicherlich zu bevorzugen.Funktionsargumenten kÃ¶nnen Default-Werte zugeordnet werden. Dabei kÃ¶nnen Default-Werte auch AbhÃ¤ngigkeit anderer Argumente definiert werden.","code":"\nf <- function(abc, bcd, bdc) c(abc, bcd, bdc)\nf(3, 2, 1)## [1] 3 2 1\nf(2, 1, abc=3)## [1] 3 2 1\nf(2, 1, a=3)## [1] 3 2 1\nf(3, b=2, 1)## Error in f(3, b = 2, 1): argument 2 matches multiple formal arguments\nf <- function(a = 1, b = 2) {\n  c(a, b)\n}\nf()## [1] 1 2\ng <- function(a = 1, b = a * 2) {\n  c(a, b)\n}\ng(a=10)## [1] 10 20"},{"path":"funktionen.html","id":"funktionsargumente-lazy-evaluation","chapter":"Kapitel 13 Funktionen","heading":"13.7 Funktionsargumente: Lazy Evaluation","text":"R wertet Funktionsargumente nur aus, wenn diese tatsÃ¤chlich benÃ¼tzt werden. Dies entspricht der Idee der Lazy Evaluation.Mit force() kann man die Auswertung eines Arguments erzwingen.Benutzt man eine verschachtelte Funktion Kombination mit lapply() oder einer Schleife, kann die Lazy Evaluation entscheidend sein.x wird beim ersten Aufruf von addiere_zu_1bis10() ausgewertet. Bis dahin ist x aber bereits von 1 bis 10 â€œgelaufenâ€ und hat damit den Wert 10. Somit wird stets 10 zum Input addiert.Erzwingt man die Auswertung, erhÃ¤lt man das gewÃ¼nschte Ergebnis.Bisher schien die Lazy Evaluation eher nachteilig. Sie kann aber auch Vorteile haben. Die Befehleerzeugen keinen Fehler, obwohl NULL>0 keinen zulÃ¤ssigen Input fÃ¼r darstellt. Da !.null(x) bereits FALSE liefert, wird die zweite Abfrage nicht mehr ausgewertet.Hauptvorteil ist aber die Effizienz. Nur notwendige AusdrÃ¼cke werden ausgewertet.","code":"\nf <- function(x) {\n  10\n}\nf(stop(\"x ist nicht 10\"))## [1] 10\nf <- function(x) {\n  force(x)\n  10\n}\nf(stop(\"x ist nicht 10\"))## Error in force(x): x ist nicht 10\naddiere_x <- function(x){\n  function(y) x+y\n}\naddiere_zu_1bis10 <- lapply(1:10, addiere_x)\naddiere_zu_1bis10[[1]](10)## [1] 11\naddiere_zu_1bis10[[5]](10)## [1] 15\naddiere_x <- function(x){\n  force(x)\n  function(y) x+y\n}\naddiere_zu_1bis10 <- lapply(1:10, addiere_x)\naddiere_zu_1bis10[[1]](10)## [1] 11\naddiere_zu_1bis10[[5]](10)## [1] 15\nx <- NULL\nif (!is.null(x) && x > 0) {\n\n}"},{"path":"funktionen.html","id":"funktionsargumente-...","chapter":"Kapitel 13 Funktionen","heading":"13.8 Funktionsargumente: ...","text":"FÃ¼r eine Funktion kann das formale ... Drei-Punkte Argument verwendet werden. Alle nicht Ã¼ber Position und/oder Name zugeordneten Argumente werden durch ... aufgenommen. der Regel werden Ã¼ber ... Argumente Ã¼bergeben, die innerhalb der Funktion andere Funktionen weitergegeben werden.... erhÃ¶ht also offensichtlich die FlexibilitÃ¤t. Ein Nachteil ist, dass falsch geschriebene Argumente keinen Fehler erzeugen und alle Argumente nach ... voll ausgeschrieben werden mÃ¼ssen.","code":"\nsumme_plus2 <- function(x, ...){\n  x <- x+2\n  sum(x, ...)\n}\nsumme_plus2(c(1, 3, 5))## [1] 15\nsumme_plus2(c(1, 3, NA), na.rm = TRUE)## [1] 8\nsum(1, 2, NA, rm.na = TRUE)## [1] NA\nsum(1, 2, NA, na.rm = TRUE)## [1] 3"},{"path":"funktionen.html","id":"funktionsrÃ¼ckgabe","chapter":"Kapitel 13 Funktionen","heading":"13.9 FunktionsrÃ¼ckgabe","text":"Wir haben den Beispielen bereits gesehen wie die RÃ¼ckgabe funktioniert. Der letzte Ausdruck, der ausgewertet wird, bildet die RÃ¼ckgabe.Falls bereits zu einem frÃ¼heren Zeitpunkte eine RÃ¼ckgabe erfolgen soll (z.B. STOP Kriterium erfÃ¼llt) und diese speziell gekennzeichnet werden soll, kann die Funktion return() verwendet werden.Funktionen kÃ¶nnen nur ein Objekt zurÃ¼ckgeben. Soll die Ausgabe einer Funktion aus mehreren Objekten bestehen, schreibt man diese einfach eine Liste und gibt die Liste zurÃ¼ck.","code":"\nf <- function(x) {\n  if (x < 10) {\n    0\n  } else {\n    10\n  }\n}\nf(5)## [1] 0\nf(15)## [1] 10\nf <- function(x) {\n  if (x < 10) {\n    n_output <- 0\n    t_output <- \"eingabe war kleiner 10\"\n  } else {\n    n_output <- 10\n    t_output <- \"eingabe war grÃ¶ÃŸer oder gleich 10\"\n\n  }\n  \n  output <- list(n_output, t_output)\n  return(output) \n}\nf(5)## [[1]]\n## [1] 0\n## \n## [[2]]\n## [1] \"eingabe war kleiner 10\"\nf(15)## [[1]]\n## [1] 10\n## \n## [[2]]\n## [1] \"eingabe war grÃ¶ÃŸer oder gleich 10\""},{"path":"funktionen.html","id":"mehr-zu","chapter":"Kapitel 13 Funktionen","heading":"13.10 mehr zu â€¦","text":"Wenn ihr mehr zufunctionsenvironmentsfunctional programmingobject-oriented programmingâ€¦wissen wollt, dann findet ihr (fast) alle Antworten auf eure Fragen im Buch Advanced R von Hadley Wickham (2015a).","code":""},{"path":"envscop.html","id":"envscop","chapter":"Kapitel 14 Environments und Scoping","heading":"Kapitel 14 Environments und Scoping","text":"","code":""},{"path":"envscop.html","id":"zuordnungen","chapter":"Kapitel 14 Environments und Scoping","heading":"14.1 Zuordnungen","text":"Wie weiÃŸ R welchen Wert es welchem Symbol zuordnen soll?Warum wÃ¤hlt R nicht die Standardfunktion sqrt() aus dem base Paket?Wenn R einem Symbol einen Wert zuordnet, dann durchsucht R eine Reihe von environments (bereits im Abschnitt Funktionen gesehen) nach dem passenden Wert. Gesucht wird folgender ReihenfolgeDas Global Environment wird durchsucht.Die namespaces (dazu spÃ¤ter mehr) der Pakete auf der search Liste werden durchsucht.Das global environment (der Workspace) wird immer zuerst und base immer zuletzt durchsucht.Die search Liste wird also beeinflusst durch die von uns geladenen Pakete.Man beachte, dass R die Namen von Daten- und Funktionsobjekten unterscheiden kann.","code":"\nsqrt(2)## [1] 1.414214\nsqrt <- function(x) x^2\nsqrt(2)## [1] 4\nsearch()## [1] \".GlobalEnv\"        \"package:stats\"     \"package:graphics\" \n## [4] \"package:grDevices\" \"package:utils\"     \"package:datasets\" \n## [7] \"package:methods\"   \"Autoloads\"         \"package:base\"\nlibrary(ggplot2)\nsearch()##  [1] \".GlobalEnv\"        \"package:ggplot2\"   \"package:stats\"    \n##  [4] \"package:graphics\"  \"package:grDevices\" \"package:utils\"    \n##  [7] \"package:datasets\"  \"package:methods\"   \"Autoloads\"        \n## [10] \"package:base\"\n(sqrt <- 2)## [1] 2\nsqrt(2)## [1] 1.414214"},{"path":"envscop.html","id":"environments","chapter":"Kapitel 14 Environments und Scoping","heading":"14.2 Environments","text":"Ein Environment verbindet eine Menge von Namen mit einer entsprechenden Menge von Werten. Environments sind Ã¤hnlich zu einer Liste, aber es gibt entscheidende Unterschiededie Namen der Objekte einem Environment sind eindeutigdie Objekte eines Environments sind nicht geordnetjedes Environment besitzt ein parent Environment, auÃŸer emptyenv()Die EintrÃ¤ge von search() sind die Eltern des Global Environment. Mit new.env() kann auch ein neues Environment erzeugt werden.Bemerkung: Die meisten Environments erzeugt man durch die Verwendung von Funktionen.","code":"\nneues_env <- new.env()\nneues_env$eins <- c(1, 2)\nneues_env$zwei <- c(\"a\", \"b\")\nls(neues_env)## [1] \"eins\" \"zwei\"\nparent.env(neues_env)## <environment: R_GlobalEnv>"},{"path":"envscop.html","id":"scoping-rules","chapter":"Kapitel 14 Environments und Scoping","heading":"14.3 Scoping Rules","text":"Der Sichtbarkeitsbereich von Variablen (Scope) wird Ã¼ber Scoping Rules festgelegt. R verwendet static scoping oder auch lexical scoping genannt (eine Alternative ist das dynamic scoping).f hat die formellen Argumente x und y sowie die freie Variable z. Die Scoping Rule bestimmt wie Werte freien Variablen zugeordnet werden. R bedeutet diesDer Wert freier Variablen (einer Funktion) wird dem Environment gesucht, dem die Funktion definiert wurde.","code":"\nf <- function(x, y){\n  x + y/z\n}"},{"path":"envscop.html","id":"static-scoping","chapter":"Kapitel 14 Environments und Scoping","heading":"14.4 Static scoping","text":"Oftmals werden Funktionen im Globalen Environment definiert. Die Werte freier Variablen sollten dann im Workspace zu finden sein. Dieses â€œVerhaltenâ€ wird von den meisten â€œNutzernâ€ erwartet und als sinnvoll angesehen.Allerdings kÃ¶nnen Funktionen auch innerhalb von Funktionen definiert werden. diesem Fall ist das Environment der body einer anderen Funktion.bilde_potenz() liefert somit eine Funktion als Ausgabe.Sucht man nach einer Variable und/oder mÃ¶chte man ihren Wert ausgeben, kann man mit den Funktionen exists() und get() arbeiten. Beide verwenden static scoping.Schauen wir uns nun den closure (Funktion + zugehÃ¶riges Environment) von zweite_potenz() und dritte_potenz() genauer .","code":"\nbilde_potenz <- function(n){\n  potenz <- function(x)\n    x^n\n}\nzweite_potenz <- bilde_potenz(2)\ndritte_potenz <- bilde_potenz(3)\nget(\"eins\", envir = neues_env)## [1] 1 2\nx <- 1\nexists(\"x\", envir = neues_env)## [1] TRUE\nexists(\"x\", envir = neues_env, inherits = FALSE)## [1] FALSE\nls(environment(zweite_potenz))## [1] \"n\"      \"potenz\"\nget(\"n\", envir = environment(zweite_potenz))## [1] 2\nls(environment(dritte_potenz))## [1] \"n\"      \"potenz\"\nget(\"n\", envir = environment(dritte_potenz))## [1] 3"},{"path":"envscop.html","id":"anwendungsbeispiel","chapter":"Kapitel 14 Environments und Scoping","heading":"14.5 Anwendungsbeispiel","text":"Wir betrachten als Anwendungsbeispiel die Minimierung der Funktion\\[\n  l_x(\\mu,\\sigma^2) =-\\left(-\\frac{n}{2}\\log(2\\pi\\sigma^2)-\\frac1{2\\sigma^2}\\sum_{=1}^n(x_i-\\mu)^2\\right)\\,,\n  \\]\nwobei \\(x_i, =1,\\dots,n,\\) bekannte GrÃ¶ÃŸen sind. Die obigen Funktion ist der negative log-Likelihood einer Normalverteilung mit Parametern \\(\\mu\\) und \\(\\sigma^2\\), aber das spielt hier keine Rolle.Optimierungsroutinen wie optim(), nlm() oder optimize() erwarten als Eingabe eine\nFunktion, deren Argumente die zu optimierenden Parameterwerte sind. Oftmals (wie im obigen Beispiel) hÃ¤ngen Funktionen aber von weiteren Werten ab.Die Funktion ist geschrieben, dass einer der beiden Parameter fixiert werden kann.Fixieren wir nun \\(\\mu\\) gleich 1, erhÃ¤lt manBemerkung: Wir verwenden optimize() anstatt optim(), da letztere nicht fÃ¼r eindimensionale Optimierung geeignet ist.Durch Ãœbergabe aller weiteren GrÃ¶ÃŸen im Environmentkonnte die Funktion l_x() nur als Funktion der unbekannten Parameter im\n.GlobalEnv definiert werden.Es muss also keine Liste weiterer Argumente der Optimierungs- funktion Ã¼bergeben werden.","code":"\nnegLogLik <- function(data, fix = c(FALSE, FALSE)){\n  param <- fix\n  function(theta){\n    param[!fix] <- theta\n    mu <- param[1]\n    sigma_2 <- param[2]\n    l_x <- -( -length(data)/2 * log(2 * pi * sigma_2 )\n              - sum((data-mu)^2) / (2*sigma_2))\n    l_x\n  }\n}\nset.seed(1234)\nx <- rnorm(1000, mean = 1, sd = 2)\nl_x <- negLogLik(x)\nl_x## function(theta){\n##     param[!fix] <- theta\n##     mu <- param[1]\n##     sigma_2 <- param[2]\n##     l_x <- -( -length(data)/2 * log(2 * pi * sigma_2 )\n##               - sum((data-mu)^2) / (2*sigma_2))\n##     l_x\n##   }\n## <bytecode: 0x7fc50864f208>\n## <environment: 0x7fc502ee5d70>\nls(environment(l_x))## [1] \"data\"  \"fix\"   \"param\"\noptim(par = c(0, 1), fn = l_x)$par## [1] 0.9465684 3.9744817\nl_x <- negLogLik(x, fix = c(1, FALSE))\noptimize(f = l_x, interval = c(1e-6, 10))$minimum## [1] 3.97759\nls(environment(l_x))## [1] \"data\"  \"fix\"   \"param\"\nparent.env(environment(l_x))## <environment: R_GlobalEnv>"},{"path":"fragen.html","id":"fragen","chapter":"Kapitel 15 Fragen und Anregungen aus der Ãœbung","heading":"Kapitel 15 Fragen und Anregungen aus der Ãœbung","text":"","code":""},{"path":"fragen.html","id":"quantilsfunktion","chapter":"Kapitel 15 Fragen und Anregungen aus der Ãœbung","heading":"15.1 Quantilsfunktion","text":"Als Beispiel betrachten wir die Quantilsfunktion\\[Q: (0,1) \\\\mathbb{R}, y \\mapsto \\text{inf}\\{x\\\\mathbb{R}: F(x)\\geq y\\}\\]der \\(N(5,4)\\) Verteilung. Diese Funktion kÃ¶nnen wir mit qnorm() berechnen und mithilfe von stat_function() dann plottenDer Grafik kÃ¶nnen wir z.B. entnehmen, dass das 0.25 Quantil \\(q_{0.25}\\) der \\(N(5,4)\\) ungefÃ¤hr den Wert 3.65 hat. Der genaue Wert lautet\\(q_{0.25}\\) ist also der Wert, sodass die Wahrscheinlichkeit (unter der \\(N(5,4)\\) Verteilung) Werte kleiner oder gleich \\(q_{0.25}\\) anzunehmen, gleich 0.25 ist","code":"\nlibrary(tidyverse)\nggplot(data.frame(x=c(0,1)), aes(x)) +\n  stat_function(fun = \"qnorm\", args = list(mean = 5, sd = 2),\n                colour = \"blue\") + ylab(\"Q(x)\") +\n  geom_hline(yintercept = qnorm(0.25, mean = 5, sd = 2), colour = \"gold\") +\n  scale_y_continuous(breaks=round(qnorm(c(0.05, 0.25, 0.5, 0.75, 0.95), mean = 5, sd = 2), 2) ) +\n  theme_minimal()\n(q_025 <- qnorm(0.25, mean = 5, sd = 2))## [1] 3.65102\npnorm(q_025, mean = 5, sd = 2)## [1] 0.25"},{"path":"fragen.html","id":"qq-plot","chapter":"Kapitel 15 Fragen und Anregungen aus der Ãœbung","heading":"15.1.1 QQ-Plot","text":"Nun erzeugen wir 500 Pseudo-Zufallszahlen mit \\(N(5,4)\\) Verteilung.FÃ¼r diese Pseudo-Zufallszahlen berechnen wir nun die geordnete Stichprobe sowie die relativen HÃ¤ufigkeiten (funktioniert hier einfach, da es sich um eine st)Die beiden Grafiken sehen Ã¤hnlich aus. Aber ein Vergleich von zwei getrennten Grafiken ist natÃ¼rlich nicht einfach. Da die Werte auf der jeweiligen x-Achse nicht von groÃŸem Interesse sind, plottet man daher einfach die empirischen und theoretischen Quantile gegeneinander.","code":"\ndf <- tibble(x = rnorm(500, mean = 5, sd = 2))\ndf %>%\n  mutate(ord_x = sort(x), p = ecdf(ord_x)(ord_x)) %>%\n  ggplot(aes(x = p, y = ord_x)) + geom_point(colour = \"blue\") + \n  geom_hline(yintercept = qnorm(0.25, mean = 5, sd = 2), colour = \"gold\") +\n  scale_y_continuous(breaks=round(qnorm(c(0.05, 0.25, 0.5, 0.75, 0.95), mean = 5, sd = 2), 2) ) +\n  ylab(\"emp. Quantile\") + theme_minimal()\nggplot(df, aes(sample = x)) + \n  stat_qq(distribution = qnorm, dparams = list(mean = 5, sd = 2)) +\n  stat_qq_line(distribution = qnorm, dparams = list(mean = 5, sd = 2)) +\n  theme_minimal()"},{"path":"literatur-3.html","id":"literatur-3","chapter":"Literatur","heading":"Literatur","text":"","code":""}]
