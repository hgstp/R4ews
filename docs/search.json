[{"path":"index.html","id":"r4ews","chapter":"R4ews","heading":"R4ews","text":"Willkommen zur R Erg√§nzung zur Einf√ºhrung die Wahrscheinlichkeitstheorie und Statistik. Im Rahmen dieser Erg√§nzung lernen wirDaten untersuchen, aufbereiten, visualisieren und analysieren,Wir wollen das reproduzierbar, wiederverwendbar und gemeinsam nutzbar machen, und vor allem wollen wir alles mit R machen.Auf dieser Website geht es um alles, bei der Datenanalyse\nauftaucht au√üer um statistische Modellierung und Schlussfolgerungen. Dieser Teil der statistischen Analyse erfolgt der Vorlesung Einf√ºhrung die Wahrscheinlichkeitstheorie und Statistik.Das Design von R4ews wurde durch die Notwendigkeit motiviert, mehr Ausgewogenheit der angewandten statistischen Ausbildung zu schaffen. Datenanalysten verbringen viel Zeit mit der Projekt-Organisation, der Datenbereinigung und -aufbereitung sowie der Kommunikation. Diese T√§tigkeiten k√∂nnen einen tiefgreifenden Einfluss auf die Qualit√§t und Glaubw√ºrdigkeit einer Analyse haben. Dennoch werden diese F√§higkeiten selten vermittelt, obwohl sie wichtig und notwendig sind. R4ews versucht diese L√ºcke etwas zu verkleinern.Das Material wird kontinuierlich √ºber das Semester hinweg erg√§nzt/erweitert/verbessert.Letzte √Ñnderung:","code":"> date()\n## [1] \"Sun Oct 17 23:12:57 2021\""},{"path":"index.html","id":"beteiligte-personen","chapter":"R4ews","heading":"Beteiligte Personen","text":"","code":""},{"path":"index.html","id":"kolophon","chapter":"R4ews","heading":"Kolophon","text":"Dieses Buch wurde bookdown innerhalb von RStudio geschrieben.Teile des Buches basieren auf stat545.com. Alle √Ñnderungen wurden gem√§√ü der Creative Commons Attribution-ShareAlike 4.0 International License durchgef√ºhrt.Wir bedanken uns bei den Autor*innen von stat545 f√ºr das gro√üartige Material.Die aktuelle Version dieses Buchs wurde miterstellt","code":"## Finding R package dependencies ... Done!\n##  setting  value                       \n##  version  R version 4.0.3 (2020-10-10)\n##  os       macOS Big Sur 10.16         \n##  system   x86_64, darwin17.0          \n##  ui       X11                         \n##  language (EN)                        \n##  collate  en_US.UTF-8                 \n##  ctype    en_US.UTF-8                 \n##  tz       Europe/Berlin               \n##  date     2021-10-17"},{"path":"index.html","id":"lizenz","chapter":"R4ews","heading":"Lizenz","text":"Diese Arbeit ist lizenziert unter Creative Commons Attribution-ShareAlike 4.0 International License.","code":""},{"path":"install.html","id":"install","chapter":"Kapitel 1 Installieren von R und RStudio","heading":"Kapitel 1 Installieren von R und RStudio","text":"","code":""},{"path":"install.html","id":"r-und-rstudio","chapter":"Kapitel 1 Installieren von R und RStudio","heading":"1.1 R und RStudio","text":"Zuerst ben√∂tigen wir R, eine freie Softwareumgebung f√ºr statistische Berechnungen und Grafiken. Installiert daher R von CRAN, dem Comprehensive R Archive Network. Wir empfehlen euch dringend, eine vorkompilierte Bin√§rdistribution zu installieren - benutzt daher die Links oben auf der CRAN Seite!Zuerst ben√∂tigen wir R, eine freie Softwareumgebung f√ºr statistische Berechnungen und Grafiken. Installiert daher R von CRAN, dem Comprehensive R Archive Network. Wir empfehlen euch dringend, eine vorkompilierte Bin√§rdistribution zu installieren - benutzt daher die Links oben auf der CRAN Seite!Danach k√∂nnt ihr die IDE (steht f√ºr integrated development environment) von RStudio installieren. Dabei handelt es sich um eine leistungsf√§hige Benutzeroberfl√§che f√ºr R.\nRStudio wird mit einem Text Editor geliefert, dass es nicht unmittelbar erforderlich ist, einen separaten, eigenst√§ndigen Editor zu installieren.\nRStudio bietet auch eine direkt Verbindung zu Git(Hub). Um die notwendige Git-Installationen m√ºsst ihr euch aber selbst k√ºmmern. Wir kommen aber auch sp√§ter auf diesen Punkt zur√ºck.\nDanach k√∂nnt ihr die IDE (steht f√ºr integrated development environment) von RStudio installieren. Dabei handelt es sich um eine leistungsf√§hige Benutzeroberfl√§che f√ºr R.RStudio wird mit einem Text Editor geliefert, dass es nicht unmittelbar erforderlich ist, einen separaten, eigenst√§ndigen Editor zu installieren.RStudio bietet auch eine direkt Verbindung zu Git(Hub). Um die notwendige Git-Installationen m√ºsst ihr euch aber selbst k√ºmmern. Wir kommen aber auch sp√§ter auf diesen Punkt zur√ºck.Wenn ihr bereits eine vorhandene R und/oder RStudio Installation habt, empfehlen wir euch dringend, beide neu zu installieren und aktuell wie m√∂glich zu halten.Wenn ihr R aktualisiert, m√ºssen ihr alle Pakete, die ihr installiert habt, aktualisieren. Das k√∂nnt ihr leicht mit dem unten stehenden Befehl machen. M√∂glicherweise m√ºsst ihr aber auch noch weitere Argumente angeben, wenn ihr z.B. eine nicht standardm√§√üige Bibliothek f√ºr eure Pakete verwendet.Bemerkung: Mit diesem Befehl wird nur nach Updates auf CRAN gesucht. Wenn ihr aber ein Paket verwenden, das z.B. nur auf GitHub lebt, m√ºsst ihr manuell aktualisieren, z.B. √ºber devtools::install_github().","code":"\nupdate.packages(ask = FALSE, checkBuilt = TRUE)"},{"path":"install.html","id":"funktioniert-alles-am-besten-ausprobieren","chapter":"Kapitel 1 Installieren von R und RStudio","heading":"1.2 Funktioniert alles? Am besten ausprobieren","text":"Startet RStudio auf eurem Computer. Dann solltet ihr ein Fenster √§hnlich zu diesemerhalten. Vermutlich ist euer Fenster nicht dunkel. Aber wer es gerne dunkel mag, soll sich mal unter Tools -> Global -> Appearance die Editor Themes anschauen.Setzt den Cursor das Fenster mit der Bezeichnung Console. √úber die Konsole seid ihr der Lage mit R zu interagieren. Erstellt ein einfaches Objekt mit einem Code wie(gefolgt von Enter oder Return). Schaut euch dann das Objekt x genauer , indem ihr x der Konsole eingebt, gefolgt von Enter oder Return. Ihr sollten dann den Wert 8 auf dem Bildschirm sehen. Wenn ja, habet ihr R und RStudio erfolgreich installiert.","code":"\nx <- 2 * 4"},{"path":"install.html","id":"add-on-packages","chapter":"Kapitel 1 Installieren von R und RStudio","heading":"1.3 Add-on packages","text":"R ist ein erweiterbares System und viele Menschen teilen n√ºtzlichen Code, den sie als Paket entwickelt haben, √ºber CRAN, GitHub, GitLab oder √§hnlichen Plattformen. Um ein Paket von CRAN zu installieren, z.B. das Paket tidyverse (ist genauer gesagt eine Kollektion von Paketen), kann man folgenden Befehl verwendenMit der Option dependencies = TRUE achten wir darauf, dass alle f√ºr tidyverse notwendigen Pakete, ebenfalls installiert werden.","code":"\ninstall.packages(\"tidyverse\", dependencies = TRUE)"},{"path":"install.html","id":"rstudio-primers","chapter":"Kapitel 1 Installieren von R und RStudio","heading":"1.4 RStudio Primers","text":"Ein guter Startpunkt f√ºr verschiedene R Themen sind die RStudio primers.Im Laufe des Kurses werdet ihr die PrimersThe BasicsWork DataVisualize Datadurcharbeiten.","code":""},{"path":"install.html","id":"aufgabe","chapter":"Kapitel 1 Installieren von R und RStudio","heading":"1.5 Aufgabe","text":"Wir beginnen mit Basics. Hier wird unterschieden Programming und Visualization Basics.Programming Basics beinhaltet Grundlagen zu Objekttypen, Funktionen und deren Argumente, Listen (eigentlich sind alle Objekte Listen, nur unterschiedlich speziell) und Paketen.Visualization Basics erkl√§rt erste Schritte der Verwendung des ggplot2 Pakets, mit dem wir uns sp√§ter noch eingehend besch√§ftigen werden.Bearbeitet eigenst√§ndig den Basics Primer.","code":""},{"path":"r-basics.html","id":"r-basics","chapter":"Kapitel 2 R Basics und Arbeitsabl√§ufe","heading":"Kapitel 2 R Basics und Arbeitsabl√§ufe","text":"","code":""},{"path":"r-basics.html","id":"ein-paar-grundlagen-f√ºr-das-arbeiten-mit-r","chapter":"Kapitel 2 R Basics und Arbeitsabl√§ufe","heading":"2.1 Ein paar Grundlagen f√ºr das Arbeiten mit R","text":"Aktueller Stand: Ihr habt bereits den Basics Primer absolviert und nun wollt ihr anfangen mit eurer RStudio/R Installation zu arbeiten.Es geht los indem ihr RStudio startet. Beachtet dabei die Standardfensterbereiche:Console (links)Environment / History (oben rechts)Files / Plots / Packages / Help (unten rechtes)Bemerkung: Die Standardanordnung der Fenster k√∂nnt ihr neben vielen anderen Dingen nach deinen Vorstellungen √§ndern/anpassen: Customizing RStudio.Geht nun die Konsole um mit R zu interagieren. Erstellt die nachfolgende Zuordnung und schau euch das erstellte Objekt genauer :Alle R Befehle, die ein Objekte erstellen (‚ÄúZuweisungen‚Äù), haben die Form:Ihr werdet im weiteren Verlauf noch viele Zuweisungen vornehmen. Tats√§chlich ist es etwas m√ºhsam den Operator <- zu tippen. Seid aber trotzdem nicht faul und benutzt stattdessen einfach = - auch wenn das theoretisch funktionieren w√ºrde. Aber sp√§ter kann die Verwendung von = f√ºr Zuweisungen zu Verwirrung f√ºhren. Verwendet stattdessen RStudio die Tastenkombination: Alt + - (Minuszeichen) bzw. option + -.Beachtet, dass RStudio automatisch <- mit Leerzeichen umgibt, eine n√ºtzliche Codeformatierung darstellt. Code ist selbst einem guten Tag eher schlecht zu lesen. G√∂nnt daher euren Augen eine Pause und verwende (ausreichend) Leerzeichen.RStudio bietet viele praktische Tastaturk√ºrzel . Eine √úbersicht erh√§lt man auch mit Alt+Shift+K bzw. option+Shift+K.Objektnamen d√ºrfen nicht mit einer Ziffer beginnen und bestimmte andere Zeichen wie ein Komma oder ein Leerzeichen nicht enthalten. Es ist daher ratsam, sich eine [Konvention zur Abgrenzung von W√∂rtern][wiki-snake-case] Objektnamen zu √ºberlegen.Wir werden stets die erste Variante verwenden.F√ºhrt nun nachfolgenden Befehl ausIn eurem Workspace ist nun das Objekt this_is_a_really_long_name vorhanden. Probiert mithilfe dieses Objekts die Vervollst√§ndigungsfunktion von RStudio aus:Gib die ersten paar Zeichen ein, dr√ºcke anschlie√üend die TAB Taste, f√ºgen weitere Zeichen hinzu, bis Eindeutigkeit hergestellt ist(wenn sonst wenig deinem Workspace ist, dann ist das schnell erreicht), und dr√ºcke dann die Eingabetaste.F√ºhrt nun den Befehlaus, um anschlie√üend den Inhalt des Objekts anzuzeigen.Die Objekte zwei.hoch.drei und zwei_Hoch_drei sind nat√ºrlich nicht vorhanden und somit f√ºhren beide Befehle zu einer Fehlermeldung. Man muss also absolut exakt sein mit seinen Befehlen.R verf√ºgt √ºber eine √ºberw√§ltigende Sammlung eingebauter Funktionen, die nach folgendem Schema aufgerufen werden:Als n√§chstes wollen wir die Funktion seq() verwenden, die regul√§re Zahlensequenzen erzeugt. Dabei wollen wir noch ein weiteres hilfreiches Feature von RStudio demonstrieren.Tippt se und dr√ºcke dann die TAB Taste. einem Pop-Fenster werden dir m√∂gliche Vervollst√§ndigungen angezeigt. Der Befehl seq() kann dann durch weiteres Tippen oder √ºber die Auswahlm√∂glichkeit (Pfeiltasten nach oben/unten) festgelegt werden. Zu jeder Auswahlm√∂glichkeit wird auch noch eine Kurzform der entsprechenden Hilfeseite angezeigt.F√ºgt man jetzt die √∂ffnende runde Klammer hinzu, wird die zugeh√∂rige schlie√üende runde Klammer automatisch hinzugef√ºgt. Tippe anschlie√üend 1, 10 (das geschieht automatisch innerhalb der runden Klammern) und Return. RStudio beendet auch den Klammerausdruck f√ºr dich. RStudio üöÄDer letzte Befehl zeigt auch ganz gut, wie R Funktionsargumente aufl√∂st. Sie k√∂nnen immer der Form Name = Wert angeben werden. Aber der Name muss nicht angegeben werden, wie man sieht. solchen F√§llen versucht R, nach der Position aufzul√∂sen. wird oben angenommen, dass wir eine Sequenz bei 1 starten wollen, also = 1, und diese bis 10 laufen soll, daher = 10. Da wir keine Schrittweite angegeben haben, wird der Standardwert f√ºr verwendet, der diesem Fall gleich 1 ist.Bei Funktionen, die man oft aufruft, kann man gut diese Aufl√∂sung nach Position f√ºr das erste und vielleicht auch das zweite Argument verwenden. Danach ist es aber ratsam immer mit Name = Wert zu arbeiten um falsche Zuweisungen (verschiedene Argumente k√∂nnen vom gleichen Typ sein, sodass eine falsche Zuweisung nicht automatisch zu einer Fehlermeldung f√ºhrt) zu vermeiden.Analog zur Unterst√ºtzung mit den runden Klammern, werden auch schlie√üende Anf√ºhrungszeichen automatisch erg√§nzt, wie man folgendem Beispiel sieht.Nach einer Zuweisung wird der entsprechende Wert des Objekts nicht angezeigt. Daher ist man vielleicht dazu geneigt das Objekt gleich erneut aufzurufenDiese typische Aktion kann verk√ºrzt werden, indem die Zuweisung Klammern gesetzt wird, wodurch die Zuweisung und ein Befehl ‚ÄúDrucke auf den Bildschirm‚Äù erfolgen.Nicht alle Funktionen haben (oder erfordern) Argumente:Schaut euch nun euren Workspace - unter Environment (vermutlich im Fenster rechts oben) seht ihr den Inhalt eures Workspace. Der Workspace ist der Ort, dem sich benutzerdefinierte Objekte ansammeln. Eine Liste dieser Objekte k√∂nnt ihr auch mit diesen Befehlen erhalten:Wenn ihr nun das Objekt mit dem Namen y entfernen m√∂chtet, k√∂nnt ihr das wie folgt machen:Alles l√∂schen kann man mit dem Befehloder man klickt auf den Besen im Environment Fenster von RStudio.","code":"> x <- 3 * 4\n> x\n## [1] 12> objectName <- valuei_use_snake_case\nother.people.use.periods\nevenOthersUseCamelCase> this_is_a_really_long_name <- 2.5> zwei_hoch_drei <- 2 ^ 3> zwei.hoch.drei\n## Error in eval(expr, envir, enclos): object 'zwei.hoch.drei' not found\n> zwei_Hoch_drei\n## Error in eval(expr, envir, enclos): object 'zwei_Hoch_drei' not found> functionName(arg1 = val1, arg2 = val2, ...)> seq(1, 10)\n##  [1]  1  2  3  4  5  6  7  8  9 10> yo <- \"hello world\"> y <- seq(1, 10)\n> y\n##  [1]  1  2  3  4  5  6  7  8  9 10> (y <- seq(1, 10))\n##  [1]  1  2  3  4  5  6  7  8  9 10> date()\n## [1] \"Sun Oct 17 23:13:01 2021\"> objects()\n## [1] \"this_is_a_really_long_name\" \"x\"                         \n## [3] \"y\"                          \"yo\"                        \n## [5] \"zwei_hoch_drei\"\n> ls()\n## [1] \"this_is_a_really_long_name\" \"x\"                         \n## [3] \"y\"                          \"yo\"                        \n## [5] \"zwei_hoch_drei\"> rm(y)> rm(list = ls())"},{"path":"r-basics.html","id":"workspace-und-working-directory","chapter":"Kapitel 2 R Basics und Arbeitsabl√§ufe","heading":"2.2 Workspace und working directory","text":"Ziemlich schnell wird der Fall eintreten, dass ihr mit eurer R Arbeit (z.B. Bearbeitung eines Hausaufgaben Projekts) noch nicht fertig seid obwohl es Zeit die Arbeit f√ºr heute zu beenden. Nat√ºrlich man aber zu einem sp√§teren Zeitpunkt mit der Analyse weitermachen, wo man gerade aufgeh√∂rt hat.Etwas sp√§ter wird es ein, dass ihr zudem auch noch Daten R einlest und damit anschlie√üend numerische Ergebnisse erzeugt, die ihr dann auch wieder exportieren wollt.Und nochmal sp√§ter wird es (vielleicht) sein, dass ihr R gleichzeitig mehreren Analysen arbeitest, die ihr aber unbedingt getrennt halten wollt/sollt.Um diese Situationen zu bew√§ltigen, m√ºsst ihr zwei Entscheidungen treffen:betrachtest du deiner Analyse als ‚ÄúErgebnis‚Äù, d.h. wirst du dauerhaft speichern?betrachtest du deiner Analyse als ‚ÄúErgebnis‚Äù, d.h. wirst du dauerhaft speichern?Wo ‚Äúlebt‚Äù deine Analyse?Wo ‚Äúlebt‚Äù deine Analyse?","code":""},{"path":"r-basics.html","id":"workspace-.rdata","chapter":"Kapitel 2 R Basics und Arbeitsabl√§ufe","heading":"2.2.1 Workspace, .RData","text":"Ihr startet gerade eure R Reise ‚úàÔ∏è. Daher w√§re es okay, wenn ihr euren Workspace als das ‚ÄúErgebnis‚Äù eurer Analyse betrachtet. Ziemlich bald, solltet ihr aber davon (vielleicht durch uns) √ºberzeugt sein, dass eure R Skripte das Ergebnis eurer Analyse sind (beiden F√§llen h√§ngt das Ergebnis vermutlich auch von Input Daten ab).Die Daten zusammen mit eurem R Code erlauben es euch jederzeit alle Ergebnisse zu reproduzieren und das ist die entscheidende Eigenschaft.Betrachtest man seinen Workspace als das Ergebnis der Analyse, dann muss man bei einem erneuten Analysedurchlauf (leicht ver√§nderte Aufgabenstellung, ‚Ä¶) entweder erneut eine Menge Tippen (nat√ºrlich fehleranf√§llig ist) oder die R History nach den n√∂tigen Befehlen durchw√ºhlen.\nStatt ‚Äúbecoming expert managing R history‚Äù als Ziel zu haben, solltet ihr euren R Code sauber ein Skript speichern, sodass er f√ºr weitere Analysen zur Verf√ºgung steht.Der Workspace Ansatz wird allerdings ‚Äúbeg√ºnstigt/gef√∂rdert‚Äù durch die Tatsache, dass RStudio beim Beenden der Session automatisch wissen ob der Workspace gespeichert werden soll. Das wollen wir mal ausprobieren.Beendet R/RStudio, entweder √ºber das Men√º oder tippt q() die Konsole. Dann erhaltet ihr eine Eingabeaufforderung wie diese:Save workspace image ~/.Rdata?Merkt euch welchem Verzeichnis die Datei gespeichert wird und dann klickt auf Save.Geht das Verzeichnis mit dem gespeicherten Workspace Image und kontrolliert ob die Datei .RData vorhanden ist. Ihr werdet dort auch die Datei .Rhistory finden, die alle Befehle eurer letzten Sitzung enth√§lt.Nun starte erneut RStudio. der Konsole seht ihr einen Befehl, der ungef√§hr aussiehtund angibt, dass euer gespeicherter Workspace wiederhergestellt wurde. Unter Environment solltet ihr die gleichen Objekte wie zuvor sehen. Im Fenster History findet ihr die gespeicherten Befehle aus der letzten Sitzung.Aber diese Art, analytische Arbeit zu beginnen und zu beenden, w√ºrde nicht lange gut gehen. Daher fangen wir gleich mal damit die automatische Nachfrage nach dem Speichern des Workspaces abzuw√§hlen. √ñffnet dazu die Global Options (unter Tools)und setzt Save workspace .RData exit auf Never. Nun werdet ihr nie mehr gefragt ob der Workspace gespeichert werden soll. Sehr wohl werdet ihr aber weiterhin gefragt ob ungesicherte √Ñnderungen euren R Skript gespeichert werden sollen, sobald ihr RStudio beenden wollt.","code":"[Workspace loaded from ~/.RData]"},{"path":"r-basics.html","id":"working-directory","chapter":"Kapitel 2 R Basics und Arbeitsabl√§ufe","heading":"2.2.2 Working directory","text":"Jeder Prozess, der auf einem Computer l√§uft, hat einen Bezug zu seinem ‚ÄúArbeitsverzeichnis‚Äù. R ist dies der Ort, dem R standardm√§√üig nach Dateien suchen w√ºrde oder der Ort wo alle Dateien, die ihr auf die Festplatte schreiben wollt, abgelegt werden. M√∂glicherweise ist euer aktuelles Arbeitsverzeichnis das Verzeichnis, das ihr gerade untersucht habt um die .RData Datei zu finden.Das aktuelle Arbeitsverzeichnis k√∂nnt ihr euch anzeigen lassen mit dem BefehlAber es wird auch oben der RStudio Konsole direkt angezeigt.Es w√§re schon, wenn das Arbeitsverzeichnis Abh√§ngigkeit vom jeweils zu bearbeitenden Projekt leicht sinnvoll gesetzt werden k√∂nnte. Im n√§chsten Abschnitt sehen wir, dass genau das m√∂glich ist.","code":"> getwd()"},{"path":"r-basics.html","id":"rprojs","chapter":"Kapitel 2 R Basics und Arbeitsabl√§ufe","heading":"2.3 RStudio Projects","text":"Alle zu einem Projekt geh√∂renden Dateien - Eingabedaten, R Skripte, Analyseergebnisse, Grafiken - einem Ort zu b√ºndeln, ist eine sinnvolle Praxis, dass RStudio √ºber seine Projects genau da erm√∂glicht.Lasst uns ein Projekt f√ºr den Kurs anlegen. Dazu w√§hlen wir oben rechts im RStudio Fenster Project: (None) -> New ProjectDanach w√§hlen wir New Directory -> New Project und geben abschlie√üend einen passenden Verzeichnisnamen ein (dabei beachten wir den Speicherort des neuen Verzeichnisses)Wir nehmen nun , dass ihr ein RStudio Projekt angelegt und auch ge√∂ffnet habt. Als N√§chstes ben√∂tigen wir nun ein wenig R Code. Dazu tippen wir den unten stehenden Code (ausnahmsweise) die KonsoleJetzt nehmen wir mal , das w√§re ein guter Start einer Analyse, die wir durchf√ºhren wollen. Daher w√ºrdest ihr das Ergebnis gerne abspeichern. Unter History k√∂nnt ihr alle obigen Befehle markieren und anschlie√üend Source klicken. Daraufhin wird sich ein neues Fenster mit einem R Skript - das nat√ºrlich die Befehle enth√§lt - √∂ffnen. Das Skript k√∂nnt ihn anschlie√üend abspeichern, und standardm√§√üig wird es den Projektordner gespeichert werden (aber nat√ºrlich k√∂nntest man den Speicherort dieser Stelle auch √§ndern/frei w√§hlen).Nun beendet das Projekt (Close Project der rechten oberen Ecke). Wer , kann sich noch den Inhalt dess Projektordners anschauen, z.B. das PDF √∂ffnen.Danach √∂ffnet ihr das Projekt wieder. Euch sollte auffallen, dass alles dem Zustand ist, wie ihr das Projekt verlassen habt, z.B. Objekte im Arbeitsbereich, die Befehlshistorie, welche Dateien zur Bearbeitung ge√∂ffnet sind, wo wir uns im Dateisystembrowser befinden, das Arbeitsverzeichnis f√ºr den R-Prozess usw. dies sind gute Dinge üòÅ.Nun √§ndert ein paar Dinge eurem Code. Sinnvoll w√§re z.B. Anfang die Stichprobenl√§nge n zu definieren und z.B. auf n <- 40 setzen. Dann\nsollten alle festen 40er Werte durch n ersetzt werden. Anschlie√üend kann man noch ein paar andere Dinge √§ndern, z.B. die Steigung b, die Farbe der Linie ‚Ä¶ auch immer. Danach k√∂nnt ihr die verschiedenen M√∂glichkeiten ausprobieren, wie ihr den Code erneut ausf√ºhren k√∂nnt:Zeile f√ºr Zeile ausf√ºhren, indem ihr entweder das Tastenk√ºrzel Command + Enter oder die Maus (auf ‚ÄúRun‚Äù klicken der oberen rechten Ecke des Editor-Fensters) verwendet.Zeile f√ºr Zeile ausf√ºhren, indem ihr entweder das Tastenk√ºrzel Command + Enter oder die Maus (auf ‚ÄúRun‚Äù klicken der oberen rechten Ecke des Editor-Fensters) verwendet.Das gesamte Dokument durchlaufen lassen, entweder per Tastenk√ºrzel Shift + Command +S oder Maus (klicken auf ‚ÄúSource‚Äù der oberen rechten Ecke des Editor-Fensters).Das gesamte Dokument durchlaufen lassen, entweder per Tastenk√ºrzel Shift + Command +S oder Maus (klicken auf ‚ÄúSource‚Äù der oberen rechten Ecke des Editor-Fensters).Anschlie√üend k√∂nnt ihr euch das PDF anschauen und die √Ñnderungen bewundern.Irgendwann werdet ihr (vielleicht) vor der Aufgabe stehen, eine Grafik neu zu gestalten oder einfach nur verstehen zu wollen, woher sie stammt. Wenn ihr (relevante) Grafiken einer Datei speichert (√ºber R Code und niemals √ºber die Maus oder die Zwischenablage) und dabei sinnvolle Dateinamen/Speicherorte (innerhalb des zugeh√∂rigen Projekts) benutzt, werden euch solche Aufgaben nie vor gro√üe Probleme stellen ‚úÖ.","code":"> a <- 2\n> b <- -3\n> sig_sq <- 0.5\n> x <- runif(40)\n> y <- a + b * x + rnorm(40, sd = sqrt(sig_sq))\n> (x_n <- mean(x))\n## [1] 0.497\n> write(x_n, \"mittelwert_x.txt\")\n> plot(x, y)\n> abline(a, b, col = \"purple\")> dev.print(pdf, \"scatterplot.pdf\")\n## quartz_off_screen \n##                 2"},{"path":"r-basics.html","id":"zu-guter-letzt","chapter":"Kapitel 2 R Basics und Arbeitsabl√§ufe","heading":"2.4 zu guter Letzt","text":"Es ist √ºblich, R-Skripte mit einem .R oder .r Suffix zu speichern. Befolgt diese Konvention, au√üer ihr habt einen sehr au√üergew√∂hnlichen Grund, es nicht zu tun.Kommentare beginnen mit einem oder mehreren #-Symbolen. Verwendet Kommentare. RStudio hilft dir dabei ausgew√§hlte Zeilen mit Ctrl+Shift+C (Windows und Linux) oder command+Shif+C (Mac) zu kommentieren oder vorhandene Kommentare wieder zu entfernen.Dieser Workflow wird dir Zukunft gute Dienste leisten:Erstelle ein RStudio Projekt f√ºr ein analytisches ProjektSpeichere alle Input Dateien innerhalb des Projekts (wir werden bald √ºber den Import sprechen)Bewahre alle Skripte zu diesem Projekt dort auf; bearbeite sie und f√ºhren sie dort ausSpeichere den Output innerhalb des Projekts (wie z.B. das PDF im letzten Beispiel)Ihr solltet vermeiden die Maus f√ºr Teile des Workflows zu verwenden, wie z.B. das Laden eines Datensatzes oder das Speichern einer Grafik. Das ist sehr wichtig f√ºr die Reproduzierbarkeit und um im Nachhinein feststellen zu k√∂nnen, wie eine numerische Tabelle oder eine PDF-Datei tats√§chlich erzeugt wurde (eine Suche auf der lokalen Festplatte nach dem entsprechenden Dateinamen unter den .R-Dateien f√ºhrt zum entsprechenden Skript).","code":""},{"path":"version-control.html","id":"version-control","chapter":"Kapitel 3 Git, GitHub, and RStudio","heading":"Kapitel 3 Git, GitHub, and RStudio","text":"Versionskontrolle sollte nach dem Besuch der Einf√ºhrung die Programmierung bereits kein unbekanntes Thema mehr sein. Falls doch, solltet ihr mit ein paar Worten zu Git und GitHub von Jenny Byran (Autorin von STAT 545) starten.Ziel dieses Abschnitts wird es sein, dass ihreuren GitHub Account anlegst (falls nicht schon vorhanden)euren GitHub Account anlegst (falls nicht schon vorhanden)Git auf deinem Computer installierstGit auf deinem Computer installierstdich bei Git vorstellstdich bei Git vorstellstalles zusammenf√ºgst und deine Verbindung zu GitHub testestalles zusammenf√ºgst und deine Verbindung zu GitHub testestabschlie√üend noch RStudio ins Spiel bringst und RStudio mit Git und GitHub verbindestabschlie√üend noch RStudio ins Spiel bringst und RStudio mit Git und GitHub verbindestBemerkung: Unter 5. wirst du ermutigt deine GitHub Zugangsdaten auf deinem Computer zu speichern. Wir k√∂nnen diesen Schritt nur empfehlen.Das Buch Happy Git GitHub useR enth√§lt noch viele weitere hilfreiche Git/GitHub Informationen. Auf manche kommen wir vielleicht im Laufe des Kurses noch zu sprechen. Andere sind vielleicht zu einem sp√§teren Zeitpunkt interessant, wenn du anspruchsvolleren Git Projekten arbeitest.","code":""},{"path":"r-markdown.html","id":"r-markdown","chapter":"Kapitel 4 R Markdown","heading":"Kapitel 4 R Markdown","text":"Ausgew√§hlte Hausaufgaben wirst du als R Markdown Dokument abgeben. R Markdown ist eine sehr zug√§ngliche Methode zur Erstellung von Dokumenten, die Prosa Text mit durch R-Code erzeugten Tabellen und Abbildungen kombinieren.Ein m√∂glicher R Markdown Workflow, der eine Interaktion mit Git, GitHub, und RStudio beinhaltet, wird vorgestellt auf der Seite:Test drive R Markdown","code":""},{"path":"basic-data-care.html","id":"basic-data-care","chapter":"Kapitel 5 Letzte Vorbereitungen ‚Ä¶","heading":"Kapitel 5 Letzte Vorbereitungen ‚Ä¶","text":"Jetzt ist es der Zeit, sich zu vergewissern welchem Verzeichnis auf deinem Computer du dich befindest. Falls du ein RStudio Projekt nutzt, sollte diese Frage leicht zu beantworten sein. Falls du trotzdem unsicher bist, gib getwd() der Konsole ein, um das aktuelle Arbeitsverzeichnis zu sehen.Alle nachfolgenden Code Beispiele wollen wir abspeichern einer .R Datei, die wir im aktuellen Arbeitsverzeichnis abspeichern wollen. Idealerweise geben wir dieser Datei noch einen Namen, wie etwa datenanalyse_teil_1.R, der uns schon viel √ºber den m√∂glichen Inhalt erz√§hlt.\nAlternativ k√∂nnen wir alle Befehle nat√ºrlich auch eine R Markdown Datei schreiben, siehe Test drive R Markdown.Prinzipiell geht es den folgenden Abschnitten um Datenmanagement. Es werden aber auch immer wieder ein paar Grafiken zu sehen sein. Dies ist aber kein Problem, da wir ja bereits den Data Visualization Basics Primerbesucht haben und den n√∂tigen Background haben.","code":""},{"path":"basic-data-care.html","id":"data-frames-sind-fantastisch","chapter":"Kapitel 5 Letzte Vorbereitungen ‚Ä¶","heading":"5.1 Data Frames sind fantastisch","text":"Das Standardformat f√ºr Daten ist ein data frame. Die meisten Funktionen zur Inferenz, Modellierung und graphischen Darstellung erwarten, dass ihnen √ºber ein data = Argument ein data frame √ºbergeben wird. Dies gilt f√ºr die Basis R schon seit langem.Die als tidyverse bekannte Kollektion von Paketen geht noch einen Schritt weiter und priorisiert ausdr√ºcklich die Verarbeitung von data frames. Tats√§chlich priorisiert tidyverse eine besondere Art von data frames, die als ‚Äútibble‚Äù bezeichnet wird.Data frames - im Gegensatz zu allgemeinen Arrays oder speziell Matrizen R - k√∂nnen Variablen unterschiedlicher Typen enthalten, wie z. B. Textdaten (Subjekt-ID oder Name), quantitative Daten (Anzahl der wei√üen Blutk√∂rperchen) und kategoriale Informationen (behandelt vs.¬†unbehandelt). Genauer gesagt k√∂nnen data frames unterschiedliche Spalten aus unterschiedlichen Datentypen bestehen. Innerhalb einer Spalte m√ºssen aber alle Eintr√§ge vom gleichen Typ sein.Daten aus einer Datenanalyse bestehen immer aus mehr als einem Datentyp. Aus diesem Grund k√∂nnen Matrizen oder Arrays nicht zur Datenanalyse verwendet werden, da man sonst mit verschiedenen, unverbundenen Objekten (Matrizen, Arrays) arbeiten m√ºsste und diese nur schwer koordinieren kann.","code":""},{"path":"basic-data-care.html","id":"gapminder-data","chapter":"Kapitel 5 Letzte Vorbereitungen ‚Ä¶","heading":"5.2 Gapminder data","text":"Wir werden mit einigen der Daten aus dem [Gapminder-Projekt] (https://www.gapminder.org)arbeiten. Die Daten sind im gapminder Paket enthalten, welches wir √ºber CRAN installieren k√∂nnen:Um die Daten zu verwenden, m√ºssen wir das Paket nat√ºrlich auch noch laden","code":"> install.packages(\"gapminder\")> library(gapminder)"},{"path":"basic-data-care.html","id":"die-gapminder-daten-sind-ein-tibble","chapter":"Kapitel 5 Letzte Vorbereitungen ‚Ä¶","heading":"5.3 Die gapminder Daten sind ein ‚Äútibble‚Äù","text":"Durch das Laden des gapminder Pakets haben wir nun Zugriff auf einen Datenobjekt mit demselben Namen. Schau dir nun mithilfe der Funktion str() die Struktur des Objekts .str() liefert eine vern√ºnftige Beschreibung von fast allem, und im schlimmsten Fall kann tats√§chlich auch nichts ‚ÄúSchlimmes‚Äù passieren. Aus dem Output erkennen wir, dass der Datensatz 1704 Beobachtungen enth√§lt.Auf der anderen Seite h√§tten wir durch direkten Aufruf von gapminder den Inhalt auch direkt auf den Bildschirm schreiben k√∂nnen. Aber vielleicht hast du schon mal einen gr√∂√üeren Datensatz aufgerufen und z√∂gerst nun etwas, da gro√üe Datens√§tze einfach die Konsole f√ºllen und nur sehr wenig Einblick bieten.Dies ist der erste gro√üe Sieg f√ºr tibbles. Tidyverse bietet eine spezielle data frame Variante : ein ‚Äútibble‚Äù. Dies wird auch verdeutlicht, wenn man sich z.B. die Klasse des gapminder Objekts anschautSchau, es ist immer noch ein regul√§res data frame, aber eben auch ein tibble.Jetzt k√∂nnen wir gapminder einfach auf den Bildschirm anzeigen! Da es sich um ein tibble handelt, wird nur das Wichtigste angezeigt und deine Konsole l√§uft nicht voll.Wenn du mit einem reinen data frame arbeitest - und dieses Feature magst - kannst du es mit as_tibble() ein tibble transformieren.Weitere M√∂glichkeiten, grundlegende Informationen zu einem data frame abzufragen:Ein bisschen deskriptive Statistik zum Inhalt eines data frames erh√§ltst du mit summary():Bemerkung: summary() ist eine generische Funktion. F√ºr eine gegebene Klasse (des Inputs) bestimmt die generische Funktion die passende Methode. Die Funktion summary() besitzt die folgenden Methoden:Obwohl wir uns formell noch nicht eingehender mit der Visualisierung besch√§ftigt haben, ist es wichtig ein paar Grafiken zu erzeugen um einen ersten Eindruck √ºber den Datensatz zu bekommen. Auf der anderen Seite werden die Grafiken aber auch nicht (viel) aufwendiger als im Data Visualisation Basics PrimerGrafiken dieser Art werden wir zu einem sp√§teren Zeitpunkt noch genauer behandeln. Dann sprechen wir auch √ºber deren Inhalt.Wir schauen uns nochmal die Ausgabe von str() , um dar√ºber zu sprechen, ein data frame genau ist.Ein data frame ist ein Sonderfall einer Liste, die R verwendet wird, um gut wie alles aufzunehmen. Data frames sind ein Spezialfall, bei dem die L√§nge jedes Listenelements gleich ist.Nehmen wir mal , dass wir eine Beschreibung der Variablenzusammen mit den Daten abspeichern wollen. Dazu k√∂nnten wir ein tibbleerzeugen, das die Beschreibungen enth√§lt. Dieses data frame hat nun die Dimension 6x2. Trotzdem k√∂nnen wir es mit gapminder kombinieren, wenn wir beide tibbles einer Liste abspeichern","code":"> str(gapminder)\n## tibble [1,704 √ó 6] (S3: tbl_df/tbl/data.frame)\n##  $ country  : Factor w/ 142 levels \"Afghanistan\",..: 1 1 1 1 1 1 1 1 1 1 ...\n##  $ continent: Factor w/ 5 levels \"Africa\",\"Americas\",..: 3 3 3 3 3 3 3 3 3 3 ...\n##  $ year     : int [1:1704] 1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 ...\n##  $ lifeExp  : num [1:1704] 28.8 30.3 32 34 36.1 ...\n##  $ pop      : int [1:1704] 8425333 9240934 10267083 11537966 13079460 14880372..\n##  $ gdpPercap: num [1:1704] 779 821 853 836 740 ...> class(gapminder)\n## [1] \"tbl_df\"     \"tbl\"        \"data.frame\"> gapminder\n## # A tibble: 1,704 x 6\n##    country     continent  year lifeExp      pop gdpPercap\n##    <fct>       <fct>     <int>   <dbl>    <int>     <dbl>\n##  1 Afghanistan Asia       1952    28.8  8425333      779.\n##  2 Afghanistan Asia       1957    30.3  9240934      821.\n##  3 Afghanistan Asia       1962    32.0 10267083      853.\n##  4 Afghanistan Asia       1967    34.0 11537966      836.\n##  5 Afghanistan Asia       1972    36.1 13079460      740.\n##  6 Afghanistan Asia       1977    38.4 14880372      786.\n##  7 Afghanistan Asia       1982    39.9 12881816      978.\n##  8 Afghanistan Asia       1987    40.8 13867957      852.\n##  9 Afghanistan Asia       1992    41.7 16317921      649.\n## 10 Afghanistan Asia       1997    41.8 22227415      635.\n## # ‚Ä¶ with 1,694 more rows> library(tidyverse)\n> as_tibble(iris)\n## # A tibble: 150 x 5\n##    Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n##           <dbl>       <dbl>        <dbl>       <dbl> <fct>  \n##  1          5.1         3.5          1.4         0.2 setosa \n##  2          4.9         3            1.4         0.2 setosa \n##  3          4.7         3.2          1.3         0.2 setosa \n##  4          4.6         3.1          1.5         0.2 setosa \n##  5          5           3.6          1.4         0.2 setosa \n##  6          5.4         3.9          1.7         0.4 setosa \n##  7          4.6         3.4          1.4         0.3 setosa \n##  8          5           3.4          1.5         0.2 setosa \n##  9          4.4         2.9          1.4         0.2 setosa \n## 10          4.9         3.1          1.5         0.1 setosa \n## # ‚Ä¶ with 140 more rows> names(gapminder)\n## [1] \"country\"   \"continent\" \"year\"      \"lifeExp\"   \"pop\"       \"gdpPercap\"\n> ncol(gapminder)\n## [1] 6\n> length(gapminder)\n## [1] 6\n> dim(gapminder)\n## [1] 1704    6\n> nrow(gapminder)\n## [1] 1704> summary(gapminder)\n##         country        continent        year         lifeExp    \n##  Afghanistan:  12   Africa  :624   Min.   :1952   Min.   :23.6  \n##  Albania    :  12   Americas:300   1st Qu.:1966   1st Qu.:48.2  \n##  Algeria    :  12   Asia    :396   Median :1980   Median :60.7  \n##  Angola     :  12   Europe  :360   Mean   :1980   Mean   :59.5  \n##  Argentina  :  12   Oceania : 24   3rd Qu.:1993   3rd Qu.:70.8  \n##  Australia  :  12                  Max.   :2007   Max.   :82.6  \n##  (Other)    :1632                                               \n##       pop             gdpPercap     \n##  Min.   :6.00e+04   Min.   :   241  \n##  1st Qu.:2.79e+06   1st Qu.:  1202  \n##  Median :7.02e+06   Median :  3532  \n##  Mean   :2.96e+07   Mean   :  7215  \n##  3rd Qu.:1.96e+07   3rd Qu.:  9325  \n##  Max.   :1.32e+09   Max.   :113523  \n## > methods(summary)\n##  [1] summary,ANY-method             summary,DBIObject-method      \n##  [3] summary.aov                    summary.aovlist*              \n##  [5] summary.aspell*                summary.check_packages_in_dir*\n##  [7] summary.connection             summary.data.frame            \n##  [9] summary.Date                   summary.default               \n## [11] summary.Duration*              summary.ecdf*                 \n## [13] summary.factor                 summary.ggplot*               \n## [15] summary.glm                    summary.haven_labelled*       \n## [17] summary.hcl_palettes*          summary.infl*                 \n## [19] summary.Interval*              summary.lm                    \n## [21] summary.loess*                 summary.manova                \n## [23] summary.matrix                 summary.mlm*                  \n## [25] summary.nls*                   summary.packageStatus*        \n## [27] summary.Period*                summary.POSIXct               \n## [29] summary.POSIXlt                summary.ppr*                  \n## [31] summary.prcomp*                summary.princomp*             \n## [33] summary.proc_time              summary.rlang_error*          \n## [35] summary.rlang_trace*           summary.srcfile               \n## [37] summary.srcref                 summary.stepfun               \n## [39] summary.stl*                   summary.table                 \n## [41] summary.tukeysmooth*           summary.vctrs_sclr*           \n## [43] summary.vctrs_vctr*            summary.warnings              \n## see '?methods' for accessing help and source code> ggplot(gapminder, mapping = aes(x = year, y = lifeExp)) +\n+          geom_point()> ggplot(gapminder, mapping = aes(x = gdpPercap, y = lifeExp)) +\n+          geom_point()> ggplot(gapminder, mapping = aes(x = log(gdpPercap), y = lifeExp)) +\n+          geom_point()> str(gapminder)\n## tibble [1,704 √ó 6] (S3: tbl_df/tbl/data.frame)\n##  $ country  : Factor w/ 142 levels \"Afghanistan\",..: 1 1 1 1 1 1 1 1 1 1 ...\n##  $ continent: Factor w/ 5 levels \"Africa\",\"Americas\",..: 3 3 3 3 3 3 3 3 3 3 ...\n##  $ year     : int [1:1704] 1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 ...\n##  $ lifeExp  : num [1:1704] 28.8 30.3 32 34 36.1 ...\n##  $ pop      : int [1:1704] 8425333 9240934 10267083 11537966 13079460 14880372..\n##  $ gdpPercap: num [1:1704] 779 821 853 836 740 ...> names(gapminder)\n## [1] \"country\"   \"continent\" \"year\"      \"lifeExp\"   \"pop\"       \"gdpPercap\"> (desc <- tibble(variables = names(gapminder),\n+                desc = c(\"factor with 142 levels\", \"factor with 5 levels\",\n+                         \"ranges from 1952 to 2007 in increments of 5 years\",\n+                         \"life expectancy at birth, in years\",\n+                         \"population\",\"GDP per capita (US$, inflation-adjusted)\")))\n## # A tibble: 6 x 2\n##   variables desc                                             \n##   <chr>     <chr>                                            \n## 1 country   factor with 142 levels                           \n## 2 continent factor with 5 levels                             \n## 3 year      ranges from 1952 to 2007 in increments of 5 years\n## 4 lifeExp   life expectancy at birth, in years               \n## 5 pop       population                                       \n## 6 gdpPercap GDP per capita (US$, inflation-adjusted)> gapminder_desc <- list(gapminder, desc)\n> str(gapminder_desc)\n## List of 2\n##  $ : tibble [1,704 √ó 6] (S3: tbl_df/tbl/data.frame)\n##   ..$ country  : Factor w/ 142 levels \"Afghanistan\",..: 1 1 1 1 1 1 1 1 1 1 ...\n##   ..$ continent: Factor w/ 5 levels \"Africa\",\"Americas\",..: 3 3 3 3 3 3 3 3 3 ..\n##   ..$ year     : int [1:1704] 1952 1957 1962 1967 1972 1977 1982 1987 1992 199..\n##   ..$ lifeExp  : num [1:1704] 28.8 30.3 32 34 36.1 ...\n##   ..$ pop      : int [1:1704] 8425333 9240934 10267083 11537966 13079460 14880..\n##   ..$ gdpPercap: num [1:1704] 779 821 853 836 740 ...\n##  $ : tibble [6 √ó 2] (S3: tbl_df/tbl/data.frame)\n##   ..$ variables: chr [1:6] \"country\" \"continent\" \"year\" \"lifeExp\" ...\n##   ..$ desc     : chr [1:6] \"factor with 142 levels\" \"factor with 5 levels\" \"r\".."},{"path":"basic-data-care.html","id":"variablen-in-einem-data-frame","chapter":"Kapitel 5 Letzte Vorbereitungen ‚Ä¶","heading":"5.4 Variablen in einem Data Frame","text":"Um eine einzelne Variable aus einem data frame anzusprechen, kann man mit dem Dollarzeichen $ arbeiten. Wir schauen uns dazu die numerische Variable lifeExp .Zus√§tzlich wollen wir die noch die Verteilung von lifeExp visualisieren und plotten dazu ein Histogramm. Da wir dazu ggplot() verwenden, k√∂nnen wir lifeExp wieder direkt aufrufen.Alternativ k√∂nnen wir die Eintr√§ge eines data frames auch √ºber die eckigen Klammern [] indizieren.Dabei spezifiziert der Eintrag links vom Komma die Zeilen und der Wert rechts davon die Spalten. Dies ist hilfreich, wenn man auf einzelne Werte zugreifen . Aber beim Aufruf einer kompletten Variable (Spalte) ist die $ Notation sicherlich vorteilhaft.Die Variable year ist eine ganzzahlige Variable, aber da es wenige unterschiedliche Werte gibt, funktioniert sie auch ein wenig wie eine kategoriale Variable.Die Variablen country und continent enthalten rein kategorische Informationen, die R (h√§ufig) als factor gespeichert werden.Die Levels von continent sind ‚ÄúAfrika‚Äù, ‚ÄúAmerica‚Äù usw., und das ist es, einem normalerweise R angezeigt werden sollte, wenn man eine Faktorvariable aufruft. Im Allgemeinen sind die Levels von Menschen lesbare Zeichenfolgen, wie ‚Äúmale/female‚Äù und ‚Äúcontrol/treated‚Äù. Aber vergiss niemals, dass R diese Information kodierter Form speichert. Schauen dir zum Beispiel das Ergebnis von str(gapminder$continent) , falls du skeptisch sein solltest.Faktorvariablen haben Vor- und Nachteil. Im weiteren Verlauf zeigen wir sowohl die Vor- wie auch die Nachteile. Generell ist aber durchaus , dass die Vorteile √ºberwiegen.Als N√§chstes erstellen wir mit der Funktion table() eine H√§ufigkeitstabelle f√ºr die Variable count. Dieser Inhalt wird anschlie√üend visualisiert √ºber die Funktion geom_bar(). Die entsprechende Berechnung der H√§ufigkeitstabelle wird dabei aber sowohl von table() wie auch von geom_bar() (√ºber die statistische Transformation stat_count()) durchgef√ºhrt, oder anders gesagt, wir k√∂nnen geom_bar() den Datensatz (hier gapminder) anstatt von vorab berechneten Werten √ºbergeben.den folgenden Abbildungen sehen wir, wie Faktoren Zahlen umgesetzt werden k√∂nnen. Der continent-Faktor l√§sst sich durch das ggplot2-Paket leicht ‚ÄúFacetten‚Äù oder Farben und eine Legende abbilden.Die Erstellung von Grafiken mit ggplot2 werden wir noch genauer besprechen. Daher kannst du dich also ruhig zur√ºcklehnen und die Plots genie√üen oder blind kopieren/einf√ºgen.","code":"> head(gapminder$lifeExp)\n## [1] 28.8 30.3 32.0 34.0 36.1 38.4\n> summary(gapminder$lifeExp)\n##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n##    23.6    48.2    60.7    59.5    70.8    82.6> ggplot(gapminder, mapping = aes(x = lifeExp)) + \n+   geom_histogram()\n## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.> summary(gapminder[,\"lifeExp\"])\n##     lifeExp    \n##  Min.   :23.6  \n##  1st Qu.:48.2  \n##  Median :60.7  \n##  Mean   :59.5  \n##  3rd Qu.:70.8  \n##  Max.   :82.6> summary(gapminder$year)\n##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n##    1952    1966    1980    1980    1993    2007\n> table(gapminder$year)\n## \n## 1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 2002 2007 \n##  142  142  142  142  142  142  142  142  142  142  142  142> class(gapminder$continent)\n## [1] \"factor\"\n> summary(gapminder$continent)\n##   Africa Americas     Asia   Europe  Oceania \n##      624      300      396      360       24\n> levels(gapminder$continent)\n## [1] \"Africa\"   \"Americas\" \"Asia\"     \"Europe\"   \"Oceania\"\n> nlevels(gapminder$continent)\n## [1] 5> str(gapminder$continent)\n##  Factor w/ 5 levels \"Africa\",\"Americas\",..: 3 3 3 3 3 3 3 3 3 3 ...> table(gapminder$continent)\n## \n##   Africa Americas     Asia   Europe  Oceania \n##      624      300      396      360       24\n> ggplot(gapminder, aes(x = continent)) + geom_bar()> # wir initialisieren ein grafik (ohne inhalt)\n> p <- ggplot(filter(gapminder, continent != \"Oceania\"),\n+             aes(x = gdpPercap, y = lifeExp))  \n> p <- p + scale_x_log10() # auf der x-achse soll eine log skala verwendet werden\n> p + geom_point() # ein scatterplot\n> p + geom_point(aes(color = continent)) # f√ºr verschiedene kontinente werden verschiedene farben verwendet\n> p + geom_point(alpha = (1/3), size = 3) + # punkte mit transparenz\n+   geom_smooth(lwd = 3, se = FALSE) # gegl√§tter zusammenhang\n## `geom_smooth()` using method = 'gam' and formula 'y ~ s(x, bs = \"cs\")'\n> p + geom_point(alpha = (1/3), size = 3) + \n+   facet_wrap(~ continent) + # f√ºr jeden kontinent wird eine eigener\n+   # plot (innerhalb einer grafik) erzeugt\n+   geom_smooth(lwd = 1.5, se = FALSE)\n## `geom_smooth()` using method = 'loess' and formula 'y ~ x'"},{"path":"basic-data-care.html","id":"recap","chapter":"Kapitel 5 Letzte Vorbereitungen ‚Ä¶","heading":"5.5 Recap","text":"Benutze data frames!!!Benutze data frames!!!Benutze tidyverse!!! Dadurch wird eine spezielle Art von data frames, ein ‚Äútibble‚Äù, bereitgestellt, die neben anderen Vorteilen ein nettes Standarddruckverhalten aufweist.Benutze tidyverse!!! Dadurch wird eine spezielle Art von data frames, ein ‚Äútibble‚Äù, bereitgestellt, die neben anderen Vorteilen ein nettes Standarddruckverhalten aufweist.Im Zweifelsfall kannst du dir immer Inhalte anzeigen lassen √ºber str() oder im Fall eines tibbles, einfach das tibble selbst aufrufen.Im Zweifelsfall kannst du dir immer Inhalte anzeigen lassen √ºber str() oder im Fall eines tibbles, einfach das tibble selbst aufrufen.Sei dir immer √ºber die Anzahl Zeilen und Spalten deiner data frames bewusst.Sei dir immer √ºber die Anzahl Zeilen und Spalten deiner data frames bewusst.Sei dir im Klaren welche Art (numerisch, kategorial, ‚Ä¶) von Variablen deinen data frames enthalten sind.Sei dir im Klaren welche Art (numerisch, kategorial, ‚Ä¶) von Variablen deinen data frames enthalten sind.Benutze factors!!! Aber mach das bewusst und mit Vorsicht.Benutze factors!!! Aber mach das bewusst und mit Vorsicht.F√ºhre f√ºr jede Variable eine grundlegende statistische und visuelle √úberpr√ºfung durch.F√ºhre f√ºr jede Variable eine grundlegende statistische und visuelle √úberpr√ºfung durch.Ruf Variablen mit ihrem Namen auf, z.B. gapminder$lifeExp, nicht mit der Spaltennummer. Dein Code wird dadurch robuster und lesbarer sein.Ruf Variablen mit ihrem Namen auf, z.B. gapminder$lifeExp, nicht mit der Spaltennummer. Dein Code wird dadurch robuster und lesbarer sein.","code":""},{"path":"dplyr-intro.html","id":"dplyr-intro","chapter":"Kapitel 6 Einf√ºhrung in dplyr","heading":"Kapitel 6 Einf√ºhrung in dplyr","text":"","code":""},{"path":"dplyr-intro.html","id":"einstieg","chapter":"Kapitel 6 Einf√ºhrung in dplyr","heading":"6.1 Einstieg","text":"dplyr ist ein Paket zur Datenmanipulation, entwickelt von Hadley Wickham und Romain Francois. erster Linie es schnell und ausdrucksstark sein. Es wird als Teil des ‚ÄúMetapakets‚Äù tidyverse installiert und geh√∂rt als Kernpaket zu den Paketen, die √ºber library(tidyverse) geladen werden.Die Wurzeln von dplyr liegen einem fr√ºheren Paket mit dem Namen plyr, das zum Ziel hat die ‚Äúsplit-apply-combine‚Äù-Strategie der Datenanalyse (Wickham 2011) umzusetzen. Wo plyr noch einen vielf√§ltigen Satz von Ein- und Ausgaben abdeckt (z.B. Arrays, data frames, Listen), hat dplyr einen klaren Fokus auf data frames oder, im Tidyverse, tibbles.dplyr bietet schnelle Alternativen zu den R Standardfunktionen: subset(), apply(), [sl]apply(), tapply(), aggregate(), split(), .call(), (), within(), und mehr. Ferner kann man dplyr nutzen um √ºber Zeilen oder Gruppen von Zeilen zu iterieren, eine schnelle Alternative zur Nutzung von Schleifen darstellt.","code":""},{"path":"dplyr-intro.html","id":"wie-immer-laden-wir-zu-beginn-tidyverse","chapter":"Kapitel 6 Einf√ºhrung in dplyr","heading":"6.1.1 Wie immer, laden wir zu Beginn tidyverse","text":"Der Fokus liegt diesem Abschnitt auf dplyr. Aber da wir immer wieder auch Funktionen aus anderen ‚Äútidyverse-Paketen‚Äù nutzen, laden wir stets tidyverse.Zus√§tzlich wollen wir auch noch gapminder laden.","code":"> library(tidyverse)\n## ‚îÄ‚îÄ Attaching packages ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ tidyverse 1.3.1 ‚îÄ‚îÄ\n## ‚úì ggplot2 3.3.5     ‚úì purrr   0.3.4\n## ‚úì tibble  3.1.2     ‚úì dplyr   1.0.7\n## ‚úì tidyr   1.1.3     ‚úì stringr 1.4.0\n## ‚úì readr   2.0.1     ‚úì forcats 0.5.1\n## ‚îÄ‚îÄ Conflicts ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ tidyverse_conflicts() ‚îÄ‚îÄ\n## x dplyr::filter() masks stats::filter()\n## x dplyr::lag()    masks stats::lag()> library(gapminder)"},{"path":"dplyr-intro.html","id":"filter-indizieren-von-zeilen","chapter":"Kapitel 6 Einf√ºhrung in dplyr","heading":"6.2 filter(): Indizieren von Zeilen","text":"filter() nimmt logische Ausdr√ºcke und gibt die Zeilen zur√ºck, f√ºr die der logische Ausdruck ein TRUE ergibt.Zum Vergleich kann man sich einen R Standardbefehl anschauen, der zum gleichen Ergebnis f√ºhrt:Unter keinen Umst√§nden solltest du allerdings deine Daten unterteilen, wie hier:Warum ist das eine bl√∂de Idee?Es ist nicht selbstdokumentierend. ist das Besondere den Zeilen 241 bis 252?Es ist fehleranf√§llig. Diese Codezeile wird zu anderen Ergebnissen f√ºhren, wenn jemand die Zeilenreihenfolge von gapminder √§ndert, z.B. die Daten fr√ºher im Skript sortiert.Dieser Aufruf erkl√§rt sich von selbst und ist ziemlich robust.","code":"> filter(gapminder, lifeExp < 29)\n## # A tibble: 2 x 6\n##   country     continent  year lifeExp     pop gdpPercap\n##   <fct>       <fct>     <int>   <dbl>   <int>     <dbl>\n## 1 Afghanistan Asia       1952    28.8 8425333      779.\n## 2 Rwanda      Africa     1992    23.6 7290203      737.\n> filter(gapminder, country == \"Rwanda\", year > 1979)\n## # A tibble: 6 x 6\n##   country continent  year lifeExp     pop gdpPercap\n##   <fct>   <fct>     <int>   <dbl>   <int>     <dbl>\n## 1 Rwanda  Africa     1982    46.2 5507565      882.\n## 2 Rwanda  Africa     1987    44.0 6349365      848.\n## 3 Rwanda  Africa     1992    23.6 7290203      737.\n## 4 Rwanda  Africa     1997    36.1 7212583      590.\n## 5 Rwanda  Africa     2002    43.4 7852401      786.\n## 6 Rwanda  Africa     2007    46.2 8860588      863.\n> filter(gapminder, country %in% c(\"Rwanda\", \"Afghanistan\"))\n## # A tibble: 24 x 6\n##    country     continent  year lifeExp      pop gdpPercap\n##    <fct>       <fct>     <int>   <dbl>    <int>     <dbl>\n##  1 Afghanistan Asia       1952    28.8  8425333      779.\n##  2 Afghanistan Asia       1957    30.3  9240934      821.\n##  3 Afghanistan Asia       1962    32.0 10267083      853.\n##  4 Afghanistan Asia       1967    34.0 11537966      836.\n##  5 Afghanistan Asia       1972    36.1 13079460      740.\n##  6 Afghanistan Asia       1977    38.4 14880372      786.\n##  7 Afghanistan Asia       1982    39.9 12881816      978.\n##  8 Afghanistan Asia       1987    40.8 13867957      852.\n##  9 Afghanistan Asia       1992    41.7 16317921      649.\n## 10 Afghanistan Asia       1997    41.8 22227415      635.\n## # ‚Ä¶ with 14 more rows> gapminder[gapminder$lifeExp < 29, ] \n> subset(gapminder, country == \"Rwanda\" & year > 1979) ## subset funktioniert √§hnlich wir filter> auswahl <- gapminder[241:252, ]> filter(gapminder, country == \"Canada\")"},{"path":"dplyr-intro.html","id":"der-pipe-operator","chapter":"Kapitel 6 Einf√ºhrung in dplyr","heading":"6.3 Der Pipe-Operator","text":"Bevor es weitergeht, wollen wir aber den Pipe-Operator, den das Tidyverse aus dem magrittr-Paket von Stefan Bache importiert, vorstellen. Mithilfe des Pipe-Operators ist man der Lage Befehle f√ºr mehrere Operationen auszuf√ºhren, ohne sie ineinander zu verschachteln. Diese neue Syntax f√ºhrt zu Code, der viel einfacher zu schreiben und zu lesen ist.Und sieht er aus: %>%. Das entsprechende RStudio Tastenk√ºrzel lautet: Ctrl+Shift+M (Windows), Cmd+Shift+M (Mac).Erstmal ein BeispielDu siehst, der Befehl ist √§quivalent zu head(gapminder). Der Pipe-Operator nimmt das Objekt auf der linken Seite und leitet es den Funktionsaufruf auf der rechten Seite weiter - er gibt es buchst√§blich als erstes Argument ein.Keine Angst, du kannst immer noch weitere Argumente f√ºr die Funktion auf der rechten Seite angeben! Um die ersten 3 Reihen von gapminder zu sehen, k√∂nnte man sagen: head(gapminder, 3) oder:Du bist wahrscheinlich noch nicht sehr beeindruckt, aber das sollte sich noch √§ndern.","code":"> gapminder %>% head()\n## # A tibble: 6 x 6\n##   country     continent  year lifeExp      pop gdpPercap\n##   <fct>       <fct>     <int>   <dbl>    <int>     <dbl>\n## 1 Afghanistan Asia       1952    28.8  8425333      779.\n## 2 Afghanistan Asia       1957    30.3  9240934      821.\n## 3 Afghanistan Asia       1962    32.0 10267083      853.\n## 4 Afghanistan Asia       1967    34.0 11537966      836.\n## 5 Afghanistan Asia       1972    36.1 13079460      740.\n## 6 Afghanistan Asia       1977    38.4 14880372      786.> gapminder %>% head(3)\n## # A tibble: 3 x 6\n##   country     continent  year lifeExp      pop gdpPercap\n##   <fct>       <fct>     <int>   <dbl>    <int>     <dbl>\n## 1 Afghanistan Asia       1952    28.8  8425333      779.\n## 2 Afghanistan Asia       1957    30.3  9240934      821.\n## 3 Afghanistan Asia       1962    32.0 10267083      853."},{"path":"dplyr-intro.html","id":"mit-select-variablen-ausw√§hlen","chapter":"Kapitel 6 Einf√ºhrung in dplyr","heading":"6.4 Mit select() Variablen ausw√§hlen","text":"Nun zur√ºck zu dplyr‚Ä¶.Verwende select(), um aus den Daten verschiedene Variablen (Spalten) auszuw√§hlen. Hier kommt eine typische Verwendung von select():Und nun noch kombiniert mit head() √ºber den Pipe-Operator:Worten: ‚ÄúNimm gapminder, w√§hle die Variablen year und lifeExp und zeige dann die ersten 4 Zeilen .‚Äù","code":"> select(gapminder, year, lifeExp)\n## # A tibble: 1,704 x 2\n##     year lifeExp\n##    <int>   <dbl>\n##  1  1952    28.8\n##  2  1957    30.3\n##  3  1962    32.0\n##  4  1967    34.0\n##  5  1972    36.1\n##  6  1977    38.4\n##  7  1982    39.9\n##  8  1987    40.8\n##  9  1992    41.7\n## 10  1997    41.8\n## # ‚Ä¶ with 1,694 more rows> gapminder %>%\n+   select(year, lifeExp) %>%\n+   head(4)\n## # A tibble: 4 x 2\n##    year lifeExp\n##   <int>   <dbl>\n## 1  1952    28.8\n## 2  1957    30.3\n## 3  1962    32.0\n## 4  1967    34.0"},{"path":"dplyr-intro.html","id":"jetzt-nochmal-ein-vergleich-zu-r-standardbefehlen","chapter":"Kapitel 6 Einf√ºhrung in dplyr","heading":"6.5 Jetzt nochmal ein Vergleich zu R Standardbefehlen","text":"Hier sind die Daten f√ºr Kambodscha, aber nur bestimmte Variablen:und w√ºrde ein typischer R Standardbefehl aussehen:der zum gleichen Ergebnis f√ºhrt. Wir w√ºrden sagen, dass der dplyr Befehl deutlich leichter zu lesen ist.","code":"> gapminder %>%\n+   filter(country == \"Cambodia\") %>%\n+   select(year, lifeExp)\n## # A tibble: 12 x 2\n##     year lifeExp\n##    <int>   <dbl>\n##  1  1952    39.4\n##  2  1957    41.4\n##  3  1962    43.4\n##  4  1967    45.4\n##  5  1972    40.3\n##  6  1977    31.2\n##  7  1982    51.0\n##  8  1987    53.9\n##  9  1992    55.8\n## 10  1997    56.5\n## 11  2002    56.8\n## 12  2007    59.7> gapminder[gapminder$country == \"Cambodia\", c(\"year\", \"lifeExp\")]\n## # A tibble: 12 x 2\n##     year lifeExp\n##    <int>   <dbl>\n##  1  1952    39.4\n##  2  1957    41.4\n##  3  1962    43.4\n##  4  1967    45.4\n##  5  1972    40.3\n##  6  1977    31.2\n##  7  1982    51.0\n##  8  1987    53.9\n##  9  1992    55.8\n## 10  1997    56.5\n## 11  2002    56.8\n## 12  2007    59.7"},{"path":"dplyr-intro.html","id":"pure-predictable-pipeable","chapter":"Kapitel 6 Einf√ºhrung in dplyr","heading":"6.6 Pure, predictable, pipeable","text":"Bisher haben wir nur etwas der Oberfl√§che von dplyr gekratzt, trotzdem m√∂chten wir auf ein Schl√ºsselprinzipien hinweisen, die du vielleicht langsam zu sch√§tzen lernen wirst.Die Verben (Hauptfunktionen) von dplyr, wie z.B. filter() und select(), sind pure functions. Dazu schreibt Hadley Wickham Functions chapter seinem Advanced R Buch (2015a):functions easiest understand reason pure functions: functions always map input output impact workspace. words, pure functions side effects: don‚Äôt affect state world way apart value return.Tats√§chlich sind diese Verben ein Spezialfall reiner Funktionen: sie nehmen als Input und Output denselben Objekttyp , .d.R. ein data frame.Die Daten sind f√ºr diese Funktionen aus stets das erste Inputargument.Die dplyr Einf√ºhrung geht weiter im Kapitel Mehr zu dplyr.","code":""},{"path":"dplyr-single.html","id":"dplyr-single","chapter":"Kapitel 7 Mehr zu dplyr","heading":"Kapitel 7 Mehr zu dplyr","text":"","code":""},{"path":"dplyr-single.html","id":"wo-stehen-wir","chapter":"Kapitel 7 Mehr zu dplyr","heading":"7.1 Wo stehen wir?","text":"Kapitel 6, Einf√ºhrung dplyr, haben wir bereits zwei sehr wichtige Verben sowie einen Operator vorgestellt und verwendet:filter() zum Ausw√§hlen spezieller Zeilen eines Datensatzesselect() zum Ausw√§hlen spezieller Variablen eines Datensatzesden Pipe-Operator %>%, der das Objekt auf der linken Seite √ºberf√ºhrt als erstes Funktionsargument der Funktion auf der rechten SeiteWir haben auch die Rolle von dplyr innerhalb des tidyverse besprochen:dplyr ist ein Kernpaket der tidyverse Kollektion von Paketen. Da wir die anderen oft beil√§ufig benutzen, werden wir stets dplyr und die anderen √ºber library(tidyverse) laden.","code":""},{"path":"dplyr-single.html","id":"falls-noch-nicht-geschehen-lade-dplyr-und-gapminder","chapter":"Kapitel 7 Mehr zu dplyr","heading":"7.2 Falls noch nicht geschehen: lade dplyr und gapminder","text":"Wir starten wieder mit dem Laden von dplyr (√ºber tidyverse)und gapminder","code":"> library(tidyverse)\n## ‚îÄ‚îÄ Attaching packages ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ tidyverse 1.3.1 ‚îÄ‚îÄ\n## ‚úì ggplot2 3.3.5     ‚úì purrr   0.3.4\n## ‚úì tibble  3.1.2     ‚úì dplyr   1.0.7\n## ‚úì tidyr   1.1.3     ‚úì stringr 1.4.0\n## ‚úì readr   2.0.1     ‚úì forcats 0.5.1\n## ‚îÄ‚îÄ Conflicts ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ tidyverse_conflicts() ‚îÄ‚îÄ\n## x dplyr::filter() masks stats::filter()\n## x dplyr::lag()    masks stats::lag()> library(gapminder)"},{"path":"dplyr-single.html","id":"mitmutate-neue-variablen-erstellen","chapter":"Kapitel 7 Mehr zu dplyr","heading":"7.3 Mitmutate() neue Variablen erstellen","text":"Wir starten mit dem Anlegen einer Kopie von gapminder, die wir dann nach unseren Vorstellungen ver√§ndern (w√§re aber auch nichts passiert, wenn wir alles mit gapminder durchf√ºhren w√ºrden).Unser Ziel ist es, dass GDP pro Land anzugeben. Das sollte machbar sein, da schlie√ülich das Pro-Kopf-GDP wie auch die Bev√∂lkerungszahl im Datensatz enthalten sind. Multiplizieren beider Variablen liefert uns das gew√ºnschte Ergebnis.mutate() ist eine Funktion, die neue Variablen definiert und ein tibble einf√ºgt. Du kannst auf bestehende Variablen einfach √ºber ihren Namen zugreifen.Hmmmm ‚Ä¶ diese GDP-Zahlen sind ziemlich gro√ü und abstrakt. dem Zusammenhang, bedenke den Ratschlag von Randall Munroe:One thing bothers large numbers presented without context‚Ä¶ ‚Äúadded zero number, sentence containing mean something different ?‚Äù answer ‚Äú‚Äù, maybe number business sentence first place.Vielleicht w√§re es f√ºr die Betrachter unseres tibbles sinnvoller, beim Pro-Kopf-GDP zu bleiben. Aber w√§re, wenn wir das Pro-Kopf-GDP angeben w√ºrde, Relation zu irgendeinem Vergleichsland. Wir k√∂nnten alles Bezug auf die entsprechenden Daten aus Deutschland angeben.Dazu m√ºssen wir eine neue Variable erstellen, die gdpPercap geteilt durch die deutschen gdpPercap Werte ist, wobei wir darauf achten m√ºssen, dass wir immer zwei Zahlen teilen, die sich auf dasselbe Jahr beziehen.Wie k√∂nnen wir das schaffen:Deutschland Beobachtungen einem Objekt ger_gap speichernErstellen Sie eine neue tempor√§re Variable tmp my_gap:\nDie gdpPercap-Variable aus tmp aufrufen.\nMit rep() die gdpPerap Wert aus tmp einmal pro Land im my_gap reproduzieren, damit ein Vektor, der die gleiche Anzahl Beobachtungen wie my_gap hat.\nDie gdpPercap-Variable aus tmp aufrufen.Mit rep() die gdpPerap Wert aus tmp einmal pro Land im my_gap reproduzieren, damit ein Vektor, der die gleiche Anzahl Beobachtungen wie my_gap hat.Dividieren der gdpPercap Werte durch die deutschen Zahlen.L√∂schen der tempor√§re Variable tmp my_gap.Beachte, dass mutate() neue Variablen sequentiell erstellt, dass du auf fr√ºhere Variablen (wie tmp) verweisen kannst um sp√§tere Variablen (wie gdpPercapRel) zu definieren. Nachdem eine Variable nicht mehr ben√∂tigt wird, kannst du sie einfach auf NULL setzen.Hat das funktioniert? Einfach mal die Werte von gdpPercapRel f√ºr Deutschland anschauen. Sollten besser alle 1 sein!Ich nehme Deutschland ist ein Land mit einem ‚Äúhohen GDP‚Äù pro Kopf, daher gehe ich davon aus, dass die Verteilung von gdpPercapRel unter 1 liegt, m√∂glicherweise sogar weit darunter. Aber besser mal nachschauen ob dem ist:Die Zahlen des relativen Pro-Kopf-GDP liegen im deutlich unter 1. Wir sehen, dass die meisten L√§nder, die diesem Datensatz erfasst werden, √ºber den gesamten Zeitraum im Vergleich zu Deutschland ein wesentlich niedrigeres Pro-Kopf-GDP aufweisen.Tipp: Vertraue niemandem. Einschlie√ülich (besonders?) dir selbst. Versuche immer, einen Weg zu finden, um zu √ºberpr√ºfen, ob du das gemacht hast, du tun wolltest. Sei nicht schockiert, wenn du manchmal feststellen musst, dass dem nicht ist.","code":"> my_gap <- gapminder> my_gap %>%\n+   mutate(gdp = pop * gdpPercap)\n## # A tibble: 1,704 x 7\n##    country     continent  year lifeExp      pop gdpPercap          gdp\n##    <fct>       <fct>     <int>   <dbl>    <int>     <dbl>        <dbl>\n##  1 Afghanistan Asia       1952    28.8  8425333      779.  6567086330.\n##  2 Afghanistan Asia       1957    30.3  9240934      821.  7585448670.\n##  3 Afghanistan Asia       1962    32.0 10267083      853.  8758855797.\n##  4 Afghanistan Asia       1967    34.0 11537966      836.  9648014150.\n##  5 Afghanistan Asia       1972    36.1 13079460      740.  9678553274.\n##  6 Afghanistan Asia       1977    38.4 14880372      786. 11697659231.\n##  7 Afghanistan Asia       1982    39.9 12881816      978. 12598563401.\n##  8 Afghanistan Asia       1987    40.8 13867957      852. 11820990309.\n##  9 Afghanistan Asia       1992    41.7 16317921      649. 10595901589.\n## 10 Afghanistan Asia       1997    41.8 22227415      635. 14121995875.\n## # ‚Ä¶ with 1,694 more rows> ger_gap <- my_gap %>%\n+   filter(country == \"Germany\")\n> \n> my_gap <- my_gap %>%\n+   mutate(tmp = rep(ger_gap$gdpPercap, nlevels(country)),\n+          gdpPercapRel = gdpPercap / tmp,\n+          tmp = NULL)> my_gap %>% \n+   filter(country == \"Germany\") %>% \n+   select(country, year, gdpPercapRel)\n## # A tibble: 12 x 3\n##    country  year gdpPercapRel\n##    <fct>   <int>        <dbl>\n##  1 Germany  1952            1\n##  2 Germany  1957            1\n##  3 Germany  1962            1\n##  4 Germany  1967            1\n##  5 Germany  1972            1\n##  6 Germany  1977            1\n##  7 Germany  1982            1\n##  8 Germany  1987            1\n##  9 Germany  1992            1\n## 10 Germany  1997            1\n## 11 Germany  2002            1\n## 12 Germany  2007            1> summary(my_gap$gdpPercapRel)\n##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n##    0.01    0.07    0.19    0.37    0.51   15.17"},{"path":"dplyr-single.html","id":"mit-arrange-die-zeilenreihenfolge-√§ndern","chapter":"Kapitel 7 Mehr zu dplyr","heading":"7.4 Mit arrange() die Zeilenreihenfolge √§ndern","text":"arrange() ordnet die Zeilen einem data frame neu . Stellen dir vor, du m√∂chtest die Daten nach Jahr und Land und nicht nach Land und Jahr geordnet haben.Oder vielleicht willst du nur die Daten aus 2007 sehen, angeordnet entsprechend der Lebenserwartung.Das war nicht du wolltest. Du wolltest nach absteigender Lebenserwartung sortieren. Dann verwende desc().Ein Tipp Ende: verlasse dich bei deinen Analysen NIEMALS darauf, dass Zeilen oder Variablen einer bestimmten Reihenfolge stehen. Aber manchmal man Tabellen anderen pr√§sentieren und dabei macht es durchaus Sinn die Zeilenreihenfolge je nach Fragestellung anzupassen.","code":"> my_gap %>%\n+   arrange(year, country)\n## # A tibble: 1,704 x 7\n##    country     continent  year lifeExp      pop gdpPercap gdpPercapRel\n##    <fct>       <fct>     <int>   <dbl>    <int>     <dbl>        <dbl>\n##  1 Afghanistan Asia       1952    28.8  8425333      779.       0.109 \n##  2 Albania     Europe     1952    55.2  1282697     1601.       0.224 \n##  3 Algeria     Africa     1952    43.1  9279525     2449.       0.343 \n##  4 Angola      Africa     1952    30.0  4232095     3521.       0.493 \n##  5 Argentina   Americas   1952    62.5 17876956     5911.       0.827 \n##  6 Australia   Oceania    1952    69.1  8691212    10040.       1.41  \n##  7 Austria     Europe     1952    66.8  6927772     6137.       0.859 \n##  8 Bahrain     Asia       1952    50.9   120447     9867.       1.38  \n##  9 Bangladesh  Asia       1952    37.5 46886859      684.       0.0958\n## 10 Belgium     Europe     1952    68    8730405     8343.       1.17  \n## # ‚Ä¶ with 1,694 more rows> my_gap %>%\n+   filter(year == 2007) %>%\n+   arrange(lifeExp)\n## # A tibble: 142 x 7\n##    country                continent  year lifeExp     pop gdpPercap gdpPercapRel\n##    <fct>                  <fct>     <int>   <dbl>   <int>     <dbl>        <dbl>\n##  1 Swaziland              Africa     2007    39.6  1.13e6     4513.       0.140 \n##  2 Mozambique             Africa     2007    42.1  2.00e7      824.       0.0256\n##  3 Zambia                 Africa     2007    42.4  1.17e7     1271.       0.0395\n##  4 Sierra Leone           Africa     2007    42.6  6.14e6      863.       0.0268\n##  5 Lesotho                Africa     2007    42.6  2.01e6     1569.       0.0488\n##  6 Angola                 Africa     2007    42.7  1.24e7     4797.       0.149 \n##  7 Zimbabwe               Africa     2007    43.5  1.23e7      470.       0.0146\n##  8 Afghanistan            Asia       2007    43.8  3.19e7      975.       0.0303\n##  9 Central African Repub‚Ä¶ Africa     2007    44.7  4.37e6      706.       0.0219\n## 10 Liberia                Africa     2007    45.7  3.19e6      415.       0.0129\n## # ‚Ä¶ with 132 more rows> my_gap %>%\n+   filter(year == 2007) %>%\n+   arrange(desc(lifeExp))\n## # A tibble: 142 x 7\n##    country          continent  year lifeExp       pop gdpPercap gdpPercapRel\n##    <fct>            <fct>     <int>   <dbl>     <int>     <dbl>        <dbl>\n##  1 Japan            Asia       2007    82.6 127467972    31656.        0.984\n##  2 Hong Kong, China Asia       2007    82.2   6980412    39725.        1.23 \n##  3 Iceland          Europe     2007    81.8    301931    36181.        1.12 \n##  4 Switzerland      Europe     2007    81.7   7554661    37506.        1.17 \n##  5 Australia        Oceania    2007    81.2  20434176    34435.        1.07 \n##  6 Spain            Europe     2007    80.9  40448191    28821.        0.896\n##  7 Sweden           Europe     2007    80.9   9031088    33860.        1.05 \n##  8 Israel           Asia       2007    80.7   6426679    25523.        0.793\n##  9 France           Europe     2007    80.7  61083916    30470.        0.947\n## 10 Canada           Americas   2007    80.7  33390141    36319.        1.13 \n## # ‚Ä¶ with 132 more rows"},{"path":"dplyr-single.html","id":"mit-rename-sch√∂ne-namen-vergeben","chapter":"Kapitel 7 Mehr zu dplyr","heading":"7.5 Mit rename() ‚Äúsch√∂ne‚Äù Namen vergeben","text":"Ein paar der Namen gapminder sind nicht besonders h√ºbsch, wie z.B. lifeExp. life expectancy w√§ren ja schlie√ülich zwei Worte und daher finde ich (pers√∂nliche Meinung) es sch√∂ner dies auch im Variablennamen zu sehenDie √Ñnderungen haben wir jetzt aber nicht abgespeichert (auch wenn sie sch√∂n waren), da wir den nachfolgenden Code auch weiterhin ausf√ºhren k√∂nnten ohne die √Ñnderung der Variablennamen durchgef√ºhrt zu haben.Bemerkung: Mit select() k√∂nnten wir bei der Auswahl von Variablen auch deren Namen √§nderneverything() w√§hlt alle √ºbrigen (au√üer gdpPercap) Variablen. Da gdpPercap erster Stelle gew√§hlt wurde, wird die Variable auch zur ersten Spalte.","code":"> my_gap %>%\n+   rename(life_exp = lifeExp,\n+          gdp_percap = gdpPercap,\n+          gdp_percap_rel = gdpPercapRel)\n## # A tibble: 1,704 x 7\n##    country     continent  year life_exp      pop gdp_percap gdp_percap_rel\n##    <fct>       <fct>     <int>    <dbl>    <int>      <dbl>          <dbl>\n##  1 Afghanistan Asia       1952     28.8  8425333       779.         0.109 \n##  2 Afghanistan Asia       1957     30.3  9240934       821.         0.0806\n##  3 Afghanistan Asia       1962     32.0 10267083       853.         0.0661\n##  4 Afghanistan Asia       1967     34.0 11537966       836.         0.0567\n##  5 Afghanistan Asia       1972     36.1 13079460       740.         0.0411\n##  6 Afghanistan Asia       1977     38.4 14880372       786.         0.0383\n##  7 Afghanistan Asia       1982     39.9 12881816       978.         0.0444\n##  8 Afghanistan Asia       1987     40.8 13867957       852.         0.0346\n##  9 Afghanistan Asia       1992     41.7 16317921       649.         0.0245\n## 10 Afghanistan Asia       1997     41.8 22227415       635.         0.0229\n## # ‚Ä¶ with 1,694 more rows> my_gap %>%\n+   filter(country == \"Burundi\", year > 1996) %>% \n+   select(yr = year, lifeExp, gdpPercap) %>% \n+   select(gdpPercap, everything())\n## # A tibble: 3 x 3\n##   gdpPercap    yr lifeExp\n##       <dbl> <int>   <dbl>\n## 1      463.  1997    45.3\n## 2      446.  2002    47.4\n## 3      430.  2007    49.6"},{"path":"dplyr-single.html","id":"group_by-macht-das-r-leben-einfacher","chapter":"Kapitel 7 Mehr zu dplyr","heading":"7.6 group_by() macht das R Leben einfacher","text":"Nehmen wir mal , dass uns die Antwort auf die Frage ‚Äúwelchem Land ist die Lebenserwartung innerhalb von 5 Jahren st√§rksten gesunken?‚Äù interessiert.dplyr bietet uns m√§chtige Hilfsmittel um diese Frage zu beantworten:group_by() f√ºgt dem Datensatz eine zus√§tzliche Struktur hinzu ‚Äì Gruppierungsinformationen ‚Äì die die Grundlage f√ºr Berechnungen innerhalb der Gruppen bilden.group_by() f√ºgt dem Datensatz eine zus√§tzliche Struktur hinzu ‚Äì Gruppierungsinformationen ‚Äì die die Grundlage f√ºr Berechnungen innerhalb der Gruppen bilden.summarise() nimmt einen Datensatz mit \\(n\\)-Beobachtungen, berechnet die angeforderten Zusammenfassungen und gibt einen Datensatz mit einer Beobachtung (falls nur eine Zusammenfassung angefordert wurde) zur√ºck.summarise() nimmt einen Datensatz mit \\(n\\)-Beobachtungen, berechnet die angeforderten Zusammenfassungen und gibt einen Datensatz mit einer Beobachtung (falls nur eine Zusammenfassung angefordert wurde) zur√ºck.Window Funktionen nehmen einen Datensatz mit \\(n\\)-Beobachtungen und geben einen Datensatz mit \\(n\\)-Beobachtungen zur√ºck.Window Funktionen nehmen einen Datensatz mit \\(n\\)-Beobachtungen und geben einen Datensatz mit \\(n\\)-Beobachtungen zur√ºck.mutate() und summarise() ber√ºcksichtigen Gruppen.mutate() und summarise() ber√ºcksichtigen Gruppen.Kombiniert mit den Verben, die du bereits kennst, kannst du mit diesen neuen Werkzeugen eine extrem vielf√§ltige Reihe von Problemen relativ einfach l√∂sen.","code":""},{"path":"dplyr-single.html","id":"die-dinge-aufz√§hlen","chapter":"Kapitel 7 Mehr zu dplyr","heading":"7.6.1 Die Dinge aufz√§hlen","text":"Beginnen wir mit dem einfachen Z√§hlen. Wie viele Beobachtungen haben wir pro Kontinent?Lassen uns hier kurz innehalten und √ºber das tidyverse nachdenken. Du k√∂nntest dir mit table() die gleichen absoluten H√§ufigkeiten berechnen.Aber das Objekt der Klasse table, das zur√ºckgegeben wird, macht die nachfolgenden Berechnungen einfach etwas kniffliger, als es dir lieb ist. Zum Beispiel ist es zu schade, dass die Namen der Kontinente nur als Namen und nicht als richtige Faktor zusammen mit den berechneten Werten zur√ºckgegeben werden. Dies ist ein Beispiel daf√ºr, wie das tidyverse √úberg√§nge gl√§ttet, bei denen die Ausgabe von Schritt die Eingabe von Schritt + 1 werden soll.Die tally() Funktion ist eine Komfortfunktion, die wei√ü, wie man Zeilen z√§hlt und dabei Gruppen ber√ºcksichtigt.Die Funktion count() bietet noch mehr Komfort. Sie kann sowohl gruppieren als auch z√§hlen.w√§re, wenn uns nicht nur die Anzahl Beobachtungen pro Kontinent interessiert, sondern auch die Anzahl unterschiedlichen L√§ndern pro Kontinent. Da wir mehrere Zusammenfassungen innerhalb von summarise() berechnen. Verwenden Sie die Funktion n_distinct(), um die Anzahl der einzelnen L√§nder innerhalb jedes Kontinents zu z√§hlen.","code":"> my_gap %>%\n+   group_by(continent) %>%\n+   summarise(n = n())\n## # A tibble: 5 x 2\n##   continent     n\n##   <fct>     <int>\n## 1 Africa      624\n## 2 Americas    300\n## 3 Asia        396\n## 4 Europe      360\n## 5 Oceania      24> table(gapminder$continent)\n## \n##   Africa Americas     Asia   Europe  Oceania \n##      624      300      396      360       24\n> str(table(gapminder$continent))\n##  'table' int [1:5(1d)] 624 300 396 360 24\n##  - attr(*, \"dimnames\")=List of 1\n##   ..$ : chr [1:5] \"Africa\" \"Americas\" \"Asia\" \"Europe\" ...> my_gap %>%\n+   group_by(continent) %>%\n+   tally()\n## # A tibble: 5 x 2\n##   continent     n\n##   <fct>     <int>\n## 1 Africa      624\n## 2 Americas    300\n## 3 Asia        396\n## 4 Europe      360\n## 5 Oceania      24> my_gap %>% \n+   count(continent)\n## # A tibble: 5 x 2\n##   continent     n\n##   <fct>     <int>\n## 1 Africa      624\n## 2 Americas    300\n## 3 Asia        396\n## 4 Europe      360\n## 5 Oceania      24> my_gap %>%\n+   group_by(continent) %>%\n+   summarise(n = n(),\n+             n_countries = n_distinct(country))\n## # A tibble: 5 x 3\n##   continent     n n_countries\n##   <fct>     <int>       <int>\n## 1 Africa      624          52\n## 2 Americas    300          25\n## 3 Asia        396          33\n## 4 Europe      360          30\n## 5 Oceania      24           2"},{"path":"dplyr-single.html","id":"deskriptive-statistiken-mit-summarise","chapter":"Kapitel 7 Mehr zu dplyr","heading":"7.6.2 Deskriptive Statistiken mit summarise()","text":"Kombination mit summarise() k√∂nnen wir eine Vielzahl verschiedenen Funktionen verwenden. Einige davon berechnen klassische deskriptive Statistiken:allen betrachteten F√§llen seien \\(x_1,\\dots,x_n\\) numerische Beobachtungen.mean() berechnet das arithmetische Mittel der Beo\\[\\overline x_n = \\frac{1}{n} \\sum_{=1}^n x_i\\,.\\]mean() berechnet das arithmetische Mittel der Beo\\[\\overline x_n = \\frac{1}{n} \\sum_{=1}^n x_i\\,.\\]median() berechnet den Median\n\\[x_{0.5} = \\begin{cases}\nx_{\\left(\\frac{n+1}{2}\\right)}, &  n\\ \\text{ungerade},\\\\\n\\frac{1}{2}\\left(x_{\\left(\\frac{n}{2}\\right)} + x_{\\left(\\frac{n}{2}+1\\right)}\\right), & n\\ \\text{gerade}\n\\end{cases}\\,.\\]median() berechnet den Median\n\\[x_{0.5} = \\begin{cases}\nx_{\\left(\\frac{n+1}{2}\\right)}, &  n\\ \\text{ungerade},\\\\\n\\frac{1}{2}\\left(x_{\\left(\\frac{n}{2}\\right)} + x_{\\left(\\frac{n}{2}+1\\right)}\\right), & n\\ \\text{gerade}\n\\end{cases}\\,.\\]var() berechnet die empirische Varianz\n\\[s_n^2 = \\frac{1}{n-1} \\sum_{=1}^n (x_i - \\overline x_n)^2\\,.\\]var() berechnet die empirische Varianz\n\\[s_n^2 = \\frac{1}{n-1} \\sum_{=1}^n (x_i - \\overline x_n)^2\\,.\\]sd() berechnet die empirische Standardabweichung\n\\[s_n = \\sqrt{s_n^2}\\,.\\]sd() berechnet die empirische Standardabweichung\n\\[s_n = \\sqrt{s_n^2}\\,.\\]IQR() berechnet den Interquartilsabstand\n\\[IQR = x_{0.75} - x_{0.25}\\,,\\]\nwobei \\(x_{0.25}\\) und \\(x_{0.75}\\) das empirische 0.25 bzw. 0.75 Quantil bezeichnen.IQR() berechnet den Interquartilsabstand\n\\[IQR = x_{0.75} - x_{0.25}\\,,\\]\nwobei \\(x_{0.25}\\) und \\(x_{0.75}\\) das empirische 0.25 bzw. 0.75 Quantil bezeichnen.min() berechnet das Minimum\n\\[x_{(1)} = \\min(x_1,\\dots,x_n)\\,.\\]min() berechnet das Minimum\n\\[x_{(1)} = \\min(x_1,\\dots,x_n)\\,.\\]und max() berechnet demnach das Maximum\n\\[x_{(n)} = \\max(x_1,\\dots,x_n)\\,.\\]und max() berechnet demnach das Maximum\n\\[x_{(n)} = \\max(x_1,\\dots,x_n)\\,.\\]Auch wenn dies statistisch gesehen unklug sein mag, lass uns die durchschnittliche Lebenserwartung pro Kontinenten berechnen.summarise_at() wendet die gleiche(n) Zusammenfassungs-Funktion(en) auf mehrere Variablen . Lass uns die durchschnittliche Lebenserwartung sowie den Median und das Pro-Kopf-GDP nach Kontinenten pro Jahr berechnen‚Ä¶ aber nur f√ºr 1952 und 2007.Konzentrieren wir uns nur auf Asien. Wie hoch ist die minimale und maximale Lebenserwartung pro Jahr?Nat√ºrlich w√§re es viel interessanter zu sehen, welches Land diese extremen Beobachtungen beigetragen hat. Kommt das Minimum (Maximum) immer aus dem gleichen Land? Wir gehen dem K√ºrze mit Window Funktionen nach.","code":"> my_gap %>%\n+   group_by(continent) %>%\n+   summarise(avg_lifeExp = mean(lifeExp))\n## # A tibble: 5 x 2\n##   continent avg_lifeExp\n##   <fct>           <dbl>\n## 1 Africa           48.9\n## 2 Americas         64.7\n## 3 Asia             60.1\n## 4 Europe           71.9\n## 5 Oceania          74.3> my_gap %>%\n+   filter(year %in% c(1952, 2007)) %>%\n+   group_by(continent, year) %>%\n+   summarise_at(vars(lifeExp, gdpPercap), list(mean, median))\n## # A tibble: 10 x 6\n## # Groups:   continent [5]\n##    continent  year lifeExp_fn1 gdpPercap_fn1 lifeExp_fn2 gdpPercap_fn2\n##    <fct>     <int>       <dbl>         <dbl>       <dbl>         <dbl>\n##  1 Africa     1952        39.1         1253.        38.8          987.\n##  2 Africa     2007        54.8         3089.        52.9         1452.\n##  3 Americas   1952        53.3         4079.        54.7         3048.\n##  4 Americas   2007        73.6        11003.        72.9         8948.\n##  5 Asia       1952        46.3         5195.        44.9         1207.\n##  6 Asia       2007        70.7        12473.        72.4         4471.\n##  7 Europe     1952        64.4         5661.        65.9         5142.\n##  8 Europe     2007        77.6        25054.        78.6        28054.\n##  9 Oceania    1952        69.3        10298.        69.3        10298.\n## 10 Oceania    2007        80.7        29810.        80.7        29810.> my_gap %>%\n+   filter(continent == \"Asia\") %>%\n+   group_by(year) %>%\n+   summarise(min_lifeExp = min(lifeExp), max_lifeExp = max(lifeExp))\n## # A tibble: 12 x 3\n##     year min_lifeExp max_lifeExp\n##    <int>       <dbl>       <dbl>\n##  1  1952        28.8        65.4\n##  2  1957        30.3        67.8\n##  3  1962        32.0        69.4\n##  4  1967        34.0        71.4\n##  5  1972        36.1        73.4\n##  6  1977        31.2        75.4\n##  7  1982        39.9        77.1\n##  8  1987        40.8        78.7\n##  9  1992        41.7        79.4\n## 10  1997        41.8        80.7\n## 11  2002        42.1        82  \n## 12  2007        43.8        82.6"},{"path":"dplyr-single.html","id":"gruppierte-ver√§nderungen","chapter":"Kapitel 7 Mehr zu dplyr","heading":"7.7 Gruppierte Ver√§nderungen","text":"Manchmal m√∂chte man die \\(n\\)-Zeilen f√ºr jede Gruppe nicht zu einer Zeile zusammenfassen. Stattdessen m√∂chte man die Gruppen behalten, aber innerhalb dieser Gruppen rechnen.","code":""},{"path":"dplyr-single.html","id":"berechnungen-innerhalb-der-gruppen","chapter":"Kapitel 7 Mehr zu dplyr","heading":"7.7.1 Berechnungen innerhalb der Gruppen","text":"Machen wir eine neue Variable, die die gewonnenen (verlorenen) Lebenserwartungsjahre im Vergleich zu 1952 f√ºr jedes einzelne Land angibt. Wir gruppieren nach L√§ndern und verwenden mutate(), um eine neue Variable zu erstellen. Die Funktion first() extrahiert dabei den ersten Wert aus einem Vektor. Beachte, dass first() mit dem Vektor der Lebenserwartungen jeder L√§ndergruppe arbeitet.Innerhalb eines Landes nehmen wir die Differenz zwischen der Lebenserwartung im Jahr \\(\\) und der Lebenserwartung im Jahr 1952. Daher sehen wir f√ºr 1952 immer Nullen und f√ºr die meisten L√§nder eine Folge von positiven und steigenden Zahlen.","code":"> my_gap %>% \n+   group_by(country) %>% \n+   select(country, year, lifeExp) %>% \n+   mutate(lifeExp_gain = lifeExp - first(lifeExp)) %>% \n+   filter(year < 1963)\n## # A tibble: 426 x 4\n## # Groups:   country [142]\n##    country      year lifeExp lifeExp_gain\n##    <fct>       <int>   <dbl>        <dbl>\n##  1 Afghanistan  1952    28.8         0   \n##  2 Afghanistan  1957    30.3         1.53\n##  3 Afghanistan  1962    32.0         3.20\n##  4 Albania      1952    55.2         0   \n##  5 Albania      1957    59.3         4.05\n##  6 Albania      1962    64.8         9.59\n##  7 Algeria      1952    43.1         0   \n##  8 Algeria      1957    45.7         2.61\n##  9 Algeria      1962    48.3         5.23\n## 10 Angola       1952    30.0         0   \n## # ‚Ä¶ with 416 more rows"},{"path":"dplyr-single.html","id":"window-functions","chapter":"Kapitel 7 Mehr zu dplyr","heading":"7.7.2 Window Funktionen","text":"Window Funktionen nehmen \\(n\\)-Eingaben entgegen und geben \\(n\\)-Ausgaben zur√ºck. Au√üerdem h√§ngt die Ausgabe von allen Werten ab. ist rank() eine Window Funktion, aber log() ist es nicht.Betrachten wir noch einmal die schlechtesten und besten Lebenserwartungen Asien im Laufe der Zeit, behalten aber Informationen dar√ºber bei, welches Land diese Extremwerte beisteuert.Wir sehen, dass (min = Afghanistan, max = Japan) das h√§ufigste Ergebnis ist, aber Kambodscha und Israel tauchen jeweils mindestens einmal als min bzw. max auf.\nAber w√§re es nicht sch√∂n, eine Zeile pro Jahr zu haben?Wie hat das eigentlich funktioniert? Dazu schauen wir uns die Beobachtungen aus Asien mal direkt .Jetzt wenden wir eine Window Funktion ‚Äì min_rank(). Da asia nach Jahren gruppiert ist, operiert min_rank() innerhalb von Mini-Datens√§tzen, jeder f√ºr ein bestimmtes Jahr. Auf die Variable LifeExp angewandt, liefert min_rank() den Rang der beobachteten Lebenserwartung jedes Landes.Bemerkung: Der min-Teil gibt nur , wie die Verbindungen unterbrochen werden.Neben dem Minimum gibt es aber auch noch eine Reihe weiterer Alternative, wie z.B. den DurchschnittDann schauen wir uns die R√§nge der Lebenserwartung innerhalb eines Jahres mal explizit f√ºr ein paar L√§nder, sowohl der (Standard-) aufsteigenden als auch der absteigenden Reihenfolge.Da wir im zweiten Schritt nach einigen L√§ndern filtern, erzeugen wir im ersten Schritt mit mutate() die gew√ºnschten Werte und weisen sie neuen Variablen zu.Afghanistan neigt dazu, 1 der le_rank-Variablen zu haben, Japan neigt dazu, 1 der le_desc_rank-Variablen zu haben und andere L√§nder, wie Thailand, zeigen deutlich weniger extreme R√§nge.Damit sollte der urspr√ºngliche filter() Befehlauch klar sein.Diese beiden S√§tze von R√§ngen werden --fly, innerhalb der Jahresgruppe, gebildet, und filter() beh√§lt Zeilen mit Rang weniger als 2. Da wir dies f√ºr aufsteigende und absteigende R√§nge tun, erhalten wir sowohl den minimalen als auch den maximalen Rang.Wenn wir nur das Minimum ODER das Maximum gewollt h√§tten, h√§tte auch ein alternativer Ansatz mit top_n() funktioniert.","code":"> my_gap %>%\n+   filter(continent == \"Asia\") %>%\n+   select(year, country, lifeExp) %>%\n+   group_by(year) %>%\n+   filter(min_rank(desc(lifeExp)) < 2 | min_rank(lifeExp) < 2) %>% \n+   arrange(year) %>%\n+   print(n = Inf)  # erzwingt eine Ausgabe aller Zeilen\n## # A tibble: 24 x 3\n## # Groups:   year [12]\n##     year country     lifeExp\n##    <int> <fct>         <dbl>\n##  1  1952 Afghanistan    28.8\n##  2  1952 Israel         65.4\n##  3  1957 Afghanistan    30.3\n##  4  1957 Israel         67.8\n##  5  1962 Afghanistan    32.0\n##  6  1962 Israel         69.4\n##  7  1967 Afghanistan    34.0\n##  8  1967 Japan          71.4\n##  9  1972 Afghanistan    36.1\n## 10  1972 Japan          73.4\n## 11  1977 Cambodia       31.2\n## 12  1977 Japan          75.4\n## 13  1982 Afghanistan    39.9\n## 14  1982 Japan          77.1\n## 15  1987 Afghanistan    40.8\n## 16  1987 Japan          78.7\n## 17  1992 Afghanistan    41.7\n## 18  1992 Japan          79.4\n## 19  1997 Afghanistan    41.8\n## 20  1997 Japan          80.7\n## 21  2002 Afghanistan    42.1\n## 22  2002 Japan          82  \n## 23  2007 Afghanistan    43.8\n## 24  2007 Japan          82.6> (asia <- my_gap %>%\n+   filter(continent == \"Asia\") %>%\n+   select(year, country, lifeExp) %>%\n+   group_by(year))\n## # A tibble: 396 x 3\n## # Groups:   year [12]\n##     year country     lifeExp\n##    <int> <fct>         <dbl>\n##  1  1952 Afghanistan    28.8\n##  2  1957 Afghanistan    30.3\n##  3  1962 Afghanistan    32.0\n##  4  1967 Afghanistan    34.0\n##  5  1972 Afghanistan    36.1\n##  6  1977 Afghanistan    38.4\n##  7  1982 Afghanistan    39.9\n##  8  1987 Afghanistan    40.8\n##  9  1992 Afghanistan    41.7\n## 10  1997 Afghanistan    41.8\n## # ‚Ä¶ with 386 more rows> rank(c(1,3,3,5), ties.method = \"min\")\n## [1] 1 2 2 4> rank(c(1,3,3,5))\n## [1] 1.0 2.5 2.5 4.0> asia %>%\n+   mutate(le_rank = min_rank(lifeExp),\n+          le_desc_rank = min_rank(desc(lifeExp))) %>% \n+   filter(country %in% c(\"Afghanistan\", \"Japan\", \"Thailand\"), year > 1995)\n## # A tibble: 9 x 5\n## # Groups:   year [3]\n##    year country     lifeExp le_rank le_desc_rank\n##   <int> <fct>         <dbl>   <int>        <int>\n## 1  1997 Afghanistan    41.8       1           33\n## 2  2002 Afghanistan    42.1       1           33\n## 3  2007 Afghanistan    43.8       1           33\n## 4  1997 Japan          80.7      33            1\n## 5  2002 Japan          82        33            1\n## 6  2007 Japan          82.6      33            1\n## 7  1997 Thailand       67.5      12           22\n## 8  2002 Thailand       68.6      12           22\n## 9  2007 Thailand       70.6      12           22> filter(min_rank(desc(lifeExp)) < 2 | min_rank(lifeExp) < 2)> my_gap %>%\n+   filter(continent == \"Asia\") %>%\n+   select(year, country, lifeExp) %>%\n+   arrange(year) %>%\n+   group_by(year) %>%\n+   #top_n(1, wt = lifeExp)        ## f√ºr das Minimum\n+   top_n(1, wt = desc(lifeExp)) ## bzw. das Maximum\n## # A tibble: 12 x 3\n## # Groups:   year [12]\n##     year country     lifeExp\n##    <int> <fct>         <dbl>\n##  1  1952 Afghanistan    28.8\n##  2  1957 Afghanistan    30.3\n##  3  1962 Afghanistan    32.0\n##  4  1967 Afghanistan    34.0\n##  5  1972 Afghanistan    36.1\n##  6  1977 Cambodia       31.2\n##  7  1982 Afghanistan    39.9\n##  8  1987 Afghanistan    40.8\n##  9  1992 Afghanistan    41.7\n## 10  1997 Afghanistan    41.8\n## 11  2002 Afghanistan    42.1\n## 12  2007 Afghanistan    43.8"},{"path":"dplyr-single.html","id":"gro√ües-finale","chapter":"Kapitel 7 Mehr zu dplyr","heading":"7.8 Gro√ües Finale","text":"Beantworten wir also die Frage: Welches Land hat den st√§rksten R√ºckgang der Lebenserwartung um 5 Jahre erlebt?Die Beobachtungsfrequenz im Datensatz ist f√ºnf Jahre, d.h. wir haben Daten f√ºr 1952, 1957 usw. Dies bedeutet also, dass die Ver√§nderungen der Lebenserwartung zwischen benachbarten Zeitpunkten betrachtet werden m√ºssen.Zum jetzigen Zeitpunkt ist das einfach zu einfach, also lasst es uns, wenn wir schon dabei sind, nach Kontinenten machen.Denk ruhig eine Weile √ºber das Ergebnis nach. Meistens sieht man hier trockenen Statistiken √ºber die durchschnittliche Lebenserwartung, wie V√∂lkermord aussieht.Unterteile den Code, beginnend von oben, St√ºcke und √ºberpr√ºfe die einzelnen Zwischenergebnisse. wurde der Code auch geschrieben/entwickelt, mit vielen Fehlern und Verfeinerungen auf dem Weg.","code":"> my_gap %>%\n+   select(country, year, continent, lifeExp) %>%\n+   group_by(continent, country) %>%\n+   # f√ºr jedes Land werden die Unterschiede berechnet\n+   mutate(le_delta = lifeExp - lag(lifeExp)) %>% \n+   ## f√ºr jedes Land wird nur der kleinste Wert behalten\n+   summarise(worst_le_delta = min(le_delta, na.rm = TRUE)) %>% \n+   ## nun wird noch pro Kontinent, die Zeile mit dem kleinsten Wert ausgegeben\n+   top_n(-1, wt = worst_le_delta) %>% \n+   arrange(worst_le_delta)\n## `summarise()` has grouped output by 'continent'. You can override using the `.groups` argument.\n## # A tibble: 5 x 3\n## # Groups:   continent [5]\n##   continent country     worst_le_delta\n##   <fct>     <fct>                <dbl>\n## 1 Africa    Rwanda             -20.4  \n## 2 Asia      Cambodia            -9.10 \n## 3 Americas  El Salvador         -1.51 \n## 4 Europe    Montenegro          -1.46 \n## 5 Oceania   Australia            0.170"},{"path":"dplyr-single.html","id":"literatur","chapter":"Kapitel 7 Mehr zu dplyr","heading":"7.9 Literatur","text":"dieser Stelle sei noch auf die dplyr Webseite und das Kapitel\nData transformation R Data Science (Wickham Grolemund 2016) verwiesen.","code":""},{"path":"import-export.html","id":"import-export","chapter":"Kapitel 8 Daten I/O","heading":"Kapitel 8 Daten I/O","text":"","code":""},{"path":"import-export.html","id":"√ºberblick","chapter":"Kapitel 8 Daten I/O","heading":"8.1 √úberblick","text":"Wir haben die Gapminder-Daten als tibble aus dem gapminder Paket geladen. Wir haben im letzten Abschnitt weder Daten noch abgeleitete Ergebnisse explizit eine Datei geschrieben. Im wirklichen Leben wirst du aber st√§ndig Daten, die Tabellenform vorliegen, R ein- und auslesen. Manchmal muss das sogar f√ºr Daten geschehen, die nicht Tabellenform vorliegen.Wie macht man das? Worauf muss man aufpassen?","code":""},{"path":"import-export.html","id":"daten-import","chapter":"Kapitel 8 Daten I/O","heading":"8.1.1 Daten Import","text":"F√ºr den Daten Import gibt es im Allgemeinen zwei M√∂glichkeiten:‚Äú√úberrasche mich!‚Äù Diese Haltung musst du einnehmen, wenn du zum ersten Mal einen Datensatz erh√§ltst. Du musst einfach froh, wenn du die Daten ohne Fehler importieren konntest. Dann schaust du dir das Ergebnis , entdeckst Fehler den Daten und/oder beim Import. Du behebst sie und beginnst nochmal von vorne.‚ÄúEin weiterer Tag im Paradies.‚Äù Das ist die Einstellung, wenn du einen aufger√§umten Datensatz einliest, den du vorher einem oder mehreren Reinigungsskripten wahnsinnig aufger√§umt haben. Es sollte keine √úberraschungen geben.Im zweiten Fall, und im weiteren Verlauf des ersten Falles, lernst du tats√§chlich eine Menge dar√ºber, wie die Daten sind/sein sollten. Ein wichtiger Import-Ratschlag: Verwende die Argumente der Importfunktion, um weit wie m√∂glich und schnell wie m√∂glich zu kommen. Anf√§ngercode hat oft eine Menge unn√∂tigen nachtr√§glichen Aufwand. Lese die Hilfe zu den Importfunktionen und nutzen die Argumente maximal aus, um den Import zu steuern.","code":""},{"path":"import-export.html","id":"daten-export","chapter":"Kapitel 8 Daten I/O","heading":"8.1.2 Daten Export","text":"Es wird viele Gelegenheiten geben, bei denen du Daten aus R exportieren willst. Zwei wichtige Beispiele:einen ges√§uberten Datensatz der bereit ist analysiert zu werden, den du heldenhaft aus recht unordentlichen Daten erstellt hastein numerisches Ergebnis aus einer Datenaggregation oder Modellierung oder einer statistischen SchlussfolgerungErster Tipp: Der Output von heute ist der Input von morgen. Denke die Schmerzen zur√ºck, die du selbst beim Import von fremden Daten erlitten hast, und f√ºgen dir nicht selbst solche Schmerzen zu!Zweiter Tipp: Sei nicht zu clever. Eine einfache Textdatei, die von einem Menschen einem Texteditor lesbar ist, sollte dein Standard sein, bis du einen guten Grund daf√ºr hast, dass dies nicht funktionieren wird. Das Lesen und Schreiben exotische Formate wird das erste sein, Zukunft oder auf einem anderen Computer kaputtgehen wird. Es schafft auch Barrieren f√ºr jeden, der ein anderes Toolkit hat als du. Strebe nach Zukunfts- und Idiotensicherheit.Wie passt das zu unserer Betonung der dynamischen Berichterstattung √ºber R Markdown? Es gibt f√ºr alles eine Zeit und einen Ort. Es gibt Projekte und Dokumente, bei denen du dich intensiv mit knitr und rmarkdown besch√§ftigen kannst/willst/musst. Aber es gibt viele gute Gr√ºnde, warum (Teile von) einer Analyse nicht (nur) einen dynamischen Bericht eingebettet werden sollten. Vielleicht bist du gerade dabei Daten zu bereinigen, um einen Datensatz f√ºr eine nachfolgende Analyse zu erzeugen. Vielleicht leistet du einen kleinen, aber entscheidenden Beitrag zu einem gigantischen Multi-Autoren-Papier. Etc. Denke auch daran, dass es nat√ºrlich auch noch andere Werkzeuge und Arbeitsabl√§ufe gibt, um etwas reproduzierbar zu machen: z.B. make.","code":""},{"path":"import-export.html","id":"load-the-tidyverse","chapter":"Kapitel 8 Daten I/O","heading":"8.2 Load the tidyverse","text":"Das Hauptpaket, das wir verwenden werden, ist readr, welches Alternativen zu den Standardfunktionen read.table() und write.table() bietet. Trotzdem laden wir standardm√§√üig einfach wieder tidyverse.","code":"> library(tidyverse)\n## ‚îÄ‚îÄ Attaching packages ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ tidyverse 1.3.1 ‚îÄ‚îÄ\n## ‚úì ggplot2 3.3.5     ‚úì purrr   0.3.4\n## ‚úì tibble  3.1.2     ‚úì dplyr   1.0.7\n## ‚úì tidyr   1.1.3     ‚úì stringr 1.4.0\n## ‚úì readr   2.0.1     ‚úì forcats 0.5.1\n## ‚îÄ‚îÄ Conflicts ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ tidyverse_conflicts() ‚îÄ‚îÄ\n## x dplyr::filter() masks stats::filter()\n## x dplyr::lag()    masks stats::lag()"},{"path":"import-export.html","id":"einlesen-der-gapminder-daten","chapter":"Kapitel 8 Daten I/O","heading":"8.3 Einlesen der Gapminder Daten","text":"Die Gapminder Daten k√∂nnten wir nat√ºrlich wie zuvor √ºber das Laden des gapminder Pakets verf√ºgbar machen. Da es diesem Abschnitt aber um das Einlesen von Daten geht, versuchen wir die Daten als .tsv Datei (tab-separated values - sind sie im Paket gespeichert) einzulesen. Aber dies bedeutet nat√ºrlich, dass wir die entsprechende .tsv Datei erst mal finden m√ºssen. Dabei hilft uns gl√ºcklicherweise das fs Paket.Nachdem wir jetzt den Speicherort der Datei kennen, k√∂nnen wir versuchen sie einzulesen.","code":"> library(fs)\n> (gap_tsv <- path_package(\"gapminder\", \"extdata\", \"gapminder.tsv\"))\n## /Library/Frameworks/R.framework/Versions/4.0/Resources/library/gapminder/extdata/gapminder.tsv"},{"path":"import-export.html","id":"einlesen-von-daten-in-tabellenform","chapter":"Kapitel 8 Daten I/O","heading":"8.4 Einlesen von Daten in Tabellenform","text":"Die Haupt-Funktion zum Einlesen von Daten readr ist read_delim(). Hier verwenden wir eine Variante, read_tsv(), f√ºr tabulatorgetrennte Daten:√úber den Tabulator Spalten einer Datentabelle zu trennen, ist nat√ºrlich nur eine Variante neben weiteren Alternativen wie Komma, Strichpunkt, Leerzeichen, ‚Ä¶F√ºr Komma getrennte Daten w√ºrde man beispielsweise read_csv() verwenden. F√ºr volle Flexibilit√§t bei der Angabe des Trennzeichens kannst du aber jederzeit direkt read_delim() verwenden.Der auff√§lligste Unterschied zwischen den readr-Funktionen und der Standardfunktion read.table()ist, dass readr standardm√§√üig Characters NICHT Faktoren umwandelt. Im Gro√üen und Ganzen ist dies ein besseres Standardverhalten, obwohl es nat√ºrlich immer wieder vorkommen wird, dass du einzelne Variablen nach dem Einlesen einen Faktoren umwandeln wirst. Aber lass dich davon nicht t√§uschen - im Allgemeinen wirst du durch die Verwendung von readr nach dem Einlesen weniger Anpassungen machen m√ºssen im Vergleich zum Standardvorgehen.Fazit: Benutze readr::read_delim() und ‚ÄúFreunde‚Äù.Die Gapminder-Daten sind zu sauber und einfach, um die gro√üartigen Funktionen von readr zur Geltung zu bringen. Ein Blick Introduction readr zeigt aber noch viele weitere Anpassungsm√∂glichkeiten der readr Funktionen.","code":"> gapminder <- read_tsv(gap_tsv)\n## Rows: 1704 Columns: 6\n## ‚îÄ‚îÄ Column specification ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n## Delimiter: \"\\t\"\n## chr (2): country, continent\n## dbl (4): year, lifeExp, pop, gdpPercap\n## \n## ‚Ñπ Use `spec()` to retrieve the full column specification for this data.\n## ‚Ñπ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n> glimpse(gapminder)\n## Rows: 1,704\n## Columns: 6\n## $ country   <chr> \"Afghanistan\", \"Afghanistan\", \"Afghanistan\", \"Afghanistan\", ‚Ä¶\n## $ continent <chr> \"Asia\", \"Asia\", \"Asia\", \"Asia\", \"Asia\", \"Asia\", \"Asia\", \"Asi‚Ä¶\n## $ year      <dbl> 1952, 1957, 1962, 1967, 1972, 1977, 1982, 1987, 1992, 1997, ‚Ä¶\n## $ lifeExp   <dbl> 28.8, 30.3, 32.0, 34.0, 36.1, 38.4, 39.9, 40.8, 41.7, 41.8, ‚Ä¶\n## $ pop       <dbl> 8425333, 9240934, 10267083, 11537966, 13079460, 14880372, 12‚Ä¶\n## $ gdpPercap <dbl> 779, 821, 853, 836, 740, 786, 978, 852, 649, 635, 727, 975, ‚Ä¶"},{"path":"import-export.html","id":"daten-exportieren","chapter":"Kapitel 8 Daten I/O","heading":"8.5 Daten exportieren","text":"Bevor wir etwas exportieren k√∂nnen, m√ºssen (das ist nat√ºrlich nicht richtig - niemand zwingt uns dazu) etwas berechnen, das es wert ist, exportiert zu werden. Lass uns eine Zusammenfassung der maximalen Lebenserwartung auf L√§nderebene erstellen.Das gap_life_exp data frame ist ein Beispiel f√ºr ein Zwischenergebnis, das wir f√ºr die Zukunft und f√ºr nachgelagerte Analysen oder Visualisierungen speichern wollen.Die Haupt-Exportfunktion readr ist write_delim(). F√ºr verschiedene Dateiformate gibt es auch hier wieder verschiedene Komfortfunktionen. Lass uns write_csv() benutzen, um eine kommagetrennte Datei zu erhalten.Schauen wir uns die ersten paar Zeilen von gap_life_exp.csv . Dazu kannst du entweder die Datei √∂ffnen oder, im Terminal, head darauf anwenden.Das sieht recht ordentlich aus, obwohl es keine sichtbare Ausrichtung oder Trennung Spalten gibt. H√§tten wir die Basisfunktion read.csv() benutzt, w√ºrden wir Zeilennamen und viele Anf√ºhrungszeichen sehen, es sei denn, wir h√§tten diese Features explizit abgeschaltet. Das sch√∂nere Standardverhalten ist daher der Hauptgrund, warum wir readr::write_csv() gegen√ºber write.csv() bevorzugen.Es ist nicht wirklich fair, sich √ºber den Mangel sichtbarer Ausrichtung zu beklagen, schlie√ülich erzeugen wir Dateien, die der Computer lesen soll. Falls du wirklich der Datei ‚Äúherumst√∂bern‚Äù willst, benutze View() RStudio oder √∂ffnen die Datei mit einem Spreadsheet Programm (!). Aber erliege NIE der Versuchung, dort Datenmanipulationen vorzunehmen ‚Ä¶ gehe zur√ºck zu R und schreibe dort die Befehle, die du die n√§chsten 15 Mal ausf√ºhren kannst, wenn du diesen Datensatz (oder Datens√§tze derselben Form) importieren/bereinigen/aggregieren/exportieren willst.","code":"> gap_life_exp <- gapminder %>%\n+   group_by(country, continent) %>% \n+   summarise(life_exp = max(lifeExp)) %>% \n+   ungroup()\n## `summarise()` has grouped output by 'country'. You can override using the `.groups` argument.\n> gap_life_exp\n## # A tibble: 142 x 3\n##    country     continent life_exp\n##    <chr>       <chr>        <dbl>\n##  1 Afghanistan Asia          43.8\n##  2 Albania     Europe        76.4\n##  3 Algeria     Africa        72.3\n##  4 Angola      Africa        42.7\n##  5 Argentina   Americas      75.3\n##  6 Australia   Oceania       81.2\n##  7 Austria     Europe        79.8\n##  8 Bahrain     Asia          75.6\n##  9 Bangladesh  Asia          64.1\n## 10 Belgium     Europe        79.4\n## # ‚Ä¶ with 132 more rows> write_csv(gap_life_exp, \"data/gap_life_exp.csv\")country,continent,life_exp\nAfghanistan,Asia,43.828\nAlbania,Europe,76.423\nAlgeria,Africa,72.301\nAngola,Africa,42.731\nArgentina,Americas,75.32"},{"path":"import-export.html","id":"daten-√ºber-eine-api","chapter":"Kapitel 8 Daten I/O","heading":"8.6 Daten √ºber eine API","text":"Interessante Datens√§tze sind der Treibstoff f√ºr ein gutes Data Science Projekt. APIs (Application Programming Interface) sind eine weitere sehr n√ºtzliche Methode, um auf interessante Daten zuzugreifen.Anstatt einen Datensatz herunterladen zu m√ºssen, erm√∂glichen APIs Daten direkt von bestimmten Websites √ºber eine Schnittstelle anzufordern. Viele gro√üe Webseiten wie Twitter und Facebook erm√∂glichen √ºber APIs den Zugriff auf Teile ihrer Daten.Wir werden die Grundlagen des Zugriffs auf eine API besprechen. Dazu ben√∂tigst du aber keine Vorwissen bzgl. APIs.","code":""},{"path":"import-export.html","id":"einf√ºhrung","chapter":"Kapitel 8 Daten I/O","heading":"8.6.1 Einf√ºhrung","text":"API ist ein allgemeiner Begriff f√ºr den Ort, dem ein Computerprogramm mit einem anderen oder mit sich selbst interagiert. Wir sprechen √ºber Web-APIs, bei denen zwei verschiedene Computer - ein Client und ein Server - miteinander interagieren, um Daten anzufordern bzw. bereitzustellen.APIs bieten eine ausgefeilte M√∂glichkeit Daten von einer Website anzufordern. Wenn eine Website wie Twitter eine API einrichtet, richten sie im Wesentlichen einen Computer ein, der auf Datenanfragen wartet.Sobald dieser Computer eine Datenanforderung empf√§ngt, verarbeitet er die Daten selbst und sendet sie den Computer, der sie angefordert hat. Unsere Aufgabe als Anforderer der Daten wird es sein R Code zu schreiben, der die Anforderung erstellt und dem Computer, auf dem die API l√§uft, mitteilt, wir ben√∂tigen. Dieser Computer liest dann unseren Code, verarbeitet die Anfrage und gibt sch√∂n formatierte Daten zur√ºck, die mithilfe existierender R Pakete verarbeitet werden k√∂nnen..","code":""},{"path":"import-export.html","id":"erstellen-von-api-anforderungen-in-r","chapter":"Kapitel 8 Daten I/O","heading":"8.6.2 Erstellen von API-Anforderungen in R","text":"Um mit APIs R zu arbeiten, m√ºssen wir ein paar neue Pakete laden (und vorher nat√ºrlich installieren). Konkret werden wir mit den Paketen httr und jsonlite arbeiten. Sie spielen bei der Einbindung der APIs unterschiedliche Rollen, aber beide sind unverzichtbar.Vermutlich hast du die beiden Pakete bisher nicht installiert. Daher ist der erste Schritt die beiden Pakete zu installierenund anschlie√üend zu laden","code":"> install.packages(c(\"httr\", \"jsonlite\"))\n> > library(httr)\n> library(jsonlite)\n## \n## Attaching package: 'jsonlite'\n## The following object is masked from 'package:purrr':\n## \n##     flatten"},{"path":"import-export.html","id":"unsere-erste-api-anfrage-stellen","chapter":"Kapitel 8 Daten I/O","heading":"8.6.3 Unsere erste API-Anfrage stellen","text":"Der erste Schritt, um Daten von einer API zu erhalten, ist die eigentliche Anfrage R. Diese Anfrage wird den Computer-Server geschickt, der √ºber die API verf√ºgt, und wenn alles reibungslos verl√§uft, wird er eine Antwort zur√ºcksenden.Es gibt verschiedene Arten von Anfragen, die man einen API-Server stellen kann. Diese Arten von Anfragen entsprechen verschiedenen Aktionen, die der Server ausf√ºhren soll.F√ºr unsere Zwecke fragen wir lediglich nach Daten, einer GET-Anfrage entspricht. Andere Arten von Anfragen sind z.B. POST und PUT, aber diese sind f√ºr uns nicht von Interesse und daher brauchen wir uns darum nicht zu k√ºmmern.Um eine GET-Anfrage zu erstellen, m√ºssen wir die GET() Funktion aus dem httr Paket verwenden. Die GET() Funktion ben√∂tigt als Input eine URL, die die Adresse des Servers angibt, den die Anforderung gesendet werden soll.Als Beispiel werden wir mit der Open Notify API arbeiten, die Daten zu verschiedenen NASA-Projekten enth√§lt. Mithilfe der Open Notify API k√∂nnen wir uns √ºber den Standort der Internationalen Raumstation informieren und erfahren, wie viele Personen sich derzeit im Weltraum aufhalten.Wir beginnen damit, dass wir unsere Anfrage mit der GET() Funktion stellen und die URL der API angeben:Die Ausgabe der Funktion GET() ist eine Liste, die alle Informationen enth√§lt, die vom API-Server zur√ºckgegeben werden.","code":"> jdata <- GET(\"http://api.open-notify.org/astros.json\")"},{"path":"import-export.html","id":"get-ausgabe","chapter":"Kapitel 8 Daten I/O","heading":"8.6.4 GET() Ausgabe","text":"Schauen wir uns einmal , wie die Variable jdata der R-Konsole aussieht:Als erstes f√§llt auf, dass die URL enthalten ist, die die GET-Anfrage gesendet wurde. Au√üerdem sehen wir das Datum und die Uhrzeit, zu der die Anfrage gestellt wurde, sowie die Gr√∂√üe der Antwort.Die Information Content-Type gibt uns eine Vorstellung davon, welche Form die Daten haben. Diese spezielle Antwort besagt, dass die Daten ein JSON-Format annehmen, womit auch klar ist warum wir das Paket jsonlite ebenfalls geladen haben.Der Status verdient eine besondere Aufmerksamkeit. Status bezieht sich auf den Erfolg oder Misserfolg der API-Anfrage, und er wird Form einer Zahl angegeben. Die zur√ºckgegebene Nummer gibt Auskunft dar√ºber, ob die Anfrage erfolgreich war oder nicht, und kann auch einige Gr√ºnde f√ºr einen m√∂glichen Misserfolg nennen.Die Zahl 200 ist das, wir sehen wollen. Sie entspricht einem erfolgreichen Antrag, und das ist es, wir hier haben. Eine √úbersicht √ºber weitere Status Codes findet man z.B. auf dieser [Webseite](https://www.restapitutorial.com/httpstatuscodes.html.","code":"> jdata\n## Response [http://api.open-notify.org/astros.json]\n##   Date: 2021-10-17 21:13\n##   Status: 200\n##   Content-Type: application/json\n##   Size: 505 B"},{"path":"import-export.html","id":"handling-json-data","chapter":"Kapitel 8 Daten I/O","heading":"8.6.5 Handling JSON Data","text":"JSON steht f√ºr JavaScript Object Notation. W√§hrend JavaScript eine weitere Programmiersprache ist, liegt unser Schwerpunkt bei JSON auf seiner Struktur. JSON ist n√ºtzlich, weil es von einem Computer leicht lesbar ist, und aus diesem Grund ist es zur prim√§ren Art und Weise geworden, wie Daten √ºber APIs transportiert werden. Die meisten APIs senden ihre Antworten im JSON-Format.JSON ist als eine Reihe von Schl√ºssel-Werte-Paaren formatiert, wobei ein bestimmtes Wort (‚ÄúSchl√ºssel‚Äù) mit einem bestimmten Wert assoziiert ist. Ein Beispiel f√ºr diese Schl√ºssel-Wert-Struktur ist unten dargestellt:ihrem aktuellen Zustand sind die Daten der Variablen jdata nicht verwendbar. Die Daten sind als Unicode-Rohdaten jdata enthalten, und m√ºssen das JSON-Format konvertiert werden.Dazu m√ºssen wir zun√§chst den rohen Unicode Character Daten konvertieren, die dem oben gezeigten JSON-Format √§hneln. Die Funktion rawToChar() f√ºhrt genau diese Aufgabe aus:Die resultierende Zeichenfolge sieht zwar recht unordentlich aus, aber es liegt wirklich die JSON-Struktur vor.Ausgehend von diesem Character Vektor k√∂nnen wir nun mit fromJSON() aus dem jsonlite alles ein Listenformat transformieren.Die fromJSON() Funktion ben√∂tigt einen Character Vektor, der die JSON-Struktur enth√§lt, die wir aus der Ausgabe von rawToChar() erhalten haben. Wenn wir also diese beiden Funktionen aneinanderreihen, erhalten wir die gew√ºnschten Daten einem Format, das wir R leichter bearbeiten k√∂nnen.Die Liste data hat drei Elemente. Uns interessiert erster Linie das Data Frame people.Also, da haben wir unsere Antwort: Zum Zeitpunkt des letzten Updates Sun Oct 17 23:13:18 2021 von R4ews befanden sich 10 Personen im Weltraum. Aber wenn du alles selbst ausprobierst, k√∂nnten es auch schon wieder andere Namen und eine andere Anzahl sein. Das ist einer der Vorteile von APIs - im Gegensatz zu herunterladbaren Datens√§tzen werden sie im Allgemeinen Echtzeit oder nahezu Echtzeit aktualisiert, dass sie eine gro√üartige M√∂glichkeit darstellen, Zugang zu sehr aktuellen Daten zu erhalten.diesem Beispiel haben wir einen sehr unkomplizierten API-Workflow durchlaufen. Die meisten APIs erfordern, dass Sie demselben allgemeinen Muster folgen, aber dabei k√∂nnen sie durchaus komplexer sein.unserem Beispiel war es ausreichen nur die URL anzugeben. Aber einige APIs verlangen durchaus mehr Informationen vom Benutzer. Im letzten Teil dieser Einf√ºhrung gehen wir darauf ein, wie du der API mit deiner Anfrage zus√§tzliche Informationen zur Verf√ºgung stellen kannst.","code":"{\n    ‚Äúname‚Äù: ‚ÄúJane Doe‚Äù,\n    ‚Äúnumber_of_skills‚Äù: 2\n}> rawToChar(jdata$content)\n## [1] \"{\\\"number\\\": 10, \\\"people\\\": [{\\\"craft\\\": \\\"ISS\\\", \\\"name\\\": \\\"Mark Vande Hei\\\"}, {\\\"craft\\\": \\\"ISS\\\", \\\"name\\\": \\\"Pyotr Dubrov\\\"}, {\\\"craft\\\": \\\"ISS\\\", \\\"name\\\": \\\"Thomas Pesquet\\\"}, {\\\"craft\\\": \\\"ISS\\\", \\\"name\\\": \\\"Megan McArthur\\\"}, {\\\"craft\\\": \\\"ISS\\\", \\\"name\\\": \\\"Shane Kimbrough\\\"}, {\\\"craft\\\": \\\"ISS\\\", \\\"name\\\": \\\"Akihiko Hoshide\\\"}, {\\\"craft\\\": \\\"ISS\\\", \\\"name\\\": \\\"Anton Shkaplerov\\\"}, {\\\"craft\\\": \\\"Shenzhou 13\\\", \\\"name\\\": \\\"Zhai Zhigang\\\"}, {\\\"craft\\\": \\\"Shenzhou 13\\\", \\\"name\\\": \\\"Wang Yaping\\\"}, {\\\"craft\\\": \\\"Shenzhou 13\\\", \\\"name\\\": \\\"Ye Guangfu\\\"}], \\\"message\\\": \\\"success\\\"}\"> data <-  fromJSON(rawToChar(jdata$content))\n> glimpse(data)\n## List of 3\n##  $ number : int 10\n##  $ people :'data.frame': 10 obs. of  2 variables:\n##   ..$ craft: chr [1:10] \"ISS\" \"ISS\" \"ISS\" \"ISS\" ...\n##   ..$ name : chr [1:10] \"Mark Vande Hei\" \"Pyotr Dubrov\" \"Thomas Pesquet\" \"Meg\"..\n##  $ message: chr \"success\"> data$people\n##          craft             name\n## 1          ISS   Mark Vande Hei\n## 2          ISS     Pyotr Dubrov\n## 3          ISS   Thomas Pesquet\n## 4          ISS   Megan McArthur\n## 5          ISS  Shane Kimbrough\n## 6          ISS  Akihiko Hoshide\n## 7          ISS Anton Shkaplerov\n## 8  Shenzhou 13     Zhai Zhigang\n## 9  Shenzhou 13      Wang Yaping\n## 10 Shenzhou 13       Ye Guangfu"},{"path":"import-export.html","id":"apis-und-abfrageparameter","chapter":"Kapitel 8 Daten I/O","heading":"8.6.6 APIs und Abfrageparameter","text":"w√§re, wenn wir wissen wollten, wann die ISS einen bestimmten Ort auf der Erde √ºberfliegen w√ºrde? Die ISS Pass Times API von Open Notify verlangt von uns, dass wir zus√§tzliche Parameter angeben, bevor sie die gew√ºnschten Daten zur√ºckgeben kann.Wir m√ºssen den L√§ngen- und Breitengrad des Ortes angeben, nach dem wir im Rahmen unserer GET() Anfrage fragen. Sobald ein L√§ngen- und Breitengrad angegeben ist, werden sie als Abfrageparameter mit der urspr√ºnglichen URL kombiniert.Lass uns die API verwenden, um herauszufinden, wann die ISS Garching (auf 48.24896 Breiten- und 11.65101 L√§ngengrad) passieren wird:Man muss der Dokumentation f√ºr die API, mit man arbeiten , nachsehen, ob es erforderliche Abfrageparameter gibt. F√ºr die √ºberwiegende Mehrheit der APIs, auf die du m√∂glicherweise zugreifen m√∂chtest, gibt es eine Dokumentation, die du lesen kannst (und lesen solltest), um ein klares Verst√§ndnis daf√ºr zu erhalten, welche Parameter deine Anfrage erfordert.Wie auch immer, jetzt, da wir unsere Anfrage einschlie√ülich der Standortparameter gestellt haben, k√∂nnen wir die Antwort mit den gleichen Funktionen √ºberpr√ºfen, die wir zuvor verwendet haben. Lass uns die Daten aus der Antwort extrahieren:Diese API gibt uns Zeiten Form von Unixzeit zur√ºck. Unixzeit ist die Zeitspanne, die seit dem 1. Januar 1970 vergangen ist. Mithilfe der Funktion as_datetime() aus dem lubridate Paket k√∂nnen wir die Unixzeit aber leicht umrechnenWir haben hier wirklich nur die Basics Bezug auf APIs eingef√ºhrt. Aber hoffentlich hat dir diese Einf√ºhrung trotzdem das Vertrauen gegeben, sich mit einigen komplexeren und leistungsf√§higeren APIs auseinanderzusetzen, und tr√§gt dadurch dazu bei, eine ganz neue Welt von Daten zu erschlie√üen, die du erforschen kannst!","code":"> jdata <-  GET(\"http://api.open-notify.org/iss-pass.json\",\n+     query = list(lat = 48.24896, lon = 11.65101))> data <- fromJSON(rawToChar(jdata$content))\n> data$response\n##   duration   risetime\n## 1      371 1634533071\n## 2      626 1634538699\n## 3      655 1634544484\n## 4      648 1634550314\n## 5      655 1634556134> lubridate::as_datetime(data$response$risetime)\n## [1] \"2021-10-18 04:57:51 UTC\" \"2021-10-18 06:31:39 UTC\"\n## [3] \"2021-10-18 08:08:04 UTC\" \"2021-10-18 09:45:14 UTC\"\n## [5] \"2021-10-18 11:22:14 UTC\""},{"path":"import-export.html","id":"weiteres-material","chapter":"Kapitel 8 Daten I/O","heading":"8.7 Weiteres Material","text":"Hier sein noch auf das Kapitel Data import im Buch R Data Science von Hadley Wickham und Garrett Grolemund (2016) verwiesen f√ºr weitere Information zum Daten Import.","code":""},{"path":"tidy.html","id":"tidy","chapter":"Kapitel 9 tidy ?","heading":"Kapitel 9 tidy ?","text":"Idealerweise liegt ein Datensatz vor, dass er gut von einem Computer gelesen werden kann. der Regel sind die Datens√§tze, mit denen wir uns besch√§ftigen, ja umfangreich, d.h. der Mensch den Datensatz ja gar nicht (ein-)lesen. Trotzdem sind Datens√§tze oft anders angelegt (der Mensch trifft die Entscheidung √ºber das Layout).Der Computer kann einen Datensatz gut verarbeiten, wenn wir den Datensatz als tidy bezeichnen k√∂nnen. Hauptmerkmal von einem tidy Datensatz:Jede Spalte ist eine VariableJede Zeile ist eine BeobachtungUntidy data mag z.B. der Grund daf√ºr sein, dass Du mit einer Abbildung k√§mpfst. Daher lohnt es sich immer mal inne zu halten um zu √ºberlegen, ob die Daten tidy sind. Unordnung ist eine h√§ufige, oft √ºbersehene Ursache f√ºr Qualen bei der Datenanalyse und -visualisierung.","code":""},{"path":"tidy.html","id":"lord-of-the-rings","chapter":"Kapitel 9 tidy ?","heading":"9.1 Lord of the Rings","text":"Von Jenny Byran (Autorin von STAT 545) habe ich folgenden Beispieldatensatz √ºbernommen: Data Lord Rings TrilogyWir haben eine Tabelle pro Film. jeder Tabelle haben wir die Gesamtzahl der gesprochenen W√∂rter, von Charakteren verschiedener Kategorien und Geschlechter.Stell dir vor, diese drei Tabellen als separate Arbeitsbl√§tter einer Excel-Arbeitsmappe zu finden. Oder einigen Zellen Rande eines Arbeitsblatts, das die zugrunde liegenden Rohdaten enth√§lt. Oder als Tabellen auf einer Webseite oder einem Word-Dokument.Das Format der Tabellen macht es f√ºr einen Menschen einfach, die Anzahl der von weiblichen Elfen ‚ÄúTwo Towers‚Äù gesprochenen W√∂rter nachzuschlagen. Aber dieses Format macht es f√ºr einen Computer ziemlich schwer, solche Z√§hlungen herauszuziehen und, noch wichtiger ist, damit zu rechnen oder sie grafisch darzustellen.Diese Aufgabe ist dann wieder nicht einfach, da die Daten untidy sind: Die Inhalte der Spalte Female und Male enthalten nicht die Information √ºber das Geschlecht. Auf der anderen Seite sind Wert der Variable (noch nicht vorhanden) Words auf zwei Spalten verteilt.","code":""},{"path":"tidy.html","id":"tidy-lord-of-the-rings-data","chapter":"Kapitel 9 tidy ?","heading":"9.2 Tidy Lord of the Rings data","text":"sauberer Form sehen die Daten folgenderma√üen aus:Beachte, dass tidy data im Allgemeinen h√∂her und schmaler sind. Bestimmte Elemente werden oft wiederholt, z. B. Hobbit. Aus diesen Gr√ºnden lehnen wir tidy Daten oft instinktiv als ineffizient oder h√§sslich ab. Aber, solange du nicht das Endprodukt f√ºr eine textuelle Pr√§sentation von Daten erstellst, solltest du diesen Instinkt ignorieren.","code":""},{"path":"tidy.html","id":"vorteile-von-tidy-data","chapter":"Kapitel 9 tidy ?","heading":"9.3 Vorteile von tidy data","text":"Wenn die Daten ordentlicher Form vorliegen, ist es naheliegend, einen Computer zu holen, um weitere Zusammenfassungen zu machen oder eine Abbildung zu erstellen.dieser Form k√∂nnen wir nun leicht folgende Fragen beantworten:Wie viele W√∂rter haben die m√§nnlichen Hobbits insgesamt gesprochen?Wie viele W√∂rter haben die m√§nnlichen Hobbits insgesamt gesprochen?Dominiert eine bestimmte Race einen Film? Unterscheidet sich die dominierende Race den Filmen?Dominiert eine bestimmte Race einen Film? Unterscheidet sich die dominierende Race den Filmen?","code":""},{"path":"tidy.html","id":"wie-viele-w√∂rter-haben-die-m√§nnlichen-hobbits-insgesamt-gesprochen","chapter":"Kapitel 9 tidy ?","heading":"9.3.0.1 Wie viele W√∂rter haben die m√§nnlichen Hobbits insgesamt gesprochen?","text":"Nun braucht es nur noch ein kleines bisschen Code, um die Gesamtwortzahl f√ºr beide Geschlechter aller Kategorien √ºber alle Filme hinweg zu berechnen. Die Gesamtzahl der von m√§nnlichen Hobbits gesprochenen W√∂rter ist 8780. Hier war es wichtig, alle Wortz√§hlungen einer einzigen Variable zu haben, innerhalb eines Data Frames, der auch eine Variable f√ºr Geschlecht und Kategorie enthielt.","code":"\nlibrary(tidyverse)\nlotr_tidy %>% \n  count(Gender, Race, wt = Words)## # A tibble: 6 x 3\n##   Gender Race       n\n##   <chr>  <chr>  <dbl>\n## 1 Female Elf     1743\n## 2 Female Hobbit    16\n## 3 Female Man      669\n## 4 Male   Elf     1994\n## 5 Male   Hobbit  8780\n## 6 Male   Man     8043"},{"path":"tidy.html","id":"dominiert-eine-bestimmte-kategorie-einen-film-unterscheidet-sich-die-dominierende-kategorie-in-den-filmen","chapter":"Kapitel 9 tidy ?","heading":"9.3.0.2 Dominiert eine bestimmte Kategorie einen Film? Unterscheidet sich die dominierende Kategorie in den Filmen?","text":"Zun√§chst summieren wir √ºber die Geschlechter hinweg, um die Wortzahlen f√ºr die verschiedenen Kategorien nach Film zu erhalten.Wir k√∂nnen ganz genau auf diese Zahlen starren, um die Frage zu beantworten. Aber noch sch√∂ner ist es, die gerade berechneten Wortzahlen einem Balkendiagramm darzustellen.Hobbits sind ‚ÄúFellowhip Ring‚Äù stark vertreten, w√§hrend die Menschen ‚ÄúTwo Towers‚Äù viel mehr Leinwandzeit hatten. Ebenso prominent waren sie im letzten Film, ‚ÄúReturn King‚Äù.Auch hier war es wichtig, alle Daten einem einzigen Data Frame zu haben, alle Wortz√§hlungen einer einzigen Variable und zugeh√∂rige Variablen f√ºr Film und Kategorie.Im n√§chsten Schritt schauen wir uns nun , wie man aus den obigen drei Tabellen eine sauberen Datensatz erzeugt.","code":"\n(by_race_film <- lotr_tidy %>% \n   group_by(Film, Race) %>% \n   summarize(Words = sum(Words)))## `summarise()` has grouped output by 'Film'. You can override using the `.groups` argument.## # A tibble: 9 x 3\n## # Groups:   Film [3]\n##   Film                       Race   Words\n##   <chr>                      <chr>  <dbl>\n## 1 The Fellowship Of The Ring Elf     2200\n## 2 The Fellowship Of The Ring Hobbit  3658\n## 3 The Fellowship Of The Ring Man     1995\n## 4 The Return Of The King     Elf      693\n## 5 The Return Of The King     Hobbit  2675\n## 6 The Return Of The King     Man     2727\n## 7 The Two Towers             Elf      844\n## 8 The Two Towers             Hobbit  2463\n## 9 The Two Towers             Man     3990\nggplot(by_race_film, aes(x = Film, y = Words, fill = Race)) + \n  geom_bar(stat = \"identity\", position = \"dodge\") +\n  coord_flip() + guides(fill = guide_legend(reverse = TRUE)) + \n  scale_fill_brewer(palette = \"Set1\")"},{"path":"tidy.html","id":"untidy-lord-of-the-rings-data","chapter":"Kapitel 9 tidy ?","heading":"9.4 Untidy Lord of the Rings data","text":"Wir importieren nun die Daten, die den drei filmspezifischen Wortz√§hlungstabellen dargestellt wurden.F√ºr jede Tabelle existiert eine eigene csv Datei:The_Fellowship_Of_The_Ring.csvThe_Two_Towers.csvThe_Return_Of_The_King.csv","code":"\nfship <- read_csv(file.path(\"data\", \"The_Fellowship_Of_The_Ring.csv\"))## Rows: 3 Columns: 4## ‚îÄ‚îÄ Column specification ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n## Delimiter: \",\"\n## chr (2): Film, Race\n## dbl (2): Female, Male## \n## ‚Ñπ Use `spec()` to retrieve the full column specification for this data.\n## ‚Ñπ Specify the column types or set `show_col_types = FALSE` to quiet this message.\nttow <- read_csv(file.path(\"data\", \"The_Two_Towers.csv\"))## Rows: 3 Columns: 4## ‚îÄ‚îÄ Column specification ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n## Delimiter: \",\"\n## chr (2): Film, Race\n## dbl (2): Female, Male## \n## ‚Ñπ Use `spec()` to retrieve the full column specification for this data.\n## ‚Ñπ Specify the column types or set `show_col_types = FALSE` to quiet this message.\nrking <- read_csv(file.path(\"data\", \"The_Return_Of_The_King.csv\")) ## Rows: 3 Columns: 4## ‚îÄ‚îÄ Column specification ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n## Delimiter: \",\"\n## chr (2): Film, Race\n## dbl (2): Female, Male## \n## ‚Ñπ Use `spec()` to retrieve the full column specification for this data.\n## ‚Ñπ Specify the column types or set `show_col_types = FALSE` to quiet this message.\nrking## # A tibble: 3 x 4\n##   Film                   Race   Female  Male\n##   <chr>                  <chr>   <dbl> <dbl>\n## 1 The Return Of The King Elf       183   510\n## 2 The Return Of The King Hobbit      2  2673\n## 3 The Return Of The King Man       268  2459"},{"path":"tidy.html","id":"und-nun-alles-zusammen","chapter":"Kapitel 9 tidy ?","heading":"9.5 Und nun alles zusammen","text":"Wir haben jetzt ein Data Frame pro Film, jeweils mit den vier VariablenDer erste Schritt beim Aufr√§umen dieser Daten besteht darin, sie zu einem Data Frame zusammenzuf√ºgen, indem wir die drei Data Frames zeilenweise stapeln. Dazu k√∂nnen wir die Funktion dplyr::bind_rows() verwenden.Das Zusammensetzen eines gro√üen Datenobjekts aus vielen kleinen ist eine relativ √ºbliche Aufgabe bei der Datenaufbereitung. Wenn die Teile √§hnlich sind wie hier, ist es sch√∂n, sie gleich zu einem Objekt zusammenzusetzen. anderen Szenarien m√ºsst du m√∂glicherweise einige Nacharbeiten den einzelnen Objekten vornehmen, bevor sie gut zusammengef√ºgt werden k√∂nnen.Wenn m√∂glich, sollte man die einzelnen St√ºcke fr√ºh wie m√∂glich\nzusammensetzen, denn es ist einfacher und effizienter, ein einzelnes Objekt aufzur√§umen als 20 oder 1000.","code":"\nnames(rking)## [1] \"Film\"   \"Race\"   \"Female\" \"Male\"\nlotr_untidy <- bind_rows(fship, ttow, rking)\nlotr_untidy## # A tibble: 9 x 4\n##   Film                       Race   Female  Male\n##   <chr>                      <chr>   <dbl> <dbl>\n## 1 The Fellowship Of The Ring Elf      1229   971\n## 2 The Fellowship Of The Ring Hobbit     14  3644\n## 3 The Fellowship Of The Ring Man         0  1995\n## 4 The Two Towers             Elf       331   513\n## 5 The Two Towers             Hobbit      0  2463\n## 6 The Two Towers             Man       401  3589\n## 7 The Return Of The King     Elf       183   510\n## 8 The Return Of The King     Hobbit      2  2673\n## 9 The Return Of The King     Man       268  2459"},{"path":"tidy.html","id":"nun-k√∂nnen-wir-aufr√§umen","chapter":"Kapitel 9 tidy ?","heading":"9.6 Nun k√∂nnen wir aufr√§umen","text":"Wir verletzen immer noch eines der Grundprinzipien von tidy data. Die Anzahl gesprochenen W√∂rtern ist eine grundlegende Variable unserem Datensatz und sie ist derzeit auf zwei Variablen verteilt, Female und Male. Konzeptionell m√ºssen wir die Wortanzahl einer einzigen Variable zusammenfassen und eine neue Variable Gender erstellen, um zu verfolgen, ob die jeweilige Anzahl Worten von Frauen oder M√§nnern gesprochen wurde. Dies Aufgabe k√∂nnen wir mit der Funktion tidyr::pivot_longer() bearbeiten.Um unseren obigen Aufruf von pivot_longer() zu erkl√§ren, lesen wir ihn links nach rechts: Nach der Auswahl des Datensatzes lotr_untidy haben wird die Spalten Female und Male genommen und ihre Werte eine einzige neue Variable Words zusammengefasst. Dies erzwang die Erstellung einer neuen Variable Gender, die angibt, ob ein bestimmter Wert von Words von Female oder Male stammt. Alle anderen Variablen, wie Film, bleiben unver√§ndert und werden einfach nach Bedarf repliziert. Die Dokumentation f√ºr pivot_longer() gibt weitere Beispiele und dokumentiert zus√§tzliche Argumente.Wenn man sich diese Arbeit gemacht hat, dann macht es schon Sinn sich auch das Ergebnis abzuspeichernTrotzdem solltet ihr auch bei/nach der Datenaufbereitung auch die Skripte zur Datenaufbereitung wie auch die Originaldaten abspeichern.","code":"\nlotr_tidy <-\n  pivot_longer(lotr_untidy, cols = c(\"Female\", \"Male\"), names_to = 'Gender', \n               values_to = 'Words')\nlotr_tidy## # A tibble: 18 x 4\n##    Film                       Race   Gender Words\n##    <chr>                      <chr>  <chr>  <dbl>\n##  1 The Fellowship Of The Ring Elf    Female  1229\n##  2 The Fellowship Of The Ring Elf    Male     971\n##  3 The Fellowship Of The Ring Hobbit Female    14\n##  4 The Fellowship Of The Ring Hobbit Male    3644\n##  5 The Fellowship Of The Ring Man    Female     0\n##  6 The Fellowship Of The Ring Man    Male    1995\n##  7 The Two Towers             Elf    Female   331\n##  8 The Two Towers             Elf    Male     513\n##  9 The Two Towers             Hobbit Female     0\n## 10 The Two Towers             Hobbit Male    2463\n## 11 The Two Towers             Man    Female   401\n## 12 The Two Towers             Man    Male    3589\n## 13 The Return Of The King     Elf    Female   183\n## 14 The Return Of The King     Elf    Male     510\n## 15 The Return Of The King     Hobbit Female     2\n## 16 The Return Of The King     Hobbit Male    2673\n## 17 The Return Of The King     Man    Female   268\n## 18 The Return Of The King     Man    Male    2459\nwrite_csv(lotr_tidy, path = file.path(\"data\", \"lotr_tidy.csv\"))## Warning: The `path` argument of `write_csv()` is deprecated as of readr 1.4.0.\n## Please use the `file` argument instead."},{"path":"tidy.html","id":"und-jetzt-noch-ein-bisschen-schmutzig-machen","chapter":"Kapitel 9 tidy ?","heading":"9.7 Und jetzt noch ein bisschen ‚Äúschmutzig‚Äù machen","text":"Manchmal (aber nicht h√§ufig) ist es doch n√∂tig die Daten im Wide Format zu haben. Daher wollen wir zum Schluss die gerade ges√§uberten LOTR Daten nochmal ein bisschen untidy machen.Dazu arbeiten wir mit den Funktion tidyr::pivot_wider(). Wir nehmen nun die Auspr√§gungen der Variable Race (anschlie√üend dann Gender) als Variablennamen der neu zu bildenden Variablen. Die Werte dieser neuen Variablen sind durch die Variable Words festgelegt.Das erste Beispiel hat immer noch 6 Beobachtungen, zwei pro Film. Nehmen wir mal , dass wir aber nur eine Beobachtung pro Film haben wollen. Dazu m√ºssten wir die m√∂glichen Kombinationen aus Race und Gender neuen/weiteren Variablen zusammenfassen. Dies k√∂nnen wir √ºber die Funktion tidyr::unite() erreichen.Kombination mit pivot_wider() ergibt sich soZum Schluss k√∂nnten wir jetzt auch noch alles zur√ºck auf Anfang stellen und die\ndrei Datens√§tze vom Anfang wiederherstellenWir erhalten eine Liste mit drei Elemente, die deren Inhalt den drei Tabellen vom Anfang entspricht. Die Daten zu ‚ÄúReturn King‚Äù sind beispielsweise im zweiten Element enthalten.","code":"\n## Race\nlotr_tidy %>% \n  pivot_wider(names_from = Race, values_from = Words)## # A tibble: 6 x 5\n##   Film                       Gender   Elf Hobbit   Man\n##   <chr>                      <chr>  <dbl>  <dbl> <dbl>\n## 1 The Fellowship Of The Ring Female  1229     14     0\n## 2 The Fellowship Of The Ring Male     971   3644  1995\n## 3 The Two Towers             Female   331      0   401\n## 4 The Two Towers             Male     513   2463  3589\n## 5 The Return Of The King     Female   183      2   268\n## 6 The Return Of The King     Male     510   2673  2459\n## Gender\nlotr_tidy %>% \n  pivot_wider(names_from = Gender, values_from = Words)## # A tibble: 9 x 4\n##   Film                       Race   Female  Male\n##   <chr>                      <chr>   <dbl> <dbl>\n## 1 The Fellowship Of The Ring Elf      1229   971\n## 2 The Fellowship Of The Ring Hobbit     14  3644\n## 3 The Fellowship Of The Ring Man         0  1995\n## 4 The Two Towers             Elf       331   513\n## 5 The Two Towers             Hobbit      0  2463\n## 6 The Two Towers             Man       401  3589\n## 7 The Return Of The King     Elf       183   510\n## 8 The Return Of The King     Hobbit      2  2673\n## 9 The Return Of The King     Man       268  2459\nlotr_tidy %>% \n  unite(Race_Gender, Race, Gender)## # A tibble: 18 x 3\n##    Film                       Race_Gender   Words\n##    <chr>                      <chr>         <dbl>\n##  1 The Fellowship Of The Ring Elf_Female     1229\n##  2 The Fellowship Of The Ring Elf_Male        971\n##  3 The Fellowship Of The Ring Hobbit_Female    14\n##  4 The Fellowship Of The Ring Hobbit_Male    3644\n##  5 The Fellowship Of The Ring Man_Female        0\n##  6 The Fellowship Of The Ring Man_Male       1995\n##  7 The Two Towers             Elf_Female      331\n##  8 The Two Towers             Elf_Male        513\n##  9 The Two Towers             Hobbit_Female     0\n## 10 The Two Towers             Hobbit_Male    2463\n## 11 The Two Towers             Man_Female      401\n## 12 The Two Towers             Man_Male       3589\n## 13 The Return Of The King     Elf_Female      183\n## 14 The Return Of The King     Elf_Male        510\n## 15 The Return Of The King     Hobbit_Female     2\n## 16 The Return Of The King     Hobbit_Male    2673\n## 17 The Return Of The King     Man_Female      268\n## 18 The Return Of The King     Man_Male       2459\nlotr_tidy %>% \n  unite(Race_Gender, Race, Gender) %>% \n  pivot_wider(names_from = Race_Gender, values_from = Words)## # A tibble: 3 x 7\n##   Film         Elf_Female Elf_Male Hobbit_Female Hobbit_Male Man_Female Man_Male\n##   <chr>             <dbl>    <dbl>         <dbl>       <dbl>      <dbl>    <dbl>\n## 1 The Fellows‚Ä¶       1229      971            14        3644          0     1995\n## 2 The Two Tow‚Ä¶        331      513             0        2463        401     3589\n## 3 The Return ‚Ä¶        183      510             2        2673        268     2459\n(sep_list <- lotr_tidy %>% \n  pivot_wider(names_from = Gender, values_from = Words) %>%\n   group_split(Film))## <list_of<\n##   tbl_df<\n##     Film  : character\n##     Race  : character\n##     Female: double\n##     Male  : double\n##   >\n## >[3]>\n## [[1]]\n## # A tibble: 3 x 4\n##   Film                       Race   Female  Male\n##   <chr>                      <chr>   <dbl> <dbl>\n## 1 The Fellowship Of The Ring Elf      1229   971\n## 2 The Fellowship Of The Ring Hobbit     14  3644\n## 3 The Fellowship Of The Ring Man         0  1995\n## \n## [[2]]\n## # A tibble: 3 x 4\n##   Film                   Race   Female  Male\n##   <chr>                  <chr>   <dbl> <dbl>\n## 1 The Return Of The King Elf       183   510\n## 2 The Return Of The King Hobbit      2  2673\n## 3 The Return Of The King Man       268  2459\n## \n## [[3]]\n## # A tibble: 3 x 4\n##   Film           Race   Female  Male\n##   <chr>          <chr>   <dbl> <dbl>\n## 1 The Two Towers Elf       331   513\n## 2 The Two Towers Hobbit      0  2463\n## 3 The Two Towers Man       401  3589\nsep_list[[2]]## # A tibble: 3 x 4\n##   Film                   Race   Female  Male\n##   <chr>                  <chr>   <dbl> <dbl>\n## 1 The Return Of The King Elf       183   510\n## 2 The Return Of The King Hobbit      2  2673\n## 3 The Return Of The King Man       268  2459"},{"path":"tidy.html","id":"literatur-1","chapter":"Kapitel 9 tidy ?","heading":"9.8 Literatur","text":"Tidy data Kapitel R Data Science, Garrett Grolemund Hadley Wickham\ntidyr Paket\ntidyr PaketBad Data Handbook Q. Ethan McCallum, published O‚ÄôReilly.\nChapter 3: Data Intended Human Consumption, Machine Consumption Paul Murrell.\nChapter 3: Data Intended Human Consumption, Machine Consumption Paul Murrell.Tidy data Hadley Wickham. Journal Statistical Software. Vol. 59, Issue 10, Sep 2014. http://www.jstatsoft.org/v59/i10","code":""},{"path":"graphics-overview.html","id":"graphics-overview","chapter":"Kapitel 10 Einf√ºhrung","heading":"Kapitel 10 Einf√ºhrung","text":"Das Paket ggplot2 verwendet eine Grammatik beim Erzeugen von Grafiken. Diese basiert aufWilkinson (2005): Grammar Graphics, Springer.Dadurchist eine starke Abstraktion bei der Definition einer Grafik m√∂glichsteht ein sehr flexibles Grafiksystem zur Verf√ºgung.","code":""},{"path":"graphics-overview.html","id":"ggplot2-laden","chapter":"Kapitel 10 Einf√ºhrung","heading":"10.1 ggplot2 laden","text":"Wie zuvor auch, laden wir stets das komplette tidyverse. Man wei√ü ja vorher nie genau man alles braucht.","code":"> library(tidyverse)\n## ‚îÄ‚îÄ Attaching packages ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ tidyverse 1.3.1 ‚îÄ‚îÄ\n## ‚úì ggplot2 3.3.5     ‚úì purrr   0.3.4\n## ‚úì tibble  3.1.2     ‚úì dplyr   1.0.7\n## ‚úì tidyr   1.1.3     ‚úì stringr 1.4.0\n## ‚úì readr   2.0.1     ‚úì forcats 0.5.1\n## ‚îÄ‚îÄ Conflicts ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ tidyverse_conflicts() ‚îÄ‚îÄ\n## x dplyr::filter() masks stats::filter()\n## x dplyr::lag()    masks stats::lag()"},{"path":"graphics-overview.html","id":"idee","chapter":"Kapitel 10 Einf√ºhrung","heading":"10.2 Idee","text":"Die grundlegende Idee des ggplot2 Ansatzes zum Erstellen von Grafiken, besteht darin die Bausteine eines Plots unabh√§ngig voneinander zu definieren. Ein Plot besteht immer aus:Daten (als data.frame oder tibble)KoordinatensystemSkalageometrisches Objekt zur Darstellung (geom)Zus√§tzlich kann er aber auch nochstatistische Transformationen (stat)verschiedene Facetten‚Ä¶enthalten.Die einzelnen Teile eines Plots werden dann mit dem + Operator zusammengef√ºgt.Initialisiert wird ein Plot mit ggplot(). Ohne weitere Bestandteile wird aber nur eine leere Grafik erzeugtIn den folgenden Abschnitten lernen wir daher wie weitere Bestandteile zum Plot hinzugef√ºgt werden.","code":"> library(gapminder)\n> ggplot(gapminder) "},{"path":"graphics-overview.html","id":"ein-einfacher-scatterplot","chapter":"Kapitel 10 Einf√ºhrung","heading":"10.3 Ein einfacher Scatterplot","text":"Wir schauen uns zum Start einfach mal f√ºr Deutschland den Verlauf des gdpPercap √ºber die Zeit .diesem einfachen Beispiel haben wir bereits gesehen, dass ggplot() √ºber den Pipe-Operator verkn√ºpft werden kann.","code":"> gapminder %>%\n+   filter(country == \"Germany\") %>% # ausw√§hlen der Daten \n+   ggplot(aes(x = year, y = gdpPercap)) +  # plot initialisieren\n+   geom_point() # punkte zum Darstellen der Daten verwenden"},{"path":"bausteine.html","id":"bausteine","chapter":"Kapitel 11 Bausteine","heading":"Kapitel 11 Bausteine","text":"","code":""},{"path":"bausteine.html","id":"aes","chapter":"Kapitel 11 Bausteine","heading":"11.1 Aesthetics","text":"Mit der Funktion aes() l√§sst sich das Aussehen der Grafik regeln (nicht der Inhalt). Wir k√∂nnen z.B.die Position: x und ydie Farbe: color und filldie Form: shapeden Linientyp: linetypedie Gr√∂√üe der Symbol: sizefestlegen. Nicht jedes aesthetic kann allerdings mit allen verf√ºgbaren geoms kombiniert werden. macht z.B. der linetype ja wenig Sinn geom_point(). Ein √úbersicht der m√∂glichen aesthetics findet man der Hilfe jeder geom-FunktionIn der aes() Funktion sollten die Daten den Wert der Argumente bestimmen. Werden Argumente auf fixe Werte gesetzt, sind sie au√üerhalb der aes() Funktion zu setzen.einem Plot der gdpPercap Daten f√ºr Deutschland und Frankreich wollen wir anhand von unterschiedlichen Farben die Daten der beiden L√§nder unterscheiden. Dazu m√ºssen wir nur colour innerhalb von aes() den Wert country zuweisen.","code":"geom_point {ggplot2}    R Documentation\nPoints\nDescription\nThe point geom is used to create scatterplots. The scatterplot is most useful for displaying the relationship between two continuous variables. It can be used to compare one continuous and one categorical variable, or two categorical variables, but a variation like geom_jitter(), geom_count(), or geom_bin2d() is usually more appropriate. A bubblechart is a scatterplot with a third variable mapped to the size of points.\n\nUsage\ngeom_point(\n  mapping = NULL,\n  data = NULL,\n  stat = \"identity\",\n  position = \"identity\",\n  ...,\n  na.rm = FALSE,\n  show.legend = NA,\n  inherit.aes = TRUE\n)\n\n...\n\nAesthetics\ngeom_point() understands the following aesthetics (required aesthetics are in bold):\n\nx\n\ny\n\nalpha\n\ncolour\n\nfill\n\ngroup\n\nshape\n\nsize\n\nstroke\n\nLearn more about setting these aesthetics in vignette(\"ggplot2-specs\").\n> gapminder %>%\n+   filter(country %in% c(\"Germany\",\"France\")) %>% # ausw√§hlen der Daten \n+   ggplot(aes(x = year, y = gdpPercap, colour = country)) +  \n+   geom_point(size = 3) # size wird auf einen fixen Wert gesetzt (au√üerhalb von aes())"},{"path":"bausteine.html","id":"geoms","chapter":"Kapitel 11 Bausteine","heading":"11.2 Geoms","text":"Mit den geom_xx() Funktionen stellen wir die Daten als geometrische Formen einer Grafik dar. Jede ggplot2 Grafik ben√∂tigt daher mindestens ein geom. Beispiele sindgeom_point()geom_line()geom_histogram()Da wir nicht alle verf√ºgbaren geoms auflisten k√∂nnen, sei dieser Stelle auf die ggplot2 Seite verwiesen.Wir haben hier die gleichen Daten visualisiert. Allerdings ist das Ergebnis doch recht unterschiedlich. Der Scatterplot zeigt alle (abgesehen von √ºberzeichnen) Daten, wohingegen mit geom_smooth() eine gegl√§tteter Zusammenhang dargestellt wird.Interessant sind hier nat√ºrlich die wenigen gro√üen gdpPercap WerteKuwait hat √ºber den gesamten Zeitraum hohe GDP Werte. Aber zu Beginn der Aufzeichnungen waren die Werte Bezug auf die damals noch recht kleine Populationsgr√∂√üe au√üergew√∂hnlich hoch.Einem ggplot Objekt k√∂nnen wir nicht nur ein geom zuordnen. Prinzipiell k√∂nnen wir beliebig viele weitere geoms hinzuf√ºgen. Wir k√∂nnen also die gerade durchgef√ºhrte Gl√§ttung der Daten auch\ndirekt zum Scatterplot hinzuf√ºgenW√§hlen wir die Farbe der geometrischen Objekte anhand einer Faktorvariable, erhalten wir automatisch eine entsprechende Legende\nBeachte auch, dass wir colour nur f√ºr geom_point() gew√§hlt haben. Die Gl√§ttung erfolgt weiterhin √ºber alle Daten und nicht separat f√ºr jeden Kontinent. Aber das w√§re nat√ºrlich auch m√∂glich. Dazu k√∂nnen wir colour wieder global ggplot() definieren.Die Punkte sind mir etwas zu gro√ü und der Linientyp gef√§llt mir auch nicht diesem Plot. Aber das l√§sst sich schnell √§ndern.","code":"> gapminder %>%\n+   ggplot(aes(x = year, y = gdpPercap)) +  \n+   geom_point() \n> \n> \n> gapminder %>%\n+   ggplot(aes(x = year, y = gdpPercap)) +  \n+   geom_smooth() \n## `geom_smooth()` using method = 'gam' and formula 'y ~ s(x, bs = \"cs\")'> gapminder %>%\n+   filter(gdpPercap > 50000)\n## # A tibble: 6 x 6\n##   country continent  year lifeExp     pop gdpPercap\n##   <fct>   <fct>     <int>   <dbl>   <int>     <dbl>\n## 1 Kuwait  Asia       1952    55.6  160000   108382.\n## 2 Kuwait  Asia       1957    58.0  212846   113523.\n## 3 Kuwait  Asia       1962    60.5  358266    95458.\n## 4 Kuwait  Asia       1967    64.6  575003    80895.\n## 5 Kuwait  Asia       1972    67.7  841934   109348.\n## 6 Kuwait  Asia       1977    69.3 1140357    59265.> gapminder %>%\n+   ggplot(aes(x = year, y = gdpPercap)) +  \n+   geom_point() +\n+   geom_smooth() \n## `geom_smooth()` using method = 'gam' and formula 'y ~ s(x, bs = \"cs\")'> gapminder %>%\n+   ggplot(aes(x = year, y = gdpPercap)) +  \n+   geom_point(aes(colour = continent)) +\n+   geom_smooth() \n## `geom_smooth()` using method = 'gam' and formula 'y ~ s(x, bs = \"cs\")'> gapminder %>%\n+   ggplot(aes(x = year, y = gdpPercap, colour = continent)) +  \n+   geom_point() +\n+   geom_smooth() \n## `geom_smooth()` using method = 'loess' and formula 'y ~ x'> gapminder %>%\n+   ggplot(aes(x = year, y = gdpPercap, colour = continent)) +  \n+   geom_point(size = 0.9) +\n+   geom_smooth(linetype = 2) \n## `geom_smooth()` using method = 'loess' and formula 'y ~ x'"},{"path":"bausteine.html","id":"stat-trans","chapter":"Kapitel 11 Bausteine","heading":"11.3 Statistische Transformationen","text":"Jede geom_xx() Funktion besitzt eine Default Statistik, die berechnet wird.Bei einem Scatterplot ist dies nur die Identit√§t.Ein Balkendiagramm verwendet anderseitsdie Transformation count, Sinn macht, da ja gez√§hlt werden muss/soll wie viele Beobachtungen die jeweilige Kategorie fallen.Der Aufruf der stat_xx() Funktion ist oftmals einfacher √ºber die entsprechende geom_xx() Funktion, aber nat√ºrlich kann die stat_xx() Funktion auch direkt aufgerufen werden.Jedes geom hat zwar ein Default-Transformation, aber nat√ºrlich k√∂nnen oftmals noch weitere Transformationen berechnet/genutzt werden. Im Abschnitt Computed variables der Hilfe zu einem geom sieht man alle verf√ºgbaren TransformationenF√ºr geom_bar() sind diesDie relativen H√§ufigkeiten berechnet man also √ºber prop. Dazu muss die y-Variable auf prop gesetzt werden. Da der Aufrufaber nach einer Variable prop suchen w√ºrde, muss eine alternative Notation diesem Fall verwendet werdenDas sieht jetzt noch nicht wie wir das erwartet haben. Die\nrelativen H√§ufigkeiten wurden innerhalb der f√ºnf Gruppen berechnet und nicht √ºber alle Beobachtungen. D.h. wir m√ºssen der Funktion noch sagen, dass es nur eine Gruppe geben soll.","code":"> args(geom_point)\n## function (mapping = NULL, data = NULL, stat = \"identity\", position = \"identity\", \n##     ..., na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) \n## NULL> args(geom_bar)\n## function (mapping = NULL, data = NULL, stat = \"count\", position = \"stack\", \n##     ..., width = NULL, na.rm = FALSE, orientation = NA, show.legend = NA, \n##     inherit.aes = TRUE) \n## NULL> ggplot(gapminder, aes(x = continent)) + \n+   geom_bar()> \n> ggplot(gapminder, aes(x = continent)) + \n+   stat_count()Computed variables\n\ncount\nnumber of points in bin\n\nprop\ngroupwise proportion\n\n> ggplot(gapminder, aes(x = continent, y = prop))> ggplot(gapminder, aes(x = continent, y = ..prop..)) + \n+   geom_bar()> ggplot(gapminder, aes(x = continent, y = ..prop..)) + \n+   geom_bar(aes(group = 1))"},{"path":"bausteine.html","id":"scales","chapter":"Kapitel 11 Bausteine","heading":"11.4 scales","text":"Scales steuern die Zuordnung von Daten zu aesthetics. Sie nehmen deine Daten und bestimmen damit Gr√∂√üe, Farbe, Position oder Form von Objekten. Sie erlauben dir auch die Achsen und die Legend nach deinen Vorstellungen anzupassen. Du kannst sicher mit ggplot2 Grafiken erstellen, ohne zu wissen, wie scales funktionieren, aber wenn du scales verstehst und lernst, wie du sie einstellen kannst, wirst du viel mehr Kontrolle √ºber deine Grafiken bekommen.Neben weiteren M√∂glichkeiten k√∂nnen wir √ºber scales alsocolor und fillpositionsizeshapeline typedurch Verwendung der scale_\"aesthetic\"_\"type\" Funktionen modifizieren. Argumente dieser Funktionen sind z.B. name, limits, breaks oder labels.Zuerst spielen wir etwas mit Farben. Dazu plotten wir erneut year gegen gdpPercap und w√§hlen f√ºr jeden Kontinent eine eigene Farbe. Da wir die Farben √ºber colour definieren, verwenden wir danach die Funktionen scale_colour_xxx() (im Vergleich zu z.B. scale_fill_brewer()).diesem Beispiel haben wir also die Farbe √ºber eine vorgegebene Palette, Grau-Stufen bzw. manuell gew√§hlt. Im letzten Beispiel haben wir zus√§tzlich noch den Titel der Legende ge√§ndert √ºber das name Argument.Die Achsenbeschriftung der y-Achse ist nicht wirklich sch√∂n, weil nicht unbedingt selbsterkl√§rend. Daher √§ndern wir im n√§chsten Schritt die Achsenbeschriftung.Da es sich bei gdpPercap um eine stetige Variable handelt, haben wir scale_y_continuous() verwendet (im Gegensatz zu scale_y_discrete()) um die Achsenbeschriftung zu √§ndern. √úber die Hilfsfunktion labs() k√∂nnen wir die Beschriftung der Grafik aber auch einfacher/intuitiver √§ndern.Die fr√ºhen Kuwait-Beobachtungen ziehen die y-Achse stark auseinander. Daher k√∂nnte man etwas den Plot hinein zoomen wollen. Dazu kann man das Koordinatensystem anpassen √ºbercoord_cartasian(). Alternativ k√∂nnte man auch mit der Funktion ylim() arbeiten (analog existiert nat√ºrlich auch xlmin()). Verwendet man xlim() bzw. ylim(), werden alle Datenpunkte, die nicht im zu plottenden Bereich liegen, aber nicht nur nicht gezeichnet, sondern auch aus dem Datensatz (f√ºr diesen einen Plot) entfernt. Dies hat Auswirkungen auf Teile des Plots, die auf statistische Transformationen basieren, die mithilfe der vorhanden Daten berechnet wurden.der rechten Grafik ist der Verlauf der Kurven unver√§ndert. der linken Grafik hingegen liegt die Kurve f√ºr Asien nun deutlich unter der Kurve f√ºr Amerika bis Mitte der 80er Jahre.Andere m√∂gliche Positions√§nderungen ergeben sich durch Skalierungen der Achsen wie scale_x_log10(), scale_y_sqrt() oderF√ºr weitere Optionen sei hier auf die online Version der neuesten Auflage von ggplot2 (Wickham 2009) verwiesen.","code":"> (p <- gapminder %>%\n+   ggplot(aes(x = year, y = gdpPercap, colour = continent)) +  \n+   geom_point(size = 0.9) +\n+   geom_smooth(linetype = 2) )\n## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\n> \n> p + scale_colour_brewer(palette = \"Set1\") # Farbpaletten von http://colorbrewer2.org/\n## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\n> \n> p + scale_colour_grey(start = 0.1, end = 0.9) # keine so gute Wahl\n## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\n> \n> p + scale_colour_manual(values = c(\"blue\", \"gold\", \"sienna1\", \"sienna4\", \"hotpink1\", \"hotpink4\"), name = \"Kontinent\")\n## `geom_smooth()` using method = 'loess' and formula 'y ~ x'> p <- p + scale_colour_manual(values = c(\"blue\", \"gold\", \"sienna1\", \"sienna4\", \"hotpink1\", \"hotpink4\"))\n> \n> p + scale_y_continuous(\"GDP pro Kopf\")\n## `geom_smooth()` using method = 'loess' and formula 'y ~ x'> (p <- p + labs(x = \"Jahr\", y = \"GDP pro Kopf\",\n+          title = \"Monoton steigendes GDP pro Kopf\",\n+          subtitle = \"Gestrichelte Linie zeigt Durchschnittswerte √ºber alle L√§nder pro Kontinent\"))\n## `geom_smooth()` using method = 'loess' and formula 'y ~ x'> p + ylim(0,55000)\n## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\n## Warning: Removed 6 rows containing non-finite values\n## (stat_smooth).\n## Warning: Removed 6 rows containing missing values\n## (geom_point).\n> (p <- p + coord_cartesian(ylim = c(0, 55000)))\n## `geom_smooth()` using method = 'loess' and formula 'y ~ x'> p + scale_x_reverse()\n## `geom_smooth()` using method = 'loess' and formula 'y ~ x'"},{"path":"bausteine.html","id":"facets","chapter":"Kapitel 11 Bausteine","heading":"11.5 facets","text":"Datens√§tze lassen sich oftmals bzgl. vorhandener Variablen gruppieren. Dann man Zusammenh√§nge weiterer Variablen innerhalb dieser Gruppen darstellen. Entsteht die Gruppierung aufgrund einer Variable, kannst du mit facet_wrap() arbeitenIn der letzten Grafik verwenden alle f√ºnf Plots die gleiche Skala auf der y-Achse um die Vergleichbarkeit der Werte zu erh√∂hen. manchen F√§llen mag dies aber st√∂rend sein. Mit dem Argument scale kannst du die Skala ‚Äúbefreien‚Äù.Erfolgt die Gruppierung anhand von zwei Variablen, bietet facet_grid() eine passende Aufteilung des Grafikfensters. Neben dem Kontinent betrachten wir nun auch noch ob die Populationsgr√∂√üe des Landes im entsprechenden Jahr gr√∂√üer als 5000000 ist, oder eben nicht.F√ºr Ozeanien erhalten wir z.B. eine Unterteilung Australien (TRUE) und Neuseeland (FALSE).","code":"> gapminder %>%\n+   ggplot(aes(x = year, y = gdpPercap )) +  \n+   geom_point(size = 0.9) +\n+   geom_smooth(linetype = 2) +\n+   facet_wrap(~ continent, ncol = 2)\n## `geom_smooth()` using method = 'loess' and formula 'y ~ x'> gapminder %>%\n+   ggplot(aes(x = year, y = gdpPercap )) +  \n+   geom_point(size = 0.9) +\n+   geom_smooth(linetype = 2) +\n+   facet_wrap(~ continent, ncol = 2, scales = \"free\")\n## `geom_smooth()` using method = 'loess' and formula 'y ~ x'> gapminder %>%\n+   group_by(continent) %>%\n+   ggplot(aes(x = year, y = gdpPercap )) +  \n+   geom_point(size = 0.9) +\n+   geom_smooth(linetype = 2) +\n+   facet_grid(continent ~ pop > 5000000, scales = \"free\")\n## `geom_smooth()` using method = 'loess' and formula 'y ~ x'"},{"path":"bausteine.html","id":"themes","chapter":"Kapitel 11 Bausteine","heading":"11.6 themes","text":"Abschlie√üend wollen wir noch √ºber verschiedene themes sprechen. √úber themes kann man das Aussehen der nicht datenbezogenen Elemente einer Grafik ver√§ndern, wie z.B.die Beschriftungenden Hintergrunddie Legende‚Ä¶.Eine Reihe von themes sind bereits vorhanden, wobei theme_gray() das Default theme ist. Siehe auch ?theme_gray().Wir m√∂chten nun gerne folgende √Ñnderungen der Grafik vornehmen:die Gr√∂√üe der Achsenbeschriftung √§nderndie Gitterlinien ohne Beschriftung entferneneine √úberschrift hinzuf√ºgendie Legende die Grafik verschiebendie Hintergrundfarbe der Grafik und der Legende √§ndernDie meisten dieser √Ñnderungen k√∂nnen wir mit theme() durchf√ºhren.Ob das nun alles sch√∂n aussieht, sei dahingestellt, aber es zeigt durchaus die vorhandenen M√∂glichkeiten.man gewisse Einstellung √∂fter verwenden, kann man diese auch einem theme Objekt speichern und wiederverwenden.","code":"> p\n## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\n> p + theme_bw()\n## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\n> p + theme_dark()\n## `geom_smooth()` using method = 'loess' and formula 'y ~ x'\n> p + theme_minimal()\n## `geom_smooth()` using method = 'loess' and formula 'y ~ x'> p +\n+   theme(\n+     axis.text = element_text(size = 14),\n+     legend.key = element_rect(fill = \"navy\"),\n+     legend.background = element_rect(fill = \"green\"),\n+     legend.position = \"bottom\",\n+     panel.grid.major = element_line(colour = \"grey40\"),\n+     panel.grid.minor = element_blank(),\n+     panel.background = element_rect(fill = \"navy\")\n+   )\n## `geom_smooth()` using method = 'loess' and formula 'y ~ x'> mein_theme <- theme(\n+     axis.text = element_text(size = 14),\n+     legend.key = element_rect(fill = \"hotpink3\"),\n+     panel.grid.major = element_line(colour = \"grey40\"),\n+     panel.grid.minor = element_blank(),\n+     panel.background = element_rect(fill = \"navy\")\n+   )\n> class(mein_theme)\n## [1] \"theme\" \"gg\"> p + mein_theme\n## `geom_smooth()` using method = 'loess' and formula 'y ~ x'"},{"path":"bausteine.html","id":"buch-zum-paket","chapter":"Kapitel 11 Bausteine","heading":"11.7 Buch zum Paket","text":"Dieser Abschnitt konnte nur einen kleinen Einblick die M√∂glichkeiten des ggplot2 Pakets geben. Eine ausf√ºhrliche Beschreibung findet man im Buch zum Paket.","code":""},{"path":"packages.html","id":"packages","chapter":"Kapitel 12 Pakete","heading":"Kapitel 12 Pakete","text":"Bei einem Paket handelt es sich umeine strukturierte, standardisierte Einheit, welche aus R Code, Dokumentation, Daten und (m√∂glicherweise) externem Quellcode besteht.Wie man ein Paket installiert und l√§dt, ist uns mittlerweile bekannt. Jetzt wollen wir eigene Pakete erstellen.Gute Gr√ºnde f√ºr die Verwendung von Paketen:dynamisches Laden und Entladen des Pakets (Speicherplatz\nsparend)dynamisches Laden und Entladen des Pakets (Speicherplatz\nsparend)einfache Installation und Update von lokalen Datentr√§gern oder √ºber\ndas Web, innerhalb von R oder √ºber die Kommandozeile des\nBetriebssystemseinfache Installation und Update von lokalen Datentr√§gern oder √ºber\ndas Web, innerhalb von R oder √ºber die Kommandozeile des\nBetriebssystemsValidierung: R bietet Befehle zur groben √úberpr√ºfung von Code,\nDokumentation und Installierbarkeit, sowie, falls man m√∂chte,\n√úberpr√ºfung von Berechnungsergebnissen.Validierung: R bietet Befehle zur groben √úberpr√ºfung von Code,\nDokumentation und Installierbarkeit, sowie, falls man m√∂chte,\n√úberpr√ºfung von Berechnungsergebnissen.einfache Verteilung der Software Dritte; Beispieldatens√§tze k√∂nnen auch ins Paket!einfache Verteilung der Software Dritte; Beispieldatens√§tze k√∂nnen auch ins Paket!","code":""},{"path":"packages.html","id":"struktur","chapter":"Kapitel 12 Pakete","heading":"12.1 Struktur","text":"Ein Paket besteht aus einigen Standard‚ÄìDateien und Verzeichnissen:DESCRIPTION: Informationen √ºber das Paket (Autor,\nLizenz, Titel, Abh√§ngigkeiten, ‚Ä¶)R/: R Code .R Dateienman/: Dokumentationen (im *.Rd Format) der einzelnen FunktionenNAMESPACE: Information √ºber die zu ‚Äúexportierenden‚Äù Funktionendata/: Datenbeispielesrc/: kompilierter C, C++ oder Fortran Codetests/: Testroutinen zur Validierung des PaketsBei der Erzeugung der Struktur (wie auch weiteren Schritten bei der Entwicklung) sollte man viel wie m√∂glich automatisieren. Wir verwenden dazu die von Hadley Wickham bereitgestellten Werkzeuge.Falls noch nicht geschehen, sollte manausf√ºhren. Diese Pakete erleichtern Kombination mit RStudio das Erstellen von Paketen.","code":"> install.packages(c(\"devtools\", \"roxygen2\", \"testthat\"))"},{"path":"packages.html","id":"c-compiler","chapter":"Kapitel 12 Pakete","heading":"12.2 C Compiler","text":"Um alle M√∂glichkeiten bei der Erstellung von R-Paketen ausn√ºtzen zu k√∂nnen, brauchst du au√üerdem einen Compiler und noch ein paar andere Werkzeuge. Dies ist aber vermutlich erst dann wirklich n√∂tig, wenn du Pakete bauen willst, die C- oder C++-Code enthalten (nicht Teil des Kurses). RStudio sollte dich auch warnen und dir Unterst√ºtzung anbieten, sobald du versuchen solltest, etwas zu tun, das die Einrichtung einer Entwicklungsumgebung erfordert.Mit has_devel() kannst du aber bereits auch jetzt mal √ºberpr√ºfen ob dein System vielleicht schon bereit istDies scheint bei mir der Fall zu sein.","code":"> library(devtools)> has_devel()\n## Your system is ready to build packages!"},{"path":"packages.html","id":"r-code","chapter":"Kapitel 12 Pakete","heading":"12.3 R Code","text":"Das Verzeichnis R/ ist der wichtigste Bestandteil eines Pakets, da dort der komplette R Code liegt.\nDieses Verzeichnis (wie auch andere Teile) erzeugt man mit der Funktion devtools::create(), z.B.Dieser Befehl erzeugt das Verzeichnis Pfad_zum_Paket/Paketname, welcheseine RStudio Projektdatei, Paketname.Rprojein R/ Verzeichniseine DESCRIPTION Dateieine NAMESPACE Dateienth√§lt. Allen R Code, der im Paket enthalten sein soll, kopiert man anschlie√üend das Verzeichnis Pfad_zum_Paket/Paketname/R.Innerhalb eines Pakets ist es nun einfach den kompletten R Code (nach √Ñnderungen) neu zu laden.devtools::load_all() l√§dt allen R Code neu. RStudio auch √ºber Strg + Shift + L m√∂glich.RStudio kann man mit Strg + Shift + B das Paket installieren, R neu starten und anschlie√üend das Paket √ºber library() neu laden.Dadurch ergibt sich der folgende ArbeitsablaufR Dateien im Editor bearbeitenStrg + Shift + L (oder Strg + Shift + B) ausf√ºhrenCode der Konsole √ºberpr√ºfenDas Ganze (falls n√∂tig) wiederholen","code":"> create(\"Pfad_zum_Paket/Paketname\")"},{"path":"packages.html","id":"verschiedene-typen","chapter":"Kapitel 12 Pakete","heading":"12.4 Verschiedene Typen","text":"Man unterscheidet f√ºnf verschiedene Typen: source, bundled, binary, installed und memory.source: Die source Version eines Pakets besteht aus dem Verzeichnis Paketnamesource: Die source Version eines Pakets besteht aus dem Verzeichnis Paketnamebundled: Komprimiert man das Verzeichnis eine .tar.gz Datei spricht man von einem ‚Äúgeb√ºndelten‚Äù Paket. Dieser Typ stellt eher einen Zwischenschritt dar. Mit devtools::build() kann aber eine solche Version erzeugt werden. Weitere Unterschiede zu einer source Version sind f√ºr uns erst mal nicht von Interesse.bundled: Komprimiert man das Verzeichnis eine .tar.gz Datei spricht man von einem ‚Äúgeb√ºndelten‚Äù Paket. Dieser Typ stellt eher einen Zwischenschritt dar. Mit devtools::build() kann aber eine solche Version erzeugt werden. Weitere Unterschiede zu einer source Version sind f√ºr uns erst mal nicht von Interesse.binary: Ein geb√ºndeltes Paket kann von anderen R Nutzern nur installiert werden, wenn sie selbst √ºber die entsprechenden ‚ÄúWerkzeuge‚Äù (Rtools, ‚Ä¶) verf√ºgen. Binary Pakete bestehen auch nur aus einer Datei, k√∂nnen aber von anderen R Nutzern auch ohne weitere ‚ÄúWerkzeuge‚Äù installiert werden. Allerdings sind binary Pakete plattformspezifisch. Ein Windows binary Paket kann also z.B. nicht auf einem Mac installiert werden. Erzeugt wird eine binary Version z.B. mit devtools::build(binary = TRUE).binary: Ein geb√ºndeltes Paket kann von anderen R Nutzern nur installiert werden, wenn sie selbst √ºber die entsprechenden ‚ÄúWerkzeuge‚Äù (Rtools, ‚Ä¶) verf√ºgen. Binary Pakete bestehen auch nur aus einer Datei, k√∂nnen aber von anderen R Nutzern auch ohne weitere ‚ÄúWerkzeuge‚Äù installiert werden. Allerdings sind binary Pakete plattformspezifisch. Ein Windows binary Paket kann also z.B. nicht auf einem Mac installiert werden. Erzeugt wird eine binary Version z.B. mit devtools::build(binary = TRUE).installed: Ein installiertes Paket ist ein eine R Library entpacktes binary Paket. Zu diesem Zustand kann man √ºber mehrere Wege gelangen, z.B.\ninstall.packages(): CRAN binary -> installed\ninstall.packages(type = source): CRAN source -> bundled -> installed\ninstall(): source -> installed\ninstalled: Ein installiertes Paket ist ein eine R Library entpacktes binary Paket. Zu diesem Zustand kann man √ºber mehrere Wege gelangen, z.B.install.packages(): CRAN binary -> installedinstall.packages(type = source): CRAN source -> bundled -> installedinstall(): source -> installedMit devtools::install_github() k√∂nnen source Pakete aus eine GitHub Projekt installiert werden.memory: Um mit einem Paket zu arbeiten muss es den Speicher geladen werden. Dies geschieht mit library() (installierte Pakete) oder load_all() (beim Entwickeln von Paketen).","code":""},{"path":"packages.html","id":"description","chapter":"Kapitel 12 Pakete","heading":"12.5 DESCRIPTION","text":"Die DESCRIPTION Datei enth√§lt Informationen √ºber das Paket und ist ein essentieller Bestandteil jedes Pakets. Der Befehlerzeugt die DESCRIPTION Dateiim Ordner meinR4EWSpckg.Die wichtigsten Felder einer DESCRIPTION Datei sind dadurch vorhanden (und m√ºssen gef√ºllt werden). √úber die Punkte Imports und Suggests (nicht automatisch vorhanden) kann festgelegt werden welche anderen R Pakete zwingend notwendig bzw. hilfreich sind f√ºr das eigene Paket.Pakete Imports werden beim Installieren des eigenen Pakets ebenfalls installiert, falls diese noch nicht vorhanden sind. Pakete Suggests werden nicht automatisch installiert.√úberkann z.B. das Paket dplyr dem Punkt Imports hinzugef√ºgt werden. usethis::use_package(type = \"Suggests\") f√ºgt Suggests weitere Pakete hinzu.","code":"> usethis::create_package(\"meinR4EWSpckg\")Package: meinR4EWSpckg\nType: Package\nTitle: What the Package Does (Title Case)\nVersion: 0.1.0\nAuthor: Who wrote it\nMaintainer: The package maintainer <yourself@somewhere.net>\nDescription: More about what it does (maybe more than one line)\n    Use four spaces when indenting paragraphs within the Description.\nLicense: What license is it under?\nEncoding: UTF-8\nLazyData: true> usethis::use_package(\"dplyr\")"},{"path":"packages.html","id":"name-titel-beschreibung","chapter":"Kapitel 12 Pakete","heading":"12.5.1 Name, Titel, Beschreibung","text":"Der Name (Package) eines Pakets darf Buchstaben, Zahlen und . enthalten und sollte mit dem Verzeichnisname √ºbereinstimmen.Title und Description sollten beschreiben das Paket genau macht. Description ist dabei deutlich ausf√ºhrlicher und enth√§lt daher .d.R. mehrere Zeilen. Nach einem Zeilenumbruch sollte 4 Leerzeichen einger√ºckt werden. Ein Beispiel w√§re","code":"Title: An implementation of the Grammar of Graphics\nDescription: An implementation of the grammar of graphics in R. \n    It combines the advantages of both base and lattice graphics: \n    conditioning and shared axes are handled automatically, and \n    you can still build up a plot step by step from multiple data \n    sources. It also implements a sophisticated multidimensional \n    conditioning system and a consistent interface to map data \n    to aesthetic attributes. See the ggplot2 website for more \n    information, documentation and examples."},{"path":"packages.html","id":"autoren","chapter":"Kapitel 12 Pakete","heading":"12.5.2 Autoren","text":"√úber das Feld Authors@R k√∂nnen die Autoren des Pakets angegeben werden. dieser Stelle kann\nder DESCRIPTION Datei R Code verwendet werden um die n√∂tigen Informationengiven, family: Vor- und Nachnameemail: E-Mailadresserole: Rolle der Person. Wichtige Beispiele sind\ncre: Ersteller oder Maintainer\naut: hat wichtige Beitr√§ge zum Paket erbracht\nctb: hat kleinere Beitr√§ge zum Paket erbracht\ncre: Ersteller oder Maintaineraut: hat wichtige Beitr√§ge zum Paket erbrachtctb: hat kleinere Beitr√§ge zum Paket erbrachtMit der Funktion person() k√∂nnen diese Informationen nun angegeben werdenDer Output von person() sieht dann folgenderma√üen aus","code":"Authors@R: person(given = \"Stephan\", family = \"Haug\", \n                  email = \"haug@tum.de\", \n                  role = c(\"cre\", \"aut\"))> person(given = \"Stephan\", family = \"Haug\", \n+                   email = \"haug@tum.de\", \n+                   role = c(\"cre\", \"aut\"))\n## [1] \"Stephan Haug <haug@tum.de> [cre, aut]\""},{"path":"packages.html","id":"version","chapter":"Kapitel 12 Pakete","heading":"12.5.3 Version","text":"devtools::create() legt die Default-Version auf 0.1.0 fest. Generell sollte die Versionsnummer aber aus drei Teilen bestehen und die Form x.y.z haben, wobei x die Nummer f√ºr gr√∂√üere Updates, y die Nummer f√ºr kleinere Updates und z die Nummer f√ºr Korrekturen ist.Die aktuelle Version von ggplot2 ist z.B.F√ºr Pakete, die sich der Entwicklung befinden, bietet es sich noch einen vierten Teil anzuf√ºgen und mit der Versionsnummer 0.0.0.9000 zu starten.Nach diesen Anpassung k√∂nnte die DESCRIPTION Datei also aussehenDer Punkt Lizenz ist f√ºr erstmal nachgeordnet. Wer aber mehr √ºber die Wahl einer passenden Lizenz erfahren m√∂chte, den verweisen wir gerene auf das Kapitel Licensing R packages.","code":"> packageVersion(\"ggplot2\")\n## [1] '3.3.5'Package: meinR4EWSpckg\nType: Package\nTitle: Paket zu R4ews, das ...\nVersion: 0.0.0.9000\nAuthors@R: person(given = \"Stephan\", family = \"Haug\", \n                  email = \"haug@tum.de\", \n                  role = c(\"cre\", \"aut\"))\nDescription: Paket, das im Rahmen des R Projekts R4ews entstanden ist.\n    Das Paket bietet ...\nLicense: What license is it under?\nEncoding: UTF-8\nLazyData: true\nImports: \n    dplyr"},{"path":"packages.html","id":"pakete-dokumentation","chapter":"Kapitel 12 Pakete","heading":"12.6 Pakete: Dokumentation","text":"Ein wichtiger Teil eines Pakets ist die ausreichende Dokumentation (wichtiger) Funktionen. Dokumentationen werden als .Rd (LaTeX √§hnliches Format) Dateien im Verzeichnis man/ abgelegt. Das Paket roxygen2 bietet eine komfortable M√∂glichkeit aus Funktionskommentaren (einem speziellen Format) eine .Rd Datei zu erzeugen.Ablauf:roxygen Kommentare die .R Datei einf√ºgendevtools::document() ausf√ºhren um Kommentare .Rd Datei zu konvertierenDokumentation mit ? betrachtengegebenenfalls alles wiederholenroxygen Kommentare beginnen mit #'.Wir f√ºgen eine Datei add_2.R mit Inhaltdem Verzeichnis meinR4EWSpckg/R hinzu.Der Befehl devtools::document() (ausgef√ºhrt im Verzeichnis meinR4EWSpckg - source Paket) erzeugt dann die Datei meinR4EWSpckg/man/add_2.RdAlle roxygen Kommentare beginnen mit #' und sind unterteilt verschiedene Tags der Form @name_tag beschreibung. Vor dem ersten Tag kommen allerdingsTitel: erste Zeile des KommentarsBeschreibung der Funktion: zweiter Abschnitt des Kommentars (l√§nger als Titel)Details zur Funktion: dritter Abschnitt des Kommentars (l√§nger als die Beschreibung) - optionalIn unserem Beispiel wurde der Titel auch gleich als Beschreibung (da nicht explizit angegeben) verwendet.Die drei wichtigsten Tags zum Kommentieren einer Funktion sind: @param, @examples und @return.\nWeitere Tags sind im Abschnitt Documenting functions des Buchs R packages beschrieben.Mit den Befehlen \\emph{}, \\strong{}, \\code{} und \\pkg{} (Paketname) kann der Text formatiert werden.Ebenso k√∂nnen Links zu anderen Dokumentationen\\code{\\link{function}}: Funktion function im eigenen Paket\\code{\\link[devtools]{load_all}}: Funktionen aus anderen Paketen, hier devtools::load_alloder dem Netz\\url{http://rstudio.com}\\href{http://rstudio.com}{RStudio}\\email{haug@@tum.de} (@@ ist n√∂tig, da @ f√ºr die Tags reserviert ist)Weitere M√∂glichkeiten der Formatierung findest du im Abschnitt Text formatting des Buch R packages.","code":"#' Addiere zwei Zahlen\n#' \n#' @param x Eine Zahl.\n#' @param y Eine Zahl.\n#' @return Die Summe von \\code{x} und \\code{y}.\n#' @examples\n#' add_2(1, 1)\n#' add_2(10, 1)\nadd_2 <- function(x, y) {\n  x + y\n}% Generated by roxygen2 (4.0.2): do not edit by hand\n\\name{add_2}\n\\alias{add_2}\n\\title{Addiere zwei Zahlen}\n\\usage{\nadd_2(x, y)\n}\n\\arguments{\n\\item{x}{Eine Zahl.}\n\n\\item{y}{Eine Zahl.}\n}\n\\value{\nDie Summe von \\code{x} und \\code{y}.\n}\n\\description{\nAddiere zwei Zahlen\n}\n\\examples{\nadd_2(1, 1)\nadd_2(10, 1)\n}\n"},{"path":"packages.html","id":"namespace","chapter":"Kapitel 12 Pakete","heading":"12.7 NAMESPACE","text":"Es ist nicht nur f√ºr das Erstellen von Paketen hilfreich das Konzept eines NAMESPACE verstanden zu haben, sondern auch f√ºr das generelle Arbeiten mit R. Man unterscheidet dabei Import NAMESPACES und Export NAMESPACES.Import legt dabei fest wie die Funktion eines Pakets eine Funktion einem anderen Paket findet. Betrachten wir z.B.Diese Funktion ist definiert Abh√§ngigkeit von dim() aus dem base Paket.Auch wenn wir die Funktiondefinieren, findet nrow() trotzdem die ‚Äúrichtige‚Äù Funktionda sie den NAMESPACE des base Pakets verwendet.Export legt fest welche Funktionen eines Pakets au√üerhalb des Pakets zur Verf√ºgung stehen sollen. Dies m√ºssen/sollten nicht alle Funktionen sein. Ein Paket kann also interne Funktionen haben, die nur intern verwendet werden k√∂nnen.√úber den Operator :: wird explizit auf den NAMESPACE eines Pakets zugegriffen. Auf diese Art und Weise vermeidet man auch Konflikte zwischen Funktionen aus verschiedenen Paketen, die aber den gleichem Namen haben. einem solchen Fall kommt es darauf welches Paket zuletzt geladen wurde. Dieses findet man dann zuerst im SuchpfadIn der NAMESPACE Datei beschreibenexport(): exportiert FunktionenexportPattern(): exportiert alle Funktionen, die zu einem bestimmten Schema passenS3method(): exportiert S3 Methodenden Export undimport(): importiert alle Funktionen aus einem PaketimportFrom(): importiert eine bestimmte Funktion aus einem PaketuseDynLib(): importiert eine Funktion aus Cden Import.Export-Eintr√§ge der NAMESPACE Datei k√∂nnen leicht √ºber roxygen Kommentare erzeugt werden.\n√úber einen @export Tag wird angegeben welche Funktion exportiert werden sollJe nach Objekttyp wird dann export(), exportPattern() oder S3method() im NAMESPACE verwendet. Generell sollte man sich die Regel halten lieber weniger als mehr Funktionen zu exportieren, wenn man das Paket Dritte weitergeben .Beim Importieren sollte man noch restriktiver sein. Man sollte √ºber Imports der DESCRIPTION Datei sicherstellen, dass alle notwendigen Pakete installiert und geladen sind. Danach kann einfach √ºber den :: Operator eigenen Funktionen auf Funktionen aus anderen geladenen Paketen zugegriffen werden, also z.B. pkg_name::funktion_aus_pkg_name().Dies erh√∂ht die sp√§tere Lesbarkeit der eigenen Programme und vermeidet potentielle Konflikte, die beim Importieren mehrerer Pakete - die dann wieder Funktionen mit gleichem Namen besitzen - auftreten k√∂nnen.Muss eine Funktion h√§ufig verwendet werden - und man nicht dauernd :: verwenden - sollte man √ºber importFrom() eher nur die Funktion und nicht das ganze Paket importieren.","code":"> nrow\n## function (x) \n## dim(x)[1L]\n## <bytecode: 0x7f90f2534e00>\n## <environment: namespace:base>> dim <- function(x) c(1,1)\n> dim(mtcars)\n## [1] 1 1> nrow(mtcars)\n## [1] 32> search()\n##  [1] \".GlobalEnv\"        \"package:devtools\"  \"package:usethis\"  \n##  [4] \"package:stats\"     \"package:graphics\"  \"package:grDevices\"\n##  [7] \"package:utils\"     \"package:datasets\"  \"package:methods\"  \n## [10] \"Autoloads\"         \"package:base\"#' @export\nexport_function <- function(...){\n  ... \n}"},{"path":"packages.html","id":"daten-einbinden","chapter":"Kapitel 12 Pakete","heading":"12.8 Daten einbinden","text":"Daten, die das Paket enthalten sollte, legt man im Verzeichnis /data ab. Als Format sollte man .rda w√§hlen (ist aber kein Muss). Der einfachste Weg dies zu ber√ºcksichtigen ist die Funktion usethis::use_data() zu verwenden.Dieser Befehl speichert die Objekte x und mtcars den Dateien data/x.rda und data/mtcars.rda ab. Der Dateiname stimmt also mit dem Objektnamen √ºberein.Datens√§tze sollten auf jeden Fall dokumentiert werden. Dazu f√ºgt man einfach eine der .R Dateien im Verzeichnis /R einen weiteren roxygen2 Absatz ein. F√ºr das Dokumentieren von Datens√§tzen stehen zwei weitere Tags bereit. √úber @format beschreibt man das genaue Format der Daten, z.B. die einzelnen Spalten eines Data Frames, und mit @source gibt man (falls vorhanden) die Datenquelle .Die Beschreibung des Datensatzes x k√∂nnte also z.B. aussehen","code":"> x <- sample(1:100, 50, replace = TRUE)\n> usethis::use_data(x, mtcars)#' Mein Datensatz\n#' \n#' Ein Datensatz bestehend aus 50 Zahlen gezogen aus den \n#' Zahlen 1 bis 100 mit Zuruecklegen\n#' \n#' @format Ein Integer Vektor der Laenge 50\n\"x\""},{"path":"packages.html","id":"c-special-topic","chapter":"Kapitel 12 Pakete","heading":"12.9 C++ (Special Topic)","text":"man seinem Paket R Funktionen verwenden, die mithilfe von Rcpp aus kompiliertem C++ Code entstanden sind, sollte man zur Vorbereitungausf√ºhren. Danach ist das das Verzeichnis /src angelegt und Rcpp zu den Feldern LinkingTo und Imports der DESCRIPTION Datei hinzugef√ºgt. Au√üerdem wird man aufgefordert die roxygen Tagsin eine der .R Dateien einzuf√ºgen.Ebenso wie die .R Dateien kann auch die .cpp Dateien die roxygen Dokumentation eingef√ºgt werden. Allerdings verwendet man //' statt #'.","code":"> usethis::use_rcpp()#' @useDynLib meinR4EWSpckg\n#' @importFrom Rcpp sourceCpp#include <Rcpp.h>\nusing namespace Rcpp;\n\n//' Multipliziere eine Zahl mit 2\n//' \n//' @param x Ein Integer.\n//' @export\n// [[Rcpp::export]]\nint malZwei(int x) {\n   return x * 2;\n}"},{"path":"packages.html","id":"git-und-githubgitlab","chapter":"Kapitel 12 Pakete","heading":"12.10 Git und GitHub/GitLab","text":"Benutze f√ºr jedes deiner Pakete (mag es auch noch klein sein) Git. Beim Anlegen des Projekts (zur Erstellung des Pakets) √ºber RStudio, kann leicht ein lokales Git repository initialisiert werdenSoll zus√§tzlich ein remote repository verwendet werden, kann man (im Standardfall) ein neues repository auf GitLab (oder GitHub) anlegen. Es sollte den gleichen Namen bekommen wie das Paket (lokales Git repository). Danach kannst du im Terminal Befehle der Formausf√ºhren.Angenommen es existiert bereits ein remote repository und das Paket soll dort ‚Äúverwaltet‚Äù werden. Dann kannst du einfach dieses repository klonenDanach existiert im Verzeichnis, dem der Befehl ausgef√ºhrt wurde, das Unterverzeichnis paketName. R kannst du anschlie√üend den Befehlausf√ºhren (im Verzeichnis, welches das Git repository paketName enth√§lt). Danach kannst du die √Ñnderungen speichern √ºber einen commit Befehlund pushen","code":"git remote add origin https://gitlab.lrz.de/vw99xyz/paketName.git\ngit push -u origin mastergit clone https://gitlab.lrz.de/vw99xyz/paketName.git> devtools::create(\"paketName\")git add -A\ngit commit -m \"paket struktur angelegt\"git push"},{"path":"packages.html","id":"literatur-2","chapter":"Kapitel 12 Pakete","heading":"12.11 Literatur","text":"Diese Folien haben einen kleinen Einblick das Erstellen eigener Pakete gegeben. Allerdings wurden viele weitere Aspekte nicht angesprochen. Weitere Informationen zu R Paketen findet man z.B. im Buch R packages von Hadley Wickham (2015b).","code":""},{"path":"funktionen.html","id":"funktionen","chapter":"Kapitel 13 Funktionen","heading":"Kapitel 13 Funktionen","text":"Wie jeder anderen Programmierumgebung, besteht auch R die M√∂glichkeit eigene Funktionen zu definieren.Eine der wichtigsten Erkenntnisse dabei ist die Tatsache, dass auch Funktionen Objekte sind. Generell ist R alles ein Objekt.Neue Funktionen werden mit der Funktion function() erzeugt.","code":""},{"path":"funktionen.html","id":"bestandteile-von-funktionen","chapter":"Kapitel 13 Funktionen","heading":"13.1 Bestandteile von Funktionen","text":"Alle R Funktionen bestehen aus den drei Teilen:formals(), Argumente, die den Funktionsaufruf ‚Äúregeln‚Äùbody(), der eigentliche Codeenvironment(), Verweis auf die Funktionseingabe","code":"\nf <- function(x) x + sin(x)\nformals(f)## $x\nbody(f)## x + sin(x)\nenvironment(f)## <environment: R_GlobalEnv>"},{"path":"funktionen.html","id":"body","chapter":"Kapitel 13 Funktionen","heading":"13.2 body()","text":"Wie alle Objekte R, besitzen auch Funktionen Attribute. Ein data frame besitzt z.B. die Attribute names, class und row.namesEine Funktion besitzt hingegen die AttributeDen Unterschied zu body() sehen wir im folgenden Beispiel.","code":"\nattributes(iris)## $names\n## [1] \"Sepal.Length\" \"Sepal.Width\"  \"Petal.Length\" \"Petal.Width\"  \"Species\"     \n## \n## $class\n## [1] \"data.frame\"\n## \n## $row.names\n##   [1]   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18\n##  [19]  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36\n##  [37]  37  38  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54\n##  [55]  55  56  57  58  59  60  61  62  63  64  65  66  67  68  69  70  71  72\n##  [73]  73  74  75  76  77  78  79  80  81  82  83  84  85  86  87  88  89  90\n##  [91]  91  92  93  94  95  96  97  98  99 100 101 102 103 104 105 106 107 108\n## [109] 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126\n## [127] 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144\n## [145] 145 146 147 148 149 150\nattributes(f)## $srcref\n## function(x) x + sin(x)\nf <- function(x){\n  # Summe von x und sin(x)#\n  x + sin(x)\n}\nbody(f)## {\n##     x + sin(x)\n## }\nattr(f, \"srcref\")## function(x){\n##   # Summe von x und sin(x)#\n##   x + sin(x)\n## }"},{"path":"funktionen.html","id":"einfache-funktionen","chapter":"Kapitel 13 Funktionen","heading":"13.3 ‚ÄúEinfache‚Äù Funktionen","text":"Es gibt eine Ausnahme von der obigen Regel, dass Funktionen aus drei Teilen bestehen. Die primitive functions wie sum(), sin() oder exp() rufen direkt √ºber die Funktion .Primitive() C Code auf, enthalten somit keinen R Code und daher sind alle drei Teile gleich NULL.","code":"\nformals(sin)## NULL\nbody(sin)## NULL\nenvironment(sin)## NULL"},{"path":"funktionen.html","id":"jede-operation-ist-ein-funktionsaufruf","chapter":"Kapitel 13 Funktionen","heading":"13.4 Jede Operation ist ein Funktionsaufruf","text":"‚Äúunderstand computations R, two slogans helpful:\nEverything exists object.\nEverything happens function call.‚Äù\n‚Äî John ChambersAlle Operationen bestehen aus Funktionsaufrufen. Somit auch +, -, /,:, , , oder []und $. Dies sieht man z.B. diesem Beispieloder auch diesem BeispielenDie Verwendung von ` erlaubt den Zugriff auf reservierte Ausdr√ºcke.Eine sinnvolle Anwendung dieser Zugriffsmethode liegt der Kombination mit den apply Funktionen (apply(), lapply(), sapply, mapply(), tapply()). Diese wenden eine zu √ºbergebende Funktion auf weitere Inputgr√∂√üen wie Listen oder Data Frames .","code":"\nx <- 10 \ny <- 5\nx + y## [1] 15\n`+`(x, y)## [1] 15\nfor (i in 1:2) print(i)## [1] 1\n## [1] 2\n`for`(i, 1:2, print(i))## [1] 1\n## [1] 2\nx[3]## [1] NA\n`[`(x, 3)## [1] NA\nx <- list(1:3, 4:9, 10:12)\nsapply(x, `[`, 2)## [1]  2  5 11\nsapply(x, function(x) x[2])## [1]  2  5 11"},{"path":"funktionen.html","id":"lapply-sapply","chapter":"Kapitel 13 Funktionen","heading":"13.5 lapply, sapply","text":"sapply() ist eine Version von lapply(), die - wenn m√∂glich - eine ‚Äúvereinfachte‚Äù Ausgabe liefert.","code":"\nx <- list(1:3, 4:6, 7:9)\nlapply(x, `+`, 3)## [[1]]\n## [1] 4 5 6\n## \n## [[2]]\n## [1] 7 8 9\n## \n## [[3]]\n## [1] 10 11 12\nis.matrix(sapply(x, `+`, 3))## [1] TRUE"},{"path":"funktionen.html","id":"funktionsargumente","chapter":"Kapitel 13 Funktionen","heading":"13.6 Funktionsargumente","text":"Funktionen besitzen formelle Argumente, denen beim Funktionsaufruf (oder per Default) Werte zugewiesen werden. Beim Aufruf k√∂nnen die Argumente durch ihre Position, den vollen oder teilweisen Namen ausgew√§hlt werden.Der folgende Aufruf kann aber nicht funktionieren.Generell sollte man die zwei, drei wichtigsten Inputgr√∂√üen den Beginn stellen. Alle anderen sollten eher nicht durch die Position ausgew√§hlt werden. Dabei ist der vollst√§ndige Namen sicherlich zu bevorzugen.Funktionsargumenten k√∂nnen Default-Werte zugeordnet werden. Dabei k√∂nnen Default-Werte auch Abh√§ngigkeit anderer Argumente definiert werden.","code":"\nf <- function(abc, bcd, bdc) c(abc, bcd, bdc)\nf(3, 2, 1)## [1] 3 2 1\nf(2, 1, abc=3)## [1] 3 2 1\nf(2, 1, a=3)## [1] 3 2 1\nf(3, b=2, 1)## Error in f(3, b = 2, 1): argument 2 matches multiple formal arguments\nf <- function(a = 1, b = 2) {\n  c(a, b)\n}\nf()## [1] 1 2\ng <- function(a = 1, b = a * 2) {\n  c(a, b)\n}\ng(a=10)## [1] 10 20"},{"path":"funktionen.html","id":"funktionsargumente-lazy-evaluation","chapter":"Kapitel 13 Funktionen","heading":"13.7 Funktionsargumente: Lazy Evaluation","text":"R wertet Funktionsargumente nur aus, wenn diese tats√§chlich ben√ºtzt werden. Dies entspricht der Idee der Lazy Evaluation.Mit force() kann man die Auswertung eines Arguments erzwingen.Benutzt man eine verschachtelte Funktion Kombination mit lapply() oder einer Schleife, kann die Lazy Evaluation entscheidend sein.x wird beim ersten Aufruf von addiere_zu_1bis10() ausgewertet. Bis dahin ist x aber bereits von 1 bis 10 ‚Äúgelaufen‚Äù und hat damit den Wert 10. Somit wird stets 10 zum Input addiert.Erzwingt man die Auswertung, erh√§lt man das gew√ºnschte Ergebnis.Bisher schien die Lazy Evaluation eher nachteilig. Sie kann aber auch Vorteile haben. Die Befehleerzeugen keinen Fehler, obwohl NULL>0 keinen zul√§ssigen Input f√ºr darstellt. Da !.null(x) bereits FALSE liefert, wird die zweite Abfrage nicht mehr ausgewertet.Hauptvorteil ist aber die Effizienz. Nur notwendige Ausdr√ºcke werden ausgewertet.","code":"\nf <- function(x) {\n  10\n}\nf(stop(\"x ist nicht 10\"))## [1] 10\nf <- function(x) {\n  force(x)\n  10\n}\nf(stop(\"x ist nicht 10\"))## Error in force(x): x ist nicht 10\naddiere_x <- function(x){\n  function(y) x+y\n}\naddiere_zu_1bis10 <- lapply(1:10, addiere_x)\naddiere_zu_1bis10[[1]](10)## [1] 11\naddiere_zu_1bis10[[5]](10)## [1] 15\naddiere_x <- function(x){\n  force(x)\n  function(y) x+y\n}\naddiere_zu_1bis10 <- lapply(1:10, addiere_x)\naddiere_zu_1bis10[[1]](10)## [1] 11\naddiere_zu_1bis10[[5]](10)## [1] 15\nx <- NULL\nif (!is.null(x) && x > 0) {\n\n}"},{"path":"funktionen.html","id":"funktionsargumente-...","chapter":"Kapitel 13 Funktionen","heading":"13.8 Funktionsargumente: ...","text":"F√ºr eine Funktion kann das formale ... Drei-Punkte Argument verwendet werden. Alle nicht √ºber Position und/oder Name zugeordneten Argumente werden durch ... aufgenommen. der Regel werden √ºber ... Argumente √ºbergeben, die innerhalb der Funktion andere Funktionen weitergegeben werden.... erh√∂ht also offensichtlich die Flexibilit√§t. Ein Nachteil ist, dass falsch geschriebene Argumente keinen Fehler erzeugen und alle Argumente nach ... voll ausgeschrieben werden m√ºssen.","code":"\nsumme_plus2 <- function(x, ...){\n  x <- x+2\n  sum(x, ...)\n}\nsumme_plus2(c(1, 3, 5))## [1] 15\nsumme_plus2(c(1, 3, NA), na.rm = TRUE)## [1] 8\nsum(1, 2, NA, rm.na = TRUE)## [1] NA\nsum(1, 2, NA, na.rm = TRUE)## [1] 3"},{"path":"funktionen.html","id":"funktionsr√ºckgabe","chapter":"Kapitel 13 Funktionen","heading":"13.9 Funktionsr√ºckgabe","text":"Wir haben den Beispielen bereits gesehen wie die R√ºckgabe funktioniert. Der letzte Ausdruck, der ausgewertet wird, bildet die R√ºckgabe.Falls bereits zu einem fr√ºheren Zeitpunkte eine R√ºckgabe erfolgen soll (z.B. STOP Kriterium erf√ºllt) und diese speziell gekennzeichnet werden soll, kann die Funktion return() verwendet werden.Funktionen k√∂nnen nur ein Objekt zur√ºckgeben. Soll die Ausgabe einer Funktion aus mehreren Objekten bestehen, schreibt man diese einfach eine Liste und gibt die Liste zur√ºck.","code":"\nf <- function(x) {\n  if (x < 10) {\n    0\n  } else {\n    10\n  }\n}\nf(5)## [1] 0\nf(15)## [1] 10\nf <- function(x) {\n  if (x < 10) {\n    n_output <- 0\n    t_output <- \"eingabe war kleiner 10\"\n  } else {\n    n_output <- 10\n    t_output <- \"eingabe war gr√∂√üer oder gleich 10\"\n\n  }\n  \n  output <- list(n_output, t_output)\n  return(output) \n}\nf(5)## [[1]]\n## [1] 0\n## \n## [[2]]\n## [1] \"eingabe war kleiner 10\"\nf(15)## [[1]]\n## [1] 10\n## \n## [[2]]\n## [1] \"eingabe war gr√∂√üer oder gleich 10\""},{"path":"funktionen.html","id":"mehr-zu","chapter":"Kapitel 13 Funktionen","heading":"13.10 mehr zu ‚Ä¶","text":"Wenn ihr mehr zufunctionsenvironmentsfunctional programmingobject-oriented programming‚Ä¶wissen wollt, dann findet ihr (fast) alle Antworten auf eure Fragen im Buch Advanced R von Hadley Wickham (2015a).","code":""},{"path":"envscop.html","id":"envscop","chapter":"Kapitel 14 Environments und Scoping","heading":"Kapitel 14 Environments und Scoping","text":"","code":""},{"path":"envscop.html","id":"zuordnungen","chapter":"Kapitel 14 Environments und Scoping","heading":"14.1 Zuordnungen","text":"Wie wei√ü R welchen Wert es welchem Symbol zuordnen soll?Warum w√§hlt R nicht die Standardfunktion sqrt() aus dem base Paket?Wenn R einem Symbol einen Wert zuordnet, dann durchsucht R eine Reihe von environments (bereits im Abschnitt Funktionen gesehen) nach dem passenden Wert. Gesucht wird folgender ReihenfolgeDas Global Environment wird durchsucht.Die namespaces (dazu sp√§ter mehr) der Pakete auf der search Liste werden durchsucht.Das global environment (der Workspace) wird immer zuerst und base immer zuletzt durchsucht.Die search Liste wird also beeinflusst durch die von uns geladenen Pakete.Man beachte, dass R die Namen von Daten- und Funktionsobjekten unterscheiden kann.","code":"\nsqrt(2)## [1] 1.414214\nsqrt <- function(x) x^2\nsqrt(2)## [1] 4\nsearch()## [1] \".GlobalEnv\"        \"package:stats\"     \"package:graphics\" \n## [4] \"package:grDevices\" \"package:utils\"     \"package:datasets\" \n## [7] \"package:methods\"   \"Autoloads\"         \"package:base\"\nlibrary(ggplot2)\nsearch()##  [1] \".GlobalEnv\"        \"package:ggplot2\"   \"package:stats\"    \n##  [4] \"package:graphics\"  \"package:grDevices\" \"package:utils\"    \n##  [7] \"package:datasets\"  \"package:methods\"   \"Autoloads\"        \n## [10] \"package:base\"\n(sqrt <- 2)## [1] 2\nsqrt(2)## [1] 1.414214"},{"path":"envscop.html","id":"environments","chapter":"Kapitel 14 Environments und Scoping","heading":"14.2 Environments","text":"Ein Environment verbindet eine Menge von Namen mit einer entsprechenden Menge von Werten. Environments sind √§hnlich zu einer Liste, aber es gibt entscheidende Unterschiededie Namen der Objekte einem Environment sind eindeutigdie Objekte eines Environments sind nicht geordnetjedes Environment besitzt ein parent Environment, au√üer emptyenv()Die Eintr√§ge von search() sind die Eltern des Global Environment. Mit new.env() kann auch ein neues Environment erzeugt werden.Bemerkung: Die meisten Environments erzeugt man durch die Verwendung von Funktionen.","code":"\nneues_env <- new.env()\nneues_env$eins <- c(1, 2)\nneues_env$zwei <- c(\"a\", \"b\")\nls(neues_env)## [1] \"eins\" \"zwei\"\nparent.env(neues_env)## <environment: R_GlobalEnv>"},{"path":"envscop.html","id":"scoping-rules","chapter":"Kapitel 14 Environments und Scoping","heading":"14.3 Scoping Rules","text":"Der Sichtbarkeitsbereich von Variablen (Scope) wird √ºber Scoping Rules festgelegt. R verwendet static scoping oder auch lexical scoping genannt (eine Alternative ist das dynamic scoping).f hat die formellen Argumente x und y sowie die freie Variable z. Die Scoping Rule bestimmt wie Werte freien Variablen zugeordnet werden. R bedeutet diesDer Wert freier Variablen (einer Funktion) wird dem Environment gesucht, dem die Funktion definiert wurde.","code":"\nf <- function(x, y){\n  x + y/z\n}"},{"path":"envscop.html","id":"static-scoping","chapter":"Kapitel 14 Environments und Scoping","heading":"14.4 Static scoping","text":"Oftmals werden Funktionen im Globalen Environment definiert. Die Werte freier Variablen sollten dann im Workspace zu finden sein. Dieses ‚ÄúVerhalten‚Äù wird von den meisten ‚ÄúNutzern‚Äù erwartet und als sinnvoll angesehen.Allerdings k√∂nnen Funktionen auch innerhalb von Funktionen definiert werden. diesem Fall ist das Environment der body einer anderen Funktion.bilde_potenz() liefert somit eine Funktion als Ausgabe.Sucht man nach einer Variable und/oder m√∂chte man ihren Wert ausgeben, kann man mit den Funktionen exists() und get() arbeiten. Beide verwenden static scoping.Schauen wir uns nun den closure (Funktion + zugeh√∂riges Environment) von zweite_potenz() und dritte_potenz() genauer .","code":"\nbilde_potenz <- function(n){\n  potenz <- function(x)\n    x^n\n}\nzweite_potenz <- bilde_potenz(2)\ndritte_potenz <- bilde_potenz(3)\nget(\"eins\", envir = neues_env)## [1] 1 2\nx <- 1\nexists(\"x\", envir = neues_env)## [1] TRUE\nexists(\"x\", envir = neues_env, inherits = FALSE)## [1] FALSE\nls(environment(zweite_potenz))## [1] \"n\"      \"potenz\"\nget(\"n\", envir = environment(zweite_potenz))## [1] 2\nls(environment(dritte_potenz))## [1] \"n\"      \"potenz\"\nget(\"n\", envir = environment(dritte_potenz))## [1] 3"},{"path":"envscop.html","id":"anwendungsbeispiel","chapter":"Kapitel 14 Environments und Scoping","heading":"14.5 Anwendungsbeispiel","text":"Wir betrachten als Anwendungsbeispiel die Minimierung der Funktion\\[\n  l_x(\\mu,\\sigma^2) =-\\left(-\\frac{n}{2}\\log(2\\pi\\sigma^2)-\\frac1{2\\sigma^2}\\sum_{=1}^n(x_i-\\mu)^2\\right)\\,,\n  \\]\nwobei \\(x_i, =1,\\dots,n,\\) bekannte Gr√∂√üen sind. Die obigen Funktion ist der negative log-Likelihood einer Normalverteilung mit Parametern \\(\\mu\\) und \\(\\sigma^2\\), aber das spielt hier keine Rolle.Optimierungsroutinen wie optim(), nlm() oder optimize() erwarten als Eingabe eine\nFunktion, deren Argumente die zu optimierenden Parameterwerte sind. Oftmals (wie im obigen Beispiel) h√§ngen Funktionen aber von weiteren Werten ab.Die Funktion ist geschrieben, dass einer der beiden Parameter fixiert werden kann.Fixieren wir nun \\(\\mu\\) gleich 1, erh√§lt manBemerkung: Wir verwenden optimize() anstatt optim(), da letztere nicht f√ºr eindimensionale Optimierung geeignet ist.Durch √úbergabe aller weiteren Gr√∂√üen im Environmentkonnte die Funktion l_x() nur als Funktion der unbekannten Parameter im\n.GlobalEnv definiert werden.Es muss also keine Liste weiterer Argumente der Optimierungs- funktion √ºbergeben werden.","code":"\nnegLogLik <- function(data, fix = c(FALSE, FALSE)){\n  param <- fix\n  function(theta){\n    param[!fix] <- theta\n    mu <- param[1]\n    sigma_2 <- param[2]\n    l_x <- -( -length(data)/2 * log(2 * pi * sigma_2 )\n              - sum((data-mu)^2) / (2*sigma_2))\n    l_x\n  }\n}\nset.seed(1234)\nx <- rnorm(1000, mean = 1, sd = 2)\nl_x <- negLogLik(x)\nl_x## function(theta){\n##     param[!fix] <- theta\n##     mu <- param[1]\n##     sigma_2 <- param[2]\n##     l_x <- -( -length(data)/2 * log(2 * pi * sigma_2 )\n##               - sum((data-mu)^2) / (2*sigma_2))\n##     l_x\n##   }\n## <bytecode: 0x7fe182fc2de8>\n## <environment: 0x7fe182829158>\nls(environment(l_x))## [1] \"data\"  \"fix\"   \"param\"\noptim(par = c(0, 1), fn = l_x)$par## [1] 0.9465684 3.9744817\nl_x <- negLogLik(x, fix = c(1, FALSE))\noptimize(f = l_x, interval = c(1e-6, 10))$minimum## [1] 3.97759\nls(environment(l_x))## [1] \"data\"  \"fix\"   \"param\"\nparent.env(environment(l_x))## <environment: R_GlobalEnv>"},{"path":"fragen.html","id":"fragen","chapter":"Kapitel 15 Fragen und Anregungen aus der √úbung","heading":"Kapitel 15 Fragen und Anregungen aus der √úbung","text":"","code":""},{"path":"fragen.html","id":"quantilsfunktion","chapter":"Kapitel 15 Fragen und Anregungen aus der √úbung","heading":"15.1 Quantilsfunktion","text":"Als Beispiel betrachten wir die Quantilsfunktion\\[Q: (0,1) \\\\mathbb{R}, y \\mapsto \\text{inf}\\{x\\\\mathbb{R}: F(x)\\geq y\\}\\]der \\(N(5,4)\\) Verteilung. Diese Funktion k√∂nnen wir mit qnorm() berechnen und mithilfe von stat_function() dann plottenDer Grafik k√∂nnen wir z.B. entnehmen, dass das 0.25 Quantil \\(q_{0.25}\\) der \\(N(5,4)\\) ungef√§hr den Wert 3.65 hat. Der genaue Wert lautet\\(q_{0.25}\\) ist also der Wert, sodass die Wahrscheinlichkeit (unter der \\(N(5,4)\\) Verteilung) Werte kleiner oder gleich \\(q_{0.25}\\) anzunehmen, gleich 0.25 ist","code":"\nlibrary(tidyverse)\nggplot(data.frame(x=c(0,1)), aes(x)) +\n  stat_function(fun = \"qnorm\", args = list(mean = 5, sd = 2),\n                colour = \"blue\") + ylab(\"Q(x)\") +\n  geom_hline(yintercept = qnorm(0.25, mean = 5, sd = 2), colour = \"gold\") +\n  scale_y_continuous(breaks=round(qnorm(c(0.05, 0.25, 0.5, 0.75, 0.95), mean = 5, sd = 2), 2) ) +\n  theme_minimal()\n(q_025 <- qnorm(0.25, mean = 5, sd = 2))## [1] 3.65102\npnorm(q_025, mean = 5, sd = 2)## [1] 0.25"},{"path":"fragen.html","id":"qq-plot","chapter":"Kapitel 15 Fragen und Anregungen aus der √úbung","heading":"15.1.1 QQ-Plot","text":"Nun erzeugen wir 500 Pseudo-Zufallszahlen mit \\(N(5,4)\\) Verteilung.F√ºr diese Pseudo-Zufallszahlen berechnen wir nun die geordnete Stichprobe sowie die relativen H√§ufigkeiten (funktioniert hier einfach, da es sich um eine st)Die beiden Grafiken sehen √§hnlich aus. Aber ein Vergleich von zwei getrennten Grafiken ist nat√ºrlich nicht einfach. Da die Werte auf der jeweiligen x-Achse nicht von gro√üem Interesse sind, plottet man daher einfach die empirischen und theoretischen Quantile gegeneinander.","code":"\ndf <- tibble(x = rnorm(500, mean = 5, sd = 2))\ndf %>%\n  mutate(ord_x = sort(x), p = ecdf(ord_x)(ord_x)) %>%\n  ggplot(aes(x = p, y = ord_x)) + geom_point(colour = \"blue\") + \n  geom_hline(yintercept = qnorm(0.25, mean = 5, sd = 2), colour = \"gold\") +\n  scale_y_continuous(breaks=round(qnorm(c(0.05, 0.25, 0.5, 0.75, 0.95), mean = 5, sd = 2), 2) ) +\n  ylab(\"emp. Quantile\") + theme_minimal()\nggplot(df, aes(sample = x)) + \n  stat_qq(distribution = qnorm, dparams = list(mean = 5, sd = 2)) +\n  stat_qq_line(distribution = qnorm, dparams = list(mean = 5, sd = 2)) +\n  theme_minimal()"},{"path":"literatur-3.html","id":"literatur-3","chapter":"Literatur","heading":"Literatur","text":"","code":""}]
