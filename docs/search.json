[{"path":"index.html","id":"r4ews","chapter":"R4ews","heading":"R4ews","text":"Willkommen zu R für EWS (Einführung die Wahrscheinlichkeitstheorie und Statistik). Im Rahmen dieser Veranstaltung lernen wir erste Schritte, wie wirDaten aufbereiten, visualisieren und analysieren. 🚀das wollen wir reproduzierbar und auch wiedervendbar machen. Und vor allem, wollen wir alles mit R machen.Auf dieser Website geht es um verschiedene Aspekte der Datenanalyse.\nEine Einführung die inferentielle Statistik erfolgt im Rahmen der Vorlesung Einführung die Wahrscheinlichkeitstheorie und Statistik. Aber auch hier werden wir ein paar der dort vorgestellten Themen aufgreifen und mithilfe von R anwenden, illustrieren, …Auf jeden Fall ist aber das Ziel von R4ews einen Fokus auf die angewandte statistische Ausbildung zu setzen. Datenanalysten verbringen viel Zeit mit der Projekt-Organisation, der Datenbereinigung und -aufbereitung sowie der Kommunikation. Diese Tätigkeiten können einen tiefgreifenden Einfluss auf die Qualität und Glaubwürdigkeit einer Analyse haben. Dennoch werden diese Fähigkeiten selten vermittelt, obwohl sie wichtig und notwendig sind. R4ews versucht diese Lücke etwas zu verkleinern.Das Material wird kontinuierlich über das Semester hinweg ergänzt/erweitert/verbessert.Letzte Änderung:","code":"\ndate()\n## [1] \"Wed Oct 16 23:45:12 2024\""},{"path":"index.html","id":"beteiligte-personen","chapter":"R4ews","heading":"Beteiligte Personen","text":"","code":""},{"path":"index.html","id":"kolophon","chapter":"R4ews","heading":"Kolophon","text":"Dieses Buch wurde bookdown innerhalb von RStudio geschrieben.Teile des Buches basieren auf stat545.com. Alle Änderungen wurden gemäß der Creative Commons Attribution-ShareAlike 4.0 International License durchgeführt.Wir bedanken uns bei den Autor*innen von stat545 für das großartige Material.Die aktuelle Version dieses Buchs wurde miterstellt","code":"## Finding R package dependencies ... Done!\n##  setting  value\n##  version  R version 4.4.0 (2024-04-24)\n##  os       macOS 15.0.1\n##  system   aarch64, darwin20\n##  ui       X11\n##  language (EN)\n##  collate  en_US.UTF-8\n##  ctype    en_US.UTF-8\n##  tz       Europe/Berlin\n##  date     2024-10-16\n##  pandoc   3.2 @ /Applications/RStudio.app/Contents/Resources/app/quarto/bin/tools/aarch64/ (via rmarkdown)"},{"path":"index.html","id":"lizenz","chapter":"R4ews","heading":"Lizenz","text":"Diese Arbeit ist lizenziert unter Creative Commons Attribution-ShareAlike 4.0 International License.","code":""},{"path":"install.html","id":"install","chapter":"Kapitel 1 Installieren von R und RStudio","heading":"Kapitel 1 Installieren von R und RStudio","text":"","code":""},{"path":"install.html","id":"r-und-rstudio","chapter":"Kapitel 1 Installieren von R und RStudio","heading":"1.1 R und RStudio","text":"Zuerst benötigen wir R, eine freie Softwareumgebung für statistische Berechnungen und Grafiken. Installiert daher R von CRAN, dem Comprehensive R Archive Network. Wir empfehlen euch dringend, eine vorkompilierte Binärdistribution zu installieren - benutzt daher die Links oben auf der CRAN Seite!Zuerst benötigen wir R, eine freie Softwareumgebung für statistische Berechnungen und Grafiken. Installiert daher R von CRAN, dem Comprehensive R Archive Network. Wir empfehlen euch dringend, eine vorkompilierte Binärdistribution zu installieren - benutzt daher die Links oben auf der CRAN Seite!Danach könnt ihr die IDE (steht für integrated development environment) von RStudio installieren. Dabei handelt es sich um eine leistungsfähige Benutzeroberfläche für R.\nRStudio wird mit einem Text Editor geliefert, dass es nicht unmittelbar erforderlich ist, einen separaten, eigenständigen Editor zu installieren.\nRStudio bietet auch eine direkt Verbindung zu Git(Hub). Um die notwendige Git-Installationen müsst ihr euch aber selbst kümmern. Wir kommen aber auch später auf diesen Punkt zurück.\nDanach könnt ihr die IDE (steht für integrated development environment) von RStudio installieren. Dabei handelt es sich um eine leistungsfähige Benutzeroberfläche für R.RStudio wird mit einem Text Editor geliefert, dass es nicht unmittelbar erforderlich ist, einen separaten, eigenständigen Editor zu installieren.RStudio bietet auch eine direkt Verbindung zu Git(Hub). Um die notwendige Git-Installationen müsst ihr euch aber selbst kümmern. Wir kommen aber auch später auf diesen Punkt zurück.Wenn ihr bereits eine vorhandene R und/oder RStudio Installation habt, empfehlen wir euch dringend, beide neu zu installieren und aktuell wie möglich zu halten.Wenn ihr R aktualisiert, müssen ihr alle Pakete, die ihr installiert habt, aktualisieren. Das könnt ihr leicht mit dem unten stehenden Befehl machen. Möglicherweise müsst ihr aber auch noch weitere Argumente angeben, wenn ihr z.B. eine nicht standardmäßige Bibliothek für eure Pakete verwendet.Bemerkung: Mit diesem Befehl wird nur nach Updates auf CRAN gesucht. Wenn ihr aber ein Paket verwenden, das z.B. nur auf GitHub lebt, müsst ihr manuell aktualisieren, z.B. über devtools::install_github().","code":"\nupdate.packages(ask = FALSE, checkBuilt = TRUE)"},{"path":"install.html","id":"funktioniert-alles-am-besten-ausprobieren","chapter":"Kapitel 1 Installieren von R und RStudio","heading":"1.2 Funktioniert alles? Am besten ausprobieren","text":"Startet RStudio auf eurem Computer. Dann solltet ihr ein Fenster ähnlich zu diesemerhalten. Vermutlich ist euer Fenster nicht dunkel. Aber wer es gerne dunkel mag, soll sich mal unter Tools -> Global -> Appearance die Editor Themes anschauen.Setzt den Cursor das Fenster mit der Bezeichnung Console. Über die Konsole seid ihr der Lage mit R zu interagieren. Erstellt ein einfaches Objekt mit einem Code wie(gefolgt von Enter oder Return). Schaut euch dann das Objekt x genauer , indem ihr x der Konsole eingebt, gefolgt von Enter oder Return. Ihr sollten dann den Wert 8 auf dem Bildschirm sehen. Wenn ja, habet ihr R und RStudio erfolgreich installiert.","code":"\nx <- 2 * 4"},{"path":"install.html","id":"add-on-packages","chapter":"Kapitel 1 Installieren von R und RStudio","heading":"1.3 Add-on packages","text":"R ist ein erweiterbares System und viele Menschen teilen nützlichen Code, den sie als Paket entwickelt haben, über CRAN, GitHub, GitLab oder ähnlichen Plattformen. Um ein Paket von CRAN zu installieren, z.B. das Paket tidyverse (ist genauer gesagt eine Kollektion von Paketen), kann man folgenden Befehl verwendenMit der Option dependencies = TRUE achten wir darauf, dass alle für tidyverse notwendigen Pakete, ebenfalls installiert werden.","code":"\ninstall.packages(\"tidyverse\", dependencies = TRUE)"},{"path":"install.html","id":"rstudio-primers","chapter":"Kapitel 1 Installieren von R und RStudio","heading":"1.4 RStudio Primers","text":"Ein guter Startpunkt für verschiedene R Themen sind die RStudio primers, die aktuell nur als Paket zur lokallen Installation verfügbar sind. Dafür kann man folgenden Befehl verwenden, um Pakete, die nicht auf CRAN verfügbar sind, zu installieren.Um die Tutorials aufzurufen muss man auch das Paket “learnr” installieren.","code":"\ninstall.packages(\"remotes\")\nremotes::install_github(\"hgstp/idsst.rtutorials\")\ninstall.packages(\"lernr\")\nlibrary(\"learnr\")"},{"path":"install.html","id":"aufgabe","chapter":"Kapitel 1 Installieren von R und RStudio","heading":"1.5 Aufgabe","text":"Wir beginnen mit den Grundlagen. Hier wird unterschieden Programming und Visualization Basics.Programming Basics beinhaltet Grundlagen zu Objekttypen, Funktionen und deren Argumente, Listen (eigentlich sind alle Objekte Listen, nur unterschiedlich speziell) und Paketen.Visualization Basics erklärt erste Schritte der Verwendung des ggplot2 Pakets, mit dem wir uns später noch eingehend beschäftigen werden.Bearbeitet eigenständig den Basics Primer. Dafür verwenden wir den Befehl","code":"\nlearnr::run_tutorial(\"programming-basics\", package = \"idsst.rtutorials\")"},{"path":"r-basics.html","id":"r-basics","chapter":"Kapitel 2 R Basics und Arbeitsabläufe","heading":"Kapitel 2 R Basics und Arbeitsabläufe","text":"","code":""},{"path":"r-basics.html","id":"ein-paar-grundlagen-für-das-arbeiten-mit-r","chapter":"Kapitel 2 R Basics und Arbeitsabläufe","heading":"2.1 Ein paar Grundlagen für das Arbeiten mit R","text":"Aktueller Stand: Ihr habt bereits den Basics Primer absolviert und nun wollt ihr anfangen mit eurer RStudio/R Installation zu arbeiten.Es geht los indem ihr RStudio startet. Beachtet dabei die Standardfensterbereiche:Console (links)Environment / History (oben rechts)Files / Plots / Packages / Help (unten rechtes)Bemerkung: Die Standardanordnung der Fenster könnt ihr neben vielen anderen Dingen nach deinen Vorstellungen ändern/anpassen: Customizing RStudio.Geht nun die Konsole um mit R zu interagieren. Erstellt die nachfolgende Zuordnung und schau euch das erstellte Objekt genauer :Alle R Befehle, die ein Objekte erstellen (“Zuweisungen”), haben die Form:Ihr werdet im weiteren Verlauf noch viele Zuweisungen vornehmen. Tatsächlich ist es etwas mühsam den Operator <- zu tippen. Seid aber trotzdem nicht faul und benutzt stattdessen einfach = - auch wenn das theoretisch funktionieren würde. Aber später kann die Verwendung von = für Zuweisungen zu Verwirrung führen. Verwendet stattdessen RStudio die Tastenkombination: Alt + - (Minuszeichen) bzw. option + -.Beachtet, dass RStudio automatisch <- mit Leerzeichen umgibt, eine nützliche Codeformatierung darstellt. Code ist selbst einem guten Tag eher schlecht zu lesen. Gönnt daher euren Augen eine Pause und verwende (ausreichend) Leerzeichen.RStudio bietet viele praktische Tastaturkürzel . Eine Übersicht erhält man auch mit Alt+Shift+K bzw. option+Shift+K.Objektnamen dürfen nicht mit einer Ziffer beginnen und bestimmte andere Zeichen wie ein Komma oder ein Leerzeichen nicht enthalten. Es ist daher ratsam, sich eine Konvention zur Abgrenzung von Wörtern Objektnamen zu überlegen.Wir werden stets die erste Variante verwenden.Führt nun nachfolgenden Befehl ausIn eurem Workspace ist nun das Objekt this_is_a_really_long_name vorhanden. Probiert mithilfe dieses Objekts die Vervollständigungsfunktion von RStudio aus:Gib die ersten paar Zeichen ein, drücke anschließend die TAB Taste, fügen weitere Zeichen hinzu, bis Eindeutigkeit hergestellt ist(wenn sonst wenig deinem Workspace ist, dann ist das schnell erreicht), und drücke dann die Eingabetaste.Führt nun den Befehlaus, um anschließend den Inhalt des Objekts anzuzeigen.Die Objekte zwei.hoch.drei und zwei_Hoch_drei sind natürlich nicht vorhanden und somit führen beide Befehle zu einer Fehlermeldung. Man muss also absolut exakt sein mit seinen Befehlen.R verfügt über eine überwältigende Sammlung eingebauter Funktionen, die nach folgendem Schema aufgerufen werden:Als nächstes wollen wir die Funktion seq() verwenden, die reguläre Zahlensequenzen erzeugt. Dabei wollen wir noch ein weiteres hilfreiches Feature von RStudio demonstrieren.Tippt se und drücke dann die TAB Taste. einem Pop-Fenster werden dir mögliche Vervollständigungen angezeigt. Der Befehl seq() kann dann durch weiteres Tippen oder über die Auswahlmöglichkeit (Pfeiltasten nach oben/unten) festgelegt werden. Zu jeder Auswahlmöglichkeit wird auch noch eine Kurzform der entsprechenden Hilfeseite angezeigt.Fügt man jetzt die öffnende runde Klammer hinzu, wird die zugehörige schließende runde Klammer automatisch hinzugefügt. Tippe anschließend 1, 10 (das geschieht automatisch innerhalb der runden Klammern) und Return. RStudio beendet auch den Klammerausdruck für dich. RStudio 🚀Der letzte Befehl zeigt auch ganz gut, wie R Funktionsargumente auflöst. Sie können immer der Form Name = Wert angeben werden. Aber der Name muss nicht angegeben werden, wie man sieht. solchen Fällen versucht R, nach der Position aufzulösen. wird oben angenommen, dass wir eine Sequenz bei 1 starten wollen, also = 1, und diese bis 10 laufen soll, daher = 10. Da wir keine Schrittweite angegeben haben, wird der Standardwert für verwendet, der diesem Fall gleich 1 ist.Bei Funktionen, die man oft aufruft, kann man gut diese Auflösung nach Position für das erste und vielleicht auch das zweite Argument verwenden. Danach ist es aber ratsam immer mit Name = Wert zu arbeiten um falsche Zuweisungen (verschiedene Argumente können vom gleichen Typ sein, sodass eine falsche Zuweisung nicht automatisch zu einer Fehlermeldung führt) zu vermeiden.Analog zur Unterstützung mit den runden Klammern, werden auch schließende Anführungszeichen automatisch ergänzt, wie man folgendem Beispiel sieht.Nach einer Zuweisung wird der entsprechende Wert des Objekts nicht angezeigt. Daher ist man vielleicht dazu geneigt das Objekt gleich erneut aufzurufenDiese typische Aktion kann verkürzt werden, indem die Zuweisung Klammern gesetzt wird, wodurch die Zuweisung und ein Befehl “Drucke auf den Bildschirm” erfolgen.Nicht alle Funktionen haben (oder erfordern) Argumente:Schaut euch nun euren Workspace - unter Environment (vermutlich im Fenster rechts oben) seht ihr den Inhalt eures Workspace. Der Workspace ist der Ort, dem sich benutzerdefinierte Objekte ansammeln. Eine Liste dieser Objekte könnt ihr auch mit diesen Befehlen erhalten:Wenn ihr nun das Objekt mit dem Namen y entfernen möchtet, könnt ihr das wie folgt machen:Alles löschen kann man mit dem Befehloder man klickt auf den Besen im Environment Fenster von RStudio.","code":"\nx <- 3 * 4\nx\n## [1] 12\nobjectName <- valuei_use_snake_case\nother.people.use.periods\nevenOthersUseCamelCase\nthis_is_a_really_long_name <- 2.5\nzwei_hoch_drei <- 2 ^ 3\nzwei.hoch.drei\n## Error: object 'zwei.hoch.drei' not found\nzwei_Hoch_drei\n## Error: object 'zwei_Hoch_drei' not found\nfunctionName(arg1 = val1, arg2 = val2, ...)\nseq(1, 10)\n##  [1]  1  2  3  4  5  6  7  8  9 10\nyo <- \"hello world\"\ny <- seq(1, 10)\ny\n##  [1]  1  2  3  4  5  6  7  8  9 10\n(y <- seq(1, 10))\n##  [1]  1  2  3  4  5  6  7  8  9 10\ndate()\n## [1] \"Wed Oct 16 23:45:14 2024\"\nobjects()\n## [1] \"this_is_a_really_long_name\" \"x\"                         \n## [3] \"y\"                          \"yo\"                        \n## [5] \"zwei_hoch_drei\"\nls()\n## [1] \"this_is_a_really_long_name\" \"x\"                         \n## [3] \"y\"                          \"yo\"                        \n## [5] \"zwei_hoch_drei\"\nrm(y)\nrm(list = ls())"},{"path":"r-basics.html","id":"workspace-und-working-directory","chapter":"Kapitel 2 R Basics und Arbeitsabläufe","heading":"2.2 Workspace und working directory","text":"Ziemlich schnell wird der Fall eintreten, dass ihr mit eurer R Arbeit (z.B. Bearbeitung eines Hausaufgaben Projekts) noch nicht fertig seid obwohl es Zeit die Arbeit für heute zu beenden. Natürlich man aber zu einem späteren Zeitpunkt mit der Analyse weitermachen, wo man gerade aufgehört hat.Etwas später wird es ein, dass ihr zudem auch noch Daten R einlest und damit anschließend numerische Ergebnisse erzeugt, die ihr dann auch wieder exportieren wollt.Und nochmal später wird es (vielleicht) sein, dass ihr R gleichzeitig mehreren Analysen arbeitest, die ihr aber unbedingt getrennt halten wollt/sollt.Um diese Situationen zu bewältigen, müsst ihr zwei Entscheidungen treffen:betrachtest du deiner Analyse als “Ergebnis”, d.h. wirst du dauerhaft speichern?betrachtest du deiner Analyse als “Ergebnis”, d.h. wirst du dauerhaft speichern?Wo “lebt” deine Analyse?Wo “lebt” deine Analyse?","code":""},{"path":"r-basics.html","id":"workspace-.rdata","chapter":"Kapitel 2 R Basics und Arbeitsabläufe","heading":"2.2.1 Workspace, .RData","text":"Ihr startet gerade eure R Reise ✈️. Daher wäre es okay, wenn ihr euren Workspace als das “Ergebnis” eurer Analyse betrachtet. Ziemlich bald, solltet ihr aber davon (vielleicht durch uns) überzeugt sein, dass eure R Skripte das Ergebnis eurer Analyse sind (beiden Fällen hängt das Ergebnis vermutlich auch von Input Daten ab).Die Daten zusammen mit eurem R Code erlauben es euch jederzeit alle Ergebnisse zu reproduzieren und das ist die entscheidende Eigenschaft.Betrachtest man seinen Workspace als das Ergebnis der Analyse, dann muss man bei einem erneuten Analysedurchlauf (leicht veränderte Aufgabenstellung, …) entweder erneut eine Menge Tippen (natürlich fehleranfällig ist) oder die R History nach den nötigen Befehlen durchwühlen.\nStatt “becoming expert managing R history” als Ziel zu haben, solltet ihr euren R Code sauber ein Skript speichern, sodass er für weitere Analysen zur Verfügung steht.Der Workspace Ansatz wird allerdings “begünstigt/gefördert” durch die Tatsache, dass RStudio beim Beenden der Session automatisch wissen ob der Workspace gespeichert werden soll. Das wollen wir mal ausprobieren.Beendet R/RStudio, entweder über das Menü oder tippt q() die Konsole. Dann erhaltet ihr eine Eingabeaufforderung wie diese:Save workspace image ~/.Rdata?Merkt euch welchem Verzeichnis die Datei gespeichert wird und dann klickt auf Save.Geht das Verzeichnis mit dem gespeicherten Workspace Image und kontrolliert ob die Datei .RData vorhanden ist. Ihr werdet dort auch die Datei .Rhistory finden, die alle Befehle eurer letzten Sitzung enthält.Nun starte erneut RStudio. der Konsole seht ihr einen Befehl, der ungefähr aussiehtund angibt, dass euer gespeicherter Workspace wiederhergestellt wurde. Unter Environment solltet ihr die gleichen Objekte wie zuvor sehen. Im Fenster History findet ihr die gespeicherten Befehle aus der letzten Sitzung.Aber diese Art, analytische Arbeit zu beginnen und zu beenden, würde nicht lange gut gehen. Daher fangen wir gleich mal damit die automatische Nachfrage nach dem Speichern des Workspaces abzuwählen. Öffnet dazu die Global Options (unter Tools)und setzt Save workspace .RData exit auf Never. Nun werdet ihr nie mehr gefragt ob der Workspace gespeichert werden soll. Sehr wohl werdet ihr aber weiterhin gefragt ob ungesicherte Änderungen euren R Skript gespeichert werden sollen, sobald ihr RStudio beenden wollt.","code":"[Workspace loaded from ~/.RData]"},{"path":"r-basics.html","id":"working-directory","chapter":"Kapitel 2 R Basics und Arbeitsabläufe","heading":"2.2.2 Working directory","text":"Jeder Prozess, der auf einem Computer läuft, hat einen Bezug zu seinem “Arbeitsverzeichnis”. R ist dies der Ort, dem R standardmäßig nach Dateien suchen würde oder der Ort wo alle Dateien, die ihr auf die Festplatte schreiben wollt, abgelegt werden. Möglicherweise ist euer aktuelles Arbeitsverzeichnis das Verzeichnis, das ihr gerade untersucht habt um die .RData Datei zu finden.Das aktuelle Arbeitsverzeichnis könnt ihr euch anzeigen lassen mit dem BefehlAber es wird auch oben der RStudio Konsole direkt angezeigt.Es wäre schon, wenn das Arbeitsverzeichnis Abhängigkeit vom jeweils zu bearbeitenden Projekt leicht sinnvoll gesetzt werden könnte. Im nächsten Abschnitt sehen wir, dass genau das möglich ist.","code":"\ngetwd()"},{"path":"r-basics.html","id":"rprojs","chapter":"Kapitel 2 R Basics und Arbeitsabläufe","heading":"2.3 RStudio Projects","text":"Alle zu einem Projekt gehörenden Dateien - Eingabedaten, R Skripte, Analyseergebnisse, Grafiken - einem Ort zu bündeln, ist eine sinnvolle Praxis, dass RStudio über seine Projects genau da ermöglicht.Lasst uns ein Projekt für den Kurs anlegen. Dazu wählen wir oben rechts im RStudio Fenster Project: (None) -> New ProjectDanach wählen wir New Directory -> New Project und geben abschließend einen passenden Verzeichnisnamen ein (dabei beachten wir den Speicherort des neuen Verzeichnisses)Wir nehmen nun , dass ihr ein RStudio Projekt angelegt und auch geöffnet habt. Als Nächstes benötigen wir nun ein wenig R Code. Dazu tippen wir den unten stehenden Code (ausnahmsweise) die KonsoleJetzt nehmen wir mal , das wäre ein guter Start einer Analyse, die wir durchführen wollen. Daher würdest ihr das Ergebnis gerne abspeichern. Unter History könnt ihr alle obigen Befehle markieren und anschließend Source klicken. Daraufhin wird sich ein neues Fenster mit einem R Skript - das natürlich die Befehle enthält - öffnen. Das Skript könnt ihn anschließend abspeichern, und standardmäßig wird es den Projektordner gespeichert werden (aber natürlich könntest man den Speicherort dieser Stelle auch ändern/frei wählen).Nun beendet das Projekt (Close Project der rechten oberen Ecke). Wer , kann sich noch den Inhalt dess Projektordners anschauen, z.B. das PDF öffnen.Danach öffnet ihr das Projekt wieder. Euch sollte auffallen, dass alles dem Zustand ist, wie ihr das Projekt verlassen habt, z.B. Objekte im Arbeitsbereich, die Befehlshistorie, welche Dateien zur Bearbeitung geöffnet sind, wo wir uns im Dateisystembrowser befinden, das Arbeitsverzeichnis für den R-Prozess usw. dies sind gute Dinge 😁.Nun ändert ein paar Dinge eurem Code. Sinnvoll wäre z.B. Anfang die Stichprobenlänge n zu definieren und z.B. auf n <- 40 setzen. Dann\nsollten alle festen 40er Werte durch n ersetzt werden. Anschließend kann man noch ein paar andere Dinge ändern, z.B. die Steigung b, die Farbe der Linie … auch immer. Danach könnt ihr die verschiedenen Möglichkeiten ausprobieren, wie ihr den Code erneut ausführen könnt:Zeile für Zeile ausführen, indem ihr entweder das Tastenkürzel Command + Enter oder die Maus (auf “Run” klicken der oberen rechten Ecke des Editor-Fensters) verwendet.Zeile für Zeile ausführen, indem ihr entweder das Tastenkürzel Command + Enter oder die Maus (auf “Run” klicken der oberen rechten Ecke des Editor-Fensters) verwendet.Das gesamte Dokument durchlaufen lassen, entweder per Tastenkürzel Shift + Command +S oder Maus (klicken auf “Source” der oberen rechten Ecke des Editor-Fensters).Das gesamte Dokument durchlaufen lassen, entweder per Tastenkürzel Shift + Command +S oder Maus (klicken auf “Source” der oberen rechten Ecke des Editor-Fensters).Anschließend könnt ihr euch das PDF anschauen und die Änderungen bewundern.Irgendwann werdet ihr (vielleicht) vor der Aufgabe stehen, eine Grafik neu zu gestalten oder einfach nur verstehen zu wollen, woher sie stammt. Wenn ihr (relevante) Grafiken einer Datei speichert (über R Code und niemals über die Maus oder die Zwischenablage) und dabei sinnvolle Dateinamen/Speicherorte (innerhalb des zugehörigen Projekts) benutzt, werden euch solche Aufgaben nie vor große Probleme stellen ✅.","code":"\na <- 2\nb <- -3\nsig_sq <- 0.5\nx <- runif(40)\ny <- a + b * x + rnorm(40, sd = sqrt(sig_sq))\n(x_n <- mean(x))\n## [1] 0.449\nwrite(x_n, \"mittelwert_x.txt\")\nplot(x, y)\nabline(a, b, col = \"purple\")\ndev.print(pdf, \"scatterplot.pdf\")\n## quartz_off_screen \n##                 2"},{"path":"r-basics.html","id":"zu-guter-letzt","chapter":"Kapitel 2 R Basics und Arbeitsabläufe","heading":"2.4 zu guter Letzt","text":"Es ist üblich, R-Skripte mit einem .R oder .r Suffix zu speichern. Befolgt diese Konvention, außer ihr habt einen sehr außergewöhnlichen Grund, es nicht zu tun.Kommentare beginnen mit einem oder mehreren #-Symbolen. Verwendet Kommentare. RStudio hilft dir dabei ausgewählte Zeilen mit Ctrl+Shift+C (Windows und Linux) oder command+Shif+C (Mac) zu kommentieren oder vorhandene Kommentare wieder zu entfernen.Dieser Workflow wird euch Zukunft gute Dienste leisten:erstelle ein RStudio Projekt für jedes neue R “Vorhaben”speichere alle Input Dateien innerhalb des Projekts (wir werden bald über den Import sprechen)bewahre alle Skripte zu diesem Projekt dort auf; bearbeite sie und führen sie dort ausspeichere den Output innerhalb des Projekts (wie z.B. das PDF im letzten Beispiel)Ihr solltet vermeiden die Maus für Teile des Workflows zu verwenden, wie z.B. das Laden eines Datensatzes oder das Speichern einer Grafik. Das ist sehr wichtig für die Reproduzierbarkeit und um im Nachhinein feststellen zu können, wie eine numerische Tabelle oder eine PDF-Datei tatsächlich erzeugt wurde.","code":""},{"path":"version-control.html","id":"version-control","chapter":"Kapitel 3 Git, GitHub, and RStudio","heading":"Kapitel 3 Git, GitHub, and RStudio","text":"Versionskontrolle sollte nach dem Besuch der Einführung die Programmierung (nicht zutreffend diesem Jahr) bereits kein unbekanntes Thema mehr sein. Falls doch, solltet ihr mit ein paar Worten zu Git und GitHub von Jenny Byran (Autorin von STAT 545) starten.Ziel dieses Abschnitts wird es sein, dass ihreinen GitHub Account anlegt (falls nicht schon vorhanden)einen GitHub Account anlegt (falls nicht schon vorhanden)Git auf eurem Computer installiertGit auf eurem Computer installierteuch bei Git vorstellteuch bei Git vorstellteure Verbindung zu GitHub testeteure Verbindung zu GitHub testetabschließend noch RStudio ins Spiel bringt und RStudio mit Git und GitHub verbindetabschließend noch RStudio ins Spiel bringt und RStudio mit Git und GitHub verbindetBemerkung: Unter 5. werdet ihr ermutigt eure GitHub Zugangsdaten auf eurem Computer zu speichern. Dieser Schritt ist sehr empfehlenswert. Dazu findet ihr auch ein kurzes Video im Moodle Kurs zu EWS.⚠️\nDie Verwendung von GitHub ist eine generelle Empfehlung. Ein GitHub Account kann verschiedenen Situationen hilfreich sein, insbesondere auch nach dem Studium.\nWährend der Veranstaltung werdet ihr aber mit eurem LRZ GitLab Account arbeiten.Das Buch Happy Git GitHub useR enthält noch viele weitere hilfreiche Git/GitHub Informationen. Auf manche kommen wir vielleicht im Laufe des Kurses noch zu sprechen. Andere sind vielleicht zu einem späteren Zeitpunkt interessant, wenn ihr anspruchsvolleren Git Projekten arbeitet.","code":""},{"path":"r-markdown.html","id":"r-markdown","chapter":"Kapitel 4 R Markdown","heading":"Kapitel 4 R Markdown","text":"Ausgewählte Hausaufgaben werdet ihr als R Markdown Dokument abgeben. R Markdown ist eine sehr zugängliche Methode zur Erstellung von Dokumenten, die Prosa Text mit R-Code und den daraus erzeugten Berechnungen, Tabellen und Abbildungen kombinieren.Ein möglicher R Markdown Workflow, der eine Interaktion mit Git, GitHub, und RStudio beinhaltet, wird auf der SeiteTest drive R Markdownvorgestellt.","code":""},{"path":"data-intro.html","id":"data-intro","chapter":"Kapitel 5 Letzte Vorbereitungen …","heading":"Kapitel 5 Letzte Vorbereitungen …","text":"Jetzt ist es der Zeit, sich zu vergewissern welchem Verzeichnis ihr auf eurem Computer ihr euch befindet. Falls ihr ein RStudio Projekt nutzt, sollte diese Frage leicht zu beantworten sein. Falls ihr trotzdem unsicher seid, gebt getwd() der Konsole ein, um das aktuelle Arbeitsverzeichnis zu sehen.Alle nachfolgenden Code Beispiele wollen wir einer .R Datei abspeichern, die dann im aktuellen Arbeitsverzeichnis gespeichert werden soll. Idealerweise geben wir dieser Datei noch einen Namen, wie etwa datenanalyse_teil_1.R, der uns schon viel über den möglichen Inhalt erzählt.\nAlternativ können wir alle Befehle natürlich auch eine R Markdown Datei schreiben, siehe Test drive R Markdown.Prinzipiell geht es den folgenden Abschnitten um Datenmanagement. Es werden aber auch immer wieder ein paar Grafiken zu sehen sein. Dies ist aber kein Problem, da ihr ja bereits den Data Visualization Basics Primerbesucht habt und somit den nötigen Background besitzt.","code":""},{"path":"data-intro.html","id":"data-frames-sind-fantastisch","chapter":"Kapitel 5 Letzte Vorbereitungen …","heading":"5.1 Data frames sind fantastisch","text":"Das Standardformat für Daten ist ein data frame. Die meisten Funktionen zur Inferenz, Modellierung und graphischen Darstellung erwarten, dass ihnen über ein data = Argument ein data frame übergeben wird. Dies gilt für Funktion aus der R Basisdistribution schon seit langem.Die als tidyverse bekannte Kollektion von Paketen geht noch einen Schritt weiter und priorisiert ausdrücklich die Verarbeitung von data frames. Tatsächlich priorisiert tidyverse eine besondere Art von data frames, die als “tibble” bezeichnet wird.Data frames - im Gegensatz zu allgemeinen Arrays oder speziell Matrizen - können Variablen unterschiedlicher Typen enthalten, wie z.B. Textdaten (Subjekt-ID oder Name), quantitative Daten (Anzahl der weißen Blutkörperchen) und qualitative/kategoriale Informationen (behandelt vs. unbehandelt). Genauer gesagt können data frames unterschiedliche Spalten aus unterschiedlichen Datentypen bestehen. Innerhalb einer Spalte müssen aber alle Einträge vom gleichen Typ sein.Daten aus einer Datenanalyse bestehen immer aus mehr als einem Datentyp. Aus diesem Grund eigenen sich Matrizen oder Arrays nicht zur Datenanalyse, da man sonst mit verschiedenen, unverbundenen Objekten (Matrizen, Arrays) arbeiten müsste und diese nur schwer koordinieren kann.","code":""},{"path":"data-intro.html","id":"gapminder-data","chapter":"Kapitel 5 Letzte Vorbereitungen …","heading":"5.2 Gapminder data","text":"Wir werden mit einem Teil der Daten aus dem Gapminder-Projektarbeiten. Die Daten sind im gapminder Paket enthalten, welches wir über CRAN installieren können:Um die Daten zu verwenden, müssen wir das Paket natürlich auch noch ladenGapminder wurde von Hans, Anna und Ola Rosling gegründet. Auf der Webseite des Projekts findet man nicht nur viel Informatives, sondern auch sehr UnterhaltsamesLeider ist Hans Rosling bereits 2017 verstorben.","code":"\ninstall.packages(\"gapminder\")\nlibrary(gapminder)"},{"path":"data-intro.html","id":"die-gapminder-daten-sind-ein-tibble","chapter":"Kapitel 5 Letzte Vorbereitungen …","heading":"5.3 Die gapminder Daten sind ein “tibble”","text":"Durch das Laden des gapminder Pakets haben wir nun Zugriff auf einen Datenobjekt mit demselben Namen. Schauen wir uns mithilfe der Funktion str() mal die Struktur dieses Objekts .str() liefert eine vernünftige Beschreibung von fast allem, und im schlimmsten Fall kann tatsächlich auch nichts “Schlimmes” passieren. Aus dem Output erkennen wir, dass der Datensatz 1704 Beobachtungen enthält.Auf der anderen Seite hätten wir durch direkten Aufruf von gapminder den Inhalt auch direkt auf den Bildschirm schreiben können. Aber vielleicht habt ihr schon mal einen größeren Datensatz aufgerufen und zögert nun etwas, da große Datensätze tendenziell einfach die Konsole füllen und nur sehr wenig Einblick bieten.Tidyverse bietet eine spezielle data frame Variante : ein tibble. gapminder ist ein tibble. Das sieht man auch, wenn man sich die Klasse dieses Objekts anzeigen lässtEs ist immer noch ein reguläres data frame, aber zusätzlich eben auch ein tibble.Wenn wir nun gapminder einfach auf den Bildschirm ausgeben, sehen wir, dass die Konsole nicht voll läuft.Dies ist der erste große Vorteil eines tibbles gegenüber einem data frame.Wenn ihr mit einem reinen data frame arbeitet - und dieses Feature gefällt euch - könnt ihr es mit as_tibble() ein tibble transformieren.Weitere Möglichkeiten, grundlegende Informationen zu einem data frame abzufragen:Ein bisschen deskriptive Statistik zum Inhalt eines data frames erhält man mit der summary() Funktion:Bemerkung: summary() ist eine generische Funktion. Für eine gegebene Klasse (des Inputs) bestimmt die generische Funktion die passende Methode. Die Funktion summary() besitzt z.B. die folgenden Methoden:Obwohl wir uns formell noch nicht eingehender mit der Visualisierung beschäftigt haben, ist es wichtig ein paar Grafiken zu erzeugen um einen ersten Eindruck über den Datensatz zu bekommen. Auf der anderen Seite werden die Grafiken aber auch nicht (viel) aufwendiger als die Beispiele im Visualisation Basics Primer.Interessant ist z.B. der zeitliche Verlauf der Lebenserwartungoder der Zusammenhang zwischen dem GDP (gross domestic product) und der LebenserwartungGrafiken dieser Art werden wir zu einem späteren Zeitpunkt noch genauer behandeln. Dann sprechen wir natürlich auch intensiv über deren Inhalt.Wir schauen uns nochmal die Ausgabe von str() , um darüber zu sprechen, ein data frame genau ist.Ein data frame ist ein Sonderfall einer Liste. R verwendet Listen um gut wie alles ein Objekt aufnehmen zu können. Data frames sind nun ein Spezialfall einer Liste, bei dem die Länge jedes Listenelements gleich ist.Nehmen wir mal , dass wir eine Beschreibung der Variablenzusammen mit den Daten abspeichern wollen. Dazu könnten wir ein tibbleerzeugen, das die Beschreibungen enthält. Dieses data frame hat nun 6 Zeilen und 2 Spalten. Trotzdem können wir es mit gapminder kombinieren, wenn wir beide tibbles einer Liste abspeichern","code":"\nstr(gapminder)\n## tibble [1,704 × 6] (S3: tbl_df/tbl/data.frame)\n##  $ country  : Factor w/ 142 levels \"Afghanistan\",..: 1 1 1 1 1 1 1 1 1 1 ...\n##  $ continent: Factor w/ 5 levels \"Africa\",\"Americas\",..: 3 3 3 3 3 3 3 3 3 3 ...\n##  $ year     : int [1:1704] 1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 ...\n##  $ lifeExp  : num [1:1704] 28.8 30.3 32 34 36.1 ...\n##  $ pop      : int [1:1704] 8425333 9240934 10267083 11537966 13079460 14880372..\n##  $ gdpPercap: num [1:1704] 779 821 853 836 740 ...\nclass(gapminder)\n## [1] \"tbl_df\"     \"tbl\"        \"data.frame\"\ngapminder\n## # A tibble: 1,704 × 6\n##    country     continent  year lifeExp      pop gdpPercap\n##    <fct>       <fct>     <int>   <dbl>    <int>     <dbl>\n##  1 Afghanistan Asia       1952    28.8  8425333      779.\n##  2 Afghanistan Asia       1957    30.3  9240934      821.\n##  3 Afghanistan Asia       1962    32.0 10267083      853.\n##  4 Afghanistan Asia       1967    34.0 11537966      836.\n##  5 Afghanistan Asia       1972    36.1 13079460      740.\n##  6 Afghanistan Asia       1977    38.4 14880372      786.\n##  7 Afghanistan Asia       1982    39.9 12881816      978.\n##  8 Afghanistan Asia       1987    40.8 13867957      852.\n##  9 Afghanistan Asia       1992    41.7 16317921      649.\n## 10 Afghanistan Asia       1997    41.8 22227415      635.\n## # ℹ 1,694 more rows\nlibrary(tidyverse)\nas_tibble(iris)\n## # A tibble: 150 × 5\n##    Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n##           <dbl>       <dbl>        <dbl>       <dbl> <fct>  \n##  1          5.1         3.5          1.4         0.2 setosa \n##  2          4.9         3            1.4         0.2 setosa \n##  3          4.7         3.2          1.3         0.2 setosa \n##  4          4.6         3.1          1.5         0.2 setosa \n##  5          5           3.6          1.4         0.2 setosa \n##  6          5.4         3.9          1.7         0.4 setosa \n##  7          4.6         3.4          1.4         0.3 setosa \n##  8          5           3.4          1.5         0.2 setosa \n##  9          4.4         2.9          1.4         0.2 setosa \n## 10          4.9         3.1          1.5         0.1 setosa \n## # ℹ 140 more rows\nnames(gapminder)\n## [1] \"country\"   \"continent\" \"year\"      \"lifeExp\"   \"pop\"       \"gdpPercap\"\nncol(gapminder)\n## [1] 6\nlength(gapminder)\n## [1] 6\ndim(gapminder)\n## [1] 1704    6\nnrow(gapminder)\n## [1] 1704\nsummary(gapminder)\n##         country        continent        year         lifeExp    \n##  Afghanistan:  12   Africa  :624   Min.   :1952   Min.   :23.6  \n##  Albania    :  12   Americas:300   1st Qu.:1966   1st Qu.:48.2  \n##  Algeria    :  12   Asia    :396   Median :1980   Median :60.7  \n##  Angola     :  12   Europe  :360   Mean   :1980   Mean   :59.5  \n##  Argentina  :  12   Oceania : 24   3rd Qu.:1993   3rd Qu.:70.8  \n##  Australia  :  12                  Max.   :2007   Max.   :82.6  \n##  (Other)    :1632                                               \n##       pop             gdpPercap     \n##  Min.   :6.00e+04   Min.   :   241  \n##  1st Qu.:2.79e+06   1st Qu.:  1202  \n##  Median :7.02e+06   Median :  3532  \n##  Mean   :2.96e+07   Mean   :  7215  \n##  3rd Qu.:1.96e+07   3rd Qu.:  9325  \n##  Max.   :1.32e+09   Max.   :113523  \n## \nmethods(summary)\n##  [1] summary.aov                         summary.aovlist*                   \n##  [3] summary.aspell*                     summary.check_packages_in_dir*     \n##  [5] summary.connection                  summary.data.frame                 \n##  [7] summary.Date                        summary.default                    \n##  [9] summary.Duration*                   summary.ecdf*                      \n## [11] summary.factor                      summary.ggplot*                    \n## [13] summary.glm                         summary.hcl_palettes*              \n## [15] summary.infl*                       summary.Interval*                  \n## [17] summary.lm                          summary.loess*                     \n## [19] summary.manova                      summary.matrix                     \n## [21] summary.mlm*                        summary.nls*                       \n## [23] summary.packageStatus*              summary.Period*                    \n## [25] summary.POSIXct                     summary.POSIXlt                    \n## [27] summary.ppr*                        summary.prcomp*                    \n## [29] summary.princomp*                   summary.proc_time                  \n## [31] summary.rlang_error*                summary.rlang_message*             \n## [33] summary.rlang_trace*                summary.rlang_warning*             \n## [35] summary.rlang:::list_of_conditions* summary.srcfile                    \n## [37] summary.srcref                      summary.stepfun                    \n## [39] summary.stl*                        summary.table                      \n## [41] summary.tukeysmooth*                summary.vctrs_sclr*                \n## [43] summary.vctrs_vctr*                 summary.warnings                   \n## see '?methods' for accessing help and source code\nggplot(gapminder, mapping = aes(x = year, y = lifeExp)) +\n         geom_point()\nggplot(gapminder, mapping = aes(x = gdpPercap, y = lifeExp)) +\n  geom_point()\nggplot(gapminder, mapping = aes(x = log(gdpPercap), y = lifeExp)) +\n  geom_point()\nstr(gapminder)\n## tibble [1,704 × 6] (S3: tbl_df/tbl/data.frame)\n##  $ country  : Factor w/ 142 levels \"Afghanistan\",..: 1 1 1 1 1 1 1 1 1 1 ...\n##  $ continent: Factor w/ 5 levels \"Africa\",\"Americas\",..: 3 3 3 3 3 3 3 3 3 3 ...\n##  $ year     : int [1:1704] 1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 ...\n##  $ lifeExp  : num [1:1704] 28.8 30.3 32 34 36.1 ...\n##  $ pop      : int [1:1704] 8425333 9240934 10267083 11537966 13079460 14880372..\n##  $ gdpPercap: num [1:1704] 779 821 853 836 740 ...\nnames(gapminder)\n## [1] \"country\"   \"continent\" \"year\"      \"lifeExp\"   \"pop\"       \"gdpPercap\"\n(desc <- tibble(variables = names(gapminder),\n               desc = c(\"factor with 142 levels\", \"factor with 5 levels\",\n                        \"ranges from 1952 to 2007 in increments of 5 years\",\n                        \"life expectancy at birth, in years\",\n                        \"population\",\"GDP per capita (US$, inflation-adjusted)\")))\n## # A tibble: 6 × 2\n##   variables desc                                             \n##   <chr>     <chr>                                            \n## 1 country   factor with 142 levels                           \n## 2 continent factor with 5 levels                             \n## 3 year      ranges from 1952 to 2007 in increments of 5 years\n## 4 lifeExp   life expectancy at birth, in years               \n## 5 pop       population                                       \n## 6 gdpPercap GDP per capita (US$, inflation-adjusted)\ngapminder_desc <- list(gapminder, desc)\nstr(gapminder_desc)\n## List of 2\n##  $ : tibble [1,704 × 6] (S3: tbl_df/tbl/data.frame)\n##   ..$ country  : Factor w/ 142 levels \"Afghanistan\",..: 1 1 1 1 1 1 1 1 1 1 ...\n##   ..$ continent: Factor w/ 5 levels \"Africa\",\"Americas\",..: 3 3 3 3 3 3 3 3 3 ..\n##   ..$ year     : int [1:1704] 1952 1957 1962 1967 1972 1977 1982 1987 1992 199..\n##   ..$ lifeExp  : num [1:1704] 28.8 30.3 32 34 36.1 ...\n##   ..$ pop      : int [1:1704] 8425333 9240934 10267083 11537966 13079460 14880..\n##   ..$ gdpPercap: num [1:1704] 779 821 853 836 740 ...\n##  $ : tibble [6 × 2] (S3: tbl_df/tbl/data.frame)\n##   ..$ variables: chr [1:6] \"country\" \"continent\" \"year\" \"lifeExp\" ...\n##   ..$ desc     : chr [1:6] \"factor with 142 levels\" \"factor with 5 levels\" \"r\".."},{"path":"data-intro.html","id":"variablen-in-einem-data-frame","chapter":"Kapitel 5 Letzte Vorbereitungen …","heading":"5.4 Variablen in einem data frame","text":"Einzelne Variable einem data frame kann man mit dem Dollarzeichen $ ansprechen. Als Beispiel schauen wir uns die numerische Variable lifeExp genauer .Die summary() Funktion berechnet, neben dem empirischen Mittel, das Five-number summary, bestehend ausdem Minimumdem Minimumdem unteren Quartil (das empirische 0.25 Quantil)dem unteren Quartil (das empirische 0.25 Quantil)dem Mediandem Mediandem oberen Quartil (das empirische 0.75 Quantil)dem oberen Quartil (das empirische 0.75 Quantil)dem Maximumdem MaximumZusätzlich wollen wir noch die Verteilung von lifeExp visualisieren und plotten dazu ein Histogramm. Dazu verwenden wir wieder ggplot().Beachtet, dass ihr innerhalb der ggplot2 Funktionen Variablen eines data frames direkt ansprechen könnt. Es ist hier also nicht nötig mit dem $ Operator zu arbeiten.Alternativ können wir die Einträge eines data frames aber auch über die eckigen Klammern [] indizieren.Dabei spezifiziert der Eintrag links vom Komma die Zeilen und der Wert rechts davon die Spalten. Dies ist hilfreich, wenn man auf einzelne Werte zugreifen . Aber beim Aufruf nur einer Variable (Spalte), ist die $ Notation sicherlich vorteilhafter.Die Variable year ist eine ganzzahlige Variable, aber da es wenige unterschiedliche Werte gibt, funktioniert sie auch ein wenig wie eine kategoriale Variable und es macht Sinn die Häufigkeit der einzelnen Ausprägungen zu zählen.Wir erkennen, dass jedem Jahr die gleiche Anzahl Beobachtungen vorhanden ist. Es handelt sich dabei stets um Beobachtungen aus den gleichen 142 Ländern. Dies erkennt man aus dieser Ausgabe aber natürlich noch nicht.Die Variablen country und continent enthalten rein kategorische Informationen, die R (häufig) als factor gespeichert werden.Die Levels von continent sind \"Afrika\", \"America\" usw., also Beschreibungen, die man gut lesen und verstehen kann. sollte es sein, wenn man R eine Faktorvariable aufruft. Im Allgemeinen sind die Levels von Menschen lesbare Zeichenfolgen, wie \"male/female\" oder \"control/treated\".Euch sollte aber auch klar sein, dass R diese Information kodierter Form speichert. Als Beispiel könnt ihr euch das Ergebnis von str(gapminder$continent) anschauenFaktorvariablen haben Vor- und Nachteil. Im weiteren Verlauf zeigen wir sowohl die Vor- wie auch die Nachteile. Generell ist aber durchaus , dass die Vorteile überwiegen.Als Nächstes erstellen wir mit der Funktion table() eine Häufigkeitstabelle für die Variable count. Die berechneten Werte wollen wir anschließend noch mithilfe der Funktion geom_bar() visualisieren. Die zu plottenden Häufigkeiten müssen dabei aber nicht die Funktion geom_bar() übergeben werden. Die Funktion berechnet selbst (über die statistische Transformation stat_count()) die entsprechenden Werte.den folgenden Abbildungen sehen wir, wie die kodierten Zahlenwerte einer Faktor Variable genutzt werden können. Der continent-Faktor lässt sich im ggplot2-Paket leicht “Facetten” oder Farben abbilden.Die Erstellung von Grafiken mit ggplot2 werden wir noch genauer besprechen. Daher könnt ihr euch also ruhig zurücklehnen und die Plots einfach genießen oder blind kopieren/einfügen.Zunächst initialisieren wir eine Grafik ohne Inhalt, da nicht gesagt wird, wie die Daten geplottet werden sollen.Für die x-Achse wählen wir im nächsten Schritt eine log Skala (zur Basis 10).Zum Grafikobjekt p werden nun weitere Komponenten hinzugefügt und dann jeweils geplottet","code":"\nhead(gapminder$lifeExp)\n## [1] 28.8 30.3 32.0 34.0 36.1 38.4\nsummary(gapminder$lifeExp)\n##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n##    23.6    48.2    60.7    59.5    70.8    82.6\nggplot(gapminder, mapping = aes(x = lifeExp)) + \n  geom_histogram()\n## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\nsummary(gapminder[,\"lifeExp\"])\n##     lifeExp    \n##  Min.   :23.6  \n##  1st Qu.:48.2  \n##  Median :60.7  \n##  Mean   :59.5  \n##  3rd Qu.:70.8  \n##  Max.   :82.6\nsummary(gapminder$year)\n##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n##    1952    1966    1980    1980    1993    2007\ntable(gapminder$year)\n## \n## 1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 2002 2007 \n##  142  142  142  142  142  142  142  142  142  142  142  142\nclass(gapminder$continent)\n## [1] \"factor\"\nsummary(gapminder$continent)\n##   Africa Americas     Asia   Europe  Oceania \n##      624      300      396      360       24\nlevels(gapminder$continent)\n## [1] \"Africa\"   \"Americas\" \"Asia\"     \"Europe\"   \"Oceania\"\nnlevels(gapminder$continent)\n## [1] 5\nstr(gapminder$continent)\n##  Factor w/ 5 levels \"Africa\",\"Americas\",..: 3 3 3 3 3 3 3 3 3 3 ...\ntable(gapminder$continent)\n## \n##   Africa Americas     Asia   Europe  Oceania \n##      624      300      396      360       24\nggplot(gapminder, aes(x = continent)) + geom_bar()\np <- ggplot(filter(gapminder, \n                   continent != \"Oceania\"), # Daten aus Oceania werden \"herausgefiltert\"\n            aes(x = gdpPercap, y = lifeExp))  \np <- p + scale_x_log10() \n# einen scatterplot\np + geom_point() \n# mit verschiedenen farben für die verschiedenen kontinente\np + geom_point(aes(color = continent))  \n# punkte mit transparenz\np + geom_point(alpha = (1/3), size = 3) + \n  geom_smooth(lwd = 3, se = FALSE) # einen geglätteten zusammenhang\n## `geom_smooth()` using method = 'gam' and formula = 'y ~ s(x, bs = \"cs\")'\n# für jeden kontinent einen eigenen plot (innerhalb einer grafik) erzeugen\np + geom_point(alpha = (1/3), size = 3) + \n  facet_wrap(~ continent) + \n  geom_smooth(lwd = 1.5, se = FALSE)\n## `geom_smooth()` using method = 'loess' and formula = 'y ~ x'"},{"path":"data-intro.html","id":"aufgabe-1","chapter":"Kapitel 5 Letzte Vorbereitungen …","heading":"5.5 Aufgabe","text":"Im nächsten Abschnitt starten wir mit dem dplyr Paket. Bearbeitet daher zur Vorbereitung die ersten beiden Abschnitte des Work Data Primers:Working Tibbbles zeigt die Verwendung von Tibbles sowie die Verwaltung von tidyverse-Paketen.Isolating Data dplyr zeigt wie ihr Variablen auswählt, Beobachtungen filtert und Werte neu anordnet. Zudem wird der Pipe-Operator von R, %>%, eingeführt.","code":""},{"path":"dplyr-intro.html","id":"dplyr-intro","chapter":"Kapitel 6 Einführung in dplyr","heading":"Kapitel 6 Einführung in dplyr","text":"","code":""},{"path":"dplyr-intro.html","id":"einstieg","chapter":"Kapitel 6 Einführung in dplyr","heading":"6.1 Einstieg","text":"dplyr ist ein Paket zur Datenmanipulation, entwickelt von Hadley Wickham und Romain Francois. Das Paket ist Teil des tidyverse und gehört als Kernpaket zu den Paketen, die über library(tidyverse) geladen werden.Die Autoren des Pakets verstehen dplyr als eine Grammatik der Datenmanipulation. Daher werden die wichtigsten dplyr Funktionen auch oft als Verben bezeichnet. Diese Verben sollen euch helfen, die häufigsten Herausforderungen bei der Datenmanipulation zu lösen:mutate(): fügt neue Variablen zum Datensatz hinzu, die Funktionen von bestehenden Variablen sindmutate(): fügt neue Variablen zum Datensatz hinzu, die Funktionen von bestehenden Variablen sindselect(): wählt Variablen (Spalten) basierend auf ihren Namen ausselect(): wählt Variablen (Spalten) basierend auf ihren Namen ausfilter(): wählt Zeilen basierend auf anzugebenden Bedingungen ausfilter(): wählt Zeilen basierend auf anzugebenden Bedingungen aussummarise(): reduziert mehrere Werte auf eine einzige Zusammenfassungsummarise(): reduziert mehrere Werte auf eine einzige Zusammenfassungarrange(): ändert die Reihenfolge der Zeilenarrange(): ändert die Reihenfolge der ZeilenDer Ursprung von dplyr liegt einem früheren Paket mit dem Namen plyr, das zum Ziel hat die “split-apply-combine”-Strategie der Datenanalyse (Wickham 2011) umzusetzen. Wo plyr noch einen vielfältigen Satz von Ein- und Ausgabetypen abdeckt (z.B. Arrays, data frames, Listen), hat dplyr einen klaren Fokus auf data frames oder tibbles (wenn man sich im tidyverse befindet).dplyr bietet schnelle Alternativen zu den R Standardfunktionen:subset()subset()apply(), sapply(), lapply(), tapply()apply(), sapply(), lapply(), tapply()aggregate()aggregate()split()split().call().call()(), within()(), within()und mehr. Ferner bietet dplyr die Möglichkeit schnell über Zeilen oder Gruppen von Zeilen zu iterieren, eine schnelle Alternative zur Nutzung von Schleifen darstellt.Wie immer, laden wir zu Beginn\nDer Fokus liegt diesem Abschnitt auf dplyr. Aber da wir immer wieder auch Funktionen aus anderen “tidyverse-Paketen” nutzen, laden wir stets tidyverse.Zusätzlich laden wir auch noch wieder das gapminder Paket, da wir erneut mit dem gapminder Datensatz arbeiten wollen.","code":"\nlibrary(tidyverse)\n## ── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n## ✔ dplyr     1.1.4     ✔ readr     2.1.5\n## ✔ forcats   1.0.0     ✔ stringr   1.5.1\n## ✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n## ✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n## ✔ purrr     1.0.2     \n## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n## ✖ dplyr::filter() masks stats::filter()\n## ✖ dplyr::lag()    masks stats::lag()\n## ℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\nlibrary(gapminder)"},{"path":"dplyr-intro.html","id":"filter-indizieren-von-zeilen","chapter":"Kapitel 6 Einführung in dplyr","heading":"6.2 filter(): Indizieren von Zeilen","text":"Die Funktion filter() erwartet neben dem Datensatz logische Ausdrücke als Input und gibt die Zeilen des Datensatzes zurück, für die die Kombination der verwendeten logischen Ausdrücke ein TRUE ergibt.letzten Befehl erkennt man, dass die verschiedenen logischen Ausdrücke mit einem & verknüpft werden. man eine “oder Abfrage” gestalten, muss diese einem logischen Ausdruck enthalten sein. kann man mit nachfolgendem Befehl beispielsweise nach allen Beobachtungen aus Ruanda oder Beobachachtungen nach 1979 fragen:man einen Vergleich mit mehr als einem Wert durchführen, kann man natürlich alle Abfragen mit einem | verknüpfen, oder gleich den %% Operator verwenden.Wir erkennen sofort, dass wir mithilfe von dplyr sehr leicht den Datensatz aufteilen können, basierend auf der Tatsache ob Bedingungen erfüllt werden oder eben nicht.Daher solltet ihr unter keinen Umständen mit Befehlen wie diesemarbeiten.Warum ist das eine blöde Idee?Der Befehl dokumentiert sich nicht selbst. ist das Besondere den Zeilen 241 bis 252?Der Befehl dokumentiert sich nicht selbst. ist das Besondere den Zeilen 241 bis 252?Der Befehl ist fehleranfällig. Diese Codezeile wird zu anderen Ergebnissen führen, wenn jemand die Zeilenreihenfolge von gapminder ändert, z.B. die Daten vor diesem Befehl erst sortiert.Der Befehl ist fehleranfällig. Diese Codezeile wird zu anderen Ergebnissen führen, wenn jemand die Zeilenreihenfolge von gapminder ändert, z.B. die Daten vor diesem Befehl erst sortiert.Ganz anders verhält es sich mit diesem BefehlEr erklärt sich von selbst und ist ziemlich robust.","code":"\n# beobachtungen mit einer lebenserwartung unter 29 jahren\nfilter(gapminder, lifeExp < 29)\n## # A tibble: 2 × 6\n##   country     continent  year lifeExp     pop gdpPercap\n##   <fct>       <fct>     <int>   <dbl>   <int>     <dbl>\n## 1 Afghanistan Asia       1952    28.8 8425333      779.\n## 2 Rwanda      Africa     1992    23.6 7290203      737.\n# beobachtungen aus ruanda nach dem jahr 1979\nfilter(gapminder, country == \"Rwanda\", year > 1979)\n## # A tibble: 6 × 6\n##   country continent  year lifeExp     pop gdpPercap\n##   <fct>   <fct>     <int>   <dbl>   <int>     <dbl>\n## 1 Rwanda  Africa     1982    46.2 5507565      882.\n## 2 Rwanda  Africa     1987    44.0 6349365      848.\n## 3 Rwanda  Africa     1992    23.6 7290203      737.\n## 4 Rwanda  Africa     1997    36.1 7212583      590.\n## 5 Rwanda  Africa     2002    43.4 7852401      786.\n## 6 Rwanda  Africa     2007    46.2 8860588      863.\nfilter(gapminder, country == \"Rwanda\" | year > 1979)\n## # A tibble: 858 × 6\n##    country     continent  year lifeExp      pop gdpPercap\n##    <fct>       <fct>     <int>   <dbl>    <int>     <dbl>\n##  1 Afghanistan Asia       1982    39.9 12881816      978.\n##  2 Afghanistan Asia       1987    40.8 13867957      852.\n##  3 Afghanistan Asia       1992    41.7 16317921      649.\n##  4 Afghanistan Asia       1997    41.8 22227415      635.\n##  5 Afghanistan Asia       2002    42.1 25268405      727.\n##  6 Afghanistan Asia       2007    43.8 31889923      975.\n##  7 Albania     Europe     1982    70.4  2780097     3631.\n##  8 Albania     Europe     1987    72    3075321     3739.\n##  9 Albania     Europe     1992    71.6  3326498     2497.\n## 10 Albania     Europe     1997    73.0  3428038     3193.\n## # ℹ 848 more rows\n# beobachtungen aus ruanda und afghanistan\nfilter(gapminder, country %in% c(\"Rwanda\", \"Afghanistan\"))\n## # A tibble: 24 × 6\n##    country     continent  year lifeExp      pop gdpPercap\n##    <fct>       <fct>     <int>   <dbl>    <int>     <dbl>\n##  1 Afghanistan Asia       1952    28.8  8425333      779.\n##  2 Afghanistan Asia       1957    30.3  9240934      821.\n##  3 Afghanistan Asia       1962    32.0 10267083      853.\n##  4 Afghanistan Asia       1967    34.0 11537966      836.\n##  5 Afghanistan Asia       1972    36.1 13079460      740.\n##  6 Afghanistan Asia       1977    38.4 14880372      786.\n##  7 Afghanistan Asia       1982    39.9 12881816      978.\n##  8 Afghanistan Asia       1987    40.8 13867957      852.\n##  9 Afghanistan Asia       1992    41.7 16317921      649.\n## 10 Afghanistan Asia       1997    41.8 22227415      635.\n## # ℹ 14 more rows\nauswahl <- gapminder[241:252, ]\nfilter(gapminder, country == \"Canada\")"},{"path":"dplyr-intro.html","id":"der-pipe-operator","chapter":"Kapitel 6 Einführung in dplyr","heading":"6.3 Der Pipe-Operator","text":"Bevor es weitergeht, wollen wir aber den Pipe-Operator, den das Tidyverse aus dem magrittr-Paket von Stefan Bache importiert, vorstellen.\nFigure 6.1: Quelle https://en.wikipedia.org/wiki/The_Treachery_of_Images\nMithilfe des Pipe-Operators ist man der Lage aufeinanderfolgende Befehle von Daten-Operationen strukturiert anzugeben, ohne sie ineinander zu verschachteln. Diese neue Syntax führt zu Code, der viel einfacher zu schreiben und zu lesen ist.Und sieht er aus: %>%.Das entsprechende RStudio Tastenkürzel lautet:\nCtrl+Shift+M (Windows), Cmd+Shift+M (Mac).Erstmal ein BeispielMan erkennt sofort, der Befehl ist äquivalent zu head(gapminder). Der Pipe-Operator nimmt das Objekt auf der linken Seite und leitet es den Funktionsaufruf auf der rechten Seite weiter - er gibt es buchstäblich als erstes Argument ein.Und natürlich kann man der Funktion auf der rechten Seite auch noch weitere Argumente übergeben. Um die ersten 3 Zeilen von gapminder auszugeben, könnte man head(gapminder, 3) nutzen oder:Der bisherige Einsatz des Pipe-Operators %>% war sicherlich noch nicht sehr beeindruckend, aber das sollte sich noch ändern.","code":"\ngapminder %>% head()\n## # A tibble: 6 × 6\n##   country     continent  year lifeExp      pop gdpPercap\n##   <fct>       <fct>     <int>   <dbl>    <int>     <dbl>\n## 1 Afghanistan Asia       1952    28.8  8425333      779.\n## 2 Afghanistan Asia       1957    30.3  9240934      821.\n## 3 Afghanistan Asia       1962    32.0 10267083      853.\n## 4 Afghanistan Asia       1967    34.0 11537966      836.\n## 5 Afghanistan Asia       1972    36.1 13079460      740.\n## 6 Afghanistan Asia       1977    38.4 14880372      786.\ngapminder %>% head(3)\n## # A tibble: 3 × 6\n##   country     continent  year lifeExp      pop gdpPercap\n##   <fct>       <fct>     <int>   <dbl>    <int>     <dbl>\n## 1 Afghanistan Asia       1952    28.8  8425333      779.\n## 2 Afghanistan Asia       1957    30.3  9240934      821.\n## 3 Afghanistan Asia       1962    32.0 10267083      853."},{"path":"dplyr-intro.html","id":"mit-select-variablen-auswählen","chapter":"Kapitel 6 Einführung in dplyr","heading":"6.4 Mit select() Variablen auswählen","text":"Verwendet select(), um aus den Daten verschiedene Variablen (Spalten) auszuwählen. Hier kommt eine typische Verwendung von select():und nun noch kombiniert mit head() über den Pipe-Operator:Der letzte Befehl nochmal Worten:“Nimm gapminder, wähle die Variablen year und lifeExp und zeige dann die ersten 4 Zeilen .”Natürlich kann man diese Operationen auch mit R Standardbefehlen ausführen. Die dplyr Befehle haben aber klare Vorteile bei der Lesbarkeit des Codes, wie man im nächsten Beispiel sieht.Wir wählen aus dem gapminder Datensatz die Variablen year und lifeExp der Kambodscha BeobachtungenDas gleiche Ergebnis würde man mit diesem R Standardbefehl erhalten:Ich hoffe, ihr stimmt mir zu, dass der dplyr Befehl deutlich leichter zu lesen ist.","code":"\nselect(gapminder, year, lifeExp)\n## # A tibble: 1,704 × 2\n##     year lifeExp\n##    <int>   <dbl>\n##  1  1952    28.8\n##  2  1957    30.3\n##  3  1962    32.0\n##  4  1967    34.0\n##  5  1972    36.1\n##  6  1977    38.4\n##  7  1982    39.9\n##  8  1987    40.8\n##  9  1992    41.7\n## 10  1997    41.8\n## # ℹ 1,694 more rows\ngapminder %>%\n  select(year, lifeExp) %>%\n  head(4)\n## # A tibble: 4 × 2\n##    year lifeExp\n##   <int>   <dbl>\n## 1  1952    28.8\n## 2  1957    30.3\n## 3  1962    32.0\n## 4  1967    34.0\ngapminder %>%\n  filter(country == \"Cambodia\") %>%\n  select(year, lifeExp)\n## # A tibble: 12 × 2\n##     year lifeExp\n##    <int>   <dbl>\n##  1  1952    39.4\n##  2  1957    41.4\n##  3  1962    43.4\n##  4  1967    45.4\n##  5  1972    40.3\n##  6  1977    31.2\n##  7  1982    51.0\n##  8  1987    53.9\n##  9  1992    55.8\n## 10  1997    56.5\n## 11  2002    56.8\n## 12  2007    59.7\ngapminder[gapminder$country == \"Cambodia\", c(\"year\", \"lifeExp\")]\n## # A tibble: 12 × 2\n##     year lifeExp\n##    <int>   <dbl>\n##  1  1952    39.4\n##  2  1957    41.4\n##  3  1962    43.4\n##  4  1967    45.4\n##  5  1972    40.3\n##  6  1977    31.2\n##  7  1982    51.0\n##  8  1987    53.9\n##  9  1992    55.8\n## 10  1997    56.5\n## 11  2002    56.8\n## 12  2007    59.7"},{"path":"dplyr-intro.html","id":"select-hilfsfunktionen","chapter":"Kapitel 6 Einführung in dplyr","heading":"6.5 select() Hilfsfunktionen","text":"Der gapminder Datensatz ist klein und damit leicht überschaubar. Daher ist eine strukturierte Auswahl von Variablen hier nicht notwendig. größeren Datensätzen kann dies aber ganz anders sein. Dort bietet es sich mit Hilfsfunktionen wie: wählt einen Bereich von Spalten aus: wählt einen Bereich von Spalten aus- wählt alle Spalten außer …- wählt alle Spalten außer …starts_with() wählt alle Spalten, die mit … startenstarts_with() wählt alle Spalten, die mit … startenends_with() wählt alle Spalten, die mit … endenends_with() wählt alle Spalten, die mit … endencontains() wählt alle Spalten, die … enthaltencontains() wählt alle Spalten, die … enthaltenmatches() wählte alle Spalten, die den regulären Ausdruck … enthaltenmatches() wählte alle Spalten, die den regulären Ausdruck … enthalten……zu arbeiten.","code":"\nselect(gapminder, \n       matches(        # von beginn ^\n         \"^.{4}$\"      # bis ende $\n         )             # enthält der namen irgendwelche . character\n       )\n## # A tibble: 1,704 × 1\n##     year\n##    <int>\n##  1  1952\n##  2  1957\n##  3  1962\n##  4  1967\n##  5  1972\n##  6  1977\n##  7  1982\n##  8  1987\n##  9  1992\n## 10  1997\n## # ℹ 1,694 more rows"},{"path":"dplyr-intro.html","id":"pure-predictable-pipeable","chapter":"Kapitel 6 Einführung in dplyr","heading":"6.6 Pure, predictable, pipeable","text":"Bisher haben wir nur etwas der Oberfläche von dplyr gekratzt, trotzdem möchten wir auf ein Schlüsselprinzip hinweisen, das du mit der Zeit schätzen lernen wirst.Die Verben (Hauptfunktionen) von dplyr, wie z.B. filter() und select(), sind pure functions. Dazu schreibt Hadley Wickham im Kapitel Functions seinem Advanced R Buch (2019):functions easiest understand reason pure functions: functions always map input output impact workspace. words, pure functions side effects: don’t affect state world way apart value return.Tatsächlich sind diese Verben ein Spezialfall reiner Funktionen: sie nehmen als Input und Output denselben Objekttyp , .d.R. ein data frame.Die Daten sind für diese Funktionen auch stets das erste Inputargument.","code":""},{"path":"dplyr-intro.html","id":"aufgabe-2","chapter":"Kapitel 6 Einführung in dplyr","heading":"6.7 Aufgabe","text":"Die dplyr Einführung geht weiter im Kapitel Mehr zu dplyr. Bearbeitet aber vorher den letzten Abschnitte des Work Data Primers:Deriving Information dplyr zeigt euch wie ihr über bestehenden Variablen neue Variablen definiert und leicht zusammenfassende Statistiken innerhalb vorab definierter Gruppen berechnet.","code":""},{"path":"dplyr-single.html","id":"dplyr-single","chapter":"Kapitel 7 Mehr zu dplyr","heading":"Kapitel 7 Mehr zu dplyr","text":"","code":""},{"path":"dplyr-single.html","id":"wo-stehen-wir","chapter":"Kapitel 7 Mehr zu dplyr","heading":"7.1 Wo stehen wir?","text":"Kapitel 6 haben wir bereits zwei sehr wichtige Verben und den Pipe Operator kennengelernt und verwendet:filter() zur Auswahl spezieller Zeilen eines Datensatzesselect() zur Auswahl spezieller Variablen eines Datensatzesder Pipe-Operator %>% überführt das Objekt auf der linken Seite des Operators das erste Funktionsargument der Funktion auf der rechten Seite des AufrufsWir haben zudem auch noch die Rolle von dplyr innerhalb des tidyverse besprochen:dplyr ist ein Kernpaket der tidyverse Kollektion von Paketen. Da wir die anderen oft beiläufig benutzen, werden wir stets dplyr und die anderen über library(tidyverse) laden.Wir starten wieder mit dem Laden von dplyr (über tidyverse)und gapminder","code":"\nlibrary(tidyverse)\n## ── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n## ✔ dplyr     1.1.4     ✔ readr     2.1.5\n## ✔ forcats   1.0.0     ✔ stringr   1.5.1\n## ✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n## ✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n## ✔ purrr     1.0.2     \n## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n## ✖ dplyr::filter() masks stats::filter()\n## ✖ dplyr::lag()    masks stats::lag()\n## ℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\nlibrary(gapminder)"},{"path":"dplyr-single.html","id":"mit-mutate-neue-variablen-erstellen","chapter":"Kapitel 7 Mehr zu dplyr","heading":"7.2 Mit mutate() neue Variablen erstellen","text":"Wir starten mit dem Anlegen einer Kopie von gapminder, die wir dann nach unseren Vorstellungen verändern (es wäre aber auch nichts passiert, wenn wir alles mit gapminder durchführen würden; mit dem Befehl gapminder::gapminder können wir immer auf die Originalversion zurückgreifen).Unser Ziel ist es, dass GDP pro Land anzugeben. Das sollte machbar sein, da schließlich das Pro-Kopf-GDP wie auch die Bevölkerungszahl im Datensatz enthalten sind. Multiplizieren beider Variablen liefert uns das gewünschte Ergebnis.mutate() ist eine Funktion, die neue Variablen definiert und ein tibble einfügt. Dabei können wir auf bestehende Variablen einfach über ihren Namen zugreifen.Hmmmm … diese GDP-Zahlen sind ziemlich groß und abstrakt. dem Zusammenhang, bedenke den Ratschlag von Randall Munroe:One thing bothers large numbers presented without context… “added zero number, sentence containing mean something different ?” answer “”, maybe number business sentence first place.Vielleicht wäre es doch sinnvoller, wenn wir beim Pro-Kopf-GDP bleiben. Aber wäre, wenn wir das Pro-Kopf-GDP angeben würden Relation zu irgendeinem Vergleichsland. Wir könnten alles Bezug auf die entsprechenden Daten aus Deutschland angeben.Dazu müssen wir eine neue Variable erstellen, die aus den gdpPercap Werten , geteilt durch die deutschen gdpPercap Werte, besteht. Beim Erstellen der Variable müssen wir aber darauf achten, dass wir immer zwei Zahlen teilen, die sich auf dasselbe Jahr beziehen.Wie können wir das schaffen?Beobachtungen für Deutschland einem Objekt ger_gap speichernErstellen einer neue temporären Variable tmp my_gap, die definiert wird durch:\ndie gdpPercap-Variable aus ger_gap aufrufen\nmit rep() die gdpPercap Wert aus ger_gap einmal pro Land im my_gap reproduzieren, damit ein Vektor entsteht, der die gleiche Anzahl Beobachtungen wie my_gap hat\ndie gdpPercap-Variable aus ger_gap aufrufenmit rep() die gdpPercap Wert aus ger_gap einmal pro Land im my_gap reproduzieren, damit ein Vektor entsteht, der die gleiche Anzahl Beobachtungen wie my_gap hatDividieren der gdpPercap Werte durch die deutschen ZahlenLöschen der temporären Variable tmp my_gapBeachte, dass mutate() neue Variablen sequentiell erstellt, dass man auf frühere Variablen (wie tmp) verweisen kann um spätere Variablen (wie gdpPercapRel) zu definieren. Nachdem eine Variable nicht mehr benötigt wird, kann man sie einfach auf NULL setzen.Bleibt die Frage ob das alles richtig war. Um diese Frage zu beantworten, können wir uns aber einfach mal die Werte von gdpPercapRel für Deutschland anschauen. Die sollten besser alle 1 sein!Ich glaube, wir können annehmen, dass Deutschland ein Land mit einem “hohen GDP” pro Kopf ist. Daher sollte die Verteilung von gdpPercapRel auf Werten unter 1 konzentriert sein, möglicherweise sogar weit darunter. Aber besser mal nachschauen ob dem ist:Die Zahlen des relativen Pro-Kopf-GDP liegen deutlich unter 1. Wir sehen, dass die meisten Länder, die diesem Datensatz erfasst werden, über den gesamten Zeitraum im Vergleich zu Deutschland ein wesentlich niedrigeres Pro-Kopf-GDP aufweisen.Tipp: Vertraut niemandem - einschließlich (besonders?) euch selbst. Versucht immer, einen Weg zu finden, um zu überprüfen, ob ihr das gemacht habt, ihr tun wolltet. Seid aber nicht schockiert, wenn ihr manchmal feststellen müsst, dass dem nicht ist. 😉","code":"\nmy_gap <- gapminder\nmy_gap %>%\n  mutate(gdp = pop * gdpPercap)\n## # A tibble: 1,704 × 7\n##    country     continent  year lifeExp      pop gdpPercap          gdp\n##    <fct>       <fct>     <int>   <dbl>    <int>     <dbl>        <dbl>\n##  1 Afghanistan Asia       1952    28.8  8425333      779.  6567086330.\n##  2 Afghanistan Asia       1957    30.3  9240934      821.  7585448670.\n##  3 Afghanistan Asia       1962    32.0 10267083      853.  8758855797.\n##  4 Afghanistan Asia       1967    34.0 11537966      836.  9648014150.\n##  5 Afghanistan Asia       1972    36.1 13079460      740.  9678553274.\n##  6 Afghanistan Asia       1977    38.4 14880372      786. 11697659231.\n##  7 Afghanistan Asia       1982    39.9 12881816      978. 12598563401.\n##  8 Afghanistan Asia       1987    40.8 13867957      852. 11820990309.\n##  9 Afghanistan Asia       1992    41.7 16317921      649. 10595901589.\n## 10 Afghanistan Asia       1997    41.8 22227415      635. 14121995875.\n## # ℹ 1,694 more rows\nger_gap <- my_gap %>%\n  filter(country == \"Germany\")\n\nmy_gap <- my_gap %>%\n  mutate(tmp = rep(ger_gap$gdpPercap, nlevels(country)),\n         gdpPercapRel = gdpPercap / tmp,\n         tmp = NULL)\nmy_gap %>% \n  filter(country == \"Germany\") %>% \n  select(country, year, gdpPercapRel)\n## # A tibble: 12 × 3\n##    country  year gdpPercapRel\n##    <fct>   <int>        <dbl>\n##  1 Germany  1952            1\n##  2 Germany  1957            1\n##  3 Germany  1962            1\n##  4 Germany  1967            1\n##  5 Germany  1972            1\n##  6 Germany  1977            1\n##  7 Germany  1982            1\n##  8 Germany  1987            1\n##  9 Germany  1992            1\n## 10 Germany  1997            1\n## 11 Germany  2002            1\n## 12 Germany  2007            1\nsummary(my_gap$gdpPercapRel)\n##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n##    0.01    0.07    0.19    0.37    0.51   15.17"},{"path":"dplyr-single.html","id":"mit-arrange-die-zeilenreihenfolge-ändern","chapter":"Kapitel 7 Mehr zu dplyr","heading":"7.3 Mit arrange() die Zeilenreihenfolge ändern","text":"arrange() ordnet die Zeilen einem data frame neu . Stellen wir uns mal vor, dass wir die Daten nach Jahr und Land und nicht nach Land und Jahr ordnen wollen.Oder vielleicht interessieren euch nur die Daten aus 2007, angeordnet entsprechend der Lebenserwartung.Das war nun aber nicht das Ergebnis, welches ihr sehen wolltet. Ihr wolltet eigentlich nach absteigender Lebenserwartung sortieren. Dazu müsst ihr desc() verwenden.Tipp: Verlasst euch NIEMALS darauf, dass Zeilen oder Variablen einer bestimmten Reihenfolge stehen. Aber manchmal man Tabellen anderen präsentieren und dabei macht es durchaus Sinn die Zeilenreihenfolge je nach Fragestellung anzupassen.","code":"\nmy_gap %>%\n  arrange(year, country)\n## # A tibble: 1,704 × 7\n##    country     continent  year lifeExp      pop gdpPercap gdpPercapRel\n##    <fct>       <fct>     <int>   <dbl>    <int>     <dbl>        <dbl>\n##  1 Afghanistan Asia       1952    28.8  8425333      779.       0.109 \n##  2 Albania     Europe     1952    55.2  1282697     1601.       0.224 \n##  3 Algeria     Africa     1952    43.1  9279525     2449.       0.343 \n##  4 Angola      Africa     1952    30.0  4232095     3521.       0.493 \n##  5 Argentina   Americas   1952    62.5 17876956     5911.       0.827 \n##  6 Australia   Oceania    1952    69.1  8691212    10040.       1.41  \n##  7 Austria     Europe     1952    66.8  6927772     6137.       0.859 \n##  8 Bahrain     Asia       1952    50.9   120447     9867.       1.38  \n##  9 Bangladesh  Asia       1952    37.5 46886859      684.       0.0958\n## 10 Belgium     Europe     1952    68    8730405     8343.       1.17  \n## # ℹ 1,694 more rows\nmy_gap %>%\n  filter(year == 2007) %>%\n  arrange(lifeExp)\n## # A tibble: 142 × 7\n##    country                 continent  year lifeExp    pop gdpPercap gdpPercapRel\n##    <fct>                   <fct>     <int>   <dbl>  <int>     <dbl>        <dbl>\n##  1 Swaziland               Africa     2007    39.6 1.13e6     4513.       0.140 \n##  2 Mozambique              Africa     2007    42.1 2.00e7      824.       0.0256\n##  3 Zambia                  Africa     2007    42.4 1.17e7     1271.       0.0395\n##  4 Sierra Leone            Africa     2007    42.6 6.14e6      863.       0.0268\n##  5 Lesotho                 Africa     2007    42.6 2.01e6     1569.       0.0488\n##  6 Angola                  Africa     2007    42.7 1.24e7     4797.       0.149 \n##  7 Zimbabwe                Africa     2007    43.5 1.23e7      470.       0.0146\n##  8 Afghanistan             Asia       2007    43.8 3.19e7      975.       0.0303\n##  9 Central African Republ… Africa     2007    44.7 4.37e6      706.       0.0219\n## 10 Liberia                 Africa     2007    45.7 3.19e6      415.       0.0129\n## # ℹ 132 more rows\nmy_gap %>%\n  filter(year == 2007) %>%\n  arrange(desc(lifeExp))\n## # A tibble: 142 × 7\n##    country          continent  year lifeExp       pop gdpPercap gdpPercapRel\n##    <fct>            <fct>     <int>   <dbl>     <int>     <dbl>        <dbl>\n##  1 Japan            Asia       2007    82.6 127467972    31656.        0.984\n##  2 Hong Kong, China Asia       2007    82.2   6980412    39725.        1.23 \n##  3 Iceland          Europe     2007    81.8    301931    36181.        1.12 \n##  4 Switzerland      Europe     2007    81.7   7554661    37506.        1.17 \n##  5 Australia        Oceania    2007    81.2  20434176    34435.        1.07 \n##  6 Spain            Europe     2007    80.9  40448191    28821.        0.896\n##  7 Sweden           Europe     2007    80.9   9031088    33860.        1.05 \n##  8 Israel           Asia       2007    80.7   6426679    25523.        0.793\n##  9 France           Europe     2007    80.7  61083916    30470.        0.947\n## 10 Canada           Americas   2007    80.7  33390141    36319.        1.13 \n## # ℹ 132 more rows"},{"path":"dplyr-single.html","id":"mit-rename-schöne-namen-vergeben","chapter":"Kapitel 7 Mehr zu dplyr","heading":"7.4 Mit rename() “schöne” Namen vergeben","text":"Ein paar der Namen gapminder sind nicht besonders hübsch, wie z.B. lifeExp. life expectancy wären ja schließlich zwei Worte und daher finde ich (persönliche Meinung) es schöner, dies auch im Variablennamen zu sehenDie Änderungen haben wir jetzt aber nicht abgespeichert (auch wenn sie schön waren), da wir den nachfolgenden Code auch weiterhin ausführen möchten, ohne die Variablennamen entsprechend zu ändern.Bemerkung: Mit select() könnten wir bei der Auswahl von Variablen auch deren Namen änderneverything() wählt alle übrigen (außer gdpPercap) Variablen. Da gdpPercap erster Stelle gewählt wurde, wird die Variable auch zur ersten Spalte.","code":"\nmy_gap %>%\n  rename(life_exp = lifeExp,\n         gdp_percap = gdpPercap,\n         gdp_percap_rel = gdpPercapRel)\n## # A tibble: 1,704 × 7\n##    country     continent  year life_exp      pop gdp_percap gdp_percap_rel\n##    <fct>       <fct>     <int>    <dbl>    <int>      <dbl>          <dbl>\n##  1 Afghanistan Asia       1952     28.8  8425333       779.         0.109 \n##  2 Afghanistan Asia       1957     30.3  9240934       821.         0.0806\n##  3 Afghanistan Asia       1962     32.0 10267083       853.         0.0661\n##  4 Afghanistan Asia       1967     34.0 11537966       836.         0.0567\n##  5 Afghanistan Asia       1972     36.1 13079460       740.         0.0411\n##  6 Afghanistan Asia       1977     38.4 14880372       786.         0.0383\n##  7 Afghanistan Asia       1982     39.9 12881816       978.         0.0444\n##  8 Afghanistan Asia       1987     40.8 13867957       852.         0.0346\n##  9 Afghanistan Asia       1992     41.7 16317921       649.         0.0245\n## 10 Afghanistan Asia       1997     41.8 22227415       635.         0.0229\n## # ℹ 1,694 more rows\nmy_gap %>%\n  filter(country == \"Burundi\", year > 1996) %>% \n  select(yr = year, lifeExp, gdpPercap) %>% \n  select(gdpPercap, everything())\n## # A tibble: 3 × 3\n##   gdpPercap    yr lifeExp\n##       <dbl> <int>   <dbl>\n## 1      463.  1997    45.3\n## 2      446.  2002    47.4\n## 3      430.  2007    49.6"},{"path":"dplyr-single.html","id":"summarise-in-kombination-mit-group_by","chapter":"Kapitel 7 Mehr zu dplyr","heading":"7.5 summarise() in Kombination mit group_by()","text":"Nehmen wir mal , dass uns die Antwort auf die Frage“welchem Land ist die Lebenserwartung innerhalb von 5 Jahren stärksten gesunken?”interessiert.dplyr bietet uns mächtige Hilfsmittel zur Beantwortung der Frage:group_by() fügt dem Datensatz eine zusätzliche Struktur hinzu – Gruppierungsinformationen – die die Grundlage für Berechnungen innerhalb der Gruppen bilden.group_by() fügt dem Datensatz eine zusätzliche Struktur hinzu – Gruppierungsinformationen – die die Grundlage für Berechnungen innerhalb der Gruppen bilden.summarise() nimmt einen Datensatz mit \\(n\\)-Beobachtungen, berechnet die angeforderten Zusammenfassungen und gibt einen Datensatz mit einer Beobachtung (falls nur eine Zusammenfassung angefordert wurde) zurück.summarise() nimmt einen Datensatz mit \\(n\\)-Beobachtungen, berechnet die angeforderten Zusammenfassungen und gibt einen Datensatz mit einer Beobachtung (falls nur eine Zusammenfassung angefordert wurde) zurück.mutate() und summarise() berücksichtigen Gruppen.mutate() und summarise() berücksichtigen Gruppen.Kombiniert mit den Verben, die wir bereits kennen, könnt ihr mit diesen neuen Werkzeugen eine extrem vielfältige Reihe von Problemen relativ einfach lösen.","code":""},{"path":"dplyr-single.html","id":"dinge-aufzählen","chapter":"Kapitel 7 Mehr zu dplyr","heading":"7.5.1 Dinge aufzählen","text":"Beginnen wir mit dem einfachen Zählen. Wie viele Beobachtungen haben wir pro Kontinent?Lasst uns hier kurz innehalten und über das tidyverse nachdenken. Ihr könntet die gleichen absoluten Häufigkeiten natürlich auch mit table() berechnen.Das Ergebnis ist ein Objekt der Klasse table. Dies macht nachfolgende Berechnungen leider etwas kniffliger, als es euch lieb ist. Zum Beispiel ist es schade, dass die Namen der Kontinente nur als Attribute und nicht als richtiger Faktor zusammen mit den berechneten Werten zurückgegeben werden.\nDies ist ein Beispiel dafür, wie das tidyverse Übergänge glättet, bei denen die Ausgabe von Schritt die Eingabe von Schritt + 1 werden soll.Die tally() Funktion ist eine Komfortfunktion, die weiß, wie man Zeilen zählt und dabei Gruppen berücksichtigt.Die Funktion count() bietet noch mehr Komfort. Sie kann sowohl gruppieren als auch zählen.wäre, wenn uns nicht nur die Anzahl Beobachtungen pro Kontinent interessiert, sondern auch die Anzahl unterschiedlichen Ländern pro Kontinent. Dazu bestimmen wir einfach mehrere Zusammenfassungen innerhalb von summarise(). Dabei verwenden wir die Funktion n_distinct(), um die Anzahl der einzelnen Länder innerhalb jedes Kontinents zu zählen.","code":"\nmy_gap %>%\n  group_by(continent) %>%\n  summarise(n = n())\n## # A tibble: 5 × 2\n##   continent     n\n##   <fct>     <int>\n## 1 Africa      624\n## 2 Americas    300\n## 3 Asia        396\n## 4 Europe      360\n## 5 Oceania      24\ntable(gapminder$continent)\n## \n##   Africa Americas     Asia   Europe  Oceania \n##      624      300      396      360       24\nstr(table(gapminder$continent))\n##  'table' int [1:5(1d)] 624 300 396 360 24\n##  - attr(*, \"dimnames\")=List of 1\n##   ..$ : chr [1:5] \"Africa\" \"Americas\" \"Asia\" \"Europe\" ...\nmy_gap %>%\n  group_by(continent) %>%\n  tally()\n## # A tibble: 5 × 2\n##   continent     n\n##   <fct>     <int>\n## 1 Africa      624\n## 2 Americas    300\n## 3 Asia        396\n## 4 Europe      360\n## 5 Oceania      24\nmy_gap %>% \n  count(continent)\n## # A tibble: 5 × 2\n##   continent     n\n##   <fct>     <int>\n## 1 Africa      624\n## 2 Americas    300\n## 3 Asia        396\n## 4 Europe      360\n## 5 Oceania      24\nmy_gap %>%\n  group_by(continent) %>%\n  summarise(n = n(),\n            n_countries = n_distinct(country))\n## # A tibble: 5 × 3\n##   continent     n n_countries\n##   <fct>     <int>       <int>\n## 1 Africa      624          52\n## 2 Americas    300          25\n## 3 Asia        396          33\n## 4 Europe      360          30\n## 5 Oceania      24           2"},{"path":"dplyr-single.html","id":"deskriptive-statistiken-mit-summarise","chapter":"Kapitel 7 Mehr zu dplyr","heading":"7.5.2 Deskriptive Statistiken mit summarise()","text":"Kombination mit summarise() können wir eine Vielzahl verschiedenen Funktionen verwenden. Einige davon berechnen klassische deskriptive Statistiken:allen betrachteten Fällen seien \\(x_1,\\dots,x_n\\) numerische Beobachtungen.mean() berechnet das arithmetische Mittel der Beobachtungen\n\\[\\overline x_n = \\frac{1}{n} \\sum_{=1}^n x_i\\,.\\]mean() berechnet das arithmetische Mittel der Beobachtungen\n\\[\\overline x_n = \\frac{1}{n} \\sum_{=1}^n x_i\\,.\\]median() berechnet den Median\n\\[x_{0.5} = \\begin{cases}\nx_{\\left(\\frac{n+1}{2}\\right)}, &  n\\ \\text{ungerade},\\\\\n\\frac{1}{2}\\left(x_{\\left(\\frac{n}{2}\\right)} + x_{\\left(\\frac{n}{2}+1\\right)}\\right), & n\\ \\text{gerade}\n\\end{cases}\\,.\\]median() berechnet den Median\n\\[x_{0.5} = \\begin{cases}\nx_{\\left(\\frac{n+1}{2}\\right)}, &  n\\ \\text{ungerade},\\\\\n\\frac{1}{2}\\left(x_{\\left(\\frac{n}{2}\\right)} + x_{\\left(\\frac{n}{2}+1\\right)}\\right), & n\\ \\text{gerade}\n\\end{cases}\\,.\\]var() berechnet die empirische Varianz\n\\[s_n^2 = \\frac{1}{n-1} \\sum_{=1}^n (x_i - \\overline x_n)^2\\,.\\]var() berechnet die empirische Varianz\n\\[s_n^2 = \\frac{1}{n-1} \\sum_{=1}^n (x_i - \\overline x_n)^2\\,.\\]sd() berechnet die empirische Standardabweichung\n\\[s_n = \\sqrt{s_n^2}\\,.\\]sd() berechnet die empirische Standardabweichung\n\\[s_n = \\sqrt{s_n^2}\\,.\\]IQR() berechnet den Interquartilsabstand\n\\[IQR = x_{0.75} - x_{0.25}\\,,\\]\nwobei \\(x_{0.25}\\) und \\(x_{0.75}\\) das empirische 0.25 bzw. 0.75 Quantil bezeichnen.IQR() berechnet den Interquartilsabstand\n\\[IQR = x_{0.75} - x_{0.25}\\,,\\]\nwobei \\(x_{0.25}\\) und \\(x_{0.75}\\) das empirische 0.25 bzw. 0.75 Quantil bezeichnen.min() berechnet das Minimum\n\\[x_{(1)} = \\min(x_1,\\dots,x_n)\\,.\\]min() berechnet das Minimum\n\\[x_{(1)} = \\min(x_1,\\dots,x_n)\\,.\\]und max() berechnet demnach das Maximum\n\\[x_{(n)} = \\max(x_1,\\dots,x_n)\\,.\\]und max() berechnet demnach das Maximum\n\\[x_{(n)} = \\max(x_1,\\dots,x_n)\\,.\\]Auch wenn dies statistisch gesehen unklug sein mag, lasst uns die durchschnittliche Lebenserwartung pro Kontinent berechnen.summarise_at() wendet die gleiche(n) Zusammenfassungs-Funktion(en) auf mehrere Variablen . Lasst uns die durchschnittliche Lebenserwartung sowie den Median und das Pro-Kopf-GDP nach Kontinenten pro Jahr berechnen… aber nur für 1952 und 2007.Im nächsten Schritt konzentrieren wir uns nur auf Asien. Wie hoch ist die minimale und maximale Lebenserwartung pro Jahr?Natürlich wäre es viel interessanter zu sehen, welches Land bzw. welche Länder diese extremen Beobachtungen beigetragen haben. Kommt das Minimum (Maximum) immer aus dem gleichen Land? Wir gehen dem Kürze mithilfe von Window Funktionen nach.","code":"\nmy_gap %>%\n  group_by(continent) %>%\n  summarise(avg_lifeExp = mean(lifeExp))\n## # A tibble: 5 × 2\n##   continent avg_lifeExp\n##   <fct>           <dbl>\n## 1 Africa           48.9\n## 2 Americas         64.7\n## 3 Asia             60.1\n## 4 Europe           71.9\n## 5 Oceania          74.3\nmy_gap %>%\n  filter(year %in% c(1952, 2007)) %>%\n  group_by(continent, year) %>%\n  summarise_at(vars(lifeExp, gdpPercap), list(mean, median))\n## # A tibble: 10 × 6\n## # Groups:   continent [5]\n##    continent  year lifeExp_fn1 gdpPercap_fn1 lifeExp_fn2 gdpPercap_fn2\n##    <fct>     <int>       <dbl>         <dbl>       <dbl>         <dbl>\n##  1 Africa     1952        39.1         1253.        38.8          987.\n##  2 Africa     2007        54.8         3089.        52.9         1452.\n##  3 Americas   1952        53.3         4079.        54.7         3048.\n##  4 Americas   2007        73.6        11003.        72.9         8948.\n##  5 Asia       1952        46.3         5195.        44.9         1207.\n##  6 Asia       2007        70.7        12473.        72.4         4471.\n##  7 Europe     1952        64.4         5661.        65.9         5142.\n##  8 Europe     2007        77.6        25054.        78.6        28054.\n##  9 Oceania    1952        69.3        10298.        69.3        10298.\n## 10 Oceania    2007        80.7        29810.        80.7        29810.\nmy_gap %>%\n  filter(continent == \"Asia\") %>%\n  group_by(year) %>%\n  summarise(min_lifeExp = min(lifeExp), max_lifeExp = max(lifeExp))\n## # A tibble: 12 × 3\n##     year min_lifeExp max_lifeExp\n##    <int>       <dbl>       <dbl>\n##  1  1952        28.8        65.4\n##  2  1957        30.3        67.8\n##  3  1962        32.0        69.4\n##  4  1967        34.0        71.4\n##  5  1972        36.1        73.4\n##  6  1977        31.2        75.4\n##  7  1982        39.9        77.1\n##  8  1987        40.8        78.7\n##  9  1992        41.7        79.4\n## 10  1997        41.8        80.7\n## 11  2002        42.1        82  \n## 12  2007        43.8        82.6"},{"path":"dplyr-single.html","id":"gruppierte-veränderungen","chapter":"Kapitel 7 Mehr zu dplyr","heading":"7.6 Gruppierte Veränderungen","text":"Manchmal möchte man die \\(n\\)-Zeilen für jede Gruppe nicht zu einer Zeile zusammenfassen. Stattdessen möchte man die Gruppen behalten, aber innerhalb dieser Gruppen rechnen.","code":""},{"path":"dplyr-single.html","id":"berechnungen-innerhalb-der-gruppen","chapter":"Kapitel 7 Mehr zu dplyr","heading":"7.6.1 Berechnungen innerhalb der Gruppen","text":"Lasst uns eine neue Variable definieren, die die gewonnenen (verlorenen) Lebenserwartungsjahre im Vergleich zu 1952 für jedes einzelne Land angibt. Wir gruppieren nach Ländern und verwenden mutate(), um eine neue Variable zu erstellen. Die Funktion first() extrahiert dabei den ersten Wert aus einem Vektor. Beachtet, dass first() mit dem Vektor der Lebenserwartungen jeder Ländergruppe arbeitet.Innerhalb eines Landes nehmen wir die Differenz zwischen der Lebenserwartung im Jahr \\(\\) und der Lebenserwartung im Jahr 1952. Daher sehen wir für 1952 immer Nullen und für die meisten Länder eine Folge von positiven und steigenden Zahlen.","code":"\nmy_gap %>% \n  group_by(country) %>% \n  select(country, year, lifeExp) %>% \n  mutate(lifeExp_gain = lifeExp - first(lifeExp)) %>% \n  filter(year < 1963)\n## # A tibble: 426 × 4\n## # Groups:   country [142]\n##    country      year lifeExp lifeExp_gain\n##    <fct>       <int>   <dbl>        <dbl>\n##  1 Afghanistan  1952    28.8         0   \n##  2 Afghanistan  1957    30.3         1.53\n##  3 Afghanistan  1962    32.0         3.20\n##  4 Albania      1952    55.2         0   \n##  5 Albania      1957    59.3         4.05\n##  6 Albania      1962    64.8         9.59\n##  7 Algeria      1952    43.1         0   \n##  8 Algeria      1957    45.7         2.61\n##  9 Algeria      1962    48.3         5.23\n## 10 Angola       1952    30.0         0   \n## # ℹ 416 more rows"},{"path":"dplyr-single.html","id":"window-functions","chapter":"Kapitel 7 Mehr zu dplyr","heading":"7.6.2 Window Funktionen","text":"Window Funktionen nehmen eine Eingabe der Länge \\(n\\) und berechnen eine Ausgabe derselben Länge. Diese Ausgabewerte hängen dabei von allen Eingabewerten ab. ist z.B. rank() eine Window Funktion, aber log() ist es nicht.Betrachten wir noch einmal die schlechtesten und besten Lebenserwartungen Asien im Laufe der Zeit, behalten aber Informationen darüber bei, welches Land diese Extremwerte beisteuert.Wir sehen, dass (min = Afghanistan, max = Japan) das häufigste Ergebnis ist, aber Kambodscha und Israel tauchen auch jeweils mindestens einmal als min bzw. max auf.Aber wäre es nicht schön eine Zeile pro Jahr zu haben?Zuerst sollten wir uns aber vielleicht nochmal fragen wie das eigentlich funktioniert hat? Dazu schauen wir uns die Beobachtungen aus Asien mal direkt .Jetzt wenden wir die Window Funktion min_rank() . Da asia nach Jahren gruppiert ist, operiert min_rank() innerhalb von Mini-Datensätzen. Auf die Variable lifeExp angewandt, liefert min_rank() den Rang der beobachteten Lebenserwartung jedes Landes.Bemerkung: Der min-Teil im Funktionsnamen min_rank() gibt nur , wie im Fall von gleichen Beobachtungswerten die Ränge bestimmt werden.Neben dem Minimum gibt es aber auch noch eine Reihe weiterer Alternativen, wie z.B. den DurchschnittIm nächsten Schritt schauen wir uns die Ränge der Lebenserwartung innerhalb eines Jahres mal explizit für ein paar Länder (Afghanistan, Japan und Thailand) - sowohl der (Standard-) aufsteigenden als auch der absteigenden Reihenfolge.Afghanistan neigt dazu, 1 der le_rank-Variablen zu haben, Japan neigt dazu, 1 der le_desc_rank-Variablen zu haben und andere Länder, wie Thailand, zeigen deutlich weniger extreme Ränge.Damit sollte der ursprüngliche filter() Befehlauch klar sein.Diese beiden Sätze von Rängen werden --fly, innerhalb der Jahresgruppe, gebildet, und filter() behält alle Zeilen, die einen Rangwert kleiner als 2 haben. Da wir dies für aufsteigende und absteigende Ränge machen, erhalten wir sowohl die Beobachtungen mit dem minimalen als auch dem maximalen Rang.Wenn wir nur das Minimum ODER das Maximum gewollt hätten, hätte auch ein alternativer Ansatz mit slice_min() bzw. slice_max() funktioniert.","code":"\nmy_gap %>%\n  filter(continent == \"Asia\") %>%\n  select(year, country, lifeExp) %>%\n  group_by(year) %>%\n  filter(min_rank(desc(lifeExp)) < 2 | min_rank(lifeExp) < 2) %>% \n  arrange(year) %>%\n  print(n = Inf)  # erzwingt eine Ausgabe aller Zeilen\n## # A tibble: 24 × 3\n## # Groups:   year [12]\n##     year country     lifeExp\n##    <int> <fct>         <dbl>\n##  1  1952 Afghanistan    28.8\n##  2  1952 Israel         65.4\n##  3  1957 Afghanistan    30.3\n##  4  1957 Israel         67.8\n##  5  1962 Afghanistan    32.0\n##  6  1962 Israel         69.4\n##  7  1967 Afghanistan    34.0\n##  8  1967 Japan          71.4\n##  9  1972 Afghanistan    36.1\n## 10  1972 Japan          73.4\n## 11  1977 Cambodia       31.2\n## 12  1977 Japan          75.4\n## 13  1982 Afghanistan    39.9\n## 14  1982 Japan          77.1\n## 15  1987 Afghanistan    40.8\n## 16  1987 Japan          78.7\n## 17  1992 Afghanistan    41.7\n## 18  1992 Japan          79.4\n## 19  1997 Afghanistan    41.8\n## 20  1997 Japan          80.7\n## 21  2002 Afghanistan    42.1\n## 22  2002 Japan          82  \n## 23  2007 Afghanistan    43.8\n## 24  2007 Japan          82.6\n(asia <- my_gap %>%\n  filter(continent == \"Asia\") %>%\n  select(year, country, lifeExp) %>%\n  group_by(year))\n## # A tibble: 396 × 3\n## # Groups:   year [12]\n##     year country     lifeExp\n##    <int> <fct>         <dbl>\n##  1  1952 Afghanistan    28.8\n##  2  1957 Afghanistan    30.3\n##  3  1962 Afghanistan    32.0\n##  4  1967 Afghanistan    34.0\n##  5  1972 Afghanistan    36.1\n##  6  1977 Afghanistan    38.4\n##  7  1982 Afghanistan    39.9\n##  8  1987 Afghanistan    40.8\n##  9  1992 Afghanistan    41.7\n## 10  1997 Afghanistan    41.8\n## # ℹ 386 more rows\nrank(c(1,3,3,5), ties.method = \"min\")\n## [1] 1 2 2 4\nrank(c(1,3,3,5))\n## [1] 1.0 2.5 2.5 4.0\nasia %>%\n  mutate(le_rank = min_rank(lifeExp),\n         le_desc_rank = min_rank(desc(lifeExp))) %>% \n  filter(country %in% c(\"Afghanistan\", \"Japan\", \"Thailand\"), year > 1995)\n## # A tibble: 9 × 5\n## # Groups:   year [3]\n##    year country     lifeExp le_rank le_desc_rank\n##   <int> <fct>         <dbl>   <int>        <int>\n## 1  1997 Afghanistan    41.8       1           33\n## 2  2002 Afghanistan    42.1       1           33\n## 3  2007 Afghanistan    43.8       1           33\n## 4  1997 Japan          80.7      33            1\n## 5  2002 Japan          82        33            1\n## 6  2007 Japan          82.6      33            1\n## 7  1997 Thailand       67.5      12           22\n## 8  2002 Thailand       68.6      12           22\n## 9  2007 Thailand       70.6      12           22\nfilter(min_rank(desc(lifeExp)) < 2 | min_rank(lifeExp) < 2)\nmy_gap %>%\n  filter(continent == \"Asia\") %>%\n  select(year, country, lifeExp) %>%\n  arrange(year) %>%\n  group_by(year) %>%\n# slice_min(lifeExp, n = 1)        ## für das Minimum\n  slice_max(lifeExp, n = 1) ## bzw. das Maximum\n## # A tibble: 12 × 3\n## # Groups:   year [12]\n##     year country lifeExp\n##    <int> <fct>     <dbl>\n##  1  1952 Israel     65.4\n##  2  1957 Israel     67.8\n##  3  1962 Israel     69.4\n##  4  1967 Japan      71.4\n##  5  1972 Japan      73.4\n##  6  1977 Japan      75.4\n##  7  1982 Japan      77.1\n##  8  1987 Japan      78.7\n##  9  1992 Japan      79.4\n## 10  1997 Japan      80.7\n## 11  2002 Japan      82  \n## 12  2007 Japan      82.6"},{"path":"dplyr-single.html","id":"großes-finale","chapter":"Kapitel 7 Mehr zu dplyr","heading":"7.7 Großes Finale","text":"Beantworten wir also die Frage:“welchem Land ist die Lebenserwartung innerhalb von 5 Jahren stärksten gesunken?”Die Beobachtungsfrequenz im Datensatz ist fünf Jahre, d.h. wir haben Daten für 1952, 1957 usw. Dies bedeutet also, dass die Veränderungen der Lebenserwartung zwischen benachbarten Zeitpunkten betrachtet werden müssen. Dazu verwenden wir die lag() Funktion. Diese veschiebt die Einträge des Inputvektors um ein Lag k.Wir können aber noch mehr erreichen. Lasst uns die Frage pro Kontinenten beantworten.Denkt ruhig eine Weile über das Ergebnis nach. Hier sieht man trockenen Statistiken über die durchschnittliche Lebenserwartung, wie Völkermord aussieht.Um den Code besser zu verstehen, unterteilt ihn, beginnend von oben, Stücke und überprüft die einzelnen Zwischenergebnisse. wurde der Code auch geschrieben/entwickelt, mit Fehlern und Verfeinerungen auf dem Weg.","code":"\nmy_gap %>%\n  group_by(continent, country) %>%\n  # für jedes Land werden die Unterschiede berechnet\n  mutate(delta = lifeExp - lag(lifeExp, n = 1)) %>% \n  ## für jedes Land wird nur der kleinste Wert behalten\n  summarise(worst_delta = min(delta, na.rm = TRUE)) %>% \n  ## nun wird noch pro Kontinent, die Zeile mit dem kleinsten Wert ausgegeben\n  slice_min(worst_delta, n = 1) %>% \n  arrange(worst_delta)\n## `summarise()` has grouped output by 'continent'. You can override using the\n## `.groups` argument.\n## # A tibble: 5 × 3\n## # Groups:   continent [5]\n##   continent country     worst_delta\n##   <fct>     <fct>             <dbl>\n## 1 Africa    Rwanda          -20.4  \n## 2 Asia      Cambodia         -9.10 \n## 3 Americas  El Salvador      -1.51 \n## 4 Europe    Montenegro       -1.46 \n## 5 Oceania   Australia         0.170"},{"path":"dplyr-single.html","id":"literatur","chapter":"Kapitel 7 Mehr zu dplyr","heading":"7.8 Literatur","text":"dieser Stelle sei noch auf die dplyr Webseite und das Kapitel\nData transformation R Data Science (Wickham Grolemund 2016) verwiesen.","code":""},{"path":"import-export.html","id":"import-export","chapter":"Kapitel 8 Daten I/O","heading":"Kapitel 8 Daten I/O","text":"","code":""},{"path":"import-export.html","id":"überblick","chapter":"Kapitel 8 Daten I/O","heading":"8.1 Überblick","text":"Im letzten Abschnitt haben wir die Gapminder-Daten als tibble aus dem gapminder Paket geladen. Dabei haben wir dann weder Daten, noch abgeleitete Ergebnisse, explizit eine Datei geschrieben. Im wirklichen Leben werdet ihr aber ständig Daten, die Tabellenform vorliegen, R ein- und auslesen. Manchmal muss das sogar für Daten geschehen, die nicht Tabellenform vorliegen.Wie macht man das? Worauf muss man aufpassen?","code":""},{"path":"import-export.html","id":"daten-import","chapter":"Kapitel 8 Daten I/O","heading":"8.1.1 Daten Import","text":"Für das Importieren von Daten gibt es im Allgemeinen zwei Szenarien:“Überrasche mich!” Diese Haltung müsst ihr einnehmen, wenn ihr einen Datensatz erhaltet und zum ersten Mal versucht diesen einzulesen. Man muss froh sein, wenn man die Daten ohne Fehlermeldung importieren kann. Im nächsten Schritt schaut man sich das Ergebnis und entdeckt vermutlich Fehler den Daten und/oder beim Import. Anschließend behebt man die Fehler und beginnt nochmal von vorne.“Überrasche mich!” Diese Haltung müsst ihr einnehmen, wenn ihr einen Datensatz erhaltet und zum ersten Mal versucht diesen einzulesen. Man muss froh sein, wenn man die Daten ohne Fehlermeldung importieren kann. Im nächsten Schritt schaut man sich das Ergebnis und entdeckt vermutlich Fehler den Daten und/oder beim Import. Anschließend behebt man die Fehler und beginnt nochmal von vorne.“Ein weiterer Tag im Paradies.” Das wird vermutlich euer Gefühl sein, wenn ihr versucht einen aufgeräumten Datensatz einzulesen (den jemand vorher einem oder mehreren “Reinigungsskripten” aufgeräumt hat). Beim Einlesen solcher Daten sollte es keine Überraschungen geben.“Ein weiterer Tag im Paradies.” Das wird vermutlich euer Gefühl sein, wenn ihr versucht einen aufgeräumten Datensatz einzulesen (den jemand vorher einem oder mehreren “Reinigungsskripten” aufgeräumt hat). Beim Einlesen solcher Daten sollte es keine Überraschungen geben.Im zweiten Fall, und im weiteren Verlauf des ersten Falles, lernt ihr tatsächlich eine Menge darüber, wie die Daten strukturiert sind/sein sollten.Ein wichtiger Import-Ratschlag: Verwende die Argumente der Importfunktion, um weit wie möglich und schnell wie möglich zu kommen. Macht man dies nicht, sind oft nach dem Einlesen der Daten noch eine Reihe von weiteren Schritten nötig, bevor man mit der eigentlichen Analyse beginnen kann. Daher lest die Hilfe zu den Importfunktionen und nutzt die Argumente maximal aus, um den Import zu steuern.","code":""},{"path":"import-export.html","id":"daten-export","chapter":"Kapitel 8 Daten I/O","heading":"8.1.2 Daten Export","text":"Es wird viele Gelegenheiten geben, bei denen ihr Daten aus R exportieren wollt. Zwei wichtige Beispiele:einen gesäuberten Datensatz, der bereit ist analysiert zu werdeneinen gesäuberten Datensatz, der bereit ist analysiert zu werdenein numerisches Ergebnis aus einer Datenaggregation oder Modellierung oder einer statistischen Schlussfolgerungein numerisches Ergebnis aus einer Datenaggregation oder Modellierung oder einer statistischen SchlussfolgerungErster Tipp: Der Output von heute ist der Input von morgen. Denkt die Schmerzen zurück, die ihr selbst beim Import von fremden Daten erlitten habt, und fügt euch nicht selbst solche Schmerzen zu!Zweiter Tipp: Seid nicht zu clever. Eine einfache Textdatei, die von einem Menschen einem Texteditor lesbar ist, sollte euer Standard sein, bis es einen guten Grund dafür gibt, dass dies nicht ausreichend ist. Das Lesen und Schreiben exotische Formate wird das Erste sein, möglicherweise Zukunft oder auf einem anderen Computer nicht mehr funktioniert. Zudem schafft es Barrieren für jeden, der ein anderes Toolkit hat als ihr.Wie passt das zu unserer Betonung der dynamischen Berichterstattung über R Markdown? Es gibt für alles eine Zeit und einen Ort. Es gibt Projekte und Dokumente, bei denen ihr euch intensiv mit knitr und rmarkdown beschäftigen könnt/wollt/müsst. Aber es gibt viele gute Gründe, warum (Teile) einer Analyse nicht (nur) einen dynamischen Bericht eingebettet werden sollten. Vielleicht wollt ihr Daten bereinigen, um einen Datensatz für eine nachfolgende Analyse zu erzeugen. Vielleicht leistet ihr einen kleinen, aber entscheidenden Beitrag zu einem gigantischen Multi-Autoren-Papier, usw. ….Denkt zudem daran, dass es natürlich auch noch andere Werkzeuge und Arbeitsabläufe gibt, um etwas reproduzierbar zu machen: z.B. make.","code":""},{"path":"import-export.html","id":"readr","chapter":"Kapitel 8 Daten I/O","heading":"8.2 readr","text":"Zur Einlesen und Ausgeben von Datensätzen verwenden wir das readr Paket, welches Alternativen zu den Standardfunktionen read.table() und write.table() bietet. readr ist Teil des tidyverse und daher führen wir standardmäßig einfach wiederaus.Einlesen der Gapminder DatenDie Gapminder Daten könnten wir natürlich wie zuvor über das Laden des gapminder Pakets verfügbar machen. Da es diesem Abschnitt aber um das Einlesen von Daten geht, versuchen wir die Daten als .tsv Datei (Tab getrennte Werte - sind die Daten im Paket gespeichert) einzulesen. Aber dies bedeutet natürlich, dass wir die entsprechende .tsv Datei erst mal finden müssen. Dabei hilft uns glücklicherweise das fs Paket.Nachdem wir jetzt den Speicherort der Datei kennen, können wir versuchen sie einzulesen.","code":"\nlibrary(tidyverse)\n## ── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n## ✔ dplyr     1.1.4     ✔ readr     2.1.5\n## ✔ forcats   1.0.0     ✔ stringr   1.5.1\n## ✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n## ✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n## ✔ purrr     1.0.2     \n## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n## ✖ dplyr::filter() masks stats::filter()\n## ✖ dplyr::lag()    masks stats::lag()\n## ℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\nlibrary(fs)\n(gap_tsv <- path_package(\"gapminder\", \"extdata\", \"gapminder.tsv\"))\n## /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/library/gapminder/extdata/gapminder.tsv"},{"path":"import-export.html","id":"einlesen-von-daten-in-tabellenform","chapter":"Kapitel 8 Daten I/O","heading":"8.3 Einlesen von Daten in Tabellenform","text":"Die Haupt-Funktion zum Einlesen von Daten readr ist read_delim(). Hier verwenden wir eine Variante, read_tsv(), für Tab getrennte Daten:Wie wir sehen, wurde standardmäßig der komplette Datensatz eingelesen. Sind aber nur Teile eines Datensatzes relevant für die angestrebte Analyse, besteht auch keine Notwendigkeit den kompletten Datensatz zu laden. solchen Fällen kann man mit dem col_types Argument arbeitenZur Auswahl eines Teils der Variablen haben wir cols_only() verwendet. Diese Funktion erwartet bei der Auswahl der Variablen die Definition des Typs. diesem Beispiel haben wir continten (anders als im Standardfall) zu einer Faktorvariable transformiert. Dadurch enthält die Variable zusätzlich die Information über die verschiedenen Ausprägungen der VariableÜber den Tabulator Spalten einer Datentabelle zu trennen, ist natürlich nur eine Möglichkeit von vielen. Weitere Alternativen sind:Komma: read_csv()Komma: read_csv()Strichpunkt: read_csv2()Strichpunkt: read_csv2()Leerzeichen: read_table()Leerzeichen: read_table()……Für volle Flexibilität bei der Angabe des Trennzeichens kann aber jederzeit direkt read_delim() verwendet werden.Der auffälligste Unterschied zwischen den readr-Funktionen und der Standardfunktion read.table()ist, dass readr immer ein Tibble erzeugt statt eines Data Frames. Da wir Tibbles bevorzugen ist unserFazit: Benutzt readr::read_delim() und “Freunde”.Die Gapminder-Daten sind zu sauber und einfach, um die großartigen Funktionen von readr zur Geltung zu bringen. Ein Blick Introduction readr zeigt aber noch viele weitere Anpassungsmöglichkeiten der readr Funktionen.","code":"\ngapminder <- read_tsv(gap_tsv)\n## Rows: 1704 Columns: 6\n## ── Column specification ────────────────────────────────────────────────────────\n## Delimiter: \"\\t\"\n## chr (2): country, continent\n## dbl (4): year, lifeExp, pop, gdpPercap\n## \n## ℹ Use `spec()` to retrieve the full column specification for this data.\n## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\ngapminder\n## # A tibble: 1,704 × 6\n##    country     continent  year lifeExp      pop gdpPercap\n##    <chr>       <chr>     <dbl>   <dbl>    <dbl>     <dbl>\n##  1 Afghanistan Asia       1952    28.8  8425333      779.\n##  2 Afghanistan Asia       1957    30.3  9240934      821.\n##  3 Afghanistan Asia       1962    32.0 10267083      853.\n##  4 Afghanistan Asia       1967    34.0 11537966      836.\n##  5 Afghanistan Asia       1972    36.1 13079460      740.\n##  6 Afghanistan Asia       1977    38.4 14880372      786.\n##  7 Afghanistan Asia       1982    39.9 12881816      978.\n##  8 Afghanistan Asia       1987    40.8 13867957      852.\n##  9 Afghanistan Asia       1992    41.7 16317921      649.\n## 10 Afghanistan Asia       1997    41.8 22227415      635.\n## # ℹ 1,694 more rows\ngapminder_short <- read_tsv(gap_tsv, col_types = cols_only(\n  country = col_character(),\n  continent = col_factor(),\n  year = col_double(),\n  lifeExp = col_double()\n))\ngapminder_short\n## # A tibble: 1,704 × 4\n##    country     continent  year lifeExp\n##    <chr>       <fct>     <dbl>   <dbl>\n##  1 Afghanistan Asia       1952    28.8\n##  2 Afghanistan Asia       1957    30.3\n##  3 Afghanistan Asia       1962    32.0\n##  4 Afghanistan Asia       1967    34.0\n##  5 Afghanistan Asia       1972    36.1\n##  6 Afghanistan Asia       1977    38.4\n##  7 Afghanistan Asia       1982    39.9\n##  8 Afghanistan Asia       1987    40.8\n##  9 Afghanistan Asia       1992    41.7\n## 10 Afghanistan Asia       1997    41.8\n## # ℹ 1,694 more rows\nlevels(gapminder_short$continent)\n## [1] \"Asia\"     \"Europe\"   \"Africa\"   \"Americas\" \"Oceania\""},{"path":"import-export.html","id":"daten-exportieren","chapter":"Kapitel 8 Daten I/O","heading":"8.4 Daten exportieren","text":"Bevor wir etwas exportieren können, müssen wir natürlich (sicher nicht richtig ist - niemand zwingt uns dazu 😉) etwas berechnen, das es wert ist, exportiert zu werden. Lasst uns daher eine Zusammenfassung der maximalen Lebenserwartung auf Länderebene erstellen.Das Objekt gap_life_exp betrachten wir nun als Zwischenergebnis, das wir für die Zukunft und für nachgelagerte Analysen oder Visualisierungen speichern wollen.Die Haupt-Exportfunktion readr ist write_delim(). Für verschiedene Dateiformate gibt es auch hier wieder verschiedene Komfortfunktionen. Mithilfe von write_csv() können wir den Inhalt von gap_life_exp einer kommagetrennten Datei abspeichern.Schauen wir uns die ersten paar Zeilen von gap_life_exp.csv . Dazu können wir entweder die Datei öffnen oder z.B. im Terminal head verwendenDas sieht recht ordentlich aus, obwohl es keine sichtbare Ausrichtung oder Trennung Spalten gibt. Hätten wir die Basisfunktion read.csv() benutzt, würden wir Zeilennamen und viele Anführungszeichen sehen, es sei denn, wir hätten diese Features explizit abgeschaltet. Das schönere Standardverhalten ist daher der Hauptgrund, warum wir readr::write_csv() gegenüber write.csv() bevorzugen.Bemerkung: Es ist auch nicht wirklich fair, sich über den Mangel sichtbarer Ausrichtung zu beklagen. Schließlich erzeugen wir Dateien, die der Computer lesen soll. Falls ihr aber wirklich der Datei “herumstöbern” wollt, benutzt View() RStudio. Oder öffnet die Datei mit einem Spreadsheet Programm (!). Aber erliegt NIE der Versuchung, dort Datenmanipulationen vorzunehmen … kehrt zurück zu R und schreibt dort die entsprechenden Befehle, die ihr die nächsten 15 Mal (oder oft wie nötig) ausführen könnt, wenn ihr diesen Datensatz (oder Datensätze derselben Form) importieren/bereinigen/aggregieren/exportieren wollt.","code":"\ngap_life_exp <- gapminder %>%\n  group_by(country, continent) %>% \n  summarise(life_exp = max(lifeExp)) %>% \n  ungroup()\n## `summarise()` has grouped output by 'country'. You can override using the\n## `.groups` argument.\ngap_life_exp\n## # A tibble: 142 × 3\n##    country     continent life_exp\n##    <chr>       <chr>        <dbl>\n##  1 Afghanistan Asia          43.8\n##  2 Albania     Europe        76.4\n##  3 Algeria     Africa        72.3\n##  4 Angola      Africa        42.7\n##  5 Argentina   Americas      75.3\n##  6 Australia   Oceania       81.2\n##  7 Austria     Europe        79.8\n##  8 Bahrain     Asia          75.6\n##  9 Bangladesh  Asia          64.1\n## 10 Belgium     Europe        79.4\n## # ℹ 132 more rows\nwrite_csv(gap_life_exp, \"data/gap_life_exp.csv\")"},{"path":"import-export.html","id":"daten-über-eine-api","chapter":"Kapitel 8 Daten I/O","heading":"8.5 Daten über eine API","text":"APIs (Application Programming Interface) sind eine sehr nützliche Methode, um auf interessante Daten zuzugreifen, die online zur Verfügung gestellt werden.Anstatt einen Datensatz herunterladen zu müssen, ermöglichen APIs Daten direkt von bestimmten Webseiten über eine Schnittstelle anzufordern. Viele große Webseiten wie Twitter und Facebook ermöglichen über APIs den Zugriff auf Teile ihrer Daten.Wir werden die Grundlagen des Zugriffs auf eine API besprechen. Dazu benötigt ihr aber kein Vorwissen bzgl. APIs.","code":""},{"path":"import-export.html","id":"einführung","chapter":"Kapitel 8 Daten I/O","heading":"8.5.1 Einführung","text":"API ist ein allgemeiner Begriff für den Ort, dem ein Computerprogramm mit einem anderen oder mit sich selbst interagiert. Wir sprechen über Web-APIs, bei denen zwei verschiedene Computer - ein Client und ein Server - miteinander interagieren, um Daten anzufordern bzw. bereitzustellen.APIs bieten eine ausgefeilte Möglichkeit Daten von einer Webseite anzufordern. Wenn eine Webseite wie Twitter eine API einrichtet, richten sie im Wesentlichen einen Computer ein, der auf Datenanfragen wartet.Sobald dieser Computer eine Datenabfrage empfängt, verarbeitet er die Daten selbst und sendet sie den Computer, der sie angefordert hat. Unsere Aufgabe wird es sein R Code zu schreiben, der die Anfrage erstellt und dem Computer, auf dem die API läuft, mitteilt, wir benötigen. Dieser Computer liest dann unseren Code, verarbeitet die Anfrage und gibt schön formatierte Daten zurück, die mithilfe existierender R Pakete verarbeitet werden können.","code":""},{"path":"import-export.html","id":"erstellen-von-api-abfragen-in-r","chapter":"Kapitel 8 Daten I/O","heading":"8.5.2 Erstellen von API-Abfragen in R","text":"Um mit APIs R zu arbeiten, müssen wir ein paar neue Pakete laden (und vorher natürlich installieren). Konkret werden wir mit den Paketen httr und jsonlite arbeiten. Sie spielen bei der Einbindung der APIs unterschiedliche Rollen, aber beide sind unverzichtbar.Vermutlich habt ihr die beiden Pakete bisher nicht installiert. Daher starten wir mit dem Installieren dieser beiden Paketeund laden sie anschließend","code":"\ninstall.packages(c(\"httr\", \"jsonlite\"))\nlibrary(httr)\nlibrary(jsonlite)\n## Warning: package 'jsonlite' was built under R version 4.4.1\n## \n## Attaching package: 'jsonlite'\n## The following object is masked from 'package:purrr':\n## \n##     flatten"},{"path":"import-export.html","id":"unsere-erste-api-anfrage-stellen","chapter":"Kapitel 8 Daten I/O","heading":"8.5.3 Unsere erste API-Anfrage stellen","text":"Der erste Schritt, um Daten von einer API zu erhalten, ist die eigentliche Anfrage R. Diese Anfrage wird den Server geschickt, der über die API verfügt, und wenn alles reibungslos verläuft, wird er uns eine Antwort zurücksenden.Es gibt verschiedene Arten von Anfragen, die man einen API-Server stellen kann. Diese verschiedenen Typen von Anfragen entsprechen verschiedenen Aktionen, die der Server ausführen soll.Für unsere Zwecke fragen wir lediglich nach Daten, einer GET-Anfrage entspricht. Andere Arten von Anfragen sind z.B. POST (post file) und PUT (send put request), aber diese sind für uns nicht von Interesse und werden wir daher nicht weiter besprechen.Um eine GET-Anfrage zu erstellen, müssen wir die GET() Funktion aus dem httr Paket verwenden. Die GET() Funktion benötigt als Input eine URL, die die Adresse des Servers angibt, den die Anforderung gesendet werden soll.Als Beispiel werden wir mit der Open Notify API arbeiten, die Daten zu verschiedenen NASA-Projekten enthält. Mithilfe der Open Notify API können wir uns über den Standort der Internationalen Raumstation informieren und erfahren, wie viele Personen sich derzeit im Weltraum aufhalten.Wir beginnen damit, dass wir unsere Anfrage mit der GET() Funktion stellen und die URL der API angeben:Die Ausgabe der Funktion GET() ist eine Liste, die alle Informationen enthält, die vom API-Server zurückgegeben werden.","code":"\njdata <- GET(\"http://api.open-notify.org/astros.json\")"},{"path":"import-export.html","id":"get-ausgabe","chapter":"Kapitel 8 Daten I/O","heading":"8.5.4 GET() Ausgabe","text":"Schauen wir uns , wie die Variable jdata der R-Konsole aussieht:Als erstes fällt auf, dass die URL enthalten ist, die die GET-Anfrage gesendet wurde. Außerdem erkennen wir das Datum und die Uhrzeit, zu der die Anfrage gestellt wurde, sowie die Größe der Antwort.Die Information Content-Type gibt uns eine Vorstellung davon, welche Form die Daten haben. Diese spezielle Antwort besagt, dass die Daten ein JSON-Format annehmen, womit auch klar ist warum wir das Paket jsonlite geladen haben.Der Status verdient eine besondere Aufmerksamkeit. Status bezieht sich auf den Erfolg oder Misserfolg der API-Anfrage, und er wird Form einer Zahl angegeben. Die zurückgegebene Nummer gibt Auskunft darüber, ob die Anfrage erfolgreich war oder nicht. Dort können auch Gründe für einen möglichen Misserfolg enthalten sein.Die Zahl 200 ist das, wir sehen wollen. Sie entspricht einem erfolgreichen Antrag, und das ist es, wir hier haben. Eine Übersicht über weitere Status Codes findet man z.B. auf dieser Webseite.","code":"\njdata\n## Response [http://api.open-notify.org/astros.json]\n##   Date: 2024-10-16 21:45\n##   Status: 200\n##   Content-Type: application/json\n##   Size: 587 B"},{"path":"import-export.html","id":"handling-json-data","chapter":"Kapitel 8 Daten I/O","heading":"8.5.5 Handling JSON Data","text":"JSON steht für JavaScript Object Notation. Während JavaScript eine weitere Programmiersprache ist, liegt unser Schwerpunkt bei JSON auf seiner Struktur. JSON ist nützlich, weil es von einem Computer leicht lesbar ist, und aus diesem Grund ist es zur primären Art und Weise geworden, wie Daten über APIs transportiert werden. Die meisten APIs senden ihre Antworten im JSON-Format.JSON ist als eine Reihe von Schlüssel-Werte-Paaren formatiert, wobei ein bestimmtes Wort (“Schlüssel”) mit einem bestimmten Wert assoziiert ist. Ein Beispiel für diese Schlüssel-Wert-Struktur ist unten dargestellt:ihrem aktuellen Zustand sind die Daten der Variablen jdata nicht verwendbar. Die Daten sind als Unicode-Rohdaten jdata enthalten, und müssen das JSON-Format konvertiert werden.Dazu müssen wir zunächst den rohen Unicode character Daten konvertieren, die dem oben gezeigten JSON-Format ähneln. Die Funktion rawToChar() führt genau diese Aufgabe aus:Die resultierende Zeichenfolge sieht zwar recht unordentlich aus, aber es liegt wirklich die JSON-Struktur vor.Ausgehend von diesem character Vektor können wir nun mit fromJSON(), aus dem jsonlite Paket, alles ein Listenformat transformieren.Die fromJSON() Funktion benötigt einen character Vektor, der die JSON-Struktur enthält, die wir aus der Ausgabe von rawToChar() erhalten haben. Wenn wir also diese beiden Funktionen nacheinander anwenden, erhalten wir die gewünschten Daten einem Format, das wir R leicht bearbeiten können.Die Liste data hat drei Elemente. Uns interessiert erster Linie das Data Frame people.Also, da haben wir unsere Antwort: Zum Zeitpunkt des letzten Updates Oct 16, 2024 von R4ews befanden sich 12 Personen im Weltraum. Aber wenn ihr den Code zu einem späteren Zeitpunkt ausprobiert, könnten es auch schon wieder andere Namen und eine andere Anzahl sein. Das ist einer der Vorteile von APIs - im Gegensatz zu Datensätzen, die man im Spreadsheet Format herunterladen kann, werden sie der Regel Echtzeit oder nahezu Echtzeit aktualisiert. APIs bieten somit die Möglichkeit leicht auf sehr aktuelle Daten zuzugreifen.diesem Beispiel haben wir einen sehr unkomplizierten API-Workflow durchlaufen. Die meisten APIs fordern, dass man demselben allgemeinen Muster folgt, aber dabei können die jeweilgen Aufrufe/Befehle durchaus deutlich komplexer sein.unserem Beispiel war es ausreichen nur die URL anzugeben. Aber einige APIs verlangen mehr Informationen vom Benutzer. Darauf gehen wir aber erstmal nicht weiter ein. Stattdessen fragen wir noch nach dem Ort der ISS im Moment der AbfrageDiese API gibt uns die Zeit Form von Unixzeit zurück. Unixzeit ist die Zeitspanne, die seit dem 1. Januar 1970 vergangen ist. Mithilfe der Funktion as_datetime() aus dem lubridate Paket können wir die Unixzeit aber leicht umrechnenDamit wollen wir den Abschnitt zu APIs beenden. Macht euch bewusst, dass wir hier wirklich nur die Basics Bezug auf APIs eingeführt haben. Aber hoffentlich hat euch diese Einführung trotzdem ausreichend Vertrauen gegeben, sich mit einigen komplexeren und leistungsfähigeren APIs auseinanderzusetzen.","code":"{\n    “name”: “Jane Doe”,\n    “number_of_skills”: 2\n}\nrawToChar(jdata$content)\n## [1] \"{\\\"people\\\": [{\\\"craft\\\": \\\"ISS\\\", \\\"name\\\": \\\"Oleg Kononenko\\\"}, {\\\"craft\\\": \\\"ISS\\\", \\\"name\\\": \\\"Nikolai Chub\\\"}, {\\\"craft\\\": \\\"ISS\\\", \\\"name\\\": \\\"Tracy Caldwell Dyson\\\"}, {\\\"craft\\\": \\\"ISS\\\", \\\"name\\\": \\\"Matthew Dominick\\\"}, {\\\"craft\\\": \\\"ISS\\\", \\\"name\\\": \\\"Michael Barratt\\\"}, {\\\"craft\\\": \\\"ISS\\\", \\\"name\\\": \\\"Jeanette Epps\\\"}, {\\\"craft\\\": \\\"ISS\\\", \\\"name\\\": \\\"Alexander Grebenkin\\\"}, {\\\"craft\\\": \\\"ISS\\\", \\\"name\\\": \\\"Butch Wilmore\\\"}, {\\\"craft\\\": \\\"ISS\\\", \\\"name\\\": \\\"Sunita Williams\\\"}, {\\\"craft\\\": \\\"Tiangong\\\", \\\"name\\\": \\\"Li Guangsu\\\"}, {\\\"craft\\\": \\\"Tiangong\\\", \\\"name\\\": \\\"Li Cong\\\"}, {\\\"craft\\\": \\\"Tiangong\\\", \\\"name\\\": \\\"Ye Guangfu\\\"}], \\\"number\\\": 12, \\\"message\\\": \\\"success\\\"}\"\ndata <-  fromJSON(rawToChar(jdata$content))\nglimpse(data)\n## List of 3\n##  $ people :'data.frame': 12 obs. of  2 variables:\n##   ..$ craft: chr [1:12] \"ISS\" \"ISS\" \"ISS\" \"ISS\" ...\n##   ..$ name : chr [1:12] \"Oleg Kononenko\" \"Nikolai Chub\" \"Tracy Caldwell Dyson\"..\n##  $ number : int 12\n##  $ message: chr \"success\"\ndata$people\n##       craft                 name\n## 1       ISS       Oleg Kononenko\n## 2       ISS         Nikolai Chub\n## 3       ISS Tracy Caldwell Dyson\n## 4       ISS     Matthew Dominick\n## 5       ISS      Michael Barratt\n## 6       ISS        Jeanette Epps\n## 7       ISS  Alexander Grebenkin\n## 8       ISS        Butch Wilmore\n## 9       ISS      Sunita Williams\n## 10 Tiangong           Li Guangsu\n## 11 Tiangong              Li Cong\n## 12 Tiangong           Ye Guangfu\njdata <-  GET(\"http://api.open-notify.org/iss-now.json\",)\ndata <- fromJSON(rawToChar(jdata$content))\ndata$iss_position\n## $latitude\n## [1] \"39.2660\"\n## \n## $longitude\n## [1] \"-140.0933\"\ndata$timestamp\n## [1] 1729115122\nlubridate::as_datetime(data$timestamp)\n## [1] \"2024-10-16 21:45:22 UTC\""},{"path":"import-export.html","id":"weiteres-material","chapter":"Kapitel 8 Daten I/O","heading":"8.6 Weiteres Material","text":"Wer noch mehr zum Thema Daten Import lesen , der soll einen Blick das Kapitel Data import im Buch R Data Science von Hadley Wickham und Garrett Grolemund (2016) werfen.","code":""},{"path":"tidy.html","id":"tidy","chapter":"Kapitel 9 tidy was?","heading":"Kapitel 9 tidy was?","text":"Idealerweise liegt ein Datensatz vor, dass er gut von einem Computer gelesen werden kann. der Regel sind die Datensätze, mit denen wir uns beschäftigen, ja umfangreich, d.h. der Mensch den Datensatz gar nicht (ein-)lesen. Trotzdem sind Datensätze oft anders angelegt (der Mensch, und nicht der Computer 💻, trifft die Entscheidung über das Layout).Der Computer kann einen Datensatz gut verarbeiten, wenn wir den Datensatz als tidy bezeichnen können. Hauptmerkmale von einem tidy Datensatz sind:jede Spalte ist eine Variablejede Zeile ist eine BeobachtungLiegen untidy Daten vor, verlängert sich (fast) immer die Zeit bis man mit den interessanten Schritten, z.B. Erstellen einer Grafik, starten kann. Daher lohnt es sich immer mal inne zu halten um zu überlegen, ob die Daten tidy sind. Unordnung im Datensatz ist eine häufige, aber oft übersehene, Ursache für unnötige Qualen bei der Datenanalyse und -visualisierung.","code":""},{"path":"tidy.html","id":"lord-of-the-rings","chapter":"Kapitel 9 tidy was?","heading":"9.1 Lord of the Rings","text":"Von Jenny Byran (Autorin von STAT 545) haben wir folgenden Beispieldatensatz übernommen: Data Lord Rings TrilogyWir haben eine Tabelle pro Film. jeder Tabelle haben wir die Gesamtzahl der gesprochenen Wörter, von Charakteren verschiedener Kategorien und Geschlechter.Stellt euch vor, diese drei Tabellen als separate Arbeitsblätter einer Excel-Datei zu finden. Oder als Tabellen auf einer Webseite oder einem Word-Dokument.Das Format der Tabellen macht es für Menschen einfach, die Anzahl der “Two Towers” von weiblichen Elfen gesprochenen Wörter zu lesen. Aber dieses Format macht es für einen Computer ziemlich schwer, solche Zahlen zu extrahieren und, noch wichtiger ist, damit zu rechnen oder sie grafisch darzustellen.Die Aufgabe ist schwer, da die Daten untidy sind. enthalten z.B. die Spalten Female und Male nicht die Information über das Geschlecht, sondern jeweils die Anzahl der gesprochenen Worte. Auf der anderen Seite gibt es keine Variable Words, deren Inhalt diese Anzahl eigentlich sein sollte..","code":""},{"path":"tidy.html","id":"tidy-lord-of-the-rings-data","chapter":"Kapitel 9 tidy was?","heading":"9.2 Tidy Lord of the Rings data","text":"Aufgeräumt sehen die Daten folgendermaßen aus:Beachtet, dass tidy Daten im Allgemeinen höher und schmaler sind. Bestimmte Elemente werden öfter wiederholt, hier z. B. Hobbit. Aus diesen Gründen lehnen wir tidy Daten oft instinktiv als ineffizient oder hässlich ab. Aber, solange ihr nicht das Endprodukt für eine textuelle Präsentation von Daten erstellt, solltet ihr diesen Instinkt ignorieren.","code":""},{"path":"tidy.html","id":"vorteile-von-tidy-data","chapter":"Kapitel 9 tidy was?","heading":"9.3 Vorteile von tidy data","text":"Wenn die Daten aufgeräumter Form vorliegen, ist es naheliegend, einen Computer zu holen, um weitere Zusammenfassungen zu machen oder eine Abbildung zu erstellen.dieser Form können wir nun leicht folgende Fragen beantworten:Wie viele Wörter haben die männlichen Hobbits insgesamt gesprochen?Wie viele Wörter haben die männlichen Hobbits insgesamt gesprochen?Dominiert eine bestimmte Race einen Film? Unterscheidet sich die dominierende Race den Filmen?Dominiert eine bestimmte Race einen Film? Unterscheidet sich die dominierende Race den Filmen?1. Wie viele Wörter haben die männlichen Hobbits insgesamt gesprochen?Nun braucht es nur noch ein kleines bisschen Code, um die Gesamtwortzahl für beide Geschlechter aller Kategorien über alle Filme hinweg zu berechnen. Wir nutzen dazu die Komfortfunktion count().Die Gesamtzahl der von männlichen Hobbits gesprochenen Wörter ist 8780. Hier war es wichtig, dass alle Wortzählungen einer Variable des Data Frames zusammengefasst sind und zugehörige Variablen für Geschlecht und Kategorie existieren.2. Dominiert eine bestimmte Kategorie einen Film? Unterscheidet sich die dominierende Kategorie den Filmen?Zunächst summieren wir über die Geschlechter hinweg, um die Wortzahlen für die verschiedenen Kategorien pro Film zu erhalten.Wir können jetzt entweder die Zahlen ein bisschen anstarren, um die Frage zu beantworten, oder besser, die gerade berechneten Wortzahlen einem Balkendiagramm darstellen.Hobbits sind “Fellowhip Ring” stark vertreten, während die Menschen “Two Towers” viel mehr Leinwandzeit hatten. Im letzten Film, “Return King”, war die Anzahl von Menschen gesprochener Wörter nur noch leicht höher als die Anzahl von Worten, die von Hobbits gesprochen wurden.Auch hier war es wichtig, alle Daten einem einzigen Data Frame zu haben, alle Wortzählungen einer einzigen Variable und zugehörige Variablen für Film und Kategorie.Im nächsten Schritt schauen wir uns nun , wie man aus den obigen drei Tabellen eine sauberen Datensatz erzeugt.","code":"\nlibrary(tidyverse)\nlotr_tidy %>% \n  count(Gender, Race, wt = Words)## # A tibble: 6 × 3\n##   Gender Race       n\n##   <chr>  <chr>  <dbl>\n## 1 Female Elf     1743\n## 2 Female Hobbit    16\n## 3 Female Man      669\n## 4 Male   Elf     1994\n## 5 Male   Hobbit  8780\n## 6 Male   Man     8043\n(by_race_film <- lotr_tidy %>% \n   group_by(Film, Race) %>% \n   summarize(Words = sum(Words)))## `summarise()` has grouped output by 'Film'. You can override using the\n## `.groups` argument.## # A tibble: 9 × 3\n## # Groups:   Film [3]\n##   Film                       Race   Words\n##   <chr>                      <chr>  <dbl>\n## 1 The Fellowship Of The Ring Elf     2200\n## 2 The Fellowship Of The Ring Hobbit  3658\n## 3 The Fellowship Of The Ring Man     1995\n## 4 The Return Of The King     Elf      693\n## 5 The Return Of The King     Hobbit  2675\n## 6 The Return Of The King     Man     2727\n## 7 The Two Towers             Elf      844\n## 8 The Two Towers             Hobbit  2463\n## 9 The Two Towers             Man     3990\nggplot(by_race_film, aes(x = Film, y = Words, fill = Race)) + \n  geom_bar(stat = \"identity\", position = \"dodge\") +\n  coord_flip() + guides(fill = guide_legend(reverse = TRUE)) + \n  scale_fill_brewer(palette = \"Set1\")"},{"path":"tidy.html","id":"untidy-lord-of-the-rings-data","chapter":"Kapitel 9 tidy was?","heading":"9.4 Untidy Lord of the Rings data","text":"Wir importieren nun die Daten, die den drei Tabellen dargestellt wurden.Für jede Tabelle existiert eine eigene csv Datei:The_Fellowship_Of_The_Ring.csvThe_Two_Towers.csvThe_Return_Of_The_King.csvWir haben jetzt ein Data Frame pro Film, jeweils mit den vier VariablenDer erste Schritt beim Aufräumen dieser Daten besteht darin, sie zu einem Data Frame zusammenzufügen, indem wir die drei Data Frames zeilenweise stapeln. Dazu können wir die Funktion dplyr::bind_rows() verwenden.Das Zusammensetzen eines großen Datenobjekts aus vielen kleinen ist eine relativ übliche Aufgabe bei der Datenaufbereitung. Wenn die Teile ähnlich sind wie hier, ist es schön, sie gleich zu einem Objekt zusammenzusetzen. anderen Szenarien müsst ihr möglicherweise einige Nacharbeiten den einzelnen Objekten vornehmen, bevor sie gut zusammengefügt werden können.Wenn möglich, sollte man die einzelnen Stücke früh wie möglich\nzusammensetzen, denn es ist einfacher und effizienter, ein einzelnes Objekt aufzuräumen als 20 oder 1000 oder …Nun können wir aufräumenDas Objekt lotr_untidy verletzt immer noch eines der Grundprinzipien von tidy data.Die Anzahl gesprochenen Wörtern ist eine grundlegende Variable unserem Datensatz und sie ist derzeit auf zwei Variablen verteilt, Female und Male.Konzeptionell müssen wir die Wortanzahl einer einzigen Variable zusammenfassen und eine neue Variable Gender erstellen, um zu verfolgen, ob die jeweilige Anzahl Worten von Frauen oder Männern gesprochen wurde. Diese Aufgabe können wir mit der Funktion tidyr::pivot_longer() bearbeiten.Um unseren obigen Aufruf von pivot_longer() zu erklären, lesen wir ihn mal von links nach rechts:Nach der Auswahl des Datensatzes lotr_untidy haben wird die Spalten Female und Male genommen und ihre Werte eine neue Variable Words zusammengefasst. Dies erzwingt die Erstellung einer neuen Variable Gender, die angibt, ob ein bestimmter Wert von Words von Female oder Male stammt.Alle anderen Variablen, wie Film, bleiben unverändert und werden einfach nach Bedarf repliziert. Die Dokumentation für pivot_longer() gibt weitere Beispiele und dokumentiert zusätzliche Argumente.Wenn man sich diese Arbeit gemacht hat, macht es Sinn sich auch das Ergebnis abzuspeichernTrotzdem solltet ihr natürlich auch die Skripte zur Datenaufbereitung sowie die Originaldaten abspeichern.","code":"\nfship <- read_csv(file.path(\"data\", \"The_Fellowship_Of_The_Ring.csv\"))\nttow <- read_csv(file.path(\"data\", \"The_Two_Towers.csv\"))\nrking <- read_csv(file.path(\"data\", \"The_Return_Of_The_King.csv\")) \nrking## # A tibble: 3 × 4\n##   Film                   Race   Female  Male\n##   <chr>                  <chr>   <dbl> <dbl>\n## 1 The Return Of The King Elf       183   510\n## 2 The Return Of The King Hobbit      2  2673\n## 3 The Return Of The King Man       268  2459\nnames(rking)## [1] \"Film\"   \"Race\"   \"Female\" \"Male\"\nlotr_untidy <- bind_rows(fship, ttow, rking)\nlotr_untidy## # A tibble: 9 × 4\n##   Film                       Race   Female  Male\n##   <chr>                      <chr>   <dbl> <dbl>\n## 1 The Fellowship Of The Ring Elf      1229   971\n## 2 The Fellowship Of The Ring Hobbit     14  3644\n## 3 The Fellowship Of The Ring Man         0  1995\n## 4 The Two Towers             Elf       331   513\n## 5 The Two Towers             Hobbit      0  2463\n## 6 The Two Towers             Man       401  3589\n## 7 The Return Of The King     Elf       183   510\n## 8 The Return Of The King     Hobbit      2  2673\n## 9 The Return Of The King     Man       268  2459\nlotr_tidy <-\n  pivot_longer(lotr_untidy, cols = c(\"Female\", \"Male\"), \n               names_to = 'Gender', \n               values_to = 'Words')\nlotr_tidy## # A tibble: 18 × 4\n##    Film                       Race   Gender Words\n##    <chr>                      <chr>  <chr>  <dbl>\n##  1 The Fellowship Of The Ring Elf    Female  1229\n##  2 The Fellowship Of The Ring Elf    Male     971\n##  3 The Fellowship Of The Ring Hobbit Female    14\n##  4 The Fellowship Of The Ring Hobbit Male    3644\n##  5 The Fellowship Of The Ring Man    Female     0\n##  6 The Fellowship Of The Ring Man    Male    1995\n##  7 The Two Towers             Elf    Female   331\n##  8 The Two Towers             Elf    Male     513\n##  9 The Two Towers             Hobbit Female     0\n## 10 The Two Towers             Hobbit Male    2463\n## 11 The Two Towers             Man    Female   401\n## 12 The Two Towers             Man    Male    3589\n## 13 The Return Of The King     Elf    Female   183\n## 14 The Return Of The King     Elf    Male     510\n## 15 The Return Of The King     Hobbit Female     2\n## 16 The Return Of The King     Hobbit Male    2673\n## 17 The Return Of The King     Man    Female   268\n## 18 The Return Of The King     Man    Male    2459\nwrite_csv(lotr_tidy, file = file.path(\"data\", \"lotr_tidy.csv\"))"},{"path":"tidy.html","id":"und-jetzt-noch-ein-bisschen-schmutzig-machen","chapter":"Kapitel 9 tidy was?","heading":"9.5 Und jetzt noch ein bisschen “schmutzig” machen","text":"Manchmal (aber nicht häufig) ist es nötig die Daten im Wide Format zu haben. Daher wollen wir zum Schluss die gerade gesäuberten LOTR Daten nochmal ein bisschen untidy machen.Dazu arbeiten wir mit den Funktion tidyr::pivot_wider(). Wir nehmen nun die Ausprägungen der Variable Race (anschließend dann Gender) als Variablennamen der neu zu bildenden Variablen. Die Werte dieser neuen Variablen sind durch die Variable Words festgelegt.Das erste Beispiel hat immer noch 6 Beobachtungen, zwei pro Film. Nehmen wir mal , dass wir aber nur eine Beobachtung pro Film haben wollen. Dazu müssten wir die möglichen Kombinationen aus Race und Gender einer neuen/weiteren Variablen zusammenfassen. Dies können wir über die Funktion tidyr::unite() erreichen.Kombination mit pivot_wider() ergibt sich soZum Schluss könnten wir auch noch alles zurück auf Anfang stellen und die\ndrei Datensätze vom Anfang wiederherstellenWir erhalten eine Liste mit drei Elemente, deren Inhalt den drei Tabellen vom Anfang entspricht. Die Daten zu “Return King” sind beispielsweise im zweiten Element enthalten.","code":"\n## Race\nlotr_tidy %>% \n  pivot_wider(names_from = Race, values_from = Words)## # A tibble: 6 × 5\n##   Film                       Gender   Elf Hobbit   Man\n##   <chr>                      <chr>  <dbl>  <dbl> <dbl>\n## 1 The Fellowship Of The Ring Female  1229     14     0\n## 2 The Fellowship Of The Ring Male     971   3644  1995\n## 3 The Two Towers             Female   331      0   401\n## 4 The Two Towers             Male     513   2463  3589\n## 5 The Return Of The King     Female   183      2   268\n## 6 The Return Of The King     Male     510   2673  2459\n## Gender\nlotr_tidy %>% \n  pivot_wider(names_from = Gender, values_from = Words)## # A tibble: 9 × 4\n##   Film                       Race   Female  Male\n##   <chr>                      <chr>   <dbl> <dbl>\n## 1 The Fellowship Of The Ring Elf      1229   971\n## 2 The Fellowship Of The Ring Hobbit     14  3644\n## 3 The Fellowship Of The Ring Man         0  1995\n## 4 The Two Towers             Elf       331   513\n## 5 The Two Towers             Hobbit      0  2463\n## 6 The Two Towers             Man       401  3589\n## 7 The Return Of The King     Elf       183   510\n## 8 The Return Of The King     Hobbit      2  2673\n## 9 The Return Of The King     Man       268  2459\nlotr_tidy %>% \n  unite(Race_Gender, Race, Gender)## # A tibble: 18 × 3\n##    Film                       Race_Gender   Words\n##    <chr>                      <chr>         <dbl>\n##  1 The Fellowship Of The Ring Elf_Female     1229\n##  2 The Fellowship Of The Ring Elf_Male        971\n##  3 The Fellowship Of The Ring Hobbit_Female    14\n##  4 The Fellowship Of The Ring Hobbit_Male    3644\n##  5 The Fellowship Of The Ring Man_Female        0\n##  6 The Fellowship Of The Ring Man_Male       1995\n##  7 The Two Towers             Elf_Female      331\n##  8 The Two Towers             Elf_Male        513\n##  9 The Two Towers             Hobbit_Female     0\n## 10 The Two Towers             Hobbit_Male    2463\n## 11 The Two Towers             Man_Female      401\n## 12 The Two Towers             Man_Male       3589\n## 13 The Return Of The King     Elf_Female      183\n## 14 The Return Of The King     Elf_Male        510\n## 15 The Return Of The King     Hobbit_Female     2\n## 16 The Return Of The King     Hobbit_Male    2673\n## 17 The Return Of The King     Man_Female      268\n## 18 The Return Of The King     Man_Male       2459\nlotr_tidy %>% \n  unite(Race_Gender, Race, Gender) %>% \n  pivot_wider(names_from = Race_Gender, values_from = Words)## # A tibble: 3 × 7\n##   Film         Elf_Female Elf_Male Hobbit_Female Hobbit_Male Man_Female Man_Male\n##   <chr>             <dbl>    <dbl>         <dbl>       <dbl>      <dbl>    <dbl>\n## 1 The Fellows…       1229      971            14        3644          0     1995\n## 2 The Two Tow…        331      513             0        2463        401     3589\n## 3 The Return …        183      510             2        2673        268     2459\n(sep_list <- lotr_tidy %>% \n  pivot_wider(names_from = Gender, values_from = Words) %>%\n   group_split(Film))## <list_of<\n##   tbl_df<\n##     Film  : character\n##     Race  : character\n##     Female: double\n##     Male  : double\n##   >\n## >[3]>\n## [[1]]\n## # A tibble: 3 × 4\n##   Film                       Race   Female  Male\n##   <chr>                      <chr>   <dbl> <dbl>\n## 1 The Fellowship Of The Ring Elf      1229   971\n## 2 The Fellowship Of The Ring Hobbit     14  3644\n## 3 The Fellowship Of The Ring Man         0  1995\n## \n## [[2]]\n## # A tibble: 3 × 4\n##   Film                   Race   Female  Male\n##   <chr>                  <chr>   <dbl> <dbl>\n## 1 The Return Of The King Elf       183   510\n## 2 The Return Of The King Hobbit      2  2673\n## 3 The Return Of The King Man       268  2459\n## \n## [[3]]\n## # A tibble: 3 × 4\n##   Film           Race   Female  Male\n##   <chr>          <chr>   <dbl> <dbl>\n## 1 The Two Towers Elf       331   513\n## 2 The Two Towers Hobbit      0  2463\n## 3 The Two Towers Man       401  3589\nsep_list[[2]]## # A tibble: 3 × 4\n##   Film                   Race   Female  Male\n##   <chr>                  <chr>   <dbl> <dbl>\n## 1 The Return Of The King Elf       183   510\n## 2 The Return Of The King Hobbit      2  2673\n## 3 The Return Of The King Man       268  2459"},{"path":"tidy.html","id":"literatur-1","chapter":"Kapitel 9 tidy was?","heading":"9.6 Literatur","text":"Tidy data Kapitel R Data Science, Garrett Grolemund Hadley Wickham\ntidyr Paket\ntidyr PaketBad Data Handbook Q. Ethan McCallum, published O’Reilly.\nChapter 3: Data Intended Human Consumption, Machine Consumption Paul Murrell.\nChapter 3: Data Intended Human Consumption, Machine Consumption Paul Murrell.Tidy data Hadley Wickham. Journal Statistical Software. Vol. 59, Issue 10, Sep 2014. http://www.jstatsoft.org/v59/i10","code":""},{"path":"einfuehrung-ggplot2.html","id":"einfuehrung-ggplot2","chapter":"Kapitel 10 Einführung","heading":"Kapitel 10 Einführung","text":"Das Paket ggplot2 verwendet eine speziell Systematik beim Erzeugen von Grafiken. Diese basiert aufWilkinson (2005): Grammar Graphics, Springer.Kurz gesagt, ist die zugrunde liegende Idee, dass eine statistische Grafik eine Abbildung von Daten auf ästhetische Attribute (Farbe, Form, Größe) von geometrischen Objekten (Punkte, Linien, Balken) ist.Ferner kann eine Grafik auch noch statistische Transformationen der Daten enthalten. Über die Verwendung verschiedener Facetten ist es möglich dieselbe Darstellung für verschiedene Untergruppen des Datensatzes zu erzeugen.Ende ist es eine Kombination dieser unabhängigen Komponenten, die eine Grafik ausmacht.Wie immer, laden wir zu Beginn\nMan weiß ja vorher nie genau man alles braucht.","code":"\nlibrary(tidyverse)\n## ── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n## ✔ dplyr     1.1.4     ✔ readr     2.1.5\n## ✔ forcats   1.0.0     ✔ stringr   1.5.1\n## ✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n## ✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n## ✔ purrr     1.0.2     \n## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n## ✖ dplyr::filter() masks stats::filter()\n## ✖ dplyr::lag()    masks stats::lag()\n## ℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors"},{"path":"einfuehrung-ggplot2.html","id":"idee","chapter":"Kapitel 10 Einführung","heading":"10.1 Idee","text":"Die grundlegende Idee des ggplot2 Ansatzes zum Erstellen von Grafiken, besteht darin die Bausteine (verschiedene Layer) eines Plots unabhängig voneinander zu definieren und diese dann zu einer Grafik zusammenzufügen. Eine Grafik besteht immer aus:den Daten (als data.frame oder tibble), die ihr visualisieren möchtetden Daten (als data.frame oder tibble), die ihr visualisieren möchteteiner Reihe von Zuordnungen (einem mapping), die beschreiben, wie Variablen aus dem Datensatz auf ästhetische Attribute abgebildet werdeneiner Reihe von Zuordnungen (einem mapping), die beschreiben, wie Variablen aus dem Datensatz auf ästhetische Attribute abgebildet werdengeometrischen Objekten (geoms), die beschreiben man Ende wirklich sieht, also z.B. Punkte, Linien, …geometrischen Objekten (geoms), die beschreiben man Ende wirklich sieht, also z.B. Punkte, Linien, …einem Koordinatensystem, das beschreibt, wie die Koordinaten der Daten auf die Ebene der Grafik abgebildet werden. Außerdem stellt es Achsen und Gitternetzlinien zur Verfügung, die das Lesen der Grafik ermöglichen. Normalerweise verwenden wir ein kartesisches Koordinatensystem, aber es gibt natürlich auch noch eine Reihe anderer Optionen.einem Koordinatensystem, das beschreibt, wie die Koordinaten der Daten auf die Ebene der Grafik abgebildet werden. Außerdem stellt es Achsen und Gitternetzlinien zur Verfügung, die das Lesen der Grafik ermöglichen. Normalerweise verwenden wir ein kartesisches Koordinatensystem, aber es gibt natürlich auch noch eine Reihe anderer Optionen.Skalen (scales), die Werte der Daten abbilden auf Werte einem ästhetischen Raum, sei es Farbe, Größe oder Form.Skalen (scales), die Werte der Daten abbilden auf Werte einem ästhetischen Raum, sei es Farbe, Größe oder Form.Zusätzlich kann die Grafik aber auch nochstatistische Transformationen (stat), die eine Zusammenfassung der Daten visualisieren,statistische Transformationen (stat), die eine Zusammenfassung der Daten visualisieren,Facetten, die es ermöglichen dieselbe Darstellung für verschiedene Untergruppen des Datensatzes zu erzeugen,Facetten, die es ermöglichen dieselbe Darstellung für verschiedene Untergruppen des Datensatzes zu erzeugen,……enthalten.Die einzelnen Teile eines Plots werden mit dem + Operator zusammengefügt. Initialisiert wird ein Plot mit ggplot(). Ohne weitere Bestandteile wird aber nur eine leere Grafik erzeugtIn den folgenden Abschnitten lernen wir daher wie weitere Bestandteile zum Plot hinzugefügt werden.","code":"\nlibrary(gapminder)\nggplot(gapminder) "},{"path":"einfuehrung-ggplot2.html","id":"ein-einfacher-scatterplot","chapter":"Kapitel 10 Einführung","heading":"10.2 Ein einfacher Scatterplot","text":"Wir schauen uns zum Start einfach mal für Deutschland den Verlauf des gdpPercap über die Zeit .dieser Grafik haben wir über geom_point() die Art des geometrischen Objekts gewählt. diesem Fall Punkte. Wenn uns die Form (shape) der Punkte nicht gefällt, können wir diese natürlich ändern, z.B. DreieckeAber dazu mehr im Abschnitt Scales.Bemerkung: diesem einfachen Beispiel haben wir bereits gesehen, dass ggplot() über den Pipe-Operator verknüpft werden kann.","code":"\ngapminder %>%\n  filter(country == \"Germany\") %>% # auswählen der Daten \n  ggplot(aes(x = year, y = gdpPercap)) +  # Plot initialisieren\n  geom_point() # Punkte zum Darstellen der Daten verwenden\ngapminder %>%\n  filter(country == \"Germany\") %>% \n  ggplot(aes(x = year, y = gdpPercap)) +  \n  geom_point(shape = 2) # shape auf festen Wert 2 gesetzt"},{"path":"bausteine.html","id":"bausteine","chapter":"Kapitel 11 Bausteine","heading":"Kapitel 11 Bausteine","text":"den nächsten Abschnitten schauen wir uns die verschiedene Bausteine einer ggplot2 Grafik genauer . Dabei sehen wir auch eine Reihe von Beispielen, die uns zeigen, wie man die verschiedenen Bausteine miteinander verknüpft.","code":""},{"path":"bausteine.html","id":"aes","chapter":"Kapitel 11 Bausteine","heading":"11.1 Aesthetics","text":"Mit der Funktion aes() lässt sich das Aussehen der Grafik regeln (nicht der Inhalt). Wir können z.B.die Position: x und ydie Farbe: color und filldie Form: shapeden Linientyp: linetypedie Größe der Symbol: sizefestlegen. Die jeweiligen Werte dieser aesthetics können entweder fix oder Abhängigkeit von Variablen aus dem verwendeten Datensatz gewählt werden.\nWerden die Werte Abhängigkeit der Daten gewählt, definiert die Funktion aes() ein mapping zwischen den Daten und den aesthetics der Grafik.Nicht jedes aesthetic kann allerdings mit allen verfügbaren geoms kombiniert werden. macht z.B. der linetype ja wenig Sinn geom_point(). Eine Übersicht der möglichen aesthetics findet man der Hilfe jeder geom-Funktion. der Hilfe von geom_point() findet man z.B.man über die Daten Werte für die verschiedenen aesthetics definieren, muss dies innerhalb der aes() Funktion geschehen. Werden Argumente auf fixe Werte gesetzt, sind sie außerhalb der aes() Funktion zu setzen.einem Plot der gdpPercap Daten für Deutschland und Frankreich wollen wir anhand von unterschiedlichen Farben die Daten der beiden Länder unterscheiden. Dazu müssen wir nur colour innerhalb von aes() den Wert country zuweisen. Zusätzlich wollen wir die Größe der zu zeichnenden Punkte etwas erhöhen. Aber die Größe soll für beide Länder gleich sein. Daher definieren wir size außerhalb der aes() Funktion.","code":"geom_point {ggplot2}    R Documentation\nPoints\nDescription\nThe point geom is used to create scatterplots. The scatterplot is most useful for displaying the relationship between two continuous variables. It can be used to compare one continuous and one categorical variable, or two categorical variables, but a variation like geom_jitter(), geom_count(), or geom_bin2d() is usually more appropriate. A bubblechart is a scatterplot with a third variable mapped to the size of points.\n\nUsage\ngeom_point(\n  mapping = NULL,\n  data = NULL,\n  stat = \"identity\",\n  position = \"identity\",\n  ...,\n  na.rm = FALSE,\n  show.legend = NA,\n  inherit.aes = TRUE\n)\n\n...\n\nAesthetics\ngeom_point() understands the following aesthetics (required aesthetics \nare in bold):\n\nx\n\ny\n\nalpha\n\ncolour\n\nfill\n\ngroup\n\nshape\n\nsize\n\nstroke\n\nLearn more about setting these aesthetics in vignette(\"ggplot2-specs\").\n\ngapminder %>%\n  filter(country %in% c(\"Germany\",\"France\")) %>%  \n  ggplot(mapping = aes(x = year, y = gdpPercap, colour = country)) +  \n  geom_point(size = 3) "},{"path":"bausteine.html","id":"geoms","chapter":"Kapitel 11 Bausteine","heading":"11.2 Geoms","text":"Mithilfe der geom_xxx() Funktionen können wir die Daten als geometrische Formen (Punkte, Linien, …) einer Grafik darstellen. Jede ggplot2 Grafik benötigt daher mindestens ein geom. Beispiele sindgeom_point()geom_line()geom_histogram()Da wir nicht alle verfügbaren geoms auflisten können/wollen, sei dieser Stelle auf die ggplot2 Seite verwiesen.Im nächsten Beispiel stellen wir die gleichen Daten/Variablen über zwei verschiedene geoms dar.Obwohl die gleichen Daten visualisiert wurden, ist das Ergebnis doch recht unterschiedlich. Der Scatterplot zeigt alle (abgesehen von Overplotting) Daten, wohingegen mit geom_smooth() eine geglätteter Zusammenhang dargestellt wird.Interessant sind hier natürlich die wenigen großen gdpPercap Werte der linken GrafikKuwait hat über den gesamten Zeitraum sehr hohe GDP Werte. Aber zu Beginn der Aufzeichnungen waren die Werte Bezug auf die damals noch recht kleine Populationsgröße sogar außergewöhnlich hoch.Einem ggplot Objekt können wir nicht nur ein geom zuordnen. Prinzipiell können wir beliebig viele weitere geoms hinzufügen. Wir können also die gerade durchgeführte Glättung der Daten auch direkt zum Scatterplot hinzufügenWählen wir die Farbe eines geometrischen Objekts (oder mehrerer) anhand einer Faktorvariable, erhalten wir automatisch eine entsprechende LegendeBeachtet dabei, dass wir colour nur für geom_point() gewählt haben. Die Glättung erfolgt weiterhin über alle Daten und nicht separat für jeden Kontinent. diesem Fall haben wir geom_point() ein lokales mapping definiert.Aber natürlich hätten wir die Glättung auch pro Kontinent durchführen können. Dazu schreiben wir einfach colour das globale mapping und löschen das lokale mapping geom_point() wieder.Nehmen wir mal , dass uns nun aber die Punkte etwas zu groß sind und die Linien sollten nicht durchgezogen sein. D.h. wir würden gerne andere (aber fixe, nicht von Variablen abhängende) aesthetic Werte setzen. Das lässt sich schnell ändern.","code":"\ngapminder %>%\n  ggplot(mapping = aes(x = year, y = gdpPercap)) +  \n  geom_point() \n\n\ngapminder %>%\n  ggplot(mapping = aes(x = year, y = gdpPercap)) +  \n  geom_smooth() \n## `geom_smooth()` using method = 'gam' and formula = 'y ~ s(x, bs = \"cs\")'\ngapminder %>%\n  filter(gdpPercap > 50000)\n## # A tibble: 6 × 6\n##   country continent  year lifeExp     pop gdpPercap\n##   <fct>   <fct>     <int>   <dbl>   <int>     <dbl>\n## 1 Kuwait  Asia       1952    55.6  160000   108382.\n## 2 Kuwait  Asia       1957    58.0  212846   113523.\n## 3 Kuwait  Asia       1962    60.5  358266    95458.\n## 4 Kuwait  Asia       1967    64.6  575003    80895.\n## 5 Kuwait  Asia       1972    67.7  841934   109348.\n## 6 Kuwait  Asia       1977    69.3 1140357    59265.\ngapminder %>%\n  ggplot(mapping = aes(x = year, y = gdpPercap)) +  \n  geom_point() +\n  geom_smooth() \n## `geom_smooth()` using method = 'gam' and formula = 'y ~ s(x, bs = \"cs\")'\ngapminder %>%\n  ggplot(mapping = aes(x = year, y = gdpPercap)) +  \n  geom_point(mapping = aes(colour = continent)) +\n  geom_smooth() \n## `geom_smooth()` using method = 'gam' and formula = 'y ~ s(x, bs = \"cs\")'\ngapminder %>%\n  ggplot(mapping = aes(x = year, y = gdpPercap, colour = continent)) +  \n  geom_point() +\n  geom_smooth() \n## `geom_smooth()` using method = 'loess' and formula = 'y ~ x'\ngapminder %>%\n  ggplot(aes(x = year, y = gdpPercap, colour = continent)) +  \n  geom_point(size = 0.9) +\n  geom_smooth(linetype = 2) \n## `geom_smooth()` using method = 'loess' and formula = 'y ~ x'"},{"path":"bausteine.html","id":"stat-trans","chapter":"Kapitel 11 Bausteine","heading":"11.3 Statistische Transformationen","text":"Jede geom_xxx() Funktion besitzt eine “Standard-Statistik”, die beim Aufruf der Funktion berechnet wird.Bei einem Scatterplot ist die Statistik einfach nur die Identität.Ein Balkendiagramm verwendet aber z.B.die Transformation count. Das macht durchaus Sinn, da ja gezählt werden muss/soll wie viele Beobachtungen die jeweilige Kategorie fallen.Die jeweiligen Statistiken könnten über die entsprechenden stat_xxx() Funktionen geplottet werden. Da aber jede geom_xxx() Funktion mit mindestens einer dieser stat_xxx() Funktionen verbunden ist, ist es oftmals einfacher direkt die entsprechende geom_xxx() Funktion zu verwenden. Aber generell könnte die jeweilige stat_xxx() Funktion auch direkt aufgerufen werden.Daher liefern die beiden nachfolgenden Befehle auch die exakt gleiche GrafikJedes geom hat zwar ein Standard-Transformation, aber natürlich können oftmals noch weitere Transformationen berechnet/genutzt werden. Im Abschnitt Computed variables der Hilfe zu einem geom sieht man alle verfügbaren Transformationen.Für geom_bar() sind diesDie relativen Häufigkeiten berechnet man also über prop. Dazu muss die y-Variable auf prop gesetzt werden. Da der Aufrufaber nach einer Variable prop suchen würde, muss eine alternative Notation diesem Fall verwendet werdenDer Befehl hat jetzt zwar eine Grafik erzeugt, aber die sieht noch nicht aus, wie wir das erwartet haben. Die\nrelativen Häufigkeiten wurden innerhalb der fünf Gruppen berechnet und nicht über alle Beobachtungen. D.h. wir müssen der Funktion noch sagen, dass die relativen Häufigkeiten der fünf verschiedenen Ausprägungen (Kontinente) eine Gruppe berechnet werden sollen. Dies geschieht über das group aesthetic.","code":"\nargs(geom_point)\n## function (mapping = NULL, data = NULL, stat = \"identity\", position = \"identity\", \n##     ..., na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) \n## NULL\nargs(geom_bar)\n## function (mapping = NULL, data = NULL, stat = \"count\", position = \"stack\", \n##     ..., just = 0.5, width = NULL, na.rm = FALSE, orientation = NA, \n##     show.legend = NA, inherit.aes = TRUE) \n## NULL\nggplot(gapminder, aes(x = continent)) + \n  geom_bar()\n\nggplot(gapminder, aes(x = continent)) + \n  stat_count()Computed variables\n\ncount\nnumber of points in bin\n\nprop\ngroupwise proportion\n\n\nggplot(gapminder, aes(x = continent, y = prop))\nggplot(gapminder, aes(x = continent, y = ..prop..)) + \n  geom_bar()\n## Warning: The dot-dot notation (`..prop..`) was deprecated\n## in ggplot2 3.4.0.\n## ℹ Please use `after_stat(prop)` instead.\n## This warning is displayed once every 8 hours.\n## Call `lifecycle::last_lifecycle_warnings()` to\n## see where this warning was generated.\nggplot(gapminder, aes(x = continent, y = ..prop..)) + \n  geom_bar(aes(group = 1))"},{"path":"bausteine.html","id":"scales","chapter":"Kapitel 11 Bausteine","heading":"11.4 Scales","text":"Scales steuern die Zuordnung von Daten zu aesthetics. Sie nehmen die Daten und bestimmen damit Größe, Farbe, Position oder Form von Objekten. Sie erlauben euch auch die Achsen und die Legend nach euren Vorstellungen anzupassen.Man kann sicherlich mit ggplot2 Grafiken erstellen, ohne zu wissen, wie scales funktionieren. Aber wenn ihr versteht wie scales funktionieren und lernt, wie ihr sie einstellen könnt, werdet ihr viel mehr Kontrolle über eure Grafiken bekommen.Über scale Funktionen der Form scale_\"aesthetic\"_\"type\" können wir aesthetics wiecolor und fillpositionsizeshapeline typemodifizieren. Argumente dieser Funktionen sind z.B. name, limits, breaks oder labels.Zuerst spielen wir etwas mit Farben. Dazu plotten wir erneut year gegen gdpPercap und wählen für jeden Kontinent eine eigene Farbe. Da wir die Farben über colour definieren, verwenden wir Funktionen aus der Klasse scale_colour_xxx(). Hätten wir beispielsweise Flächen über das aesthetic fill mit Farbe gefüllt, würden wir Funktionen aus der Klasse scale_fill_xxx() verwenden um die Farben anzupassen.diesem Beispiel haben wir also die Farbe nachträglich über eine vorgegebene Palette, Grau-Stufen bzw. manuell gewählt. Im letzten Beispiel haben wir zusätzlich noch den Titel der Legende geändert über das name Argument.Die Achsenbeschriftung der y-Achse ist nicht wirklich schön, weil nicht unbedingt selbsterklärend. Daher ändern wir im nächsten Schritt die Achsenbeschriftung.Da es sich bei gdpPercap um eine stetige Variable handelt, haben wir scale_y_continuous() verwendet (im Gegensatz zu scale_y_discrete()) um die Achsenbeschriftung zu ändern. Über die Hilfsfunktion labs() können wir die Beschriftung der Grafik aber auch einfacher/intuitiver ändern.Die frühen Kuwait-Beobachtungen ziehen die y-Achse stark auseinander. Daher könnte man vielleicht etwas den Plot hinein zoomen wollen. Dazu kann man das Koordinatensystem anpassen über coord_cartasian(). Alternativ könnte man auch mit der Funktion ylim() arbeiten (analog existiert natürlich auch xlim()).Verwendet man aber xlim() bzw. ylim(), werden alle Datenpunkte, die nicht im zu plottenden Bereich liegen, aber nicht nur nicht gezeichnet, sondern auch aus dem Datensatz (für diesen einen Plot) entfernt. Dies hat dann Auswirkungen auf Teile des Plots, die auf statistische Transformationen basieren, welche mithilfe der vorhanden Daten berechnet werden.der rechten Grafik ist der Verlauf der Kurven unverändert. der linken Grafik hingegen liegt die Kurve für Asien nun bis Mitte der 80er Jahre deutlich unter der Kurve für Amerika.Weitere (mögliche) Positionsänderungen ergeben sich durch Skalierungen der Achsen wie scale_x_log10(), scale_y_sqrt() oderAm Ende von diesem Abschnitt wollen wir nochmal ein Blick auf die Häufigkeitsverteilung bzgl. der verschiedenen Kontinente werfen. Diesmal wollen wir aber zusätzlich noch die GDP pro Kopf Werte berücksichtigen. Dazu teilen wir die GDP Werte niedrig (kleiner als das 0.25 Quantil aller Beobachtungen), mittel (zwischen dem 0.25 und 0.75 Quantil aller Beobachtungen) und hoch (über dem 0.75 Quantil aller Beobachtungen) ein. Diese Information nutzen wir dann zum Einfärben der BalkenWir erkennen, dass die notwendige Klassifizierung der GDP Werte im Plot Befehl erfolgen kann. Das produzierte Ergebnis ist aber natürlich nicht überzeugend. Die Überschrift, wie die Beschriftungen der Legende müssen angepasst werden. Dazu verwenden wir die Funktion scale_fill_discrete().dieser Darstellung bleibt es bei einem Balken pro Kontinent. Würden wir aber gerne (bis zu) drei Balken pro Kontinent sehen, müssen die Positionierung ändern.Gefällt einem das kartesische Koordinatensystem nicht, könnte man beispielsweise mit Polarkoordinaten arbeiten.Für weitere Optionen sei hier auf die online Version der neuesten Auflage von ggplot2 (Wickham 2009) verwiesen.","code":"\n(p <- gapminder %>%\n  ggplot(aes(x = year, y = gdpPercap, colour = continent)) +  \n  geom_point(size = 0.9) +\n  geom_smooth(linetype = 2) )\n## `geom_smooth()` using method = 'loess' and\n## formula = 'y ~ x'\n\np + scale_colour_brewer(palette = \"Set1\") \n## `geom_smooth()` using method = 'loess' and\n## formula = 'y ~ x'\n# Farbpaletten von http://colorbrewer2.org/\n\np + scale_colour_grey(start = 0.1, end = 0.9) # keine so gute Wahl\n## `geom_smooth()` using method = 'loess' and\n## formula = 'y ~ x'\n\np + scale_colour_manual(\n  values = c(\"palevioletred3\", \"seagreen\", \"sienna1\", \"sienna4\", \"yellow\"),\n  name = \"Kontinent\")\n## `geom_smooth()` using method = 'loess' and\n## formula = 'y ~ x'\np <- p + \n  scale_colour_manual(\n  values = c(\"palevioletred3\", \"seagreen\", \"sienna1\", \"sienna4\", \"yellow\"))\n\np + scale_y_continuous(\"GDP pro Kopf\")\n## `geom_smooth()` using method = 'loess' and\n## formula = 'y ~ x'\n(p <- p + labs(x = \"Jahr\", y = \"GDP pro Kopf\",\n         title = \"Monoton steigendes GDP pro Kopf\",\n         subtitle = \"Gestrichelte Linie zeigt Durchschnittswerte über alle\n         Länder pro Kontinent\"))\n## `geom_smooth()` using method = 'loess' and\n## formula = 'y ~ x'\np + ylim(0,55000)\n## `geom_smooth()` using method = 'loess' and\n## formula = 'y ~ x'\n## Warning: Removed 6 rows containing non-finite outside the\n## scale range (`stat_smooth()`).\n## Warning: Removed 6 rows containing missing values or\n## values outside the scale range (`geom_point()`).\n(p <- p + coord_cartesian(ylim = c(0, 55000)))\n## `geom_smooth()` using method = 'loess' and\n## formula = 'y ~ x'\np + scale_x_reverse()\n## `geom_smooth()` using method = 'loess' and\n## formula = 'y ~ x'\nggplot(gapminder, \n       aes(x = continent,\n           fill = cut(gdpPercap, \n                      breaks = c(0, quantile(gdpPercap,0.25),\n                                 quantile(gdpPercap, 0.75),\n                                 max(gdpPercap))\n                      )\n           )) + \n  geom_bar()\nq <- ggplot(gapminder, \n       aes(x = continent,\n           fill = cut(gdpPercap, \n                      breaks = c(0, quantile(gdpPercap,0.25),\n                                 quantile(gdpPercap, 0.75),\n                                 max(gdpPercap))\n                      )\n           )) \nq + \n  geom_bar() +\n  scale_fill_discrete(name = \"GDP\\nKlassifizierung\",\n                      labels = c(\"niedrig\", \"mittel\", \"hoch\"))\nq + \n  geom_bar(position = \"dodge\") +\n  scale_fill_discrete(name = \"GDP\\nKlassifizierung\",\n                      labels = c(\"niedrig\", \"mittel\", \"hoch\")) \nq + \n  geom_bar(position = \"dodge\") +\n  scale_fill_discrete(name = \"GDP\\nKlassifizierung\",\n                      labels = c(\"niedrig\", \"mittel\", \"hoch\")) +\n  coord_polar()"},{"path":"bausteine.html","id":"facets","chapter":"Kapitel 11 Bausteine","heading":"11.5 Facets","text":"Datensätze lassen sich oftmals bzgl. vorhandener Variablen gruppieren. Die zu untersuchenden Zusammenhänge zwischen weiteren Variablen sollten dann innerhalb dieser Gruppen dargestellt werden. Entsteht die Gruppierung basierend auf den Ausprägungen einer Variable, kann man z.B. mit facet_wrap() arbeitenIn der letzten Grafik verwenden alle fünf Plots die gleiche Skala auf der y-Achse um die Vergleichbarkeit der Werte zu erhöhen. manchen Fällen mag dies aber störend sein. Mit dem Argument scales könnt ihr die Skala “befreien”.Erfolgt die Gruppierung anhand von zwei Variablen, bietet facet_grid() eine passende Aufteilung des Grafikfensters Zeilen und Spalten. Neben dem Kontinent berücksichtigen wir jetzt auch noch die Populationsgröße des Landes. Konkret fragen wir ob die Population im entsprechenden Jahr größer als 5000000 ist, oder eben nicht.Für Ozeanien erhalten wir z.B. eine Unterteilung Australien (TRUE) und Neuseeland (FALSE).Die Beschriftung der Spalten sieht natürlich nicht besonders schön aus. Ohne den Code ist die Beschriftung auch nicht zu verstehen, “ist wahr??”.Daher versuchen wir die Beschriftung über das Argument labeller der facet_grid() Funktion zu ändern. Zulässige Werte für das Argument labeller können über die labeller() Funktion definiert werden. Hier hat man neben weiteren Optionen die Möglichkeit für jede Ausprägung der Variable, die eine Spalten- (oder Zeilen-) Aufteilung definiert, ein Label zu setzen. Dazu muss\ndie Variable über ihren Namen aufgerufen werden. Nun scheint es , dass ein Aufruf über “Sondernamen” wie pop > 5000000 nicht funktioniert. Um trotzdem die Verwendung von labeller zu illustrieren, definieren wir zuerst mit mutate eine neue Variable pop5 und setzen anschließend die Labels über das Argument labeller.","code":"\ngapminder %>%\n  ggplot(aes(x = year, y = gdpPercap )) +  \n  geom_point(size = 0.9) +\n  geom_smooth(linetype = 2) +\n  facet_wrap(~ continent, ncol = 5)\n## `geom_smooth()` using method = 'loess' and\n## formula = 'y ~ x'\ngapminder %>%\n  ggplot(aes(x = year, y = gdpPercap )) +  \n  geom_point(size = 0.9) +\n  geom_smooth(linetype = 2) +\n  facet_wrap(~ continent, ncol = 2, scales = \"free\")\n## `geom_smooth()` using method = 'loess' and\n## formula = 'y ~ x'\ngapminder %>%\n  group_by(continent) %>%\n  ggplot(aes(x = year, y = gdpPercap )) +  \n  geom_point(size = 0.9) +\n  geom_smooth(linetype = 2) +\n  facet_grid(continent ~ pop > 5000000, scales = \"free\")\n## `geom_smooth()` using method = 'loess' and\n## formula = 'y ~ x'\ngapminder %>%\n  mutate(pop5 = pop > 5000000) %>%\n  group_by(continent) %>%\n  ggplot(aes(x = year, y = gdpPercap )) +  \n  geom_point(size = 0.9) +\n  geom_smooth(linetype = 2) +\n  facet_grid(continent ~ pop5, scales = \"free\",\n             labeller = labeller(\n               pop5 = c(`TRUE` = \"pop large than 5 MM\", \n                        `FALSE` = \"pop at most 5 MM\")))\n## `geom_smooth()` using method = 'loess' and\n## formula = 'y ~ x'"},{"path":"bausteine.html","id":"themes","chapter":"Kapitel 11 Bausteine","heading":"11.6 Themes","text":"Abschließend wollen wir noch über verschiedene themes sprechen. Über themes kann man das Aussehen der nicht datenbezogenen Elemente einer Grafik, wie z.B.die Beschriftungenden Hintergrunddie Legende….verändern. Eine Reihe von themes sind bereits vorhanden, wobei theme_gray() das Default theme ist. Siehe auch ?theme_gray().Wir möchten nun gerne folgende Änderungen der Grafik vornehmen:die Größe der Achsenbeschriftung änderndie Gitterlinien ohne Beschriftung entfernendie Legende die Grafik verschiebendie Hintergrundfarbe der Grafik und der Legende ändernDie meisten dieser Änderungen können wir mit theme() durchführen.Ob das nun alles schön aussieht, sei dahingestellt, aber es zeigt durchaus die vorhandenen Möglichkeiten.man gewisse Einstellung öfter verwenden, kann man diese auch einem theme Objekt speichern und wiederverwenden.","code":"\np\n## `geom_smooth()` using method = 'loess' and\n## formula = 'y ~ x'\np + theme_bw()\n## `geom_smooth()` using method = 'loess' and\n## formula = 'y ~ x'\np + theme_dark()\n## `geom_smooth()` using method = 'loess' and\n## formula = 'y ~ x'\np + theme_minimal()\n## `geom_smooth()` using method = 'loess' and\n## formula = 'y ~ x'\np <- p + scale_colour_brewer(palette = \"Set1\") \n## Scale for colour is already present.\n## Adding another scale for colour, which will\n## replace the existing scale.\np +\n  theme(\n    axis.text = element_text(size = 14),\n    legend.key = element_rect(fill = \"gold\"),\n    legend.background = element_rect(fill = \"#0065BD\"),\n    legend.position = \"bottom\",\n    legend.text = element_text(colour = \"white\"),\n    panel.grid.major = element_line(colour = \"grey40\"),\n    panel.grid.minor = element_blank(),\n    panel.background = element_rect(fill = \"gold\")\n  )\n## `geom_smooth()` using method = 'loess' and\n## formula = 'y ~ x'\nmein_theme <- theme(\n    axis.text = element_text(size = 14),\n    legend.key = element_rect(fill = \"hotpink3\"),\n    panel.grid.major = element_line(colour = \"grey40\"),\n    panel.grid.minor = element_blank(),\n    panel.background = element_rect(fill = \"navy\")\n  )\nclass(mein_theme)\n## [1] \"theme\" \"gg\"\np + mein_theme\n## `geom_smooth()` using method = 'loess' and\n## formula = 'y ~ x'"},{"path":"bausteine.html","id":"buch-zum-paket","chapter":"Kapitel 11 Bausteine","heading":"11.7 Buch zum Paket","text":"Dieser Abschnitt konnte nur einen kleinen Einblick die Möglichkeiten des ggplot2 Pakets geben. Eine ausführliche Beschreibung findet man im Buch zum Paket.Findet man dort noch nicht die Funktionalität, die man sucht, sollte man einen Blick auf die ggplot2 extensions werfen. Oder vielleicht direkt dort starten.","code":""},{"path":"pakete.html","id":"pakete","chapter":"Kapitel 12 Pakete","heading":"Kapitel 12 Pakete","text":"Bei einem Paket 📦 handelt es sich umeine strukturierte, standardisierte Einheit, welche aus R Code, Dokumentation, Daten und (möglicherweise) externem Quellcode besteht.Wie man ein Paket installiert und lädt, ist uns mittlerweile bekannt. Jetzt wollen wir eigene Pakete erstellen.Gute Gründe für die Verwendung von Paketen:dynamisches Laden und Entladen des Pakets (Speicherplatz\nsparend)dynamisches Laden und Entladen des Pakets (Speicherplatz\nsparend)einfache Installation und Update von lokalen Datenträgern über\ndas Web (innerhalb von R oder über die Kommandozeile des\nBetriebssystems)einfache Installation und Update von lokalen Datenträgern über\ndas Web (innerhalb von R oder über die Kommandozeile des\nBetriebssystems)Validierung: R bietet Befehle zur groben Überprüfung von Code,\nDokumentation und Installierbarkeit, sowie, falls man möchte,\nÜberprüfung von BerechnungsergebnissenValidierung: R bietet Befehle zur groben Überprüfung von Code,\nDokumentation und Installierbarkeit, sowie, falls man möchte,\nÜberprüfung von Berechnungsergebnisseneinfache Verteilung der Software Dritteeinfache Verteilung der Software DritteBeispieldatensätze können das Paket integriert werdenBeispieldatensätze können das Paket integriert werden","code":""},{"path":"pakete.html","id":"struktur","chapter":"Kapitel 12 Pakete","heading":"12.1 Struktur","text":"Ein Paket besteht aus einigen Standard–Dateien und Verzeichnissen:DESCRIPTION: Informationen über das Paket (Autor,\nLizenz, Titel, Abhängigkeiten, …)R/: R Code .R Dateienman/: Dokumentationen (im *.Rd Format) der einzelnen FunktionenNAMESPACE: Information über die zu “exportierenden” Funktionendata/: Datenbeispielesrc/: kompilierter C, C++ oder Fortran Codetests/: Testroutinen zur Validierung des PaketsBei der Erzeugung der Struktur (wie auch weiteren Schritten bei der Entwicklung) sollte man viel wie möglich automatisieren. Wir verwenden dazu die von Hadley Wickham bereitgestellten Werkzeuge.Falls noch nicht geschehen, solltet ihr die Pakete devtools, roxygen2 und testthat installierenDiese Pakete erleichtern Kombination mit RStudio das Erstellen von Paketen.","code":"\ninstall.packages(c(\"devtools\", \"roxygen2\", \"testthat\"))"},{"path":"pakete.html","id":"c-compiler","chapter":"Kapitel 12 Pakete","heading":"12.2 C Compiler","text":"Um alle Möglichkeiten bei der Erstellung von R-Paketen ausnützen zu können, benötigt man zusätzlich noch einen C Compiler und ein paar andere Werkzeuge. Dies ist aber vermutlich erst dann wirklich nötig, wenn ihr Pakete bauen wollt, die C- oder C++-Code enthalten (nicht Teil des Kurses). RStudio sollte dich auch warnen und dir Unterstützung anbieten, sobald du versuchen solltest, etwas zu tun, das die Einrichtung einer Entwicklungsumgebung erfordert.Mit has_devel() könnt ihr aber auch schon jetzt überprüfen ob euer System vielleicht schon bereit dazu wäreDies scheint bei mir der Fall zu sein.","code":"\nlibrary(devtools)\nhas_devel()## Your system is ready to build packages!"},{"path":"pakete.html","id":"r-code","chapter":"Kapitel 12 Pakete","heading":"12.3 R Code","text":"Das Verzeichnis R/ ist der wichtigste Bestandteil eines Pakets, da dort der komplette R Code liegt.\nDieses Verzeichnis (wie auch andere Teile) erzeugt man mit der Funktion devtools::create(), z.B.Dieser Befehl erzeugt das Verzeichnis Pfad_zum_Paket/Paketname, welcheseine RStudio Projektdatei, Paketname.Rprojein R/ Verzeichniseine DESCRIPTION Dateieine NAMESPACE Dateienthält. Allen R Code, der im Paket enthalten sein soll, kopiert man anschließend das Verzeichnis Pfad_zum_Paket/Paketname/R.Innerhalb eines Pakets ist es nun einfach den kompletten R Code (nach Änderungen) neu zu laden.devtools::load_all() lädt allen R Code neu. RStudio auch über Strg + Shift + L möglich.RStudio kann man mit Strg + Shift + B das Paket installieren, R neu starten und anschließend das Paket über library() neu laden.Dadurch ergibt sich der folgende ArbeitsablaufR Dateien im Editor bearbeitenStrg + Shift + L (oder Strg + Shift + B) ausführenCode der Konsole überprüfenDas Ganze (falls nötig) wiederholen","code":"\ncreate(\"Pfad_zum_Paket/Paketname\")"},{"path":"pakete.html","id":"verschiedene-typen","chapter":"Kapitel 12 Pakete","heading":"12.4 Verschiedene Typen","text":"Man unterscheidet fünf verschiedene Typen: source, bundled, binary, installed und memory.source: Die source Version eines Pakets besteht aus dem Verzeichnis Paketnamesource: Die source Version eines Pakets besteht aus dem Verzeichnis Paketnamebundled: Komprimiert man das Verzeichnis eine .tar.gz Datei spricht man von einem “gebündelten” Paket. Dieser Typ stellt eher einen Zwischenschritt dar. Mit devtools::build() kann aber eine solche Version erzeugt werden. Weitere Unterschiede zu einer source Version sind für uns erst mal nicht von Interesse.bundled: Komprimiert man das Verzeichnis eine .tar.gz Datei spricht man von einem “gebündelten” Paket. Dieser Typ stellt eher einen Zwischenschritt dar. Mit devtools::build() kann aber eine solche Version erzeugt werden. Weitere Unterschiede zu einer source Version sind für uns erst mal nicht von Interesse.binary: Ein gebündeltes Paket kann von anderen R Nutzern nur installiert werden, wenn sie selbst über die entsprechenden “Werkzeuge” (Rtools, …) verfügen. Binary Pakete bestehen auch nur aus einer Datei, können aber von anderen R Nutzern auch ohne weitere “Werkzeuge” installiert werden. Allerdings sind binary Pakete plattformspezifisch. Ein Windows binary Paket kann also z.B. nicht auf einem Mac installiert werden. Erzeugt wird eine binary Version z.B. mit devtools::build(binary = TRUE).binary: Ein gebündeltes Paket kann von anderen R Nutzern nur installiert werden, wenn sie selbst über die entsprechenden “Werkzeuge” (Rtools, …) verfügen. Binary Pakete bestehen auch nur aus einer Datei, können aber von anderen R Nutzern auch ohne weitere “Werkzeuge” installiert werden. Allerdings sind binary Pakete plattformspezifisch. Ein Windows binary Paket kann also z.B. nicht auf einem Mac installiert werden. Erzeugt wird eine binary Version z.B. mit devtools::build(binary = TRUE).installed: Ein installiertes Paket ist ein eine R Library entpacktes binary Paket. Zu diesem Zustand kann man über mehrere Wege gelangen, z.B.\ninstall.packages(): CRAN binary -> installed\ninstall.packages(type = source): CRAN source -> bundled -> installed\ninstall(): source -> installed\ninstalled: Ein installiertes Paket ist ein eine R Library entpacktes binary Paket. Zu diesem Zustand kann man über mehrere Wege gelangen, z.B.install.packages(): CRAN binary -> installedinstall.packages(type = source): CRAN source -> bundled -> installedinstall(): source -> installedMit devtools::install_github() können source Pakete aus eine GitHub Projekt installiert werden, und mit devtools::_install_gitlab() aus einem GitLab Projekt.memory: man mit mehreren Funktionen eines Paket arbeiten, sollte es den Speicher geladen werden. Dies geschieht mit library() (installierte Pakete) oder load_all() (beim Entwickeln von Paketen).","code":""},{"path":"pakete.html","id":"description","chapter":"Kapitel 12 Pakete","heading":"12.5 DESCRIPTION","text":"Die DESCRIPTION Datei enthält Informationen über das Paket und ist ein essentieller Bestandteil jedes Pakets. Der Befehlerzeugt die DESCRIPTION Dateiim Ordner meinR4EWSpckg.Die wichtigsten Felder einer DESCRIPTION Datei sind dadurch vorhanden (und müssen gefüllt werden). Über die Punkte Imports und Suggests (nicht automatisch vorhanden) kann festgelegt werden welche anderen R Pakete zwingend notwendig bzw. hilfreich sind für das eigene Paket.Pakete Imports werden beim Installieren des eigenen Pakets ebenfalls installiert, falls diese noch nicht vorhanden sind. Pakete Suggests werden nicht automatisch installiert.Überkann z.B. das Paket dplyr dem Punkt Imports hinzugefügt werden. usethis::use_package(type = \"Suggests\") fügt Suggests weitere Pakete hinzu.","code":"\nusethis::create_package(\"meinR4EWSpckg\")Package: meinR4EWSpckg\nType: Package\nTitle: What the Package Does (Title Case)\nVersion: 0.1.0\nAuthor: Who wrote it\nMaintainer: The package maintainer <yourself@somewhere.net>\nDescription: More about what it does (maybe more than one line)\n    Use four spaces when indenting paragraphs within the Description.\nLicense: What license is it under?\nEncoding: UTF-8\nLazyData: true\nusethis::use_package(\"dplyr\")"},{"path":"pakete.html","id":"name-titel-beschreibung","chapter":"Kapitel 12 Pakete","heading":"12.5.1 Name, Titel, Beschreibung","text":"Der Name (Package) eines Pakets darf Buchstaben, Zahlen und . enthalten und sollte mit dem Verzeichnisname übereinstimmen.Title und Description sollten beschreiben das Paket genau macht. Description ist dabei deutlich ausführlicher und enthält daher .d.R. mehrere Zeilen. Nach einem Zeilenumbruch sollte 4 Leerzeichen eingerückt werden. Ein Beispiel wäre","code":"Title: An implementation of the Grammar of Graphics\nDescription: An implementation of the grammar of graphics in R. \n    It combines the advantages of both base and lattice graphics: \n    conditioning and shared axes are handled automatically, and \n    you can still build up a plot step by step from multiple data \n    sources. It also implements a sophisticated multidimensional \n    conditioning system and a consistent interface to map data \n    to aesthetic attributes. See the ggplot2 website for more \n    information, documentation and examples."},{"path":"pakete.html","id":"autoren","chapter":"Kapitel 12 Pakete","heading":"12.5.2 Autoren","text":"Über das Feld Authors@R können die Autoren des Pakets angegeben werden. dieser Stelle kann\nder DESCRIPTION Datei R Code verwendet werden um die nötigen Informationengiven, family: Vor- und Nachnameemail: E-Mailadresserole: Rolle der Person. Wichtige Beispiele sind\ncre: Ersteller oder Maintainer\naut: hat wichtige Beiträge zum Paket erbracht\nctb: hat kleinere Beiträge zum Paket erbracht\ncre: Ersteller oder Maintaineraut: hat wichtige Beiträge zum Paket erbrachtctb: hat kleinere Beiträge zum Paket erbrachtMit der Funktion person() können diese Informationen nun angegeben werdenDer Output von person() sieht dann folgendermaßen aus","code":"Authors@R: person(given = \"Stephan\", family = \"Haug\", \n                  email = \"haug@tum.de\", \n                  role = c(\"cre\", \"aut\"))\nperson(given = \"Stephan\", family = \"Haug\", \n                  email = \"haug@tum.de\", \n                  role = c(\"cre\", \"aut\"))## [1] \"Stephan Haug <haug@tum.de> [cre, aut]\""},{"path":"pakete.html","id":"version","chapter":"Kapitel 12 Pakete","heading":"12.5.3 Version","text":"devtools::create() legt die Default-Version auf 0.1.0 fest. Generell sollte die Versionsnummer aus drei Teilen bestehen und die Form x.y.z haben, wobei x die Nummer für größere Updates, y die Nummer für kleinere Updates und z die Nummer für Korrekturen ist.Die aktuelle Version von ggplot2 ist z.B.Für Pakete, die sich der Entwicklung befinden, bietet es sich noch einen vierten Teil anzufügen und mit der Versionsnummer 0.0.0.9000 zu starten.Nach diesen Anpassung könnte die DESCRIPTION Datei also aussehenDer Punkt Lizenz ist für erstmal nachgeordnet. Wer aber mehr über die Wahl einer passenden Lizenz erfahren möchte, den verweisen wir gerene auf das Kapitel Licensing R packages.","code":"\npackageVersion(\"ggplot2\")## [1] '3.5.1'Package: meinR4EWSpckg\nType: Package\nTitle: Paket zu R4ews, das ...\nVersion: 0.0.0.9000\nAuthors@R: person(given = \"Stephan\", family = \"Haug\", \n                  email = \"haug@tum.de\", \n                  role = c(\"cre\", \"aut\"))\nDescription: Paket, das im Rahmen des R Projekts R4ews entstanden ist.\n    Das Paket bietet ...\nLicense: What license is it under?\nEncoding: UTF-8\nLazyData: true\nImports: \n    dplyr"},{"path":"pakete.html","id":"pakete-dokumentation","chapter":"Kapitel 12 Pakete","heading":"12.6 Pakete: Dokumentation","text":"Ein wichtiger Teil eines Pakets ist die ausreichende Dokumentation (wichtiger) Funktionen. Dokumentationen werden als .Rd (LaTeX ähnliches Format) Dateien im Verzeichnis man/ abgelegt. Das Paket roxygen2 bietet eine komfortable Möglichkeit aus Funktionskommentaren (einem speziellen Format) eine .Rd Datei zu erzeugen.Ablauf:roxygen Kommentare die .R Datei einfügendevtools::document() ausführen um Kommentare .Rd Datei zu konvertierenDokumentation mit ? betrachtengegebenenfalls alles wiederholenroxygen Kommentare beginnen mit #'.Wir fügen eine Datei add_2.R mit Inhaltdem Verzeichnis meinR4EWSpckg/R hinzu.Der Befehl devtools::document() (ausgeführt im Verzeichnis meinR4EWSpckg - source Paket) erzeugt dann die Datei meinR4EWSpckg/man/add_2.RdAlle roxygen Kommentare beginnen mit #' und sind unterteilt verschiedene Tags der Form @name_tag beschreibung. Vor dem ersten Tag kommen allerdingsTitel: erste Zeile des KommentarsBeschreibung der Funktion: zweiter Abschnitt des Kommentars (länger als Titel)Details zur Funktion: dritter Abschnitt des Kommentars (länger als die Beschreibung) - optionalIn unserem Beispiel wurde der Titel auch gleich als Beschreibung (da nicht explizit angegeben) verwendet.Die drei wichtigsten Tags zum Kommentieren einer Funktion sind: @param, @examples und @return.\nWeitere Tags sind im Abschnitt Documenting functions des Buchs R packages beschrieben.Mit den Befehlen \\emph{}, \\strong{}, \\code{} und \\pkg{} (Paketname) kann der Text formatiert werden.Ebenso können Links zu anderen Dokumentationen\\code{\\link{function}}: Funktion function im eigenen Paket\\code{\\link[devtools]{load_all}}: Funktionen aus anderen Paketen, hier devtools::load_alloder dem Netz\\url{http://rstudio.com}\\href{http://rstudio.com}{RStudio}\\email{haug@@tum.de} (@@ ist nötig, da @ für die Tags reserviert ist)Weitere Möglichkeiten der Formatierung findet man im Abschnitt Text formatting des Buch R packages.","code":"#' Addiere zwei Zahlen\n#' \n#' @param x Eine Zahl.\n#' @param y Eine Zahl.\n#' @return Die Summe von \\code{x} und \\code{y}.\n#' @examples\n#' add_2(1, 1)\n#' add_2(10, 1)\nadd_2 <- function(x, y) {\n  x + y\n}% Generated by roxygen2 (4.0.2): do not edit by hand\n\\name{add_2}\n\\alias{add_2}\n\\title{Addiere zwei Zahlen}\n\\usage{\nadd_2(x, y)\n}\n\\arguments{\n\\item{x}{Eine Zahl.}\n\n\\item{y}{Eine Zahl.}\n}\n\\value{\nDie Summe von \\code{x} und \\code{y}.\n}\n\\description{\nAddiere zwei Zahlen\n}\n\\examples{\nadd_2(1, 1)\nadd_2(10, 1)\n}\n"},{"path":"pakete.html","id":"namespace","chapter":"Kapitel 12 Pakete","heading":"12.7 NAMESPACE","text":"Es ist nicht nur für das Erstellen von Paketen hilfreich das Konzept eines NAMESPACE verstanden zu haben, sondern auch für das generelle Arbeiten mit R. Man unterscheidet dabei Import NAMESPACES und Export NAMESPACES.Import legt dabei fest wie die Funktion eines Pakets eine Funktion einem anderen Paket findet. Betrachten wir z.B.Diese Funktion ist definiert Abhängigkeit von dim() aus dem base Paket.Auch wenn wir die Funktiondefinieren, findet nrow() trotzdem die “richtige” Funktionda sie den NAMESPACE des base Pakets verwendet.Export legt fest welche Funktionen eines Pakets außerhalb des Pakets zur Verfügung stehen sollen. Dies müssen/sollten nicht alle Funktionen sein. Ein Paket kann also interne Funktionen haben, die nur intern verwendet werden können.Über den Operator :: wird explizit auf den NAMESPACE eines Pakets zugegriffen. Auf diese Art und Weise vermeidet man auch Konflikte zwischen Funktionen aus verschiedenen Paketen, die aber den gleichem Namen haben. einem solchen Fall kommt es darauf welches Paket zuletzt geladen wurde. Dieses findet man dann zuerst im SuchpfadIn der NAMESPACE Datei beschreibenexport(): exportiert FunktionenexportPattern(): exportiert alle Funktionen, die zu einem bestimmten Schema passenS3method(): exportiert S3 Methodenden Export undimport(): importiert alle Funktionen aus einem PaketimportFrom(): importiert eine bestimmte Funktion aus einem PaketuseDynLib(): importiert eine Funktion aus Cden Import.Export-Einträge der NAMESPACE Datei können leicht über roxygen Kommentare erzeugt werden.\nÜber einen @export Tag wird angegeben welche Funktion exportiert werden sollJe nach Objekttyp wird dann export(), exportPattern() oder S3method() im NAMESPACE verwendet. Generell sollte man sich die Regel halten lieber weniger als mehr Funktionen zu exportieren, wenn man das Paket Dritte weitergeben .Beim Importieren sollte man noch restriktiver sein. Man sollte über Imports der DESCRIPTION Datei sicherstellen, dass alle notwendigen Pakete installiert und geladen sind. Danach kann einfach über den :: Operator eigenen Funktionen auf Funktionen aus anderen geladenen Paketen zugegriffen werden, also z.B. pkg_name::funktion_aus_pkg_name().Dies erhöht die spätere Lesbarkeit der eigenen Programme und vermeidet potentielle Konflikte, die beim Importieren mehrerer Pakete - die dann wieder Funktionen mit gleichem Namen besitzen - auftreten können.Muss eine Funktion häufig verwendet werden - und man nicht dauernd :: verwenden - sollte man über importFrom() eher nur die Funktion und nicht das ganze Paket importieren.","code":"\nnrow## function (x) \n## dim(x)[1L]\n## <bytecode: 0x11bdba388>\n## <environment: namespace:base>\ndim <- function(x) c(1,1)\ndim(mtcars)## [1] 1 1\nnrow(mtcars)## [1] 32\nsearch()##  [1] \".GlobalEnv\"        \"package:devtools\"  \"package:usethis\"  \n##  [4] \"package:stats\"     \"package:graphics\"  \"package:grDevices\"\n##  [7] \"package:utils\"     \"package:datasets\"  \"package:methods\"  \n## [10] \"Autoloads\"         \"package:base\"#' @export\nexport_function <- function(...){\n  ... \n}"},{"path":"pakete.html","id":"daten-einbinden","chapter":"Kapitel 12 Pakete","heading":"12.8 Daten einbinden","text":"Daten, die das Paket enthalten sollte, legt man im Verzeichnis /data ab. Als Format sollte man .rda wählen (ist aber kein Muss). Der einfachste Weg dies zu berücksichtigen ist die Funktion usethis::use_data() zu verwenden.Dieser Befehl speichert die Objekte x und mtcars den Dateien data/x.rda und data/mtcars.rda ab. Der Dateiname stimmt also mit dem Objektnamen überein.Datensätze sollten auf jeden Fall dokumentiert werden. Dazu fügt man einfach eine der .R Dateien im Verzeichnis /R einen weiteren roxygen2 Absatz ein. Für das Dokumentieren von Datensätzen stehen zwei weitere Tags bereit. Über @format beschreibt man das genaue Format der Daten, z.B. die einzelnen Spalten eines Data Frames, und mit @source gibt man (falls vorhanden) die Datenquelle .Die Beschreibung des Datensatzes x könnte also z.B. aussehen","code":"\nx <- sample(1:100, 50, replace = TRUE)\nusethis::use_data(x, mtcars)#' Mein Datensatz\n#' \n#' Ein Datensatz bestehend aus 50 Zahlen gezogen aus den \n#' Zahlen 1 bis 100 mit Zuruecklegen\n#' \n#' @format Ein Integer Vektor der Laenge 50\n\"x\""},{"path":"pakete.html","id":"c-special-topic","chapter":"Kapitel 12 Pakete","heading":"12.9 C++ (Special Topic)","text":"man seinem Paket R Funktionen verwenden, die mithilfe von Rcpp aus kompiliertem C++ Code entstanden sind, sollte man zur Vorbereitungausführen. Danach ist das das Verzeichnis /src angelegt und Rcpp zu den Feldern LinkingTo und Imports der DESCRIPTION Datei hinzugefügt. Außerdem wird man aufgefordert die roxygen Tagsin eine der .R Dateien einzufügen.Ebenso wie die .R Dateien kann auch die .cpp Dateien die roxygen Dokumentation eingefügt werden. Allerdings verwendet man //' statt #'.","code":"\nusethis::use_rcpp()#' @useDynLib meinR4EWSpckg\n#' @importFrom Rcpp sourceCpp#include <Rcpp.h>\nusing namespace Rcpp;\n\n//' Multipliziere eine Zahl mit 2\n//' \n//' @param x Ein Integer.\n//' @export\n// [[Rcpp::export]]\nint malZwei(int x) {\n   return x * 2;\n}"},{"path":"pakete.html","id":"git-und-githubgitlab","chapter":"Kapitel 12 Pakete","heading":"12.10 Git und GitHub/GitLab","text":"Jedes Pakete (mag es auch noch klein sein) sollte unter Verwendung von Git erstellt werden. Beim Anlegen des Projekts (zur Erstellung des Pakets) über RStudio, kann leicht ein lokales Git repository initialisiert werdenSoll zusätzlich ein remote repository verwendet werden, kann man (im Standardfall) ein neues repository auf GitLab (oder GitHub) anlegen. Es sollte den gleichen Namen bekommen wie das Paket (lokales Git repository). Danach kann man im Terminal Befehle der Formausführen.Angenommen es existiert bereits ein remote repository und das Paket soll dort “verwaltet” werden, kann einfach dieses repository geklont werdenDanach existiert im Verzeichnis, dem der Befehl ausgeführt wurde, das Unterverzeichnis paketName. R kann anschließend den Befehlausgeführt werden (im Verzeichnis, welches das Git repository paketName enthält). Danach sichert man alle Änderungen s über einen commit Befehlund pusht","code":"git remote add origin https://gitlab.lrz.de/vw99xyz/paketName.git\ngit push -u origin mastergit clone https://gitlab.lrz.de/vw99xyz/paketName.git\ndevtools::create(\"paketName\")git add .\ngit commit -m \"paket struktur angelegt\"git push"},{"path":"pakete.html","id":"literatur-2","chapter":"Kapitel 12 Pakete","heading":"12.11 Literatur","text":"Dieser Abschnitt hat einen kleinen Einblick das Erstellen eigener Pakete gegeben. Allerdings wurden viele weitere Aspekte nicht angesprochen. Weitere Informationen zu R Paketen findet man z.B. im Buch R packages von Hadley Wickham (2015b).","code":""},{"path":"funktionen.html","id":"funktionen","chapter":"Kapitel 13 Funktionen","heading":"Kapitel 13 Funktionen","text":"Wie jeder anderen Programmierumgebung, besteht auch R die Möglichkeit eigene Funktionen zu definieren.Eine der wichtigsten Erkenntnisse dabei ist die Tatsache, dass auch Funktionen Objekte sind. Generell ist R alles ein Objekt.Neue Funktionen werden mit der Funktion function() erzeugt.","code":""},{"path":"funktionen.html","id":"bestandteile-von-funktionen","chapter":"Kapitel 13 Funktionen","heading":"13.1 Bestandteile von Funktionen","text":"Alle R Funktionen bestehen aus den drei Teilen:formals(), Argumente, die den Funktionsaufruf “regeln”body(), der eigentliche Codeenvironment(), Verweis auf die Funktionseingabe","code":"\nf <- function(x) x + sin(x)\nformals(f)## $x\nbody(f)## x + sin(x)\nenvironment(f)## <environment: R_GlobalEnv>"},{"path":"funktionen.html","id":"body","chapter":"Kapitel 13 Funktionen","heading":"13.2 body()","text":"Wie alle Objekte R, besitzen auch Funktionen Attribute. Ein data frame besitzt z.B. die Attribute names, class und row.namesEine Funktion besitzt hingegen die AttributeDen Unterschied zu body() sehen wir im folgenden Beispiel.","code":"\nattributes(iris)## $names\n## [1] \"Sepal.Length\" \"Sepal.Width\"  \"Petal.Length\" \"Petal.Width\"  \"Species\"     \n## \n## $class\n## [1] \"data.frame\"\n## \n## $row.names\n##   [1]   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18\n##  [19]  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36\n##  [37]  37  38  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54\n##  [55]  55  56  57  58  59  60  61  62  63  64  65  66  67  68  69  70  71  72\n##  [73]  73  74  75  76  77  78  79  80  81  82  83  84  85  86  87  88  89  90\n##  [91]  91  92  93  94  95  96  97  98  99 100 101 102 103 104 105 106 107 108\n## [109] 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126\n## [127] 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144\n## [145] 145 146 147 148 149 150\nattributes(f)## NULL\nf <- function(x){\n  # Summe von x und sin(x)#\n  x + sin(x)\n}\nbody(f)## {\n##     x + sin(x)\n## }\nattr(f, \"srcref\")## NULL"},{"path":"funktionen.html","id":"einfache-funktionen","chapter":"Kapitel 13 Funktionen","heading":"13.3 “Einfache” Funktionen","text":"Es gibt eine Ausnahme von der obigen Regel, dass Funktionen aus drei Teilen bestehen. Die primitive functions wie sum(), sin() oder exp() rufen direkt über die Funktion .Primitive() C Code auf, enthalten somit keinen R Code und daher sind alle drei Teile gleich NULL.","code":"\nformals(sin)## NULL\nbody(sin)## NULL\nenvironment(sin)## NULL"},{"path":"funktionen.html","id":"jede-operation-ist-ein-funktionsaufruf","chapter":"Kapitel 13 Funktionen","heading":"13.4 Jede Operation ist ein Funktionsaufruf","text":"“understand computations R, two slogans helpful:\nEverything exists object.\nEverything happens function call.”\n— John ChambersAlle Operationen bestehen aus Funktionsaufrufen. Somit auch +, -, /,:, , , oder []und $. Dies sieht man z.B. diesem Beispieloder auch diesem BeispielenDie Verwendung von ` erlaubt den Zugriff auf reservierte Ausdrücke.Eine sinnvolle Anwendung dieser Zugriffsmethode liegt der Kombination mit den apply Funktionen (apply(), lapply(), sapply, mapply(), tapply()). Diese wenden eine zu übergebende Funktion auf weitere Inputgrößen wie Listen oder Data Frames .sapply() ist eine Version von lapply(), die - wenn möglich - eine “vereinfachte” Ausgabe liefert.","code":"\nx <- 10 \ny <- 5\nx + y## [1] 15\n`+`(x, y)## [1] 15\nfor (i in 1:2) print(i)## [1] 1\n## [1] 2\n`for`(i, 1:2, print(i))## [1] 1\n## [1] 2\nx[3]## [1] NA\n`[`(x, 3)## [1] NA\nx <- list(1:3, 4:9, 10:12)\nsapply(x, `[`, 2)## [1]  2  5 11\nsapply(x, function(x) x[2])## [1]  2  5 11\nx <- list(1:3, 4:6, 7:9)\nlapply(x, `+`, 3)## [[1]]\n## [1] 4 5 6\n## \n## [[2]]\n## [1] 7 8 9\n## \n## [[3]]\n## [1] 10 11 12\nis.matrix(sapply(x, `+`, 3))## [1] TRUE"},{"path":"funktionen.html","id":"funktionsargumente","chapter":"Kapitel 13 Funktionen","heading":"13.5 Funktionsargumente","text":"Funktionen besitzen formelle Argumente, denen beim Funktionsaufruf (oder per Default) Werte zugewiesen werden. Beim Aufruf können die Argumente durch ihre Position, den vollen oder teilweisen Namen ausgewählt werden.Der folgende Aufruf kann aber nicht funktionieren.Generell sollte man die zwei, drei wichtigsten Inputgrößen den Beginn stellen. Alle anderen sollten eher nicht durch die Position ausgewählt werden. Dabei ist der vollständige Namen sicherlich zu bevorzugen.Funktionsargumenten können Default-Werte zugeordnet werden. Dabei können Default-Werte auch Abhängigkeit anderer Argumente definiert werden.","code":"\nf <- function(abc, bcd, bdc) c(abc, bcd, bdc)\nf(3, 2, 1)## [1] 3 2 1\nf(2, 1, abc=3)## [1] 3 2 1\nf(2, 1, a=3)## [1] 3 2 1\nf(3, b=2, 1)## Error in f(3, b = 2, 1): argument 2 matches multiple formal arguments\nf <- function(a = 1, b = 2) {\n  c(a, b)\n}\nf()## [1] 1 2\ng <- function(a = 1, b = a * 2) {\n  c(a, b)\n}\ng(a=10)## [1] 10 20"},{"path":"funktionen.html","id":"funktionsargumente-lazy-evaluation","chapter":"Kapitel 13 Funktionen","heading":"13.6 Funktionsargumente: Lazy Evaluation","text":"R wertet Funktionsargumente nur aus, wenn diese tatsächlich benützt werden. Dies entspricht der Idee der Lazy Evaluation.Mit force() kann man die Auswertung eines Arguments erzwingen.Benutzt man eine verschachtelte Funktion Kombination mit lapply() oder einer Schleife, kann die Lazy Evaluation entscheidend sein.x wird beim ersten Aufruf von addiere_zu_1bis10() ausgewertet. Bis dahin ist x aber bereits von 1 bis 10 “gelaufen” und hat damit den Wert 10. Somit wird stets 10 zum Input addiert.Erzwingt man die Auswertung, erhält man das gewünschte Ergebnis.Bisher schien die Lazy Evaluation eher nachteilig. Sie kann aber auch Vorteile haben. Die Befehleerzeugen keinen Fehler, obwohl NULL>0 keinen zulässigen Input für darstellt. Da !.null(x) bereits FALSE liefert, wird die zweite Abfrage nicht mehr ausgewertet.Hauptvorteil ist aber die Effizienz. Nur notwendige Ausdrücke werden ausgewertet.","code":"\nf <- function(x) {\n  10\n}\nf(stop(\"x ist nicht 10\"))## [1] 10\nf <- function(x) {\n  force(x)\n  10\n}\nf(stop(\"x ist nicht 10\"))## Error in force(x): x ist nicht 10\naddiere_x <- function(x){\n  function(y) x+y\n}\naddiere_zu_1bis10 <- lapply(1:10, addiere_x)\naddiere_zu_1bis10[[1]](10)## [1] 11\naddiere_zu_1bis10[[5]](10)## [1] 15\naddiere_x <- function(x){\n  force(x)\n  function(y) x+y\n}\naddiere_zu_1bis10 <- lapply(1:10, addiere_x)\naddiere_zu_1bis10[[1]](10)## [1] 11\naddiere_zu_1bis10[[5]](10)## [1] 15\nx <- NULL\nif (!is.null(x) && x > 0) {\n\n}"},{"path":"funktionen.html","id":"funktionsargumente-...","chapter":"Kapitel 13 Funktionen","heading":"13.7 Funktionsargumente: ...","text":"Für eine Funktion kann das formale ... Drei-Punkte Argument verwendet werden. Alle nicht über Position und/oder Name zugeordneten Argumente werden durch ... aufgenommen. der Regel werden über ... Argumente übergeben, die innerhalb der Funktion andere Funktionen weitergegeben werden.... erhöht also offensichtlich die Flexibilität. Ein Nachteil ist, dass falsch geschriebene Argumente keinen Fehler erzeugen und alle Argumente nach ... voll ausgeschrieben werden müssen.","code":"\nsumme_plus2 <- function(x, ...){\n  x <- x+2\n  sum(x, ...)\n}\nsumme_plus2(c(1, 3, 5))## [1] 15\nsumme_plus2(c(1, 3, NA), na.rm = TRUE)## [1] 8\nsum(1, 2, NA, rm.na = TRUE)## [1] NA\nsum(1, 2, NA, na.rm = TRUE)## [1] 3"},{"path":"funktionen.html","id":"funktionsrückgabe","chapter":"Kapitel 13 Funktionen","heading":"13.8 Funktionsrückgabe","text":"Wir haben den Beispielen bereits gesehen wie die Rückgabe funktioniert. Der letzte Ausdruck, der ausgewertet wird, bildet die Rückgabe.Falls bereits zu einem früheren Zeitpunkte eine Rückgabe erfolgen soll (z.B. STOP Kriterium erfüllt) und diese speziell gekennzeichnet werden soll, kann die Funktion return() verwendet werden.Funktionen können nur ein Objekt zurückgeben. Soll die Ausgabe einer Funktion aus mehreren Objekten bestehen, schreibt man diese einfach eine Liste und gibt die Liste zurück.","code":"\nf <- function(x) {\n  if (x < 10) {\n    0\n  } else {\n    10\n  }\n}\nf(5)## [1] 0\nf(15)## [1] 10\nf <- function(x) {\n  if (x < 10) {\n    n_output <- 0\n    t_output <- \"eingabe war kleiner 10\"\n  } else {\n    n_output <- 10\n    t_output <- \"eingabe war größer oder gleich 10\"\n\n  }\n  \n  output <- list(n_output, t_output)\n  return(output) \n}\nf(5)## [[1]]\n## [1] 0\n## \n## [[2]]\n## [1] \"eingabe war kleiner 10\"\nf(15)## [[1]]\n## [1] 10\n## \n## [[2]]\n## [1] \"eingabe war größer oder gleich 10\""},{"path":"funktionen.html","id":"mehr-zu","chapter":"Kapitel 13 Funktionen","heading":"13.9 mehr zu …","text":"Wenn ihr mehr zufunctionsenvironmentsfunctional programmingobject-oriented programming…wissen wollt, dann findet ihr (fast) alle Antworten auf eure Fragen im Buch Advanced R von Hadley Wickham (2015a).","code":""},{"path":"envscop.html","id":"envscop","chapter":"Kapitel 14 Environments und Scoping","heading":"Kapitel 14 Environments und Scoping","text":"","code":""},{"path":"envscop.html","id":"zuordnungen","chapter":"Kapitel 14 Environments und Scoping","heading":"14.1 Zuordnungen","text":"Wie weiß R welchen Wert es welchem Symbol zuordnen soll?Warum wählt R nicht die Standardfunktion sqrt() aus dem base Paket?Wenn R einem Symbol einen Wert zuordnet, dann durchsucht R eine Reihe von environments (bereits im Abschnitt Funktionen gesehen) nach dem passenden Wert. Gesucht wird folgender ReihenfolgeDas Global Environment wird durchsucht.Die namespaces (dazu später mehr) der Pakete auf der search Liste werden durchsucht.Das global environment (der Workspace) wird immer zuerst und base immer zuletzt durchsucht.Die search Liste wird also beeinflusst durch die von uns geladenen Pakete.Man beachte, dass R die Namen von Daten- und Funktionsobjekten unterscheiden kann.","code":"\nsqrt(2)## [1] 1.414214\nsqrt <- function(x) x^2\nsqrt(2)## [1] 4\nsearch()## [1] \".GlobalEnv\"        \"package:stats\"     \"package:graphics\" \n## [4] \"package:grDevices\" \"package:utils\"     \"package:datasets\" \n## [7] \"package:methods\"   \"Autoloads\"         \"package:base\"\nlibrary(ggplot2)\nsearch()##  [1] \".GlobalEnv\"        \"package:ggplot2\"   \"package:stats\"    \n##  [4] \"package:graphics\"  \"package:grDevices\" \"package:utils\"    \n##  [7] \"package:datasets\"  \"package:methods\"   \"Autoloads\"        \n## [10] \"package:base\"\n(sqrt <- 2)## [1] 2\nsqrt(2)## [1] 1.414214"},{"path":"envscop.html","id":"environments","chapter":"Kapitel 14 Environments und Scoping","heading":"14.2 Environments","text":"Ein Environment verbindet eine Menge von Namen mit einer entsprechenden Menge von Werten. Environments sind ähnlich zu einer Liste, aber es gibt entscheidende Unterschiededie Namen der Objekte einem Environment sind eindeutigdie Objekte eines Environments sind nicht geordnetjedes Environment besitzt ein parent Environment, außer emptyenv()Die Einträge von search() sind die Eltern des Global Environment. Mit new.env() kann auch ein neues Environment erzeugt werden.Bemerkung: Die meisten Environments erzeugt man durch die Verwendung von Funktionen.","code":"\nneues_env <- new.env()\nneues_env$eins <- c(1, 2)\nneues_env$zwei <- c(\"a\", \"b\")\nls(neues_env)## [1] \"eins\" \"zwei\"\nparent.env(neues_env)## <environment: R_GlobalEnv>"},{"path":"envscop.html","id":"scoping-rules","chapter":"Kapitel 14 Environments und Scoping","heading":"14.3 Scoping Rules","text":"Der Sichtbarkeitsbereich von Variablen (Scope) wird über Scoping Rules festgelegt. R verwendet static scoping oder auch lexical scoping genannt (eine Alternative ist das dynamic scoping).f hat die formellen Argumente x und y sowie die freie Variable z. Die Scoping Rule bestimmt wie Werte freien Variablen zugeordnet werden. R bedeutet diesDer Wert freier Variablen (einer Funktion) wird dem Environment gesucht, dem die Funktion definiert wurde.","code":"\nf <- function(x, y){\n  x + y/z\n}"},{"path":"envscop.html","id":"static-scoping","chapter":"Kapitel 14 Environments und Scoping","heading":"14.4 Static scoping","text":"Oftmals werden Funktionen im Globalen Environment definiert. Die Werte freier Variablen sollten dann im Workspace zu finden sein. Dieses “Verhalten” wird von den meisten “Nutzern” erwartet und als sinnvoll angesehen.Allerdings können Funktionen auch innerhalb von Funktionen definiert werden. diesem Fall ist das Environment der body einer anderen Funktion.bilde_potenz() liefert somit eine Funktion als Ausgabe.Sucht man nach einer Variable und/oder möchte man ihren Wert ausgeben, kann man mit den Funktionen exists() und get() arbeiten. Beide verwenden static scoping.Schauen wir uns nun den closure (Funktion + zugehöriges Environment) von zweite_potenz() und dritte_potenz() genauer .","code":"\nbilde_potenz <- function(n){\n  potenz <- function(x)\n    x^n\n}\nzweite_potenz <- bilde_potenz(2)\ndritte_potenz <- bilde_potenz(3)\nget(\"eins\", envir = neues_env)## [1] 1 2\nx <- 1\nexists(\"x\", envir = neues_env)## [1] TRUE\nexists(\"x\", envir = neues_env, inherits = FALSE)## [1] FALSE\nls(environment(zweite_potenz))## [1] \"n\"      \"potenz\"\nget(\"n\", envir = environment(zweite_potenz))## [1] 2\nls(environment(dritte_potenz))## [1] \"n\"      \"potenz\"\nget(\"n\", envir = environment(dritte_potenz))## [1] 3"},{"path":"envscop.html","id":"anwendungsbeispiel","chapter":"Kapitel 14 Environments und Scoping","heading":"14.5 Anwendungsbeispiel","text":"Wir betrachten als Anwendungsbeispiel die Minimierung der Funktion\\[\n  l_x(\\mu,\\sigma^2) =-\\left(-\\frac{n}{2}\\log(2\\pi\\sigma^2)-\\frac1{2\\sigma^2}\\sum_{=1}^n(x_i-\\mu)^2\\right)\\,,\n  \\]\nwobei \\(x_i, =1,\\dots,n,\\) bekannte Größen sind. Die obigen Funktion ist der negative log-Likelihood einer Normalverteilung mit Parametern \\(\\mu\\) und \\(\\sigma^2\\), aber das spielt hier keine Rolle.Optimierungsroutinen wie optim(), nlm() oder optimize() erwarten als Eingabe eine\nFunktion, deren Argumente die zu optimierenden Parameterwerte sind. Oftmals (wie im obigen Beispiel) hängen Funktionen aber von weiteren Werten ab.Die Funktion ist geschrieben, dass einer der beiden Parameter fixiert werden kann.Fixieren wir nun \\(\\mu\\) gleich 1, erhält manBemerkung: Wir verwenden optimize() anstatt optim(), da letztere nicht für eindimensionale Optimierung geeignet ist.Durch Übergabe aller weiteren Größen im Environmentkonnte die Funktion l_x() nur als Funktion der unbekannten Parameter im\n.GlobalEnv definiert werden.Es muss also keine Liste weiterer Argumente der Optimierungs- funktion übergeben werden.","code":"\nnegLogLik <- function(data, fix = c(FALSE, FALSE)){\n  param <- fix\n  function(theta){\n    param[!fix] <- theta\n    mu <- param[1]\n    sigma_2 <- param[2]\n    l_x <- -( -length(data)/2 * log(2 * pi * sigma_2 )\n              - sum((data-mu)^2) / (2*sigma_2))\n    l_x\n  }\n}\nset.seed(1234)\nx <- rnorm(1000, mean = 1, sd = 2)\nl_x <- negLogLik(x)\nl_x## function (theta) \n## {\n##     param[!fix] <- theta\n##     mu <- param[1]\n##     sigma_2 <- param[2]\n##     l_x <- -(-length(data)/2 * log(2 * pi * sigma_2) - sum((data - \n##         mu)^2)/(2 * sigma_2))\n##     l_x\n## }\n## <bytecode: 0x10bc6ee48>\n## <environment: 0x12873af40>\nls(environment(l_x))## [1] \"data\"  \"fix\"   \"param\"\noptim(par = c(0, 1), fn = l_x)$par## [1] 0.9465684 3.9744817\nl_x <- negLogLik(x, fix = c(1, FALSE))\noptimize(f = l_x, interval = c(1e-6, 10))$minimum## [1] 3.97759\nls(environment(l_x))## [1] \"data\"  \"fix\"   \"param\"\nparent.env(environment(l_x))## <environment: R_GlobalEnv>"},{"path":"literatur-3.html","id":"literatur-3","chapter":"Literatur","heading":"Literatur","text":"","code":""}]
